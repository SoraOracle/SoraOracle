{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/interfaces/IPancakePair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IPancakePair {\n    function price0CumulativeLast() external view returns (uint256);\n    function price1CumulativeLast() external view returns (uint256);\n    function getReserves() external view returns (\n        uint112 reserve0,\n        uint112 reserve1,\n        uint32 blockTimestampLast\n    );\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n}\n"
    },
    "contracts/PancakeTWAPOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./interfaces/IPancakePair.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title PancakeTWAPOracle\n * @notice Time-Weighted Average Price oracle for PancakeSwap V2 pairs\n * @dev Provides manipulation-resistant price feeds using Uniswap V2 TWAP pattern\n */\ncontract PancakeTWAPOracle is Ownable {\n    struct Observation {\n        uint32 timestamp;\n        uint256 price0Cumulative;\n        uint256 price1Cumulative;\n    }\n\n    IPancakePair public immutable pair;\n    address public immutable token0;\n    address public immutable token1;\n    \n    Observation public observationOld;\n    Observation public observationNew;\n    \n    uint32 public constant MIN_PERIOD = 5 minutes;\n    uint224 constant Q112 = 2**112;\n\n    event OracleUpdated(uint32 timestamp, uint256 price0Cumulative, uint256 price1Cumulative);\n\n    constructor(address _pair) Ownable(msg.sender) {\n        require(_pair != address(0), \"Invalid pair address\");\n        pair = IPancakePair(_pair);\n        token0 = pair.token0();\n        token1 = pair.token1();\n        \n        (uint256 price0Cumulative, uint256 price1Cumulative, uint32 blockTimestamp) = currentCumulativePrices();\n        require(price0Cumulative > 0 || price1Cumulative > 0, \"No data\");\n        \n        observationOld = Observation({\n            timestamp: blockTimestamp,\n            price0Cumulative: price0Cumulative,\n            price1Cumulative: price1Cumulative\n        });\n        \n        observationNew = observationOld;\n    }\n\n    /**\n     * @notice Compute current cumulative prices\n     * @dev Follows Uniswap V2 oracle pattern - adds time-weighted price since last update\n     */\n    function currentCumulativePrices() public view returns (\n        uint256 price0Cumulative,\n        uint256 price1Cumulative,\n        uint32 blockTimestamp\n    ) {\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = pair.getReserves();\n        \n        price0Cumulative = pair.price0CumulativeLast();\n        price1Cumulative = pair.price1CumulativeLast();\n        blockTimestamp = uint32(block.timestamp);\n        \n        // If time has elapsed since the last update, compute the time-weighted price\n        if (blockTimestampLast != blockTimestamp) {\n            uint32 timeElapsed;\n            unchecked {\n                timeElapsed = blockTimestamp - blockTimestampLast;\n            }\n            \n            // Add the accumulated price during the elapsed time\n            // price0 = reserve1 / reserve0, encoded as UQ112x112\n            // price1 = reserve0 / reserve1, encoded as UQ112x112\n            if (reserve0 != 0 && reserve1 != 0) {\n                unchecked {\n                    price0Cumulative += uint256(uint224(reserve1)) * Q112 / reserve0 * timeElapsed;\n                    price1Cumulative += uint256(uint224(reserve0)) * Q112 / reserve1 * timeElapsed;\n                }\n            }\n        }\n    }\n\n    function update() external {\n        (uint256 price0Cumulative, uint256 price1Cumulative, uint32 blockTimestamp) = currentCumulativePrices();\n        uint32 timeElapsed;\n        unchecked {\n            timeElapsed = blockTimestamp - observationNew.timestamp;\n        }\n        \n        require(timeElapsed >= MIN_PERIOD, \"Period not elapsed\");\n        \n        observationOld = observationNew;\n        \n        observationNew = Observation({\n            timestamp: blockTimestamp,\n            price0Cumulative: price0Cumulative,\n            price1Cumulative: price1Cumulative\n        });\n\n        emit OracleUpdated(blockTimestamp, price0Cumulative, price1Cumulative);\n    }\n\n    /**\n     * @notice Get TWAP price - falls back to spot if bootstrapping\n     * @dev Permissionless: returns spot price for first 5 min after oracle creation\n     * @param token Token to price  \n     * @param amountIn Amount of input token\n     * @return amountOut Expected output based on TWAP (or spot during bootstrap)\n     */\n    function consult(address token, uint256 amountIn) external view returns (uint256 amountOut) {\n        require(token == token0 || token == token1, \"Invalid token\");\n        \n        uint32 timeElapsed;\n        unchecked {\n            timeElapsed = observationNew.timestamp - observationOld.timestamp;\n        }\n        \n        // Bootstrap mode: return spot price if not enough data yet\n        if (timeElapsed < MIN_PERIOD) {\n            return _getCurrentPrice(token, amountIn);\n        }\n        \n        // Normal mode: return TWAP\n        uint256 priceCumulativeDelta;\n        if (token == token0) {\n            unchecked {\n                priceCumulativeDelta = observationNew.price0Cumulative - observationOld.price0Cumulative;\n            }\n            uint224 priceAverage = uint224(priceCumulativeDelta / timeElapsed);\n            amountOut = (amountIn * priceAverage) / Q112;\n        } else {\n            unchecked {\n                priceCumulativeDelta = observationNew.price1Cumulative - observationOld.price1Cumulative;\n            }\n            uint224 priceAverage = uint224(priceCumulativeDelta / timeElapsed);\n            amountOut = (amountIn * priceAverage) / Q112;\n        }\n    }\n    \n    /**\n     * @notice Check if oracle has enough data for true TWAP (vs spot fallback)\n     * @return bool True if MIN_PERIOD elapsed (using TWAP), false if using spot\n     */\n    function canConsult() external view returns (bool) {\n        uint32 timeElapsed;\n        unchecked {\n            timeElapsed = observationNew.timestamp - observationOld.timestamp;\n        }\n        return timeElapsed >= MIN_PERIOD;\n    }\n\n    function getCurrentPrice(address token, uint256 amountIn) external view returns (uint256 amountOut) {\n        return _getCurrentPrice(token, amountIn);\n    }\n\n    function _getCurrentPrice(address token, uint256 amountIn) internal view returns (uint256 amountOut) {\n        require(token == token0 || token == token1, \"Invalid token\");\n        \n        (uint112 reserve0, uint112 reserve1,) = pair.getReserves();\n        require(reserve0 != 0 && reserve1 != 0, \"No reserves\");\n        \n        if (token == token0) {\n            amountOut = (amountIn * reserve1) / reserve0;\n        } else {\n            amountOut = (amountIn * reserve0) / reserve1;\n        }\n    }\n\n    function canUpdate() external view returns (bool) {\n        uint32 timeElapsed;\n        unchecked {\n            timeElapsed = uint32(block.timestamp) - observationNew.timestamp;\n        }\n        return timeElapsed >= MIN_PERIOD;\n    }\n}\n"
    },
    "contracts/SimplePredictionMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./SoraOracle.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title SimplePredictionMarket\n * @notice MVP prediction market that uses Sora Oracle for outcome resolution\n * @dev Supports binary (yes/no) prediction markets\n */\ncontract SimplePredictionMarket is Ownable, ReentrancyGuard {\n    \n    enum MarketStatus { OPEN, CLOSED, RESOLVED, CANCELED }\n    enum Outcome { UNRESOLVED, YES, NO }\n\n    struct Market {\n        string question;\n        uint256 questionId;\n        uint256 resolutionTime;\n        uint256 yesPool;\n        uint256 noPool;\n        MarketStatus status;\n        Outcome outcome;\n        uint256 totalFees;\n    }\n\n    struct Position {\n        uint96 yesAmount;    // 12 bytes - max ~79B BNB (plenty)\n        uint96 noAmount;     // 12 bytes\n        uint48 feesPaid;     // 6 bytes - max ~281k BNB fees\n        bool claimed;        // 1 byte\n        // Total: 31 bytes (1 slot)\n    }\n\n    SoraOracle public oracle;\n    uint256 public marketCounter;\n    uint256 public constant FEE_PERCENTAGE = 2; // 2% platform fee\n    uint256 public accumulatedFees;\n    \n    mapping(uint256 => Market) public markets;\n    mapping(uint256 => mapping(address => Position)) public positions;\n\n    event MarketCreated(uint256 indexed marketId, string question, uint256 resolutionTime);\n    event PositionTaken(uint256 indexed marketId, address indexed user, bool isYes, uint256 amount);\n    event MarketResolved(uint256 indexed marketId, Outcome outcome);\n    event MarketCanceled(uint256 indexed marketId);\n    event WinningsClaimed(uint256 indexed marketId, address indexed user, uint256 amount);\n    event FeesWithdrawn(address indexed owner, uint256 amount);\n\n    constructor(address payable _oracle) Ownable(msg.sender) {\n        require(_oracle != address(0), \"Invalid oracle\");\n        oracle = SoraOracle(_oracle);\n    }\n\n    /**\n     * @notice Create a new prediction market\n     * @param _question The yes/no question\n     * @param _resolutionTime When the market should resolve\n     */\n    function createMarket(string memory _question, uint256 _resolutionTime) \n        external \n        payable \n        returns (uint256 marketId) \n    {\n        require(_resolutionTime > block.timestamp, \"Invalid resolution time\");\n        require(bytes(_question).length > 0, \"Question empty\");\n\n        // Ask the oracle (forwards the fee)\n        uint256 oracleFee = oracle.oracleFee();\n        require(msg.value >= oracleFee, \"Insufficient oracle fee\");\n        \n        uint256 questionId = oracle.askYesNoQuestion{value: oracleFee}(_question, _resolutionTime);\n        \n        marketId = marketCounter++;\n        markets[marketId] = Market({\n            question: _question,\n            questionId: questionId,\n            resolutionTime: _resolutionTime,\n            yesPool: 0,\n            noPool: 0,\n            status: MarketStatus.OPEN,\n            outcome: Outcome.UNRESOLVED,\n            totalFees: 0\n        });\n\n        emit MarketCreated(marketId, _question, _resolutionTime);\n\n        // Return any excess payment\n        if (msg.value > oracleFee) {\n            (bool success, ) = msg.sender.call{value: msg.value - oracleFee}(\"\");\n            require(success, \"Refund failed\");\n        }\n    }\n\n    /**\n     * @notice Take a position on a market\n     * @param _marketId Market ID\n     * @param _isYes True for YES, false for NO\n     */\n    function takePosition(uint256 _marketId, bool _isYes) \n        external \n        payable \n        nonReentrant \n    {\n        Market storage market = markets[_marketId];\n        require(market.status == MarketStatus.OPEN, \"Market not open\");\n        require(block.timestamp < market.resolutionTime, \"Market expired\");\n        require(msg.value > 0, \"Amount must be > 0\");\n\n        uint256 fee = (msg.value * FEE_PERCENTAGE) / 100;\n        uint256 betAmount = msg.value - fee;\n        \n        require(fee <= type(uint48).max, \"Fee overflow\");\n        require(betAmount <= type(uint96).max, \"Amount overflow\");\n\n        market.totalFees += fee;\n        // Note: fees are NOT added to accumulatedFees yet - only when market resolves\n\n        Position storage position = positions[_marketId][msg.sender];\n        position.feesPaid += uint48(fee);\n\n        if (_isYes) {\n            market.yesPool += betAmount;\n            position.yesAmount += uint96(position.yesAmount + betAmount);\n        } else {\n            market.noPool += betAmount;\n            position.noAmount += uint96(position.noAmount + betAmount);\n        }\n\n        emit PositionTaken(_marketId, msg.sender, _isYes, betAmount);\n    }\n\n    /**\n     * @notice Resolve market using oracle answer\n     * @param _marketId Market ID\n     */\n    function resolveMarket(uint256 _marketId) external nonReentrant {\n        Market storage market = markets[_marketId];\n        require(market.status == MarketStatus.OPEN, \"Market not open\");\n        require(block.timestamp >= market.resolutionTime, \"Too early\");\n\n        // Get oracle answer\n        (, SoraOracle.Answer memory answer) = oracle.getQuestionWithAnswer(market.questionId);\n        require(answer.confidenceScore > 0, \"Not answered yet\");\n\n        market.outcome = answer.boolAnswer ? Outcome.YES : Outcome.NO;\n        market.status = MarketStatus.RESOLVED;\n\n        // Release platform fees now that market is resolved (won't be canceled)\n        accumulatedFees += market.totalFees;\n\n        emit MarketResolved(_marketId, market.outcome);\n    }\n\n    /**\n     * @notice Claim winnings from a resolved market\n     * @param _marketId Market ID\n     */\n    function claimWinnings(uint256 _marketId) external nonReentrant {\n        Market storage market = markets[_marketId];\n        Position storage position = positions[_marketId][msg.sender];\n        \n        require(market.status == MarketStatus.RESOLVED, \"Not resolved\");\n        require(!position.claimed, \"Already claimed\");\n\n        uint256 winnings = calculateWinnings(_marketId, msg.sender);\n        require(winnings > 0, \"No winnings\");\n\n        position.claimed = true;\n\n        (bool success, ) = msg.sender.call{value: winnings}(\"\");\n        require(success, \"Transfer failed\");\n\n        emit WinningsClaimed(_marketId, msg.sender, winnings);\n    }\n\n    /**\n     * @notice Calculate potential winnings for a user\n     * @param _marketId Market ID\n     * @param _user User address\n     */\n    function calculateWinnings(uint256 _marketId, address _user) \n        public \n        view \n        returns (uint256) \n    {\n        Market storage market = markets[_marketId];\n        Position storage position = positions[_marketId][_user];\n\n        if (market.status != MarketStatus.RESOLVED || position.claimed) {\n            return 0;\n        }\n\n        uint256 totalPool = market.yesPool + market.noPool;\n        if (totalPool == 0) return 0;\n\n        if (market.outcome == Outcome.YES && position.yesAmount > 0) {\n            if (market.yesPool == 0) return 0;\n            return (position.yesAmount * totalPool) / market.yesPool;\n        } else if (market.outcome == Outcome.NO && position.noAmount > 0) {\n            if (market.noPool == 0) return 0;\n            return (position.noAmount * totalPool) / market.noPool;\n        }\n\n        return 0;\n    }\n\n    /**\n     * @notice Get market details\n     */\n    function getMarket(uint256 _marketId) \n        external \n        view \n        returns (Market memory) \n    {\n        return markets[_marketId];\n    }\n\n    /**\n     * @notice Get user position\n     */\n    function getPosition(uint256 _marketId, address _user) \n        external \n        view \n        returns (Position memory) \n    {\n        return positions[_marketId][_user];\n    }\n\n    /**\n     * @notice Cancel a market if oracle hasn't answered\n     * @param _marketId Market ID\n     * @dev Allows users to reclaim bets if oracle fails to answer\n     */\n    function cancelMarket(uint256 _marketId) external nonReentrant {\n        Market storage market = markets[_marketId];\n        require(market.status == MarketStatus.OPEN, \"Market not open\");\n        require(block.timestamp > market.resolutionTime + 7 days, \"Too early to cancel\");\n\n        (, SoraOracle.Answer memory answer) = oracle.getQuestionWithAnswer(market.questionId);\n        require(answer.confidenceScore == 0, \"Already answered\");\n\n        market.status = MarketStatus.CANCELED;\n        emit MarketCanceled(_marketId);\n    }\n\n    /**\n     * @notice Claim refund from canceled market\n     * @param _marketId Market ID\n     * @dev Returns full stake including exact fees paid\n     * Note: Canceled market fees were never added to accumulatedFees, so no deduction needed\n     */\n    function claimRefund(uint256 _marketId) external nonReentrant {\n        Market storage market = markets[_marketId];\n        Position storage position = positions[_marketId][msg.sender];\n        \n        require(market.status == MarketStatus.CANCELED, \"Market not canceled\");\n        require(!position.claimed, \"Already claimed\");\n\n        uint256 netPosition = position.yesAmount + position.noAmount;\n        uint256 feesPaid = position.feesPaid;\n        uint256 fullRefund = netPosition + feesPaid;\n        \n        require(fullRefund > 0, \"No position\");\n\n        position.claimed = true;\n\n        (bool success, ) = msg.sender.call{value: fullRefund}(\"\");\n        require(success, \"Refund failed\");\n    }\n\n    /**\n     * @notice Withdraw accumulated platform fees\n     * @dev Only owner can withdraw\n     */\n    function withdrawFees() external onlyOwner nonReentrant {\n        uint256 amount = accumulatedFees;\n        require(amount > 0, \"No fees to withdraw\");\n\n        accumulatedFees = 0;\n\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Withdrawal failed\");\n\n        emit FeesWithdrawn(msg.sender, amount);\n    }\n}\n"
    },
    "contracts/SoraOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"./PancakeTWAPOracle.sol\";\n\n/**\n * @title SoraOracle\n * @notice Decentralized oracle for prediction markets with TWAP integration\n * @dev Supports price feeds, yes/no questions, and numeric predictions\n */\ncontract SoraOracle is Ownable, ReentrancyGuard, Pausable {\n    \n    enum QuestionType { GENERAL, PRICE, YESNO, NUMERIC }\n    enum AnswerStatus { PENDING, ANSWERED, DISPUTED, FINALIZED }\n\n    struct Question {\n        address requester;          // 20 bytes\n        uint88 bounty;              // 11 bytes (max ~309k BNB - plenty)\n        uint32 timestamp;           // 4 bytes (good until 2106)\n        uint32 deadline;            // 4 bytes\n        QuestionType questionType;  // 1 byte\n        AnswerStatus status;        // 1 byte\n        bool refunded;              // 1 byte\n        // Total: 32 bytes (1 slot) + hash in separate mapping\n    }\n\n    struct Answer {\n        address provider;           // 20 bytes\n        uint8 confidenceScore;      // 1 byte (0-100)\n        bool boolAnswer;            // 1 byte\n        // 10 bytes free in slot\n        uint64 numericAnswer;       // 8 bytes (for most price data)\n        uint32 timestamp;           // 4 bytes\n        // Slot 2: 12 bytes used, 20 free\n        // Text/dataSource in events only\n    }\n\n    mapping(uint256 => Question) public questions;\n    mapping(uint256 => Answer) public answers;\n    mapping(uint256 => bytes32) public questionHashes; // Hash of question text\n    mapping(address => PancakeTWAPOracle) public twapOracles;\n    \n    uint256 public questionCounter;\n    uint256 public oracleFee = 0.01 ether;\n    address public oracleProvider;\n    uint256 public providerBalance;\n    uint256 public constant REFUND_PERIOD = 7 days;\n    uint256 public constant TWAP_DEPLOYMENT_FEE = 0.02 ether; // Covers ~2M gas deployment cost\n\n    event QuestionAsked(\n        uint256 indexed questionId,\n        address indexed requester,\n        QuestionType questionType,\n        string question,\n        uint256 bounty,\n        uint256 deadline\n    );\n\n    event AnswerProvided(\n        uint256 indexed questionId,\n        string textAnswer,\n        uint256 numericAnswer,\n        uint8 confidenceScore,\n        string dataSource\n    );\n\n    event TWAPOracleAdded(address indexed pairAddress, address indexed oracleAddress);\n    event OracleFeeUpdated(uint256 oldFee, uint256 newFee);\n\n    modifier onlyOracleProvider() {\n        require(msg.sender == oracleProvider, \"Only oracle provider\");\n        _;\n    }\n\n    constructor(address _oracleProvider) Ownable(msg.sender) {\n        require(_oracleProvider != address(0), \"Invalid provider\");\n        oracleProvider = _oracleProvider;\n    }\n\n    /**\n     * @notice Ask a general question to the oracle\n     * @param _question The question to ask\n     * @param _deadline Timestamp by which answer is needed\n     */\n    function askOracle(\n        string memory _question,\n        uint256 _deadline\n    ) external payable whenNotPaused nonReentrant returns (uint256 questionId) {\n        return _askQuestion(QuestionType.GENERAL, _question, _deadline);\n    }\n\n    /**\n     * @notice Ask a price-related question (can use TWAP)\n     * @param _question The price question\n     * @param _deadline Timestamp by which answer is needed\n     */\n    function askPriceQuestion(\n        string memory _question,\n        uint256 _deadline\n    ) external payable whenNotPaused nonReentrant returns (uint256 questionId) {\n        return _askQuestion(QuestionType.PRICE, _question, _deadline);\n    }\n\n    /**\n     * @notice Ask a yes/no question\n     * @param _question The yes/no question\n     * @param _deadline Timestamp by which answer is needed\n     */\n    function askYesNoQuestion(\n        string memory _question,\n        uint256 _deadline\n    ) external payable whenNotPaused nonReentrant returns (uint256 questionId) {\n        return _askQuestion(QuestionType.YESNO, _question, _deadline);\n    }\n\n    function _askQuestion(\n        QuestionType _type,\n        string memory _question,\n        uint256 _deadline\n    ) private returns (uint256 questionId) {\n        require(msg.value >= oracleFee, \"Insufficient fee\");\n        require(bytes(_question).length > 0, \"Question empty\");\n        require(bytes(_question).length <= 500, \"Question too long\");\n        require(_deadline > block.timestamp, \"Invalid deadline\");\n        require(_deadline <= type(uint32).max, \"Deadline overflow\");\n        require(msg.value <= type(uint88).max, \"Bounty overflow\");\n\n        questionId = questionCounter++;\n        \n        questions[questionId] = Question({\n            requester: msg.sender,\n            questionType: _type,\n            bounty: uint88(msg.value),\n            timestamp: uint32(block.timestamp),\n            deadline: uint32(_deadline),\n            status: AnswerStatus.PENDING,\n            refunded: false\n        });\n\n        // Store question hash, emit full text in event\n        questionHashes[questionId] = keccak256(bytes(_question));\n        emit QuestionAsked(questionId, msg.sender, _type, _question, msg.value, _deadline);\n    }\n\n    /**\n     * @notice Provide an answer to a question\n     * @param _questionId The question ID\n     * @param _textAnswer Text answer (for general questions) - emitted in event only\n     * @param _numericAnswer Numeric answer (for price/numeric questions) - max uint64\n     * @param _boolAnswer Boolean answer (for yes/no questions)\n     * @param _confidenceScore Confidence score 0-100\n     * @param _dataSource Data source used (e.g., \"TWAP\", \"Manual\", \"API\") - emitted in event only\n     */\n    function provideAnswer(\n        uint256 _questionId,\n        string memory _textAnswer,\n        uint256 _numericAnswer,\n        bool _boolAnswer,\n        uint8 _confidenceScore,\n        string memory _dataSource\n    ) external onlyOracleProvider whenNotPaused nonReentrant {\n        Question storage q = questions[_questionId];\n        require(q.status == AnswerStatus.PENDING, \"Already answered\");\n        require(!q.refunded, \"Already refunded\");\n        require(_confidenceScore <= 100, \"Invalid confidence\");\n        require(bytes(_dataSource).length > 0, \"Data source required\");\n        require(_numericAnswer <= type(uint64).max, \"Numeric answer overflow\");\n\n        answers[_questionId] = Answer({\n            provider: msg.sender,\n            confidenceScore: _confidenceScore,\n            boolAnswer: _boolAnswer,\n            numericAnswer: uint64(_numericAnswer),\n            timestamp: uint32(block.timestamp)\n        });\n\n        q.status = AnswerStatus.ANSWERED;\n        providerBalance += q.bounty;\n\n        emit AnswerProvided(_questionId, _textAnswer, _numericAnswer, _confidenceScore, _dataSource);\n    }\n\n    /**\n     * @notice Get price from TWAP oracle for a token pair\n     * @dev Oracle must exist (use addTWAPOracle first)\n     * @param _pairAddress PancakeSwap pair address\n     * @param _token Token to price\n     * @param _amount Amount of tokens\n     */\n    function getTWAPPrice(\n        address _pairAddress,\n        address _token,\n        uint256 _amount\n    ) external view returns (uint256) {\n        require(address(twapOracles[_pairAddress]) != address(0), \"Oracle not found - call addTWAPOracle first\");\n        return twapOracles[_pairAddress].consult(_token, _amount);\n    }\n\n    /**\n     * @notice Add a TWAP oracle for a trading pair (permissionless)\n     * @dev Anyone can add any PancakeSwap pair - caller pays deployment cost\n     * @param _pairAddress PancakeSwap pair address\n     */\n    function addTWAPOracle(address _pairAddress) external payable {\n        require(address(twapOracles[_pairAddress]) == address(0), \"Already exists\");\n        require(msg.value >= TWAP_DEPLOYMENT_FEE, \"Insufficient deployment fee\");\n        _createTWAPOracle(_pairAddress);\n        \n        // Refund excess\n        if (msg.value > TWAP_DEPLOYMENT_FEE) {\n            (bool success, ) = payable(msg.sender).call{value: msg.value - TWAP_DEPLOYMENT_FEE}(\"\");\n            require(success, \"Refund failed\");\n        }\n    }\n\n    /**\n     * @notice Internal function to create TWAP oracle\n     * @param _pairAddress PancakeSwap pair address\n     */\n    function _createTWAPOracle(address _pairAddress) internal {\n        require(_pairAddress != address(0), \"Invalid pair\");\n        \n        PancakeTWAPOracle newOracle = new PancakeTWAPOracle(_pairAddress);\n        twapOracles[_pairAddress] = newOracle;\n        \n        emit TWAPOracleAdded(_pairAddress, address(newOracle));\n    }\n\n    /**\n     * @notice Refund unanswered question after refund period\n     */\n    function refundUnansweredQuestion(uint256 _questionId) external nonReentrant {\n        Question storage q = questions[_questionId];\n        require(msg.sender == q.requester, \"Only requester\");\n        require(q.status == AnswerStatus.PENDING, \"Already answered\");\n        require(!q.refunded, \"Already refunded\");\n        require(block.timestamp >= q.timestamp + REFUND_PERIOD, \"Too early\");\n\n        q.refunded = true;\n        uint256 refundAmount = q.bounty;\n        q.bounty = 0;\n\n        (bool success, ) = payable(msg.sender).call{value: refundAmount}(\"\");\n        require(success, \"Refund failed\");\n    }\n\n    /**\n     * @notice Withdraw oracle provider earnings\n     */\n    function withdraw() external onlyOracleProvider nonReentrant {\n        uint256 amount = providerBalance;\n        require(amount > 0, \"No balance\");\n\n        providerBalance = 0;\n        \n        (bool success, ) = payable(oracleProvider).call{value: amount}(\"\");\n        require(success, \"Withdrawal failed\");\n    }\n\n    /**\n     * @notice Get full question and answer data\n     */\n    function getQuestionWithAnswer(uint256 _questionId) \n        external \n        view \n        returns (\n            Question memory question,\n            Answer memory answer\n        ) \n    {\n        return (questions[_questionId], answers[_questionId]);\n    }\n\n    /**\n     * @notice Update oracle fee\n     */\n    function setOracleFee(uint256 _newFee) external onlyOwner {\n        uint256 oldFee = oracleFee;\n        oracleFee = _newFee;\n        emit OracleFeeUpdated(oldFee, _newFee);\n    }\n\n    /**\n     * @notice Update oracle provider address\n     */\n    function setOracleProvider(address _newProvider) external onlyOwner {\n        require(_newProvider != address(0), \"Invalid provider\");\n        oracleProvider = _newProvider;\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    receive() external payable {\n        revert(\"Direct transfers not allowed\");\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}
