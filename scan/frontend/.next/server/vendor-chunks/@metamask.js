/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@metamask";
exports.ids = ["vendor-chunks/@metamask"];
exports.modules = {

/***/ "(rsc)/../../node_modules/@metamask/abi-utils/dist/abi.js":
/*!**********************************************************!*\
  !*** ../../node_modules/@metamask/abi-utils/dist/abi.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// ESLint gets confused by the nested list and tables in the docs, so we disable\n// the rule for this file.\n/* eslint-disable jsdoc/check-indentation, jsdoc/match-description */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodeSingle = exports.decode = exports.encodePacked = exports.encodeSingle = exports.encode = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(rsc)/../../node_modules/@metamask/utils/dist/index.cjs\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/errors.js\");\nconst packer_1 = __webpack_require__(/*! ./packer */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/packer.js\");\n/**\n * Encode the data with the provided types. The types must be valid Solidity\n * ABI types.\n *\n * This will attempt to parse the values into the correct types. For example,\n * if you pass in a hex string for a `uint256`, it will be parsed into a\n * `bigint`. Regular strings are interpreted as UTF-8 strings. If you want to\n * pass in a hex string, you must pass it in as a `Uint8Array`, or use the\n * \"0x\"-prefix.\n *\n * It will also attempt to infer the types of the values. For example, if you\n * pass in a string for a `uint256`, it will result in a TypeScript compile-time\n * error. This does not work for all types, however. For example, if you use\n * nested arrays or tuples, the type will be inferred as `unknown`.\n *\n * The following types are supported:\n *\n * - `address`: A 20-byte Ethereum address.\n *   - As a 40-character-long hexadecimal string, starting with \"0x\".\n *   - As a 20-byte-long byte array, i.e., `Uint8Array`.\n * - `bool`: A boolean value.\n *   - As a boolean literal, i.e., `true` or `false`.\n *   - As the strings \"true\" or \"false\".\n * - `bytes(n)`: A dynamic byte array.\n *   - As a hexadecimal string, starting with \"0x\".\n *   - As a byte array, i.e., `Uint8Array`.\n *   - As a regular string, which will be interpreted as UTF-8.\n * - `function`: A Solidity function.\n *   - As a 48-character-long hexadecimal string, starting with \"0x\".\n *   - As a 24-byte-long byte array, i.e., `Uint8Array`.\n *   - As a {@link SolidityFunction} object.\n * - `int(n)`: A signed integer.\n *   - As a number.\n *   - As a `bigint`.\n *   - As a hexadecimal string, starting with \"0x\".\n * - `string`: A dynamic UTF-8 string.\n *   - As a regular string.\n *   - As a hexadecimal string, starting with \"0x\".\n *   - As a byte array, i.e., `Uint8Array`.\n * - `tuple`: A tuple of values.\n *   - As an array of values.\n * - `uint(n)`: An unsigned integer.\n *   - As a number.\n *   - As a `bigint`.\n *   - As a hexadecimal string, starting with \"0x\".\n *\n * @example\n * ```typescript\n * import { encode, decode } from '@metamask/abi-utils';\n *\n * const types = ['uint256', 'string'];\n * const encoded = encode(types, [42, 'Hello, world!']);\n * const decoded = decode(types, encoded);\n *\n * console.log(decoded); // [42n, 'Hello, world!']\n * ```\n * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html\n * @param types - The types to encode.\n * @param values - The values to encode. This array must have the same length as\n * the types array.\n * @param packed - Whether to use the non-standard packed mode. Defaults to\n * `false`.\n * @param tight - Whether to pack the values tightly. When enabled, the values\n * will be packed without any padding. This matches the behaviour of\n * `ethereumjs-abi`. Defaults to `false`.\n * @returns The ABI encoded bytes.\n */\nconst encode = (types, values, packed, tight) => {\n    try {\n        return (0, packer_1.pack)({ types, values, packed, tight });\n    }\n    catch (error) {\n        if (error instanceof errors_1.ParserError) {\n            throw new errors_1.ParserError(`Unable to encode value: ${error.message}`, error);\n        }\n        throw new errors_1.ParserError(`An unexpected error occurred: ${(0, errors_1.getErrorMessage)(error)}`, error);\n    }\n};\nexports.encode = encode;\n/**\n * Encode the data with the provided type. The type must be a valid Solidity\n * ABI type.\n *\n * See {@link encode} for more information on how values are parsed.\n *\n * @example\n * ```typescript\n * import { encodeSingle, decodeSingle } from '@metamask/abi-utils';\n *\n * const encoded = encodeSingle('uint256', 42);\n * const decoded = decodeSingle('uint256', encoded);\n *\n * console.log(decoded); // 42n\n * ```\n * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#types\n * @param type - The type to encode.\n * @param value - The value to encode.\n * @returns The ABI encoded bytes.\n */\nconst encodeSingle = (type, value) => {\n    return (0, exports.encode)([type], [value]);\n};\nexports.encodeSingle = encodeSingle;\n/**\n * Encode the data with the provided types. The types must be valid Solidity\n * ABI types. This is similar to {@link encode}, but the values are encoded in\n * the non-standard packed mode. This differs from the standard encoding in the\n * following ways:\n *\n * - Most values are packed tightly, without alignment padding.\n *   - The exception is array values, which are padded to 32 bytes.\n * - Values are still padded to their full size, i.e., `uint16` values are still\n *  padded to 2 bytes, regardless of the length of the value.\n * - The encoding of dynamic types (`bytes`, `string`) is different. The length\n * of the dynamic type is not included in the encoding, and the dynamic type is\n * not padded to a multiple of 32 bytes.\n * - All values are encoded in-place, without any offsets.\n *\n * The encoding of this is ambiguous as soon as there is more than one dynamic\n * type. That means that these values cannot be decoded with {@link decode} or\n * Solidity's `abi.decode` function.\n *\n * See {@link encode} for more information on how values are parsed.\n *\n * @example\n * ```typescript\n * import { encodePacked } from '@metamask/abi-utils';\n *\n * const encoded = encodePacked(['uint8'], [42]);\n *\n * console.log(encoded); // `Uint8Array [ 42 ]`\n * ```\n * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#types\n * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#non-standard-packed-mode\n * @param types - The types to encode.\n * @param values - The values to encode.\n * @param tight - Whether to pack the values tightly. When enabled, `bytesN`\n * values in arrays will be packed without any padding. This matches the\n * behaviour of `ethereumjs-abi`. Defaults to `false`.\n * @returns The ABI encoded bytes.\n */\nconst encodePacked = (types, values, tight) => {\n    return (0, exports.encode)(types, values, true, tight);\n};\nexports.encodePacked = encodePacked;\n/**\n * Decode an ABI encoded buffer with the specified types. The types must be\n * valid Solidity ABI types.\n *\n * This will attempt to infer the output types from the input types. For\n * example, if you use `uint256` as an input type, the output type will be\n * `bigint`. This does not work for all types, however. For example, if you use\n * nested array types or tuple types, the output type will be `unknown`.\n *\n * The resulting types of the values will be as follows:\n *\n * | Contract ABI Type | Resulting JavaScript Type |\n * | ----------------- | ------------------------- |\n * | `address`         | `string`                  |\n * | `bool`            | `boolean`                 |\n * | `bytes(n)`        | `Uint8Array`              |\n * | `function`        | {@link SolidityFunction}  |\n * | `int(n)`          | `bigint`                  |\n * | `string`          | `string`                  |\n * | `tuple`           | `Array`                   |\n * | `array`           | `Array`                   |\n * | `uint(n)`         | `bigint`                  |\n *\n * @example\n * ```typescript\n * import { encode, decode } from '@metamask/abi-utils';\n *\n * const types = ['uint256', 'string'];\n * const encoded = encode(types, [42, 'Hello, world!']);\n * const decoded = decode(types, encoded);\n *\n * console.log(decoded); // [42n, 'Hello, world!']\n * ```\n * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#types\n * @param types - The types to decode the bytes with.\n * @param value - The bytes-like value to decode.\n * @returns The decoded values as array.\n */\nconst decode = (types, value) => {\n    const bytes = (0, utils_1.createBytes)(value);\n    try {\n        return (0, packer_1.unpack)(types, bytes);\n    }\n    catch (error) {\n        if (error instanceof errors_1.ParserError) {\n            throw new errors_1.ParserError(`Unable to decode value: ${error.message}`, error);\n        }\n        throw new errors_1.ParserError(`An unexpected error occurred: ${(0, errors_1.getErrorMessage)(error)}`, error);\n    }\n};\nexports.decode = decode;\n/**\n * Decode the data with the provided type. The type must be a valid Solidity\n * ABI type.\n *\n * See {@link decode} for more information on how values are parsed.\n *\n * @example\n * ```typescript\n * import { encodeSingle, decodeSingle } from '@metamask/abi-utils';\n *\n * const encoded = encodeSingle('uint256', 42);\n * const decoded = decodeSingle('uint256', encoded);\n *\n * console.log(decoded); // 42n\n * ```\n * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#types\n * @param type - The type to decode.\n * @param value - The bytes-like value to decode.\n * @returns The decoded value.\n */\nconst decodeSingle = (type, value) => {\n    const result = (0, exports.decode)([type], value);\n    (0, utils_1.assert)(result.length === 1, new errors_1.ParserError('Decoded value array has unexpected length.'));\n    return result[0];\n};\nexports.decodeSingle = decodeSingle;\n//# sourceMappingURL=abi.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC9hYmkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcsY0FBYyxHQUFHLG9CQUFvQixHQUFHLG9CQUFvQixHQUFHLGNBQWM7QUFDcEcsZ0JBQWdCLG1CQUFPLENBQUMsZ0ZBQWlCO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLDZFQUFVO0FBQ25DLGlCQUFpQixtQkFBTyxDQUFDLDZFQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsOEJBQThCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxjQUFjO0FBQ3BGO0FBQ0Esd0VBQXdFLHFDQUFxQztBQUM3RztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxjQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0Esa0NBQWtDLGFBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsY0FBYztBQUM1RTtBQUNBO0FBQ0EsUUFBUSxjQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseUJBQXlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGNBQWM7QUFDcEY7QUFDQSx3RUFBd0UscUNBQXFDO0FBQzdHO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGNBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2QkFBNkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L2FiaS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIEVTTGludCBnZXRzIGNvbmZ1c2VkIGJ5IHRoZSBuZXN0ZWQgbGlzdCBhbmQgdGFibGVzIGluIHRoZSBkb2NzLCBzbyB3ZSBkaXNhYmxlXG4vLyB0aGUgcnVsZSBmb3IgdGhpcyBmaWxlLlxuLyogZXNsaW50LWRpc2FibGUganNkb2MvY2hlY2staW5kZW50YXRpb24sIGpzZG9jL21hdGNoLWRlc2NyaXB0aW9uICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZVNpbmdsZSA9IGV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5lbmNvZGVQYWNrZWQgPSBleHBvcnRzLmVuY29kZVNpbmdsZSA9IGV4cG9ydHMuZW5jb2RlID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svdXRpbHNcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IHBhY2tlcl8xID0gcmVxdWlyZShcIi4vcGFja2VyXCIpO1xuLyoqXG4gKiBFbmNvZGUgdGhlIGRhdGEgd2l0aCB0aGUgcHJvdmlkZWQgdHlwZXMuIFRoZSB0eXBlcyBtdXN0IGJlIHZhbGlkIFNvbGlkaXR5XG4gKiBBQkkgdHlwZXMuXG4gKlxuICogVGhpcyB3aWxsIGF0dGVtcHQgdG8gcGFyc2UgdGhlIHZhbHVlcyBpbnRvIHRoZSBjb3JyZWN0IHR5cGVzLiBGb3IgZXhhbXBsZSxcbiAqIGlmIHlvdSBwYXNzIGluIGEgaGV4IHN0cmluZyBmb3IgYSBgdWludDI1NmAsIGl0IHdpbGwgYmUgcGFyc2VkIGludG8gYVxuICogYGJpZ2ludGAuIFJlZ3VsYXIgc3RyaW5ncyBhcmUgaW50ZXJwcmV0ZWQgYXMgVVRGLTggc3RyaW5ncy4gSWYgeW91IHdhbnQgdG9cbiAqIHBhc3MgaW4gYSBoZXggc3RyaW5nLCB5b3UgbXVzdCBwYXNzIGl0IGluIGFzIGEgYFVpbnQ4QXJyYXlgLCBvciB1c2UgdGhlXG4gKiBcIjB4XCItcHJlZml4LlxuICpcbiAqIEl0IHdpbGwgYWxzbyBhdHRlbXB0IHRvIGluZmVyIHRoZSB0eXBlcyBvZiB0aGUgdmFsdWVzLiBGb3IgZXhhbXBsZSwgaWYgeW91XG4gKiBwYXNzIGluIGEgc3RyaW5nIGZvciBhIGB1aW50MjU2YCwgaXQgd2lsbCByZXN1bHQgaW4gYSBUeXBlU2NyaXB0IGNvbXBpbGUtdGltZVxuICogZXJyb3IuIFRoaXMgZG9lcyBub3Qgd29yayBmb3IgYWxsIHR5cGVzLCBob3dldmVyLiBGb3IgZXhhbXBsZSwgaWYgeW91IHVzZVxuICogbmVzdGVkIGFycmF5cyBvciB0dXBsZXMsIHRoZSB0eXBlIHdpbGwgYmUgaW5mZXJyZWQgYXMgYHVua25vd25gLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgdHlwZXMgYXJlIHN1cHBvcnRlZDpcbiAqXG4gKiAtIGBhZGRyZXNzYDogQSAyMC1ieXRlIEV0aGVyZXVtIGFkZHJlc3MuXG4gKiAgIC0gQXMgYSA0MC1jaGFyYWN0ZXItbG9uZyBoZXhhZGVjaW1hbCBzdHJpbmcsIHN0YXJ0aW5nIHdpdGggXCIweFwiLlxuICogICAtIEFzIGEgMjAtYnl0ZS1sb25nIGJ5dGUgYXJyYXksIGkuZS4sIGBVaW50OEFycmF5YC5cbiAqIC0gYGJvb2xgOiBBIGJvb2xlYW4gdmFsdWUuXG4gKiAgIC0gQXMgYSBib29sZWFuIGxpdGVyYWwsIGkuZS4sIGB0cnVlYCBvciBgZmFsc2VgLlxuICogICAtIEFzIHRoZSBzdHJpbmdzIFwidHJ1ZVwiIG9yIFwiZmFsc2VcIi5cbiAqIC0gYGJ5dGVzKG4pYDogQSBkeW5hbWljIGJ5dGUgYXJyYXkuXG4gKiAgIC0gQXMgYSBoZXhhZGVjaW1hbCBzdHJpbmcsIHN0YXJ0aW5nIHdpdGggXCIweFwiLlxuICogICAtIEFzIGEgYnl0ZSBhcnJheSwgaS5lLiwgYFVpbnQ4QXJyYXlgLlxuICogICAtIEFzIGEgcmVndWxhciBzdHJpbmcsIHdoaWNoIHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXMgVVRGLTguXG4gKiAtIGBmdW5jdGlvbmA6IEEgU29saWRpdHkgZnVuY3Rpb24uXG4gKiAgIC0gQXMgYSA0OC1jaGFyYWN0ZXItbG9uZyBoZXhhZGVjaW1hbCBzdHJpbmcsIHN0YXJ0aW5nIHdpdGggXCIweFwiLlxuICogICAtIEFzIGEgMjQtYnl0ZS1sb25nIGJ5dGUgYXJyYXksIGkuZS4sIGBVaW50OEFycmF5YC5cbiAqICAgLSBBcyBhIHtAbGluayBTb2xpZGl0eUZ1bmN0aW9ufSBvYmplY3QuXG4gKiAtIGBpbnQobilgOiBBIHNpZ25lZCBpbnRlZ2VyLlxuICogICAtIEFzIGEgbnVtYmVyLlxuICogICAtIEFzIGEgYGJpZ2ludGAuXG4gKiAgIC0gQXMgYSBoZXhhZGVjaW1hbCBzdHJpbmcsIHN0YXJ0aW5nIHdpdGggXCIweFwiLlxuICogLSBgc3RyaW5nYDogQSBkeW5hbWljIFVURi04IHN0cmluZy5cbiAqICAgLSBBcyBhIHJlZ3VsYXIgc3RyaW5nLlxuICogICAtIEFzIGEgaGV4YWRlY2ltYWwgc3RyaW5nLCBzdGFydGluZyB3aXRoIFwiMHhcIi5cbiAqICAgLSBBcyBhIGJ5dGUgYXJyYXksIGkuZS4sIGBVaW50OEFycmF5YC5cbiAqIC0gYHR1cGxlYDogQSB0dXBsZSBvZiB2YWx1ZXMuXG4gKiAgIC0gQXMgYW4gYXJyYXkgb2YgdmFsdWVzLlxuICogLSBgdWludChuKWA6IEFuIHVuc2lnbmVkIGludGVnZXIuXG4gKiAgIC0gQXMgYSBudW1iZXIuXG4gKiAgIC0gQXMgYSBgYmlnaW50YC5cbiAqICAgLSBBcyBhIGhleGFkZWNpbWFsIHN0cmluZywgc3RhcnRpbmcgd2l0aCBcIjB4XCIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IGVuY29kZSwgZGVjb2RlIH0gZnJvbSAnQG1ldGFtYXNrL2FiaS11dGlscyc7XG4gKlxuICogY29uc3QgdHlwZXMgPSBbJ3VpbnQyNTYnLCAnc3RyaW5nJ107XG4gKiBjb25zdCBlbmNvZGVkID0gZW5jb2RlKHR5cGVzLCBbNDIsICdIZWxsbywgd29ybGQhJ10pO1xuICogY29uc3QgZGVjb2RlZCA9IGRlY29kZSh0eXBlcywgZW5jb2RlZCk7XG4gKlxuICogY29uc29sZS5sb2coZGVjb2RlZCk7IC8vIFs0Mm4sICdIZWxsbywgd29ybGQhJ11cbiAqIGBgYFxuICogQHNlZSBodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi92MC44LjE3L2FiaS1zcGVjLmh0bWxcbiAqIEBwYXJhbSB0eXBlcyAtIFRoZSB0eXBlcyB0byBlbmNvZGUuXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byBlbmNvZGUuIFRoaXMgYXJyYXkgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aCBhc1xuICogdGhlIHR5cGVzIGFycmF5LlxuICogQHBhcmFtIHBhY2tlZCAtIFdoZXRoZXIgdG8gdXNlIHRoZSBub24tc3RhbmRhcmQgcGFja2VkIG1vZGUuIERlZmF1bHRzIHRvXG4gKiBgZmFsc2VgLlxuICogQHBhcmFtIHRpZ2h0IC0gV2hldGhlciB0byBwYWNrIHRoZSB2YWx1ZXMgdGlnaHRseS4gV2hlbiBlbmFibGVkLCB0aGUgdmFsdWVzXG4gKiB3aWxsIGJlIHBhY2tlZCB3aXRob3V0IGFueSBwYWRkaW5nLiBUaGlzIG1hdGNoZXMgdGhlIGJlaGF2aW91ciBvZlxuICogYGV0aGVyZXVtanMtYWJpYC4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAqIEByZXR1cm5zIFRoZSBBQkkgZW5jb2RlZCBieXRlcy5cbiAqL1xuY29uc3QgZW5jb2RlID0gKHR5cGVzLCB2YWx1ZXMsIHBhY2tlZCwgdGlnaHQpID0+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKDAsIHBhY2tlcl8xLnBhY2spKHsgdHlwZXMsIHZhbHVlcywgcGFja2VkLCB0aWdodCB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIGVycm9yc18xLlBhcnNlckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuUGFyc2VyRXJyb3IoYFVuYWJsZSB0byBlbmNvZGUgdmFsdWU6ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlBhcnNlckVycm9yKGBBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkOiAkeygwLCBlcnJvcnNfMS5nZXRFcnJvck1lc3NhZ2UpKGVycm9yKX1gLCBlcnJvcik7XG4gICAgfVxufTtcbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuLyoqXG4gKiBFbmNvZGUgdGhlIGRhdGEgd2l0aCB0aGUgcHJvdmlkZWQgdHlwZS4gVGhlIHR5cGUgbXVzdCBiZSBhIHZhbGlkIFNvbGlkaXR5XG4gKiBBQkkgdHlwZS5cbiAqXG4gKiBTZWUge0BsaW5rIGVuY29kZX0gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IHZhbHVlcyBhcmUgcGFyc2VkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBlbmNvZGVTaW5nbGUsIGRlY29kZVNpbmdsZSB9IGZyb20gJ0BtZXRhbWFzay9hYmktdXRpbHMnO1xuICpcbiAqIGNvbnN0IGVuY29kZWQgPSBlbmNvZGVTaW5nbGUoJ3VpbnQyNTYnLCA0Mik7XG4gKiBjb25zdCBkZWNvZGVkID0gZGVjb2RlU2luZ2xlKCd1aW50MjU2JywgZW5jb2RlZCk7XG4gKlxuICogY29uc29sZS5sb2coZGVjb2RlZCk7IC8vIDQyblxuICogYGBgXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5zb2xpZGl0eWxhbmcub3JnL2VuL3YwLjguMTcvYWJpLXNwZWMuaHRtbCN0eXBlc1xuICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZW5jb2RlLlxuICogQHJldHVybnMgVGhlIEFCSSBlbmNvZGVkIGJ5dGVzLlxuICovXG5jb25zdCBlbmNvZGVTaW5nbGUgPSAodHlwZSwgdmFsdWUpID0+IHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuZW5jb2RlKShbdHlwZV0sIFt2YWx1ZV0pO1xufTtcbmV4cG9ydHMuZW5jb2RlU2luZ2xlID0gZW5jb2RlU2luZ2xlO1xuLyoqXG4gKiBFbmNvZGUgdGhlIGRhdGEgd2l0aCB0aGUgcHJvdmlkZWQgdHlwZXMuIFRoZSB0eXBlcyBtdXN0IGJlIHZhbGlkIFNvbGlkaXR5XG4gKiBBQkkgdHlwZXMuIFRoaXMgaXMgc2ltaWxhciB0byB7QGxpbmsgZW5jb2RlfSwgYnV0IHRoZSB2YWx1ZXMgYXJlIGVuY29kZWQgaW5cbiAqIHRoZSBub24tc3RhbmRhcmQgcGFja2VkIG1vZGUuIFRoaXMgZGlmZmVycyBmcm9tIHRoZSBzdGFuZGFyZCBlbmNvZGluZyBpbiB0aGVcbiAqIGZvbGxvd2luZyB3YXlzOlxuICpcbiAqIC0gTW9zdCB2YWx1ZXMgYXJlIHBhY2tlZCB0aWdodGx5LCB3aXRob3V0IGFsaWdubWVudCBwYWRkaW5nLlxuICogICAtIFRoZSBleGNlcHRpb24gaXMgYXJyYXkgdmFsdWVzLCB3aGljaCBhcmUgcGFkZGVkIHRvIDMyIGJ5dGVzLlxuICogLSBWYWx1ZXMgYXJlIHN0aWxsIHBhZGRlZCB0byB0aGVpciBmdWxsIHNpemUsIGkuZS4sIGB1aW50MTZgIHZhbHVlcyBhcmUgc3RpbGxcbiAqICBwYWRkZWQgdG8gMiBieXRlcywgcmVnYXJkbGVzcyBvZiB0aGUgbGVuZ3RoIG9mIHRoZSB2YWx1ZS5cbiAqIC0gVGhlIGVuY29kaW5nIG9mIGR5bmFtaWMgdHlwZXMgKGBieXRlc2AsIGBzdHJpbmdgKSBpcyBkaWZmZXJlbnQuIFRoZSBsZW5ndGhcbiAqIG9mIHRoZSBkeW5hbWljIHR5cGUgaXMgbm90IGluY2x1ZGVkIGluIHRoZSBlbmNvZGluZywgYW5kIHRoZSBkeW5hbWljIHR5cGUgaXNcbiAqIG5vdCBwYWRkZWQgdG8gYSBtdWx0aXBsZSBvZiAzMiBieXRlcy5cbiAqIC0gQWxsIHZhbHVlcyBhcmUgZW5jb2RlZCBpbi1wbGFjZSwgd2l0aG91dCBhbnkgb2Zmc2V0cy5cbiAqXG4gKiBUaGUgZW5jb2Rpbmcgb2YgdGhpcyBpcyBhbWJpZ3VvdXMgYXMgc29vbiBhcyB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIGR5bmFtaWNcbiAqIHR5cGUuIFRoYXQgbWVhbnMgdGhhdCB0aGVzZSB2YWx1ZXMgY2Fubm90IGJlIGRlY29kZWQgd2l0aCB7QGxpbmsgZGVjb2RlfSBvclxuICogU29saWRpdHkncyBgYWJpLmRlY29kZWAgZnVuY3Rpb24uXG4gKlxuICogU2VlIHtAbGluayBlbmNvZGV9IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGhvdyB2YWx1ZXMgYXJlIHBhcnNlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgZW5jb2RlUGFja2VkIH0gZnJvbSAnQG1ldGFtYXNrL2FiaS11dGlscyc7XG4gKlxuICogY29uc3QgZW5jb2RlZCA9IGVuY29kZVBhY2tlZChbJ3VpbnQ4J10sIFs0Ml0pO1xuICpcbiAqIGNvbnNvbGUubG9nKGVuY29kZWQpOyAvLyBgVWludDhBcnJheSBbIDQyIF1gXG4gKiBgYGBcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vdjAuOC4xNy9hYmktc3BlYy5odG1sI3R5cGVzXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5zb2xpZGl0eWxhbmcub3JnL2VuL3YwLjguMTcvYWJpLXNwZWMuaHRtbCNub24tc3RhbmRhcmQtcGFja2VkLW1vZGVcbiAqIEBwYXJhbSB0eXBlcyAtIFRoZSB0eXBlcyB0byBlbmNvZGUuXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byBlbmNvZGUuXG4gKiBAcGFyYW0gdGlnaHQgLSBXaGV0aGVyIHRvIHBhY2sgdGhlIHZhbHVlcyB0aWdodGx5LiBXaGVuIGVuYWJsZWQsIGBieXRlc05gXG4gKiB2YWx1ZXMgaW4gYXJyYXlzIHdpbGwgYmUgcGFja2VkIHdpdGhvdXQgYW55IHBhZGRpbmcuIFRoaXMgbWF0Y2hlcyB0aGVcbiAqIGJlaGF2aW91ciBvZiBgZXRoZXJldW1qcy1hYmlgLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICogQHJldHVybnMgVGhlIEFCSSBlbmNvZGVkIGJ5dGVzLlxuICovXG5jb25zdCBlbmNvZGVQYWNrZWQgPSAodHlwZXMsIHZhbHVlcywgdGlnaHQpID0+IHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuZW5jb2RlKSh0eXBlcywgdmFsdWVzLCB0cnVlLCB0aWdodCk7XG59O1xuZXhwb3J0cy5lbmNvZGVQYWNrZWQgPSBlbmNvZGVQYWNrZWQ7XG4vKipcbiAqIERlY29kZSBhbiBBQkkgZW5jb2RlZCBidWZmZXIgd2l0aCB0aGUgc3BlY2lmaWVkIHR5cGVzLiBUaGUgdHlwZXMgbXVzdCBiZVxuICogdmFsaWQgU29saWRpdHkgQUJJIHR5cGVzLlxuICpcbiAqIFRoaXMgd2lsbCBhdHRlbXB0IHRvIGluZmVyIHRoZSBvdXRwdXQgdHlwZXMgZnJvbSB0aGUgaW5wdXQgdHlwZXMuIEZvclxuICogZXhhbXBsZSwgaWYgeW91IHVzZSBgdWludDI1NmAgYXMgYW4gaW5wdXQgdHlwZSwgdGhlIG91dHB1dCB0eXBlIHdpbGwgYmVcbiAqIGBiaWdpbnRgLiBUaGlzIGRvZXMgbm90IHdvcmsgZm9yIGFsbCB0eXBlcywgaG93ZXZlci4gRm9yIGV4YW1wbGUsIGlmIHlvdSB1c2VcbiAqIG5lc3RlZCBhcnJheSB0eXBlcyBvciB0dXBsZSB0eXBlcywgdGhlIG91dHB1dCB0eXBlIHdpbGwgYmUgYHVua25vd25gLlxuICpcbiAqIFRoZSByZXN1bHRpbmcgdHlwZXMgb2YgdGhlIHZhbHVlcyB3aWxsIGJlIGFzIGZvbGxvd3M6XG4gKlxuICogfCBDb250cmFjdCBBQkkgVHlwZSB8IFJlc3VsdGluZyBKYXZhU2NyaXB0IFR5cGUgfFxuICogfCAtLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfFxuICogfCBgYWRkcmVzc2AgICAgICAgICB8IGBzdHJpbmdgICAgICAgICAgICAgICAgICAgfFxuICogfCBgYm9vbGAgICAgICAgICAgICB8IGBib29sZWFuYCAgICAgICAgICAgICAgICAgfFxuICogfCBgYnl0ZXMobilgICAgICAgICB8IGBVaW50OEFycmF5YCAgICAgICAgICAgICAgfFxuICogfCBgZnVuY3Rpb25gICAgICAgICB8IHtAbGluayBTb2xpZGl0eUZ1bmN0aW9ufSAgfFxuICogfCBgaW50KG4pYCAgICAgICAgICB8IGBiaWdpbnRgICAgICAgICAgICAgICAgICAgfFxuICogfCBgc3RyaW5nYCAgICAgICAgICB8IGBzdHJpbmdgICAgICAgICAgICAgICAgICAgfFxuICogfCBgdHVwbGVgICAgICAgICAgICB8IGBBcnJheWAgICAgICAgICAgICAgICAgICAgfFxuICogfCBgYXJyYXlgICAgICAgICAgICB8IGBBcnJheWAgICAgICAgICAgICAgICAgICAgfFxuICogfCBgdWludChuKWAgICAgICAgICB8IGBiaWdpbnRgICAgICAgICAgICAgICAgICAgfFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBlbmNvZGUsIGRlY29kZSB9IGZyb20gJ0BtZXRhbWFzay9hYmktdXRpbHMnO1xuICpcbiAqIGNvbnN0IHR5cGVzID0gWyd1aW50MjU2JywgJ3N0cmluZyddO1xuICogY29uc3QgZW5jb2RlZCA9IGVuY29kZSh0eXBlcywgWzQyLCAnSGVsbG8sIHdvcmxkISddKTtcbiAqIGNvbnN0IGRlY29kZWQgPSBkZWNvZGUodHlwZXMsIGVuY29kZWQpO1xuICpcbiAqIGNvbnNvbGUubG9nKGRlY29kZWQpOyAvLyBbNDJuLCAnSGVsbG8sIHdvcmxkISddXG4gKiBgYGBcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vdjAuOC4xNy9hYmktc3BlYy5odG1sI3R5cGVzXG4gKiBAcGFyYW0gdHlwZXMgLSBUaGUgdHlwZXMgdG8gZGVjb2RlIHRoZSBieXRlcyB3aXRoLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGJ5dGVzLWxpa2UgdmFsdWUgdG8gZGVjb2RlLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgdmFsdWVzIGFzIGFycmF5LlxuICovXG5jb25zdCBkZWNvZGUgPSAodHlwZXMsIHZhbHVlKSA9PiB7XG4gICAgY29uc3QgYnl0ZXMgPSAoMCwgdXRpbHNfMS5jcmVhdGVCeXRlcykodmFsdWUpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoMCwgcGFja2VyXzEudW5wYWNrKSh0eXBlcywgYnl0ZXMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgZXJyb3JzXzEuUGFyc2VyRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5QYXJzZXJFcnJvcihgVW5hYmxlIHRvIGRlY29kZSB2YWx1ZTogJHtlcnJvci5tZXNzYWdlfWAsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuUGFyc2VyRXJyb3IoYEFuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWQ6ICR7KDAsIGVycm9yc18xLmdldEVycm9yTWVzc2FnZSkoZXJyb3IpfWAsIGVycm9yKTtcbiAgICB9XG59O1xuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG4vKipcbiAqIERlY29kZSB0aGUgZGF0YSB3aXRoIHRoZSBwcm92aWRlZCB0eXBlLiBUaGUgdHlwZSBtdXN0IGJlIGEgdmFsaWQgU29saWRpdHlcbiAqIEFCSSB0eXBlLlxuICpcbiAqIFNlZSB7QGxpbmsgZGVjb2RlfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBob3cgdmFsdWVzIGFyZSBwYXJzZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IGVuY29kZVNpbmdsZSwgZGVjb2RlU2luZ2xlIH0gZnJvbSAnQG1ldGFtYXNrL2FiaS11dGlscyc7XG4gKlxuICogY29uc3QgZW5jb2RlZCA9IGVuY29kZVNpbmdsZSgndWludDI1NicsIDQyKTtcbiAqIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVTaW5nbGUoJ3VpbnQyNTYnLCBlbmNvZGVkKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhkZWNvZGVkKTsgLy8gNDJuXG4gKiBgYGBcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vdjAuOC4xNy9hYmktc3BlYy5odG1sI3R5cGVzXG4gKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIHRvIGRlY29kZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBieXRlcy1saWtlIHZhbHVlIHRvIGRlY29kZS5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIHZhbHVlLlxuICovXG5jb25zdCBkZWNvZGVTaW5nbGUgPSAodHlwZSwgdmFsdWUpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSAoMCwgZXhwb3J0cy5kZWNvZGUpKFt0eXBlXSwgdmFsdWUpO1xuICAgICgwLCB1dGlsc18xLmFzc2VydCkocmVzdWx0Lmxlbmd0aCA9PT0gMSwgbmV3IGVycm9yc18xLlBhcnNlckVycm9yKCdEZWNvZGVkIHZhbHVlIGFycmF5IGhhcyB1bmV4cGVjdGVkIGxlbmd0aC4nKSk7XG4gICAgcmV0dXJuIHJlc3VsdFswXTtcbn07XG5leHBvcnRzLmRlY29kZVNpbmdsZSA9IGRlY29kZVNpbmdsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFiaS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/abi-utils/dist/abi.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/abi-utils/dist/errors.js":
/*!*************************************************************!*\
  !*** ../../node_modules/@metamask/abi-utils/dist/errors.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ParserError = exports.getErrorStack = exports.getErrorMessage = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(rsc)/../../node_modules/@metamask/utils/dist/index.cjs\");\n/**\n * Attempt to get an error message from a value.\n *\n * - If the value is an error, the error's message is returned.\n * - If the value is an object with a `message` property, the value of that\n * property is returned.\n * - If the value is a string, the value is returned.\n * - Otherwise, \"Unknown error.\" is returned.\n *\n * @param error - The value to get an error message from.\n * @returns The error message.\n * @internal\n */\nconst getErrorMessage = (error) => {\n    if (typeof error === 'string') {\n        return error;\n    }\n    if (error instanceof Error) {\n        return error.message;\n    }\n    if ((0, utils_1.isObject)(error) &&\n        (0, utils_1.hasProperty)(error, 'message') &&\n        typeof error.message === 'string') {\n        return error.message;\n    }\n    return 'Unknown error.';\n};\nexports.getErrorMessage = getErrorMessage;\n/**\n * Get the error stack from a value. If the value is an error, the error's stack\n * is returned. Otherwise, it returns `undefined`.\n *\n * @param error - The value to get an error stack from.\n * @returns The error stack, or `undefined` if the value is not an error.\n * @internal\n */\nconst getErrorStack = (error) => {\n    if (error instanceof Error) {\n        return error.stack;\n    }\n    return undefined;\n};\nexports.getErrorStack = getErrorStack;\n/**\n * An error that is thrown when the ABI encoder or decoder encounters an\n * issue.\n */\nclass ParserError extends Error {\n    constructor(message, originalError) {\n        super(message);\n        this.name = 'ParserError';\n        const originalStack = (0, exports.getErrorStack)(originalError);\n        if (originalStack) {\n            this.stack = originalStack;\n        }\n    }\n}\nexports.ParserError = ParserError;\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcscUJBQXFCLEdBQUcsdUJBQXVCO0FBQ3JFLGdCQUFnQixtQkFBTyxDQUFDLGdGQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWJpLXV0aWxzL2Rpc3QvZXJyb3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYXJzZXJFcnJvciA9IGV4cG9ydHMuZ2V0RXJyb3JTdGFjayA9IGV4cG9ydHMuZ2V0RXJyb3JNZXNzYWdlID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svdXRpbHNcIik7XG4vKipcbiAqIEF0dGVtcHQgdG8gZ2V0IGFuIGVycm9yIG1lc3NhZ2UgZnJvbSBhIHZhbHVlLlxuICpcbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGFuIGVycm9yLCB0aGUgZXJyb3IncyBtZXNzYWdlIGlzIHJldHVybmVkLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYSBgbWVzc2FnZWAgcHJvcGVydHksIHRoZSB2YWx1ZSBvZiB0aGF0XG4gKiBwcm9wZXJ0eSBpcyByZXR1cm5lZC5cbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nLCB0aGUgdmFsdWUgaXMgcmV0dXJuZWQuXG4gKiAtIE90aGVyd2lzZSwgXCJVbmtub3duIGVycm9yLlwiIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSBlcnJvciAtIFRoZSB2YWx1ZSB0byBnZXQgYW4gZXJyb3IgbWVzc2FnZSBmcm9tLlxuICogQHJldHVybnMgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgZ2V0RXJyb3JNZXNzYWdlID0gKGVycm9yKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgICB9XG4gICAgaWYgKCgwLCB1dGlsc18xLmlzT2JqZWN0KShlcnJvcikgJiZcbiAgICAgICAgKDAsIHV0aWxzXzEuaGFzUHJvcGVydHkpKGVycm9yLCAnbWVzc2FnZScpICYmXG4gICAgICAgIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuICdVbmtub3duIGVycm9yLic7XG59O1xuZXhwb3J0cy5nZXRFcnJvck1lc3NhZ2UgPSBnZXRFcnJvck1lc3NhZ2U7XG4vKipcbiAqIEdldCB0aGUgZXJyb3Igc3RhY2sgZnJvbSBhIHZhbHVlLiBJZiB0aGUgdmFsdWUgaXMgYW4gZXJyb3IsIHRoZSBlcnJvcidzIHN0YWNrXG4gKiBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlLCBpdCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICpcbiAqIEBwYXJhbSBlcnJvciAtIFRoZSB2YWx1ZSB0byBnZXQgYW4gZXJyb3Igc3RhY2sgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBlcnJvciBzdGFjaywgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIHZhbHVlIGlzIG5vdCBhbiBlcnJvci5cbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBnZXRFcnJvclN0YWNrID0gKGVycm9yKSA9PiB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLnN0YWNrO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbmV4cG9ydHMuZ2V0RXJyb3JTdGFjayA9IGdldEVycm9yU3RhY2s7XG4vKipcbiAqIEFuIGVycm9yIHRoYXQgaXMgdGhyb3duIHdoZW4gdGhlIEFCSSBlbmNvZGVyIG9yIGRlY29kZXIgZW5jb3VudGVycyBhblxuICogaXNzdWUuXG4gKi9cbmNsYXNzIFBhcnNlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdQYXJzZXJFcnJvcic7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsU3RhY2sgPSAoMCwgZXhwb3J0cy5nZXRFcnJvclN0YWNrKShvcmlnaW5hbEVycm9yKTtcbiAgICAgICAgaWYgKG9yaWdpbmFsU3RhY2spIHtcbiAgICAgICAgICAgIHRoaXMuc3RhY2sgPSBvcmlnaW5hbFN0YWNrO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5QYXJzZXJFcnJvciA9IFBhcnNlckVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/abi-utils/dist/errors.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/abi-utils/dist/index.js":
/*!************************************************************!*\
  !*** ../../node_modules/@metamask/abi-utils/dist/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./abi */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/abi.js\"), exports);\n__exportStar(__webpack_require__(/*! ./errors */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/errors.js\"), exports);\n__exportStar(__webpack_require__(/*! ./types */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/types/index.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsdUVBQU87QUFDNUIsYUFBYSxtQkFBTyxDQUFDLDZFQUFVO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyxpRkFBUztBQUM5QiIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYWJpXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lcnJvcnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3R5cGVzXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/abi-utils/dist/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/abi-utils/dist/iterator.js":
/*!***************************************************************!*\
  !*** ../../node_modules/@metamask/abi-utils/dist/iterator.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.iterate = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(rsc)/../../node_modules/@metamask/utils/dist/index.cjs\");\n/**\n * Iterate over a buffer with the specified size. This will yield a part of the\n * buffer starting at an increment of the specified size, until the end of the\n * buffer is reached.\n *\n * Calling the `skip` function will make it skip the specified number of bytes.\n *\n * @param buffer - The buffer to iterate over.\n * @param size - The number of bytes to iterate with.\n * @returns An iterator that yields the parts of the byte array.\n * @yields The parts of the byte array.\n */\nconst iterate = function* (buffer, size = 32) {\n    for (let pointer = 0; pointer < buffer.length; pointer += size) {\n        const skip = (length) => {\n            (0, utils_1.assert)(length >= 0, 'Cannot skip a negative number of bytes.');\n            (0, utils_1.assert)(length % size === 0, 'Length must be a multiple of the size.');\n            pointer += length;\n        };\n        const value = buffer.subarray(pointer);\n        yield { skip, value };\n    }\n    return {\n        skip: () => undefined,\n        value: new Uint8Array(),\n    };\n};\nexports.iterate = iterate;\n//# sourceMappingURL=iterator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC9pdGVyYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2YsZ0JBQWdCLG1CQUFPLENBQUMsZ0ZBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWJpLXV0aWxzL2Rpc3QvaXRlcmF0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLml0ZXJhdGUgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay91dGlsc1wiKTtcbi8qKlxuICogSXRlcmF0ZSBvdmVyIGEgYnVmZmVyIHdpdGggdGhlIHNwZWNpZmllZCBzaXplLiBUaGlzIHdpbGwgeWllbGQgYSBwYXJ0IG9mIHRoZVxuICogYnVmZmVyIHN0YXJ0aW5nIGF0IGFuIGluY3JlbWVudCBvZiB0aGUgc3BlY2lmaWVkIHNpemUsIHVudGlsIHRoZSBlbmQgb2YgdGhlXG4gKiBidWZmZXIgaXMgcmVhY2hlZC5cbiAqXG4gKiBDYWxsaW5nIHRoZSBgc2tpcGAgZnVuY3Rpb24gd2lsbCBtYWtlIGl0IHNraXAgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgYnl0ZXMuXG4gKlxuICogQHBhcmFtIGJ1ZmZlciAtIFRoZSBidWZmZXIgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHNpemUgLSBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGl0ZXJhdGUgd2l0aC5cbiAqIEByZXR1cm5zIEFuIGl0ZXJhdG9yIHRoYXQgeWllbGRzIHRoZSBwYXJ0cyBvZiB0aGUgYnl0ZSBhcnJheS5cbiAqIEB5aWVsZHMgVGhlIHBhcnRzIG9mIHRoZSBieXRlIGFycmF5LlxuICovXG5jb25zdCBpdGVyYXRlID0gZnVuY3Rpb24qIChidWZmZXIsIHNpemUgPSAzMikge1xuICAgIGZvciAobGV0IHBvaW50ZXIgPSAwOyBwb2ludGVyIDwgYnVmZmVyLmxlbmd0aDsgcG9pbnRlciArPSBzaXplKSB7XG4gICAgICAgIGNvbnN0IHNraXAgPSAobGVuZ3RoKSA9PiB7XG4gICAgICAgICAgICAoMCwgdXRpbHNfMS5hc3NlcnQpKGxlbmd0aCA+PSAwLCAnQ2Fubm90IHNraXAgYSBuZWdhdGl2ZSBudW1iZXIgb2YgYnl0ZXMuJyk7XG4gICAgICAgICAgICAoMCwgdXRpbHNfMS5hc3NlcnQpKGxlbmd0aCAlIHNpemUgPT09IDAsICdMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIHRoZSBzaXplLicpO1xuICAgICAgICAgICAgcG9pbnRlciArPSBsZW5ndGg7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYnVmZmVyLnN1YmFycmF5KHBvaW50ZXIpO1xuICAgICAgICB5aWVsZCB7IHNraXAsIHZhbHVlIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNraXA6ICgpID0+IHVuZGVmaW5lZCxcbiAgICAgICAgdmFsdWU6IG5ldyBVaW50OEFycmF5KCksXG4gICAgfTtcbn07XG5leHBvcnRzLml0ZXJhdGUgPSBpdGVyYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXRlcmF0b3IuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/abi-utils/dist/iterator.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/abi-utils/dist/packer.js":
/*!*************************************************************!*\
  !*** ../../node_modules/@metamask/abi-utils/dist/packer.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unpack = exports.pack = exports.isDynamicParser = exports.getParser = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(rsc)/../../node_modules/@metamask/utils/dist/index.cjs\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/errors.js\");\nconst iterator_1 = __webpack_require__(/*! ./iterator */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/iterator.js\");\nconst parsers_1 = __webpack_require__(/*! ./parsers */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/index.js\");\nconst utils_2 = __webpack_require__(/*! ./utils */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/utils/index.js\");\n/**\n * Get the parser for the specified type.\n *\n * @param type - The type to get a parser for.\n * @returns The parser.\n * @throws If there is no parser for the specified type.\n */\nconst getParser = (type) => {\n    const parsers = {\n        address: parsers_1.address,\n        array: parsers_1.array,\n        bool: parsers_1.bool,\n        bytes: parsers_1.bytes,\n        fixedBytes: parsers_1.fixedBytes,\n        function: parsers_1.fn,\n        number: parsers_1.number,\n        string: parsers_1.string,\n        tuple: parsers_1.tuple,\n    };\n    const staticParser = parsers[type];\n    if (staticParser) {\n        return staticParser;\n    }\n    const parser = Object.values(parsers).find((value) => value.isType(type));\n    if (parser) {\n        return parser;\n    }\n    throw new errors_1.ParserError(`The type \"${type}\" is not supported.`);\n};\nexports.getParser = getParser;\n/**\n * Check if the specified parser is dynamic, for the provided types. This is\n * primarily used for parsing tuples, where a tuple can be dynamic based on the\n * types. For other parsers, it will simply use the set `isDynamic` value.\n *\n * @param parser - The parser to check.\n * @param type - The type to check the parser with.\n * @returns Whether the parser is dynamic.\n */\nconst isDynamicParser = (parser, type) => {\n    const { isDynamic } = parser;\n    if (typeof isDynamic === 'function') {\n        return isDynamic(type);\n    }\n    return isDynamic;\n};\nexports.isDynamicParser = isDynamicParser;\n/**\n * Pack the provided values in a buffer, encoded with the specified types. If a\n * buffer is specified, the resulting value will be concatenated with the\n * buffer.\n *\n * @param args - The arguments object.\n * @param args.types - The types of the values to pack.\n * @param args.values - The values to pack.\n * @param args.packed - Whether to use the non-standard packed mode. Defaults to\n * `false`.\n * @param args.arrayPacked - Whether to use the non-standard packed mode for\n * arrays. Defaults to `false`.\n * @param args.byteArray - The byte array to encode the values into. Defaults to\n * an empty array.\n * @param args.tight - Whether to use tight packing mode. Only applicable when\n * `packed` is true. When true, the packed mode will not add any padding bytes.\n * This matches the packing behaviour of `ethereumjs-abi`, but is not standard.\n * @returns The resulting encoded buffer.\n */\nconst pack = ({ types, values, packed = false, tight = false, arrayPacked = false, byteArray = new Uint8Array(), }) => {\n    (0, utils_1.assert)(types.length === values.length, new errors_1.ParserError(`The number of types (${types.length}) does not match the number of values (${values.length}).`));\n    const { staticBuffer, dynamicBuffer, pointers } = types.reduce(\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    ({ staticBuffer, dynamicBuffer, pointers }, type, index) => {\n        const parser = (0, exports.getParser)(type);\n        const value = values[index];\n        // If packed mode is enabled, we can skip the dynamic check, as all\n        // values are encoded in the static buffer.\n        if (packed || arrayPacked || !(0, exports.isDynamicParser)(parser, type)) {\n            return {\n                staticBuffer: parser.encode({\n                    buffer: staticBuffer,\n                    value,\n                    type,\n                    packed,\n                    tight,\n                }),\n                dynamicBuffer,\n                pointers,\n            };\n        }\n        const newStaticBuffer = (0, utils_1.concatBytes)([staticBuffer, new Uint8Array(32)]);\n        const newDynamicBuffer = parser.encode({\n            buffer: dynamicBuffer,\n            value,\n            type,\n            packed,\n            tight,\n        });\n        return {\n            staticBuffer: newStaticBuffer,\n            dynamicBuffer: newDynamicBuffer,\n            pointers: [\n                ...pointers,\n                { position: staticBuffer.length, pointer: dynamicBuffer.length },\n            ],\n        };\n    }, {\n        staticBuffer: new Uint8Array(),\n        dynamicBuffer: new Uint8Array(),\n        pointers: [],\n    });\n    // If packed mode is enabled, there shouldn't be any dynamic values.\n    (0, utils_1.assert)((!packed && !arrayPacked) || dynamicBuffer.length === 0, new errors_1.ParserError('Invalid pack state.'));\n    const dynamicStart = staticBuffer.length;\n    const updatedBuffer = pointers.reduce((target, { pointer, position }) => {\n        const offset = (0, utils_2.padStart)((0, utils_1.numberToBytes)(dynamicStart + pointer));\n        return (0, utils_2.set)(target, offset, position);\n    }, staticBuffer);\n    return (0, utils_1.concatBytes)([byteArray, updatedBuffer, dynamicBuffer]);\n};\nexports.pack = pack;\nconst unpack = (types, buffer) => {\n    const iterator = (0, iterator_1.iterate)(buffer);\n    return types.map((type) => {\n        const { value: { value, skip }, done, } = iterator.next();\n        (0, utils_1.assert)(!done, new errors_1.ParserError(`The encoded value is invalid for the provided types. Reached end of buffer while attempting to parse \"${type}\".`));\n        const parser = (0, exports.getParser)(type);\n        const isDynamic = (0, exports.isDynamicParser)(parser, type);\n        if (isDynamic) {\n            const pointer = (0, utils_1.bytesToNumber)(value.subarray(0, 32));\n            const target = buffer.subarray(pointer);\n            return parser.decode({ type, value: target, skip });\n        }\n        return parser.decode({ type, value, skip });\n    });\n};\nexports.unpack = unpack;\n//# sourceMappingURL=packer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC9wYWNrZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLFlBQVksR0FBRyx1QkFBdUIsR0FBRyxpQkFBaUI7QUFDM0UsZ0JBQWdCLG1CQUFPLENBQUMsZ0ZBQWlCO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLDZFQUFVO0FBQ25DLG1CQUFtQixtQkFBTyxDQUFDLGlGQUFZO0FBQ3ZDLGtCQUFrQixtQkFBTyxDQUFDLHFGQUFXO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLGlGQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxLQUFLO0FBQ3JEO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0dBQWtHO0FBQ2xILHlHQUF5RyxhQUFhLHlDQUF5QyxjQUFjO0FBQzdLLFlBQVksd0NBQXdDO0FBQ3BEO0FBQ0EsT0FBTyx1Q0FBdUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4REFBOEQ7QUFDaEY7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscURBQXFELG1CQUFtQjtBQUN4RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVMsYUFBYSxVQUFVO0FBQ2hELHFLQUFxSyxLQUFLO0FBQzFLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMkJBQTJCO0FBQzlEO0FBQ0EsK0JBQStCLG1CQUFtQjtBQUNsRCxLQUFLO0FBQ0w7QUFDQSxjQUFjO0FBQ2QiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC9wYWNrZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVucGFjayA9IGV4cG9ydHMucGFjayA9IGV4cG9ydHMuaXNEeW5hbWljUGFyc2VyID0gZXhwb3J0cy5nZXRQYXJzZXIgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay91dGlsc1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgaXRlcmF0b3JfMSA9IHJlcXVpcmUoXCIuL2l0ZXJhdG9yXCIpO1xuY29uc3QgcGFyc2Vyc18xID0gcmVxdWlyZShcIi4vcGFyc2Vyc1wiKTtcbmNvbnN0IHV0aWxzXzIgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qKlxuICogR2V0IHRoZSBwYXJzZXIgZm9yIHRoZSBzcGVjaWZpZWQgdHlwZS5cbiAqXG4gKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIHRvIGdldCBhIHBhcnNlciBmb3IuXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VyLlxuICogQHRocm93cyBJZiB0aGVyZSBpcyBubyBwYXJzZXIgZm9yIHRoZSBzcGVjaWZpZWQgdHlwZS5cbiAqL1xuY29uc3QgZ2V0UGFyc2VyID0gKHR5cGUpID0+IHtcbiAgICBjb25zdCBwYXJzZXJzID0ge1xuICAgICAgICBhZGRyZXNzOiBwYXJzZXJzXzEuYWRkcmVzcyxcbiAgICAgICAgYXJyYXk6IHBhcnNlcnNfMS5hcnJheSxcbiAgICAgICAgYm9vbDogcGFyc2Vyc18xLmJvb2wsXG4gICAgICAgIGJ5dGVzOiBwYXJzZXJzXzEuYnl0ZXMsXG4gICAgICAgIGZpeGVkQnl0ZXM6IHBhcnNlcnNfMS5maXhlZEJ5dGVzLFxuICAgICAgICBmdW5jdGlvbjogcGFyc2Vyc18xLmZuLFxuICAgICAgICBudW1iZXI6IHBhcnNlcnNfMS5udW1iZXIsXG4gICAgICAgIHN0cmluZzogcGFyc2Vyc18xLnN0cmluZyxcbiAgICAgICAgdHVwbGU6IHBhcnNlcnNfMS50dXBsZSxcbiAgICB9O1xuICAgIGNvbnN0IHN0YXRpY1BhcnNlciA9IHBhcnNlcnNbdHlwZV07XG4gICAgaWYgKHN0YXRpY1BhcnNlcikge1xuICAgICAgICByZXR1cm4gc3RhdGljUGFyc2VyO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZXIgPSBPYmplY3QudmFsdWVzKHBhcnNlcnMpLmZpbmQoKHZhbHVlKSA9PiB2YWx1ZS5pc1R5cGUodHlwZSkpO1xuICAgIGlmIChwYXJzZXIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IGVycm9yc18xLlBhcnNlckVycm9yKGBUaGUgdHlwZSBcIiR7dHlwZX1cIiBpcyBub3Qgc3VwcG9ydGVkLmApO1xufTtcbmV4cG9ydHMuZ2V0UGFyc2VyID0gZ2V0UGFyc2VyO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgc3BlY2lmaWVkIHBhcnNlciBpcyBkeW5hbWljLCBmb3IgdGhlIHByb3ZpZGVkIHR5cGVzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZCBmb3IgcGFyc2luZyB0dXBsZXMsIHdoZXJlIGEgdHVwbGUgY2FuIGJlIGR5bmFtaWMgYmFzZWQgb24gdGhlXG4gKiB0eXBlcy4gRm9yIG90aGVyIHBhcnNlcnMsIGl0IHdpbGwgc2ltcGx5IHVzZSB0aGUgc2V0IGBpc0R5bmFtaWNgIHZhbHVlLlxuICpcbiAqIEBwYXJhbSBwYXJzZXIgLSBUaGUgcGFyc2VyIHRvIGNoZWNrLlxuICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSB0byBjaGVjayB0aGUgcGFyc2VyIHdpdGguXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBwYXJzZXIgaXMgZHluYW1pYy5cbiAqL1xuY29uc3QgaXNEeW5hbWljUGFyc2VyID0gKHBhcnNlciwgdHlwZSkgPT4ge1xuICAgIGNvbnN0IHsgaXNEeW5hbWljIH0gPSBwYXJzZXI7XG4gICAgaWYgKHR5cGVvZiBpc0R5bmFtaWMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGlzRHluYW1pYyh0eXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRHluYW1pYztcbn07XG5leHBvcnRzLmlzRHluYW1pY1BhcnNlciA9IGlzRHluYW1pY1BhcnNlcjtcbi8qKlxuICogUGFjayB0aGUgcHJvdmlkZWQgdmFsdWVzIGluIGEgYnVmZmVyLCBlbmNvZGVkIHdpdGggdGhlIHNwZWNpZmllZCB0eXBlcy4gSWYgYVxuICogYnVmZmVyIGlzIHNwZWNpZmllZCwgdGhlIHJlc3VsdGluZyB2YWx1ZSB3aWxsIGJlIGNvbmNhdGVuYXRlZCB3aXRoIHRoZVxuICogYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBvYmplY3QuXG4gKiBAcGFyYW0gYXJncy50eXBlcyAtIFRoZSB0eXBlcyBvZiB0aGUgdmFsdWVzIHRvIHBhY2suXG4gKiBAcGFyYW0gYXJncy52YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIHBhY2suXG4gKiBAcGFyYW0gYXJncy5wYWNrZWQgLSBXaGV0aGVyIHRvIHVzZSB0aGUgbm9uLXN0YW5kYXJkIHBhY2tlZCBtb2RlLiBEZWZhdWx0cyB0b1xuICogYGZhbHNlYC5cbiAqIEBwYXJhbSBhcmdzLmFycmF5UGFja2VkIC0gV2hldGhlciB0byB1c2UgdGhlIG5vbi1zdGFuZGFyZCBwYWNrZWQgbW9kZSBmb3JcbiAqIGFycmF5cy4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAqIEBwYXJhbSBhcmdzLmJ5dGVBcnJheSAtIFRoZSBieXRlIGFycmF5IHRvIGVuY29kZSB0aGUgdmFsdWVzIGludG8uIERlZmF1bHRzIHRvXG4gKiBhbiBlbXB0eSBhcnJheS5cbiAqIEBwYXJhbSBhcmdzLnRpZ2h0IC0gV2hldGhlciB0byB1c2UgdGlnaHQgcGFja2luZyBtb2RlLiBPbmx5IGFwcGxpY2FibGUgd2hlblxuICogYHBhY2tlZGAgaXMgdHJ1ZS4gV2hlbiB0cnVlLCB0aGUgcGFja2VkIG1vZGUgd2lsbCBub3QgYWRkIGFueSBwYWRkaW5nIGJ5dGVzLlxuICogVGhpcyBtYXRjaGVzIHRoZSBwYWNraW5nIGJlaGF2aW91ciBvZiBgZXRoZXJldW1qcy1hYmlgLCBidXQgaXMgbm90IHN0YW5kYXJkLlxuICogQHJldHVybnMgVGhlIHJlc3VsdGluZyBlbmNvZGVkIGJ1ZmZlci5cbiAqL1xuY29uc3QgcGFjayA9ICh7IHR5cGVzLCB2YWx1ZXMsIHBhY2tlZCA9IGZhbHNlLCB0aWdodCA9IGZhbHNlLCBhcnJheVBhY2tlZCA9IGZhbHNlLCBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheSgpLCB9KSA9PiB7XG4gICAgKDAsIHV0aWxzXzEuYXNzZXJ0KSh0eXBlcy5sZW5ndGggPT09IHZhbHVlcy5sZW5ndGgsIG5ldyBlcnJvcnNfMS5QYXJzZXJFcnJvcihgVGhlIG51bWJlciBvZiB0eXBlcyAoJHt0eXBlcy5sZW5ndGh9KSBkb2VzIG5vdCBtYXRjaCB0aGUgbnVtYmVyIG9mIHZhbHVlcyAoJHt2YWx1ZXMubGVuZ3RofSkuYCkpO1xuICAgIGNvbnN0IHsgc3RhdGljQnVmZmVyLCBkeW5hbWljQnVmZmVyLCBwb2ludGVycyB9ID0gdHlwZXMucmVkdWNlKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tc2hhZG93XG4gICAgKHsgc3RhdGljQnVmZmVyLCBkeW5hbWljQnVmZmVyLCBwb2ludGVycyB9LCB0eXBlLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBwYXJzZXIgPSAoMCwgZXhwb3J0cy5nZXRQYXJzZXIpKHR5cGUpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgIC8vIElmIHBhY2tlZCBtb2RlIGlzIGVuYWJsZWQsIHdlIGNhbiBza2lwIHRoZSBkeW5hbWljIGNoZWNrLCBhcyBhbGxcbiAgICAgICAgLy8gdmFsdWVzIGFyZSBlbmNvZGVkIGluIHRoZSBzdGF0aWMgYnVmZmVyLlxuICAgICAgICBpZiAocGFja2VkIHx8IGFycmF5UGFja2VkIHx8ICEoMCwgZXhwb3J0cy5pc0R5bmFtaWNQYXJzZXIpKHBhcnNlciwgdHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdGljQnVmZmVyOiBwYXJzZXIuZW5jb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiBzdGF0aWNCdWZmZXIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICBwYWNrZWQsXG4gICAgICAgICAgICAgICAgICAgIHRpZ2h0LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGR5bmFtaWNCdWZmZXIsXG4gICAgICAgICAgICAgICAgcG9pbnRlcnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1N0YXRpY0J1ZmZlciA9ICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShbc3RhdGljQnVmZmVyLCBuZXcgVWludDhBcnJheSgzMildKTtcbiAgICAgICAgY29uc3QgbmV3RHluYW1pY0J1ZmZlciA9IHBhcnNlci5lbmNvZGUoe1xuICAgICAgICAgICAgYnVmZmVyOiBkeW5hbWljQnVmZmVyLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgcGFja2VkLFxuICAgICAgICAgICAgdGlnaHQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdGljQnVmZmVyOiBuZXdTdGF0aWNCdWZmZXIsXG4gICAgICAgICAgICBkeW5hbWljQnVmZmVyOiBuZXdEeW5hbWljQnVmZmVyLFxuICAgICAgICAgICAgcG9pbnRlcnM6IFtcbiAgICAgICAgICAgICAgICAuLi5wb2ludGVycyxcbiAgICAgICAgICAgICAgICB7IHBvc2l0aW9uOiBzdGF0aWNCdWZmZXIubGVuZ3RoLCBwb2ludGVyOiBkeW5hbWljQnVmZmVyLmxlbmd0aCB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICB9LCB7XG4gICAgICAgIHN0YXRpY0J1ZmZlcjogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgZHluYW1pY0J1ZmZlcjogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgcG9pbnRlcnM6IFtdLFxuICAgIH0pO1xuICAgIC8vIElmIHBhY2tlZCBtb2RlIGlzIGVuYWJsZWQsIHRoZXJlIHNob3VsZG4ndCBiZSBhbnkgZHluYW1pYyB2YWx1ZXMuXG4gICAgKDAsIHV0aWxzXzEuYXNzZXJ0KSgoIXBhY2tlZCAmJiAhYXJyYXlQYWNrZWQpIHx8IGR5bmFtaWNCdWZmZXIubGVuZ3RoID09PSAwLCBuZXcgZXJyb3JzXzEuUGFyc2VyRXJyb3IoJ0ludmFsaWQgcGFjayBzdGF0ZS4nKSk7XG4gICAgY29uc3QgZHluYW1pY1N0YXJ0ID0gc3RhdGljQnVmZmVyLmxlbmd0aDtcbiAgICBjb25zdCB1cGRhdGVkQnVmZmVyID0gcG9pbnRlcnMucmVkdWNlKCh0YXJnZXQsIHsgcG9pbnRlciwgcG9zaXRpb24gfSkgPT4ge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAoMCwgdXRpbHNfMi5wYWRTdGFydCkoKDAsIHV0aWxzXzEubnVtYmVyVG9CeXRlcykoZHluYW1pY1N0YXJ0ICsgcG9pbnRlcikpO1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzIuc2V0KSh0YXJnZXQsIG9mZnNldCwgcG9zaXRpb24pO1xuICAgIH0sIHN0YXRpY0J1ZmZlcik7XG4gICAgcmV0dXJuICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShbYnl0ZUFycmF5LCB1cGRhdGVkQnVmZmVyLCBkeW5hbWljQnVmZmVyXSk7XG59O1xuZXhwb3J0cy5wYWNrID0gcGFjaztcbmNvbnN0IHVucGFjayA9ICh0eXBlcywgYnVmZmVyKSA9PiB7XG4gICAgY29uc3QgaXRlcmF0b3IgPSAoMCwgaXRlcmF0b3JfMS5pdGVyYXRlKShidWZmZXIpO1xuICAgIHJldHVybiB0eXBlcy5tYXAoKHR5cGUpID0+IHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZTogeyB2YWx1ZSwgc2tpcCB9LCBkb25lLCB9ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAoMCwgdXRpbHNfMS5hc3NlcnQpKCFkb25lLCBuZXcgZXJyb3JzXzEuUGFyc2VyRXJyb3IoYFRoZSBlbmNvZGVkIHZhbHVlIGlzIGludmFsaWQgZm9yIHRoZSBwcm92aWRlZCB0eXBlcy4gUmVhY2hlZCBlbmQgb2YgYnVmZmVyIHdoaWxlIGF0dGVtcHRpbmcgdG8gcGFyc2UgXCIke3R5cGV9XCIuYCkpO1xuICAgICAgICBjb25zdCBwYXJzZXIgPSAoMCwgZXhwb3J0cy5nZXRQYXJzZXIpKHR5cGUpO1xuICAgICAgICBjb25zdCBpc0R5bmFtaWMgPSAoMCwgZXhwb3J0cy5pc0R5bmFtaWNQYXJzZXIpKHBhcnNlciwgdHlwZSk7XG4gICAgICAgIGlmIChpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXIgPSAoMCwgdXRpbHNfMS5ieXRlc1RvTnVtYmVyKSh2YWx1ZS5zdWJhcnJheSgwLCAzMikpO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gYnVmZmVyLnN1YmFycmF5KHBvaW50ZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlci5kZWNvZGUoeyB0eXBlLCB2YWx1ZTogdGFyZ2V0LCBza2lwIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZXIuZGVjb2RlKHsgdHlwZSwgdmFsdWUsIHNraXAgfSk7XG4gICAgfSk7XG59O1xuZXhwb3J0cy51bnBhY2sgPSB1bnBhY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWNrZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/abi-utils/dist/packer.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/address.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/@metamask/abi-utils/dist/parsers/address.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.address = exports.getAddress = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(rsc)/../../node_modules/@metamask/utils/dist/index.cjs\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/errors.js\");\nconst utils_2 = __webpack_require__(/*! ../utils */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/utils/index.js\");\n/**\n * Normalize an address value. This accepts the address as:\n *\n * - A hex string starting with the `0x` prefix.\n * - A byte array (`Uint8Array` or `Buffer`).\n *\n * It checks that the address is 20 bytes long.\n *\n * @param value - The value to normalize.\n * @returns The normalized address as `Uint8Array`.\n */\nconst getAddress = (value) => {\n    const bytesValue = (0, utils_1.createBytes)(value);\n    (0, utils_1.assert)(bytesValue.length <= 20, new errors_1.ParserError(`Invalid address value. Expected address to be 20 bytes long, but received ${bytesValue.length} bytes.`));\n    return (0, utils_2.padStart)(bytesValue, 20);\n};\nexports.getAddress = getAddress;\nexports.address = {\n    isDynamic: false,\n    /**\n     * Get if the given value is a valid address type. Since `address` is a simple\n     * type, this is just a check that the value is \"address\".\n     *\n     * @param type - The type to check.\n     * @returns Whether the type is a valid address type.\n     */\n    isType: (type) => type === 'address',\n    /**\n     * Get the byte length of an encoded address. Since `address` is a simple\n     * type, this always returns 32.\n     *\n     * Note that actual addresses are only 20 bytes long, but the encoding of\n     * the `address` type is always 32 bytes long.\n     *\n     * @returns The byte length of an encoded address.\n     */\n    getByteLength() {\n        return 32;\n    },\n    /**\n     * Encode the given address to a 32-byte-long byte array.\n     *\n     * @param args - The encoding arguments.\n     * @param args.buffer - The byte array to add to.\n     * @param args.value - The address to encode.\n     * @param args.packed - Whether to use packed encoding.\n     * @returns The bytes with the encoded address added to it.\n     */\n    encode({ buffer, value, packed }) {\n        const addressValue = (0, exports.getAddress)(value);\n        // If we're using packed encoding, we can just add the address bytes to the\n        // byte array, without adding any padding.\n        if (packed) {\n            return (0, utils_1.concatBytes)([buffer, addressValue]);\n        }\n        const addressBuffer = (0, utils_2.padStart)(addressValue);\n        return (0, utils_1.concatBytes)([buffer, addressBuffer]);\n    },\n    /**\n     * Decode the given byte array to an address.\n     *\n     * @param args - The decoding arguments.\n     * @param args.value - The byte array to decode.\n     * @returns The decoded address as a hexadecimal string, starting with the\n     * \"0x\"-prefix.\n     */\n    decode({ value }) {\n        return (0, utils_1.add0x)((0, utils_1.bytesToHex)(value.slice(12, 32)));\n    },\n};\n//# sourceMappingURL=address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC9wYXJzZXJzL2FkZHJlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxHQUFHLGtCQUFrQjtBQUNwQyxnQkFBZ0IsbUJBQU8sQ0FBQyxnRkFBaUI7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMsOEVBQVc7QUFDcEMsZ0JBQWdCLG1CQUFPLENBQUMsa0ZBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SkFBdUosbUJBQW1CO0FBQzFLO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC9wYXJzZXJzL2FkZHJlc3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFkZHJlc3MgPSBleHBvcnRzLmdldEFkZHJlc3MgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay91dGlsc1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IHV0aWxzXzIgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG4vKipcbiAqIE5vcm1hbGl6ZSBhbiBhZGRyZXNzIHZhbHVlLiBUaGlzIGFjY2VwdHMgdGhlIGFkZHJlc3MgYXM6XG4gKlxuICogLSBBIGhleCBzdHJpbmcgc3RhcnRpbmcgd2l0aCB0aGUgYDB4YCBwcmVmaXguXG4gKiAtIEEgYnl0ZSBhcnJheSAoYFVpbnQ4QXJyYXlgIG9yIGBCdWZmZXJgKS5cbiAqXG4gKiBJdCBjaGVja3MgdGhhdCB0aGUgYWRkcmVzcyBpcyAyMCBieXRlcyBsb25nLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBub3JtYWxpemUuXG4gKiBAcmV0dXJucyBUaGUgbm9ybWFsaXplZCBhZGRyZXNzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuY29uc3QgZ2V0QWRkcmVzcyA9ICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGJ5dGVzVmFsdWUgPSAoMCwgdXRpbHNfMS5jcmVhdGVCeXRlcykodmFsdWUpO1xuICAgICgwLCB1dGlsc18xLmFzc2VydCkoYnl0ZXNWYWx1ZS5sZW5ndGggPD0gMjAsIG5ldyBlcnJvcnNfMS5QYXJzZXJFcnJvcihgSW52YWxpZCBhZGRyZXNzIHZhbHVlLiBFeHBlY3RlZCBhZGRyZXNzIHRvIGJlIDIwIGJ5dGVzIGxvbmcsIGJ1dCByZWNlaXZlZCAke2J5dGVzVmFsdWUubGVuZ3RofSBieXRlcy5gKSk7XG4gICAgcmV0dXJuICgwLCB1dGlsc18yLnBhZFN0YXJ0KShieXRlc1ZhbHVlLCAyMCk7XG59O1xuZXhwb3J0cy5nZXRBZGRyZXNzID0gZ2V0QWRkcmVzcztcbmV4cG9ydHMuYWRkcmVzcyA9IHtcbiAgICBpc0R5bmFtaWM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEdldCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCBhZGRyZXNzIHR5cGUuIFNpbmNlIGBhZGRyZXNzYCBpcyBhIHNpbXBsZVxuICAgICAqIHR5cGUsIHRoaXMgaXMganVzdCBhIGNoZWNrIHRoYXQgdGhlIHZhbHVlIGlzIFwiYWRkcmVzc1wiLlxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB0eXBlIGlzIGEgdmFsaWQgYWRkcmVzcyB0eXBlLlxuICAgICAqL1xuICAgIGlzVHlwZTogKHR5cGUpID0+IHR5cGUgPT09ICdhZGRyZXNzJyxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJ5dGUgbGVuZ3RoIG9mIGFuIGVuY29kZWQgYWRkcmVzcy4gU2luY2UgYGFkZHJlc3NgIGlzIGEgc2ltcGxlXG4gICAgICogdHlwZSwgdGhpcyBhbHdheXMgcmV0dXJucyAzMi5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBhY3R1YWwgYWRkcmVzc2VzIGFyZSBvbmx5IDIwIGJ5dGVzIGxvbmcsIGJ1dCB0aGUgZW5jb2Rpbmcgb2ZcbiAgICAgKiB0aGUgYGFkZHJlc3NgIHR5cGUgaXMgYWx3YXlzIDMyIGJ5dGVzIGxvbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYnl0ZSBsZW5ndGggb2YgYW4gZW5jb2RlZCBhZGRyZXNzLlxuICAgICAqL1xuICAgIGdldEJ5dGVMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiAzMjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEVuY29kZSB0aGUgZ2l2ZW4gYWRkcmVzcyB0byBhIDMyLWJ5dGUtbG9uZyBieXRlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgZW5jb2RpbmcgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSBhcmdzLmJ1ZmZlciAtIFRoZSBieXRlIGFycmF5IHRvIGFkZCB0by5cbiAgICAgKiBAcGFyYW0gYXJncy52YWx1ZSAtIFRoZSBhZGRyZXNzIHRvIGVuY29kZS5cbiAgICAgKiBAcGFyYW0gYXJncy5wYWNrZWQgLSBXaGV0aGVyIHRvIHVzZSBwYWNrZWQgZW5jb2RpbmcuXG4gICAgICogQHJldHVybnMgVGhlIGJ5dGVzIHdpdGggdGhlIGVuY29kZWQgYWRkcmVzcyBhZGRlZCB0byBpdC5cbiAgICAgKi9cbiAgICBlbmNvZGUoeyBidWZmZXIsIHZhbHVlLCBwYWNrZWQgfSkge1xuICAgICAgICBjb25zdCBhZGRyZXNzVmFsdWUgPSAoMCwgZXhwb3J0cy5nZXRBZGRyZXNzKSh2YWx1ZSk7XG4gICAgICAgIC8vIElmIHdlJ3JlIHVzaW5nIHBhY2tlZCBlbmNvZGluZywgd2UgY2FuIGp1c3QgYWRkIHRoZSBhZGRyZXNzIGJ5dGVzIHRvIHRoZVxuICAgICAgICAvLyBieXRlIGFycmF5LCB3aXRob3V0IGFkZGluZyBhbnkgcGFkZGluZy5cbiAgICAgICAgaWYgKHBhY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShbYnVmZmVyLCBhZGRyZXNzVmFsdWVdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzQnVmZmVyID0gKDAsIHV0aWxzXzIucGFkU3RhcnQpKGFkZHJlc3NWYWx1ZSk7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoW2J1ZmZlciwgYWRkcmVzc0J1ZmZlcl0pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGVjb2RlIHRoZSBnaXZlbiBieXRlIGFycmF5IHRvIGFuIGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBkZWNvZGluZyBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIGFyZ3MudmFsdWUgLSBUaGUgYnl0ZSBhcnJheSB0byBkZWNvZGUuXG4gICAgICogQHJldHVybnMgVGhlIGRlY29kZWQgYWRkcmVzcyBhcyBhIGhleGFkZWNpbWFsIHN0cmluZywgc3RhcnRpbmcgd2l0aCB0aGVcbiAgICAgKiBcIjB4XCItcHJlZml4LlxuICAgICAqL1xuICAgIGRlY29kZSh7IHZhbHVlIH0pIHtcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmFkZDB4KSgoMCwgdXRpbHNfMS5ieXRlc1RvSGV4KSh2YWx1ZS5zbGljZSgxMiwgMzIpKSk7XG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/address.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/array.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@metamask/abi-utils/dist/parsers/array.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.array = exports.getTupleType = exports.getArrayType = exports.isArrayType = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(rsc)/../../node_modules/@metamask/utils/dist/index.cjs\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/errors.js\");\nconst packer_1 = __webpack_require__(/*! ../packer */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/packer.js\");\nconst utils_2 = __webpack_require__(/*! ../utils */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/utils/index.js\");\nconst fixed_bytes_1 = __webpack_require__(/*! ./fixed-bytes */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/fixed-bytes.js\");\nconst tuple_1 = __webpack_require__(/*! ./tuple */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/tuple.js\");\nconst ARRAY_REGEX = /^(?<type>.*)\\[(?<length>\\d*?)\\]$/u;\nconst isArrayType = (type) => ARRAY_REGEX.test(type);\nexports.isArrayType = isArrayType;\n/**\n * Get the type of the array.\n *\n * @param type - The type to get the array type for.\n * @returns The array type.\n */\nconst getArrayType = (type) => {\n    const match = type.match(ARRAY_REGEX);\n    (0, utils_1.assert)(match?.groups?.type, new errors_1.ParserError(`Invalid array type. Expected an array type, but received \"${type}\".`));\n    return [\n        match.groups.type,\n        match.groups.length ? parseInt(match.groups.length, 10) : undefined,\n    ];\n};\nexports.getArrayType = getArrayType;\n/**\n * Get the type of the array as a tuple type. This is used for encoding fixed\n * length arrays, which are encoded as tuples.\n *\n * @param innerType - The type of the array.\n * @param length - The length of the array.\n * @returns The tuple type.\n */\nconst getTupleType = (innerType, length) => {\n    return `(${new Array(length).fill(innerType).join(',')})`;\n};\nexports.getTupleType = getTupleType;\nexports.array = {\n    /**\n     * Check if the array is dynamic. Arrays are dynamic if the array does not\n     * have a fixed length, or if the array type is dynamic.\n     *\n     * @param type - The type to check.\n     * @returns Whether the array is dynamic.\n     */\n    isDynamic(type) {\n        const [innerType, length] = (0, exports.getArrayType)(type);\n        return (\n        // `T[]` is dynamic for any `T`. `T[k]` is dynamic for any dynamic `T` and\n        // any `k >= 0`.\n        length === undefined || (0, packer_1.isDynamicParser)((0, packer_1.getParser)(innerType), innerType));\n    },\n    /**\n     * Check if a type is an array type.\n     *\n     * @param type - The type to check.\n     * @returns Whether the type is an array type.\n     */\n    isType(type) {\n        return (0, exports.isArrayType)(type);\n    },\n    /**\n     * Get the byte length of an encoded array. If the array is dynamic, this\n     * returns 32, i.e., the length of the pointer to the array. If the array is\n     * static, this returns the byte length of the resulting tuple type.\n     *\n     * @param type - The type to get the byte length for.\n     * @returns The byte length of an encoded array.\n     */\n    getByteLength(type) {\n        (0, utils_1.assert)((0, exports.isArrayType)(type), new errors_1.ParserError(`Expected an array type, but received \"${type}\".`));\n        const [innerType, length] = (0, exports.getArrayType)(type);\n        if (!(0, packer_1.isDynamicParser)(this, type) && length !== undefined) {\n            return tuple_1.tuple.getByteLength((0, exports.getTupleType)(innerType, length));\n        }\n        return 32;\n    },\n    /**\n     * Encode the given array to a byte array. If the array is static, this uses\n     * the tuple encoder.\n     *\n     * @param args - The encoding arguments.\n     * @param args.type - The type of the array.\n     * @param args.buffer - The byte array to add to.\n     * @param args.value - The array to encode.\n     * @param args.packed - Whether to use non-standard packed encoding.\n     * @param args.tight - Whether to use non-standard tight encoding.\n     * @returns The bytes with the encoded array added to it.\n     */\n    encode({ type, buffer, value, packed, tight }) {\n        const [arrayType, fixedLength] = (0, exports.getArrayType)(type);\n        // Packed encoding does not support nested arrays.\n        (0, utils_1.assert)(!packed || !(0, exports.isArrayType)(arrayType), new errors_1.ParserError(`Cannot pack nested arrays.`));\n        // Tightly pack `T[]` where `T` is a dynamic type. This is not supported in\n        // Solidity, but is commonly used in the Ethereum ecosystem.\n        if (packed && (0, packer_1.isDynamicParser)((0, packer_1.getParser)(arrayType), arrayType)) {\n            return (0, packer_1.pack)({\n                types: new Array(value.length).fill(arrayType),\n                values: value,\n                byteArray: buffer,\n                packed,\n                arrayPacked: true,\n                tight,\n            });\n        }\n        if (fixedLength) {\n            (0, utils_1.assert)(fixedLength === value.length, new errors_1.ParserError(`Array length does not match type length. Expected a length of ${fixedLength}, but received ${value.length}.`));\n            // `T[k]` for any `T` and `k` is encoded as `(T[0], ..., T[k - 1])`.\n            return tuple_1.tuple.encode({\n                type: (0, exports.getTupleType)(arrayType, fixedLength),\n                buffer,\n                value,\n                // In \"tight\" mode, we don't pad the values to 32 bytes if the value is\n                // of type `bytesN`. This is an edge case in `ethereumjs-abi` that we\n                // support to provide compatibility with it.\n                packed: fixed_bytes_1.fixedBytes.isType(arrayType) && tight,\n                tight,\n            });\n        }\n        // For packed encoding, we don't need to encode the length of the array,\n        // so we can just encode the values.\n        if (packed) {\n            return (0, packer_1.pack)({\n                types: new Array(value.length).fill(arrayType),\n                values: value,\n                byteArray: buffer,\n                // In \"tight\" mode, we don't pad the values to 32 bytes if the value is\n                // of type `bytesN`. This is an edge case in `ethereumjs-abi` that we\n                // support to provide compatibility with it.\n                packed: fixed_bytes_1.fixedBytes.isType(arrayType) && tight,\n                arrayPacked: true,\n                tight,\n            });\n        }\n        // `T[]` with `k` elements is encoded as `k (T[0], ..., T[k - 1])`. That\n        // means that we just need to encode the length of the array, and then the\n        // array itself. The pointer is encoded by the {@link pack} function.\n        const arrayLength = (0, utils_2.padStart)((0, utils_1.numberToBytes)(value.length));\n        return (0, packer_1.pack)({\n            types: new Array(value.length).fill(arrayType),\n            values: value,\n            byteArray: (0, utils_1.concatBytes)([buffer, arrayLength]),\n            packed,\n            tight,\n        });\n    },\n    /**\n     * Decode an array from the given byte array.\n     *\n     * @param args - The decoding arguments.\n     * @param args.type - The type of the array.\n     * @param args.value - The byte array to decode.\n     * @returns The decoded array.\n     */\n    decode({ type, value, ...rest }) {\n        const [arrayType, fixedLength] = (0, exports.getArrayType)(type);\n        if (fixedLength) {\n            const result = tuple_1.tuple.decode({\n                type: (0, exports.getTupleType)(arrayType, fixedLength),\n                value,\n                ...rest,\n            });\n            (0, utils_1.assert)(result.length === fixedLength, new errors_1.ParserError(`Array length does not match type length. Expected a length of ${fixedLength}, but received ${result.length}.`));\n            return result;\n        }\n        const arrayLength = (0, utils_1.bytesToNumber)(value.subarray(0, 32));\n        return (0, packer_1.unpack)(new Array(arrayLength).fill(arrayType), value.subarray(32));\n    },\n};\n//# sourceMappingURL=array.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC9wYXJzZXJzL2FycmF5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0IsR0FBRyxtQkFBbUI7QUFDakYsZ0JBQWdCLG1CQUFPLENBQUMsZ0ZBQWlCO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLDhFQUFXO0FBQ3BDLGlCQUFpQixtQkFBTyxDQUFDLDhFQUFXO0FBQ3BDLGdCQUFnQixtQkFBTyxDQUFDLGtGQUFVO0FBQ2xDLHNCQUFzQixtQkFBTyxDQUFDLCtGQUFlO0FBQzdDLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFTO0FBQ2pDO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1JQUFtSSxLQUFLO0FBQ3hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0Q0FBNEM7QUFDM0Q7QUFDQSxvQkFBb0I7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEhBQThILEtBQUs7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9DQUFvQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esd0pBQXdKLFlBQVksaUJBQWlCLGFBQWE7QUFDbE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsWUFBWTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix5SkFBeUosWUFBWSxpQkFBaUIsY0FBYztBQUNwTTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWJpLXV0aWxzL2Rpc3QvcGFyc2Vycy9hcnJheS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXJyYXkgPSBleHBvcnRzLmdldFR1cGxlVHlwZSA9IGV4cG9ydHMuZ2V0QXJyYXlUeXBlID0gZXhwb3J0cy5pc0FycmF5VHlwZSA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL3V0aWxzXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgcGFja2VyXzEgPSByZXF1aXJlKFwiLi4vcGFja2VyXCIpO1xuY29uc3QgdXRpbHNfMiA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IGZpeGVkX2J5dGVzXzEgPSByZXF1aXJlKFwiLi9maXhlZC1ieXRlc1wiKTtcbmNvbnN0IHR1cGxlXzEgPSByZXF1aXJlKFwiLi90dXBsZVwiKTtcbmNvbnN0IEFSUkFZX1JFR0VYID0gL14oPzx0eXBlPi4qKVxcWyg/PGxlbmd0aD5cXGQqPylcXF0kL3U7XG5jb25zdCBpc0FycmF5VHlwZSA9ICh0eXBlKSA9PiBBUlJBWV9SRUdFWC50ZXN0KHR5cGUpO1xuZXhwb3J0cy5pc0FycmF5VHlwZSA9IGlzQXJyYXlUeXBlO1xuLyoqXG4gKiBHZXQgdGhlIHR5cGUgb2YgdGhlIGFycmF5LlxuICpcbiAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgdG8gZ2V0IHRoZSBhcnJheSB0eXBlIGZvci5cbiAqIEByZXR1cm5zIFRoZSBhcnJheSB0eXBlLlxuICovXG5jb25zdCBnZXRBcnJheVR5cGUgPSAodHlwZSkgPT4ge1xuICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaChBUlJBWV9SRUdFWCk7XG4gICAgKDAsIHV0aWxzXzEuYXNzZXJ0KShtYXRjaD8uZ3JvdXBzPy50eXBlLCBuZXcgZXJyb3JzXzEuUGFyc2VyRXJyb3IoYEludmFsaWQgYXJyYXkgdHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgdHlwZSwgYnV0IHJlY2VpdmVkIFwiJHt0eXBlfVwiLmApKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBtYXRjaC5ncm91cHMudHlwZSxcbiAgICAgICAgbWF0Y2guZ3JvdXBzLmxlbmd0aCA/IHBhcnNlSW50KG1hdGNoLmdyb3Vwcy5sZW5ndGgsIDEwKSA6IHVuZGVmaW5lZCxcbiAgICBdO1xufTtcbmV4cG9ydHMuZ2V0QXJyYXlUeXBlID0gZ2V0QXJyYXlUeXBlO1xuLyoqXG4gKiBHZXQgdGhlIHR5cGUgb2YgdGhlIGFycmF5IGFzIGEgdHVwbGUgdHlwZS4gVGhpcyBpcyB1c2VkIGZvciBlbmNvZGluZyBmaXhlZFxuICogbGVuZ3RoIGFycmF5cywgd2hpY2ggYXJlIGVuY29kZWQgYXMgdHVwbGVzLlxuICpcbiAqIEBwYXJhbSBpbm5lclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgYXJyYXkuXG4gKiBAcGFyYW0gbGVuZ3RoIC0gVGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gKiBAcmV0dXJucyBUaGUgdHVwbGUgdHlwZS5cbiAqL1xuY29uc3QgZ2V0VHVwbGVUeXBlID0gKGlubmVyVHlwZSwgbGVuZ3RoKSA9PiB7XG4gICAgcmV0dXJuIGAoJHtuZXcgQXJyYXkobGVuZ3RoKS5maWxsKGlubmVyVHlwZSkuam9pbignLCcpfSlgO1xufTtcbmV4cG9ydHMuZ2V0VHVwbGVUeXBlID0gZ2V0VHVwbGVUeXBlO1xuZXhwb3J0cy5hcnJheSA9IHtcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgYXJyYXkgaXMgZHluYW1pYy4gQXJyYXlzIGFyZSBkeW5hbWljIGlmIHRoZSBhcnJheSBkb2VzIG5vdFxuICAgICAqIGhhdmUgYSBmaXhlZCBsZW5ndGgsIG9yIGlmIHRoZSBhcnJheSB0eXBlIGlzIGR5bmFtaWMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGFycmF5IGlzIGR5bmFtaWMuXG4gICAgICovXG4gICAgaXNEeW5hbWljKHR5cGUpIHtcbiAgICAgICAgY29uc3QgW2lubmVyVHlwZSwgbGVuZ3RoXSA9ICgwLCBleHBvcnRzLmdldEFycmF5VHlwZSkodHlwZSk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgIC8vIGBUW11gIGlzIGR5bmFtaWMgZm9yIGFueSBgVGAuIGBUW2tdYCBpcyBkeW5hbWljIGZvciBhbnkgZHluYW1pYyBgVGAgYW5kXG4gICAgICAgIC8vIGFueSBgayA+PSAwYC5cbiAgICAgICAgbGVuZ3RoID09PSB1bmRlZmluZWQgfHwgKDAsIHBhY2tlcl8xLmlzRHluYW1pY1BhcnNlcikoKDAsIHBhY2tlcl8xLmdldFBhcnNlcikoaW5uZXJUeXBlKSwgaW5uZXJUeXBlKSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHR5cGUgaXMgYW4gYXJyYXkgdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgdHlwZSBpcyBhbiBhcnJheSB0eXBlLlxuICAgICAqL1xuICAgIGlzVHlwZSh0eXBlKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5pc0FycmF5VHlwZSkodHlwZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJ5dGUgbGVuZ3RoIG9mIGFuIGVuY29kZWQgYXJyYXkuIElmIHRoZSBhcnJheSBpcyBkeW5hbWljLCB0aGlzXG4gICAgICogcmV0dXJucyAzMiwgaS5lLiwgdGhlIGxlbmd0aCBvZiB0aGUgcG9pbnRlciB0byB0aGUgYXJyYXkuIElmIHRoZSBhcnJheSBpc1xuICAgICAqIHN0YXRpYywgdGhpcyByZXR1cm5zIHRoZSBieXRlIGxlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHR1cGxlIHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIHRvIGdldCB0aGUgYnl0ZSBsZW5ndGggZm9yLlxuICAgICAqIEByZXR1cm5zIFRoZSBieXRlIGxlbmd0aCBvZiBhbiBlbmNvZGVkIGFycmF5LlxuICAgICAqL1xuICAgIGdldEJ5dGVMZW5ndGgodHlwZSkge1xuICAgICAgICAoMCwgdXRpbHNfMS5hc3NlcnQpKCgwLCBleHBvcnRzLmlzQXJyYXlUeXBlKSh0eXBlKSwgbmV3IGVycm9yc18xLlBhcnNlckVycm9yKGBFeHBlY3RlZCBhbiBhcnJheSB0eXBlLCBidXQgcmVjZWl2ZWQgXCIke3R5cGV9XCIuYCkpO1xuICAgICAgICBjb25zdCBbaW5uZXJUeXBlLCBsZW5ndGhdID0gKDAsIGV4cG9ydHMuZ2V0QXJyYXlUeXBlKSh0eXBlKTtcbiAgICAgICAgaWYgKCEoMCwgcGFja2VyXzEuaXNEeW5hbWljUGFyc2VyKSh0aGlzLCB0eXBlKSAmJiBsZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHR1cGxlXzEudHVwbGUuZ2V0Qnl0ZUxlbmd0aCgoMCwgZXhwb3J0cy5nZXRUdXBsZVR5cGUpKGlubmVyVHlwZSwgbGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDMyO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRW5jb2RlIHRoZSBnaXZlbiBhcnJheSB0byBhIGJ5dGUgYXJyYXkuIElmIHRoZSBhcnJheSBpcyBzdGF0aWMsIHRoaXMgdXNlc1xuICAgICAqIHRoZSB0dXBsZSBlbmNvZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgZW5jb2RpbmcgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSBhcmdzLnR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgYXJyYXkuXG4gICAgICogQHBhcmFtIGFyZ3MuYnVmZmVyIC0gVGhlIGJ5dGUgYXJyYXkgdG8gYWRkIHRvLlxuICAgICAqIEBwYXJhbSBhcmdzLnZhbHVlIC0gVGhlIGFycmF5IHRvIGVuY29kZS5cbiAgICAgKiBAcGFyYW0gYXJncy5wYWNrZWQgLSBXaGV0aGVyIHRvIHVzZSBub24tc3RhbmRhcmQgcGFja2VkIGVuY29kaW5nLlxuICAgICAqIEBwYXJhbSBhcmdzLnRpZ2h0IC0gV2hldGhlciB0byB1c2Ugbm9uLXN0YW5kYXJkIHRpZ2h0IGVuY29kaW5nLlxuICAgICAqIEByZXR1cm5zIFRoZSBieXRlcyB3aXRoIHRoZSBlbmNvZGVkIGFycmF5IGFkZGVkIHRvIGl0LlxuICAgICAqL1xuICAgIGVuY29kZSh7IHR5cGUsIGJ1ZmZlciwgdmFsdWUsIHBhY2tlZCwgdGlnaHQgfSkge1xuICAgICAgICBjb25zdCBbYXJyYXlUeXBlLCBmaXhlZExlbmd0aF0gPSAoMCwgZXhwb3J0cy5nZXRBcnJheVR5cGUpKHR5cGUpO1xuICAgICAgICAvLyBQYWNrZWQgZW5jb2RpbmcgZG9lcyBub3Qgc3VwcG9ydCBuZXN0ZWQgYXJyYXlzLlxuICAgICAgICAoMCwgdXRpbHNfMS5hc3NlcnQpKCFwYWNrZWQgfHwgISgwLCBleHBvcnRzLmlzQXJyYXlUeXBlKShhcnJheVR5cGUpLCBuZXcgZXJyb3JzXzEuUGFyc2VyRXJyb3IoYENhbm5vdCBwYWNrIG5lc3RlZCBhcnJheXMuYCkpO1xuICAgICAgICAvLyBUaWdodGx5IHBhY2sgYFRbXWAgd2hlcmUgYFRgIGlzIGEgZHluYW1pYyB0eXBlLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgaW5cbiAgICAgICAgLy8gU29saWRpdHksIGJ1dCBpcyBjb21tb25seSB1c2VkIGluIHRoZSBFdGhlcmV1bSBlY29zeXN0ZW0uXG4gICAgICAgIGlmIChwYWNrZWQgJiYgKDAsIHBhY2tlcl8xLmlzRHluYW1pY1BhcnNlcikoKDAsIHBhY2tlcl8xLmdldFBhcnNlcikoYXJyYXlUeXBlKSwgYXJyYXlUeXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBwYWNrZXJfMS5wYWNrKSh7XG4gICAgICAgICAgICAgICAgdHlwZXM6IG5ldyBBcnJheSh2YWx1ZS5sZW5ndGgpLmZpbGwoYXJyYXlUeXBlKSxcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGJ5dGVBcnJheTogYnVmZmVyLFxuICAgICAgICAgICAgICAgIHBhY2tlZCxcbiAgICAgICAgICAgICAgICBhcnJheVBhY2tlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0aWdodCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXhlZExlbmd0aCkge1xuICAgICAgICAgICAgKDAsIHV0aWxzXzEuYXNzZXJ0KShmaXhlZExlbmd0aCA9PT0gdmFsdWUubGVuZ3RoLCBuZXcgZXJyb3JzXzEuUGFyc2VyRXJyb3IoYEFycmF5IGxlbmd0aCBkb2VzIG5vdCBtYXRjaCB0eXBlIGxlbmd0aC4gRXhwZWN0ZWQgYSBsZW5ndGggb2YgJHtmaXhlZExlbmd0aH0sIGJ1dCByZWNlaXZlZCAke3ZhbHVlLmxlbmd0aH0uYCkpO1xuICAgICAgICAgICAgLy8gYFRba11gIGZvciBhbnkgYFRgIGFuZCBga2AgaXMgZW5jb2RlZCBhcyBgKFRbMF0sIC4uLiwgVFtrIC0gMV0pYC5cbiAgICAgICAgICAgIHJldHVybiB0dXBsZV8xLnR1cGxlLmVuY29kZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogKDAsIGV4cG9ydHMuZ2V0VHVwbGVUeXBlKShhcnJheVR5cGUsIGZpeGVkTGVuZ3RoKSxcbiAgICAgICAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgLy8gSW4gXCJ0aWdodFwiIG1vZGUsIHdlIGRvbid0IHBhZCB0aGUgdmFsdWVzIHRvIDMyIGJ5dGVzIGlmIHRoZSB2YWx1ZSBpc1xuICAgICAgICAgICAgICAgIC8vIG9mIHR5cGUgYGJ5dGVzTmAuIFRoaXMgaXMgYW4gZWRnZSBjYXNlIGluIGBldGhlcmV1bWpzLWFiaWAgdGhhdCB3ZVxuICAgICAgICAgICAgICAgIC8vIHN1cHBvcnQgdG8gcHJvdmlkZSBjb21wYXRpYmlsaXR5IHdpdGggaXQuXG4gICAgICAgICAgICAgICAgcGFja2VkOiBmaXhlZF9ieXRlc18xLmZpeGVkQnl0ZXMuaXNUeXBlKGFycmF5VHlwZSkgJiYgdGlnaHQsXG4gICAgICAgICAgICAgICAgdGlnaHQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgcGFja2VkIGVuY29kaW5nLCB3ZSBkb24ndCBuZWVkIHRvIGVuY29kZSB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSxcbiAgICAgICAgLy8gc28gd2UgY2FuIGp1c3QgZW5jb2RlIHRoZSB2YWx1ZXMuXG4gICAgICAgIGlmIChwYWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgcGFja2VyXzEucGFjaykoe1xuICAgICAgICAgICAgICAgIHR5cGVzOiBuZXcgQXJyYXkodmFsdWUubGVuZ3RoKS5maWxsKGFycmF5VHlwZSksXG4gICAgICAgICAgICAgICAgdmFsdWVzOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBieXRlQXJyYXk6IGJ1ZmZlcixcbiAgICAgICAgICAgICAgICAvLyBJbiBcInRpZ2h0XCIgbW9kZSwgd2UgZG9uJ3QgcGFkIHRoZSB2YWx1ZXMgdG8gMzIgYnl0ZXMgaWYgdGhlIHZhbHVlIGlzXG4gICAgICAgICAgICAgICAgLy8gb2YgdHlwZSBgYnl0ZXNOYC4gVGhpcyBpcyBhbiBlZGdlIGNhc2UgaW4gYGV0aGVyZXVtanMtYWJpYCB0aGF0IHdlXG4gICAgICAgICAgICAgICAgLy8gc3VwcG9ydCB0byBwcm92aWRlIGNvbXBhdGliaWxpdHkgd2l0aCBpdC5cbiAgICAgICAgICAgICAgICBwYWNrZWQ6IGZpeGVkX2J5dGVzXzEuZml4ZWRCeXRlcy5pc1R5cGUoYXJyYXlUeXBlKSAmJiB0aWdodCxcbiAgICAgICAgICAgICAgICBhcnJheVBhY2tlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0aWdodCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGBUW11gIHdpdGggYGtgIGVsZW1lbnRzIGlzIGVuY29kZWQgYXMgYGsgKFRbMF0sIC4uLiwgVFtrIC0gMV0pYC4gVGhhdFxuICAgICAgICAvLyBtZWFucyB0aGF0IHdlIGp1c3QgbmVlZCB0byBlbmNvZGUgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXksIGFuZCB0aGVuIHRoZVxuICAgICAgICAvLyBhcnJheSBpdHNlbGYuIFRoZSBwb2ludGVyIGlzIGVuY29kZWQgYnkgdGhlIHtAbGluayBwYWNrfSBmdW5jdGlvbi5cbiAgICAgICAgY29uc3QgYXJyYXlMZW5ndGggPSAoMCwgdXRpbHNfMi5wYWRTdGFydCkoKDAsIHV0aWxzXzEubnVtYmVyVG9CeXRlcykodmFsdWUubGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiAoMCwgcGFja2VyXzEucGFjaykoe1xuICAgICAgICAgICAgdHlwZXM6IG5ldyBBcnJheSh2YWx1ZS5sZW5ndGgpLmZpbGwoYXJyYXlUeXBlKSxcbiAgICAgICAgICAgIHZhbHVlczogdmFsdWUsXG4gICAgICAgICAgICBieXRlQXJyYXk6ICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShbYnVmZmVyLCBhcnJheUxlbmd0aF0pLFxuICAgICAgICAgICAgcGFja2VkLFxuICAgICAgICAgICAgdGlnaHQsXG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGVjb2RlIGFuIGFycmF5IGZyb20gdGhlIGdpdmVuIGJ5dGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBkZWNvZGluZyBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIGFyZ3MudHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBhcnJheS5cbiAgICAgKiBAcGFyYW0gYXJncy52YWx1ZSAtIFRoZSBieXRlIGFycmF5IHRvIGRlY29kZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgZGVjb2RlZCBhcnJheS5cbiAgICAgKi9cbiAgICBkZWNvZGUoeyB0eXBlLCB2YWx1ZSwgLi4ucmVzdCB9KSB7XG4gICAgICAgIGNvbnN0IFthcnJheVR5cGUsIGZpeGVkTGVuZ3RoXSA9ICgwLCBleHBvcnRzLmdldEFycmF5VHlwZSkodHlwZSk7XG4gICAgICAgIGlmIChmaXhlZExlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdHVwbGVfMS50dXBsZS5kZWNvZGUoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICgwLCBleHBvcnRzLmdldFR1cGxlVHlwZSkoYXJyYXlUeXBlLCBmaXhlZExlbmd0aCksXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgKDAsIHV0aWxzXzEuYXNzZXJ0KShyZXN1bHQubGVuZ3RoID09PSBmaXhlZExlbmd0aCwgbmV3IGVycm9yc18xLlBhcnNlckVycm9yKGBBcnJheSBsZW5ndGggZG9lcyBub3QgbWF0Y2ggdHlwZSBsZW5ndGguIEV4cGVjdGVkIGEgbGVuZ3RoIG9mICR7Zml4ZWRMZW5ndGh9LCBidXQgcmVjZWl2ZWQgJHtyZXN1bHQubGVuZ3RofS5gKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFycmF5TGVuZ3RoID0gKDAsIHV0aWxzXzEuYnl0ZXNUb051bWJlcikodmFsdWUuc3ViYXJyYXkoMCwgMzIpKTtcbiAgICAgICAgcmV0dXJuICgwLCBwYWNrZXJfMS51bnBhY2spKG5ldyBBcnJheShhcnJheUxlbmd0aCkuZmlsbChhcnJheVR5cGUpLCB2YWx1ZS5zdWJhcnJheSgzMikpO1xuICAgIH0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJyYXkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/array.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/bool.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@metamask/abi-utils/dist/parsers/bool.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bool = exports.getBooleanValue = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(rsc)/../../node_modules/@metamask/superstruct/dist/index.cjs\");\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(rsc)/../../node_modules/@metamask/utils/dist/index.cjs\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/errors.js\");\nconst number_1 = __webpack_require__(/*! ./number */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/number.js\");\nconst BooleanCoercer = (0, superstruct_1.coerce)((0, superstruct_1.boolean)(), (0, superstruct_1.union)([(0, superstruct_1.literal)('true'), (0, superstruct_1.literal)('false')]), (value) => value === 'true');\n/**\n * Normalize a boolean value. This accepts the boolean as:\n *\n * - A boolean literal.\n * - The string \"true\" or \"false\".\n *\n * @param value - The value to get a boolean for.\n * @returns The parsed boolean value. This is `BigInt(1)` for truthy values, or\n * `BigInt(0)` for falsy values.\n */\nconst getBooleanValue = (value) => {\n    try {\n        const booleanValue = (0, superstruct_1.create)(value, BooleanCoercer);\n        if (booleanValue) {\n            return BigInt(1);\n        }\n        return BigInt(0);\n    }\n    catch {\n        throw new errors_1.ParserError(`Invalid boolean value. Expected a boolean literal, or the string \"true\" or \"false\", but received \"${value}\".`);\n    }\n};\nexports.getBooleanValue = getBooleanValue;\nexports.bool = {\n    isDynamic: false,\n    /**\n     * Get if the given value is a valid boolean type. Since `bool` is a simple\n     * type, this is just a check that the value is \"bool\".\n     *\n     * @param type - The type to check.\n     * @returns Whether the type is a valid boolean type.\n     */\n    isType: (type) => type === 'bool',\n    /**\n     * Get the byte length of an encoded boolean. Since `bool` is a simple\n     * type, this always returns 32.\n     *\n     * Note that actual booleans are only 1 byte long, but the encoding of\n     * the `bool` type is always 32 bytes long.\n     *\n     * @returns The byte length of an encoded boolean.\n     */\n    getByteLength() {\n        return 32;\n    },\n    /**\n     * Encode the given boolean to a byte array.\n     *\n     * @param args - The encoding arguments.\n     * @param args.buffer - The byte array to add to.\n     * @param args.value - The boolean to encode.\n     * @param args.packed - Whether the value is packed.\n     * @param args.tight - Whether to use non-standard tight encoding.\n     * @returns The bytes with the encoded boolean added to it.\n     */\n    encode({ buffer, value, packed, tight }) {\n        const booleanValue = (0, exports.getBooleanValue)(value);\n        // For packed encoding, we add a single byte (`0x00` or `0x01`) to the byte\n        // array.\n        if (packed) {\n            return (0, utils_1.concatBytes)([buffer, (0, utils_1.bigIntToBytes)(booleanValue)]);\n        }\n        // Booleans are encoded as 32-byte integers, so we use the number parser\n        // to encode the boolean value.\n        return number_1.number.encode({\n            type: 'uint256',\n            buffer,\n            value: booleanValue,\n            packed,\n            tight,\n        });\n    },\n    /**\n     * Decode the given byte array to a boolean.\n     *\n     * @param args - The decoding arguments.\n     * @returns The decoded boolean.\n     */\n    decode(args) {\n        // Booleans are encoded as 32-byte integers, so we use the number parser\n        // to decode the boolean value.\n        return number_1.number.decode({ ...args, type: 'uint256' }) === BigInt(1);\n    },\n};\n//# sourceMappingURL=bool.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC9wYXJzZXJzL2Jvb2wuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWSxHQUFHLHVCQUF1QjtBQUN0QyxzQkFBc0IsbUJBQU8sQ0FBQyw0RkFBdUI7QUFDckQsZ0JBQWdCLG1CQUFPLENBQUMsZ0ZBQWlCO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLDhFQUFXO0FBQ3BDLGlCQUFpQixtQkFBTyxDQUFDLHFGQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SUFBNEksTUFBTTtBQUNsSjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4QkFBOEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDBCQUEwQjtBQUNsRSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvYm9vbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYm9vbCA9IGV4cG9ydHMuZ2V0Qm9vbGVhblZhbHVlID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svc3VwZXJzdHJ1Y3RcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay91dGlsc1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IG51bWJlcl8xID0gcmVxdWlyZShcIi4vbnVtYmVyXCIpO1xuY29uc3QgQm9vbGVhbkNvZXJjZXIgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jb2VyY2UpKCgwLCBzdXBlcnN0cnVjdF8xLmJvb2xlYW4pKCksICgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbKDAsIHN1cGVyc3RydWN0XzEubGl0ZXJhbCkoJ3RydWUnKSwgKDAsIHN1cGVyc3RydWN0XzEubGl0ZXJhbCkoJ2ZhbHNlJyldKSwgKHZhbHVlKSA9PiB2YWx1ZSA9PT0gJ3RydWUnKTtcbi8qKlxuICogTm9ybWFsaXplIGEgYm9vbGVhbiB2YWx1ZS4gVGhpcyBhY2NlcHRzIHRoZSBib29sZWFuIGFzOlxuICpcbiAqIC0gQSBib29sZWFuIGxpdGVyYWwuXG4gKiAtIFRoZSBzdHJpbmcgXCJ0cnVlXCIgb3IgXCJmYWxzZVwiLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBnZXQgYSBib29sZWFuIGZvci5cbiAqIEByZXR1cm5zIFRoZSBwYXJzZWQgYm9vbGVhbiB2YWx1ZS4gVGhpcyBpcyBgQmlnSW50KDEpYCBmb3IgdHJ1dGh5IHZhbHVlcywgb3JcbiAqIGBCaWdJbnQoMClgIGZvciBmYWxzeSB2YWx1ZXMuXG4gKi9cbmNvbnN0IGdldEJvb2xlYW5WYWx1ZSA9ICh2YWx1ZSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGJvb2xlYW5WYWx1ZSA9ICgwLCBzdXBlcnN0cnVjdF8xLmNyZWF0ZSkodmFsdWUsIEJvb2xlYW5Db2VyY2VyKTtcbiAgICAgICAgaWYgKGJvb2xlYW5WYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCgxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmlnSW50KDApO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5QYXJzZXJFcnJvcihgSW52YWxpZCBib29sZWFuIHZhbHVlLiBFeHBlY3RlZCBhIGJvb2xlYW4gbGl0ZXJhbCwgb3IgdGhlIHN0cmluZyBcInRydWVcIiBvciBcImZhbHNlXCIsIGJ1dCByZWNlaXZlZCBcIiR7dmFsdWV9XCIuYCk7XG4gICAgfVxufTtcbmV4cG9ydHMuZ2V0Qm9vbGVhblZhbHVlID0gZ2V0Qm9vbGVhblZhbHVlO1xuZXhwb3J0cy5ib29sID0ge1xuICAgIGlzRHluYW1pYzogZmFsc2UsXG4gICAgLyoqXG4gICAgICogR2V0IGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIGJvb2xlYW4gdHlwZS4gU2luY2UgYGJvb2xgIGlzIGEgc2ltcGxlXG4gICAgICogdHlwZSwgdGhpcyBpcyBqdXN0IGEgY2hlY2sgdGhhdCB0aGUgdmFsdWUgaXMgXCJib29sXCIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHR5cGUgaXMgYSB2YWxpZCBib29sZWFuIHR5cGUuXG4gICAgICovXG4gICAgaXNUeXBlOiAodHlwZSkgPT4gdHlwZSA9PT0gJ2Jvb2wnLFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYnl0ZSBsZW5ndGggb2YgYW4gZW5jb2RlZCBib29sZWFuLiBTaW5jZSBgYm9vbGAgaXMgYSBzaW1wbGVcbiAgICAgKiB0eXBlLCB0aGlzIGFsd2F5cyByZXR1cm5zIDMyLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGFjdHVhbCBib29sZWFucyBhcmUgb25seSAxIGJ5dGUgbG9uZywgYnV0IHRoZSBlbmNvZGluZyBvZlxuICAgICAqIHRoZSBgYm9vbGAgdHlwZSBpcyBhbHdheXMgMzIgYnl0ZXMgbG9uZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBieXRlIGxlbmd0aCBvZiBhbiBlbmNvZGVkIGJvb2xlYW4uXG4gICAgICovXG4gICAgZ2V0Qnl0ZUxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIDMyO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRW5jb2RlIHRoZSBnaXZlbiBib29sZWFuIHRvIGEgYnl0ZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGVuY29kaW5nIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0gYXJncy5idWZmZXIgLSBUaGUgYnl0ZSBhcnJheSB0byBhZGQgdG8uXG4gICAgICogQHBhcmFtIGFyZ3MudmFsdWUgLSBUaGUgYm9vbGVhbiB0byBlbmNvZGUuXG4gICAgICogQHBhcmFtIGFyZ3MucGFja2VkIC0gV2hldGhlciB0aGUgdmFsdWUgaXMgcGFja2VkLlxuICAgICAqIEBwYXJhbSBhcmdzLnRpZ2h0IC0gV2hldGhlciB0byB1c2Ugbm9uLXN0YW5kYXJkIHRpZ2h0IGVuY29kaW5nLlxuICAgICAqIEByZXR1cm5zIFRoZSBieXRlcyB3aXRoIHRoZSBlbmNvZGVkIGJvb2xlYW4gYWRkZWQgdG8gaXQuXG4gICAgICovXG4gICAgZW5jb2RlKHsgYnVmZmVyLCB2YWx1ZSwgcGFja2VkLCB0aWdodCB9KSB7XG4gICAgICAgIGNvbnN0IGJvb2xlYW5WYWx1ZSA9ICgwLCBleHBvcnRzLmdldEJvb2xlYW5WYWx1ZSkodmFsdWUpO1xuICAgICAgICAvLyBGb3IgcGFja2VkIGVuY29kaW5nLCB3ZSBhZGQgYSBzaW5nbGUgYnl0ZSAoYDB4MDBgIG9yIGAweDAxYCkgdG8gdGhlIGJ5dGVcbiAgICAgICAgLy8gYXJyYXkuXG4gICAgICAgIGlmIChwYWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoW2J1ZmZlciwgKDAsIHV0aWxzXzEuYmlnSW50VG9CeXRlcykoYm9vbGVhblZhbHVlKV0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJvb2xlYW5zIGFyZSBlbmNvZGVkIGFzIDMyLWJ5dGUgaW50ZWdlcnMsIHNvIHdlIHVzZSB0aGUgbnVtYmVyIHBhcnNlclxuICAgICAgICAvLyB0byBlbmNvZGUgdGhlIGJvb2xlYW4gdmFsdWUuXG4gICAgICAgIHJldHVybiBudW1iZXJfMS5udW1iZXIuZW5jb2RlKHtcbiAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICAgIHZhbHVlOiBib29sZWFuVmFsdWUsXG4gICAgICAgICAgICBwYWNrZWQsXG4gICAgICAgICAgICB0aWdodCxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEZWNvZGUgdGhlIGdpdmVuIGJ5dGUgYXJyYXkgdG8gYSBib29sZWFuLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgZGVjb2RpbmcgYXJndW1lbnRzLlxuICAgICAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIGJvb2xlYW4uXG4gICAgICovXG4gICAgZGVjb2RlKGFyZ3MpIHtcbiAgICAgICAgLy8gQm9vbGVhbnMgYXJlIGVuY29kZWQgYXMgMzItYnl0ZSBpbnRlZ2Vycywgc28gd2UgdXNlIHRoZSBudW1iZXIgcGFyc2VyXG4gICAgICAgIC8vIHRvIGRlY29kZSB0aGUgYm9vbGVhbiB2YWx1ZS5cbiAgICAgICAgcmV0dXJuIG51bWJlcl8xLm51bWJlci5kZWNvZGUoeyAuLi5hcmdzLCB0eXBlOiAndWludDI1NicgfSkgPT09IEJpZ0ludCgxKTtcbiAgICB9LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvb2wuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/bool.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/bytes.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@metamask/abi-utils/dist/parsers/bytes.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bytes = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(rsc)/../../node_modules/@metamask/utils/dist/index.cjs\");\nconst utils_2 = __webpack_require__(/*! ../utils */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/utils/index.js\");\nexports.bytes = {\n    isDynamic: true,\n    /**\n     * Check if a type is a bytes type. Since `bytes` is a simple type, this is\n     * just a check that the type is \"bytes\".\n     *\n     * @param type - The type to check.\n     * @returns Whether the type is a bytes type.\n     */\n    isType: (type) => type === 'bytes',\n    /**\n     * Get the byte length of an encoded bytes value. Since `bytes` is a simple\n     * type, this always returns 32.\n     *\n     * Note that actual length of a bytes value is variable, but the encoded\n     * static value (pointer) is always 32 bytes long.\n     *\n     * @returns The byte length of an encoded bytes value.\n     */\n    getByteLength() {\n        return 32;\n    },\n    /**\n     * Encode the given bytes value to a byte array.\n     *\n     * @param args - The encoding arguments.\n     * @param args.buffer - The byte array to add to.\n     * @param args.value - The bytes value to encode.\n     * @param args.packed - Whether to use packed encoding.\n     * @returns The bytes with the encoded bytes value added to it.\n     */\n    encode({ buffer, value, packed }) {\n        const bufferValue = (0, utils_1.createBytes)(value);\n        // For packed encoding, we can just add the bytes value to the byte array,\n        // without adding any padding or alignment. There is also no need to\n        // encode the length of the bytes.\n        if (packed) {\n            return (0, utils_1.concatBytes)([buffer, bufferValue]);\n        }\n        const paddedSize = Math.ceil(bufferValue.byteLength / 32) * 32;\n        // Bytes of length `k` are encoded as `k pad_right(bytes)`.\n        return (0, utils_1.concatBytes)([\n            buffer,\n            (0, utils_2.padStart)((0, utils_1.numberToBytes)(bufferValue.byteLength)),\n            (0, utils_2.padEnd)(bufferValue, paddedSize),\n        ]);\n    },\n    /**\n     * Decode the given byte array to a bytes value.\n     *\n     * @param args - The decoding arguments.\n     * @param args.value - The byte array to decode.\n     * @returns The decoded bytes value as a `Uint8Array`.\n     */\n    decode({ value }) {\n        const bytesValue = value.subarray(0, 32);\n        const length = (0, utils_1.bytesToNumber)(bytesValue);\n        // Since we're returning a `Uint8Array`, we use `slice` to copy the bytes\n        // into a new array.\n        return value.slice(32, 32 + length);\n    },\n};\n//# sourceMappingURL=bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC9wYXJzZXJzL2J5dGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWE7QUFDYixnQkFBZ0IsbUJBQU8sQ0FBQyxnRkFBaUI7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsa0ZBQVU7QUFDbEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC9wYXJzZXJzL2J5dGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ieXRlcyA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL3V0aWxzXCIpO1xuY29uc3QgdXRpbHNfMiA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmV4cG9ydHMuYnl0ZXMgPSB7XG4gICAgaXNEeW5hbWljOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgdHlwZSBpcyBhIGJ5dGVzIHR5cGUuIFNpbmNlIGBieXRlc2AgaXMgYSBzaW1wbGUgdHlwZSwgdGhpcyBpc1xuICAgICAqIGp1c3QgYSBjaGVjayB0aGF0IHRoZSB0eXBlIGlzIFwiYnl0ZXNcIi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgdHlwZSBpcyBhIGJ5dGVzIHR5cGUuXG4gICAgICovXG4gICAgaXNUeXBlOiAodHlwZSkgPT4gdHlwZSA9PT0gJ2J5dGVzJyxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJ5dGUgbGVuZ3RoIG9mIGFuIGVuY29kZWQgYnl0ZXMgdmFsdWUuIFNpbmNlIGBieXRlc2AgaXMgYSBzaW1wbGVcbiAgICAgKiB0eXBlLCB0aGlzIGFsd2F5cyByZXR1cm5zIDMyLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGFjdHVhbCBsZW5ndGggb2YgYSBieXRlcyB2YWx1ZSBpcyB2YXJpYWJsZSwgYnV0IHRoZSBlbmNvZGVkXG4gICAgICogc3RhdGljIHZhbHVlIChwb2ludGVyKSBpcyBhbHdheXMgMzIgYnl0ZXMgbG9uZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBieXRlIGxlbmd0aCBvZiBhbiBlbmNvZGVkIGJ5dGVzIHZhbHVlLlxuICAgICAqL1xuICAgIGdldEJ5dGVMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiAzMjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEVuY29kZSB0aGUgZ2l2ZW4gYnl0ZXMgdmFsdWUgdG8gYSBieXRlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgZW5jb2RpbmcgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSBhcmdzLmJ1ZmZlciAtIFRoZSBieXRlIGFycmF5IHRvIGFkZCB0by5cbiAgICAgKiBAcGFyYW0gYXJncy52YWx1ZSAtIFRoZSBieXRlcyB2YWx1ZSB0byBlbmNvZGUuXG4gICAgICogQHBhcmFtIGFyZ3MucGFja2VkIC0gV2hldGhlciB0byB1c2UgcGFja2VkIGVuY29kaW5nLlxuICAgICAqIEByZXR1cm5zIFRoZSBieXRlcyB3aXRoIHRoZSBlbmNvZGVkIGJ5dGVzIHZhbHVlIGFkZGVkIHRvIGl0LlxuICAgICAqL1xuICAgIGVuY29kZSh7IGJ1ZmZlciwgdmFsdWUsIHBhY2tlZCB9KSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlclZhbHVlID0gKDAsIHV0aWxzXzEuY3JlYXRlQnl0ZXMpKHZhbHVlKTtcbiAgICAgICAgLy8gRm9yIHBhY2tlZCBlbmNvZGluZywgd2UgY2FuIGp1c3QgYWRkIHRoZSBieXRlcyB2YWx1ZSB0byB0aGUgYnl0ZSBhcnJheSxcbiAgICAgICAgLy8gd2l0aG91dCBhZGRpbmcgYW55IHBhZGRpbmcgb3IgYWxpZ25tZW50LiBUaGVyZSBpcyBhbHNvIG5vIG5lZWQgdG9cbiAgICAgICAgLy8gZW5jb2RlIHRoZSBsZW5ndGggb2YgdGhlIGJ5dGVzLlxuICAgICAgICBpZiAocGFja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuY29uY2F0Qnl0ZXMpKFtidWZmZXIsIGJ1ZmZlclZhbHVlXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFkZGVkU2l6ZSA9IE1hdGguY2VpbChidWZmZXJWYWx1ZS5ieXRlTGVuZ3RoIC8gMzIpICogMzI7XG4gICAgICAgIC8vIEJ5dGVzIG9mIGxlbmd0aCBga2AgYXJlIGVuY29kZWQgYXMgYGsgcGFkX3JpZ2h0KGJ5dGVzKWAuXG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoW1xuICAgICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgICAgKDAsIHV0aWxzXzIucGFkU3RhcnQpKCgwLCB1dGlsc18xLm51bWJlclRvQnl0ZXMpKGJ1ZmZlclZhbHVlLmJ5dGVMZW5ndGgpKSxcbiAgICAgICAgICAgICgwLCB1dGlsc18yLnBhZEVuZCkoYnVmZmVyVmFsdWUsIHBhZGRlZFNpemUpLFxuICAgICAgICBdKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERlY29kZSB0aGUgZ2l2ZW4gYnl0ZSBhcnJheSB0byBhIGJ5dGVzIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgZGVjb2RpbmcgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSBhcmdzLnZhbHVlIC0gVGhlIGJ5dGUgYXJyYXkgdG8gZGVjb2RlLlxuICAgICAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIGJ5dGVzIHZhbHVlIGFzIGEgYFVpbnQ4QXJyYXlgLlxuICAgICAqL1xuICAgIGRlY29kZSh7IHZhbHVlIH0pIHtcbiAgICAgICAgY29uc3QgYnl0ZXNWYWx1ZSA9IHZhbHVlLnN1YmFycmF5KDAsIDMyKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gKDAsIHV0aWxzXzEuYnl0ZXNUb051bWJlcikoYnl0ZXNWYWx1ZSk7XG4gICAgICAgIC8vIFNpbmNlIHdlJ3JlIHJldHVybmluZyBhIGBVaW50OEFycmF5YCwgd2UgdXNlIGBzbGljZWAgdG8gY29weSB0aGUgYnl0ZXNcbiAgICAgICAgLy8gaW50byBhIG5ldyBhcnJheS5cbiAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDMyLCAzMiArIGxlbmd0aCk7XG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/bytes.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/fixed-bytes.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/@metamask/abi-utils/dist/parsers/fixed-bytes.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fixedBytes = exports.getByteLength = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(rsc)/../../node_modules/@metamask/utils/dist/index.cjs\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/errors.js\");\nconst utils_2 = __webpack_require__(/*! ../utils */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/utils/index.js\");\nconst BYTES_REGEX = /^bytes([0-9]{1,2})$/u;\n/**\n * Get the length of the specified type. If a length is not specified, or if the\n * length is out of range (0 < n <= 32), this will throw an error.\n *\n * @param type - The type to get the length for.\n * @returns The byte length of the type.\n */\nconst getByteLength = (type) => {\n    const bytes = type.match(BYTES_REGEX)?.[1];\n    (0, utils_1.assert)(bytes, `Invalid byte length. Expected a number between 1 and 32, but received \"${type}\".`);\n    const length = Number(bytes);\n    (0, utils_1.assert)(length > 0 && length <= 32, new errors_1.ParserError(`Invalid byte length. Expected a number between 1 and 32, but received \"${type}\".`));\n    return length;\n};\nexports.getByteLength = getByteLength;\nexports.fixedBytes = {\n    isDynamic: false,\n    /**\n     * Check if a type is a fixed bytes type.\n     *\n     * @param type - The type to check.\n     * @returns Whether the type is a fixed bytes type.\n     */\n    isType(type) {\n        return BYTES_REGEX.test(type);\n    },\n    /**\n     * Get the byte length of an encoded fixed bytes type.\n     *\n     * @returns The byte length of the type.\n     */\n    getByteLength() {\n        return 32;\n    },\n    /**\n     * Encode a fixed bytes value.\n     *\n     * @param args - The arguments to encode.\n     * @param args.type - The type of the value.\n     * @param args.buffer - The byte array to add to.\n     * @param args.value - The value to encode.\n     * @param args.packed - Whether to use packed encoding.\n     * @returns The bytes with the encoded value added to it.\n     */\n    encode({ type, buffer, value, packed }) {\n        const length = (0, exports.getByteLength)(type);\n        const bufferValue = (0, utils_1.createBytes)(value);\n        (0, utils_1.assert)(bufferValue.length <= length, new errors_1.ParserError(`Expected a value of length ${length}, but received a value of length ${bufferValue.length}.`));\n        // For packed encoding, the value is padded to the length of the type, and\n        // then added to the byte array.\n        if (packed) {\n            return (0, utils_1.concatBytes)([buffer, (0, utils_2.padEnd)(bufferValue, length)]);\n        }\n        return (0, utils_1.concatBytes)([buffer, (0, utils_2.padEnd)(bufferValue)]);\n    },\n    /**\n     * Decode a fixed bytes value.\n     *\n     * @param args - The arguments to decode.\n     * @param args.type - The type of the value.\n     * @param args.value - The value to decode.\n     * @returns The decoded value as a `Uint8Array`.\n     */\n    decode({ type, value }) {\n        const length = (0, exports.getByteLength)(type);\n        // Since we're returning a `Uint8Array`, we use `slice` to copy the bytes\n        // into a new array.\n        return value.slice(0, length);\n    },\n};\n//# sourceMappingURL=fixed-bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC9wYXJzZXJzL2ZpeGVkLWJ5dGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLHFCQUFxQjtBQUMxQyxnQkFBZ0IsbUJBQU8sQ0FBQyxnRkFBaUI7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMsOEVBQVc7QUFDcEMsZ0JBQWdCLG1CQUFPLENBQUMsa0ZBQVU7QUFDbEMsa0NBQWtDLElBQUk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLEtBQUs7QUFDOUc7QUFDQSx1SkFBdUosS0FBSztBQUM1SjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZCQUE2QjtBQUMxQztBQUNBO0FBQ0EsaUhBQWlILE9BQU8sbUNBQW1DLG1CQUFtQjtBQUM5SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWJpLXV0aWxzL2Rpc3QvcGFyc2Vycy9maXhlZC1ieXRlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZml4ZWRCeXRlcyA9IGV4cG9ydHMuZ2V0Qnl0ZUxlbmd0aCA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL3V0aWxzXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgdXRpbHNfMiA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IEJZVEVTX1JFR0VYID0gL15ieXRlcyhbMC05XXsxLDJ9KSQvdTtcbi8qKlxuICogR2V0IHRoZSBsZW5ndGggb2YgdGhlIHNwZWNpZmllZCB0eXBlLiBJZiBhIGxlbmd0aCBpcyBub3Qgc3BlY2lmaWVkLCBvciBpZiB0aGVcbiAqIGxlbmd0aCBpcyBvdXQgb2YgcmFuZ2UgKDAgPCBuIDw9IDMyKSwgdGhpcyB3aWxsIHRocm93IGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgdG8gZ2V0IHRoZSBsZW5ndGggZm9yLlxuICogQHJldHVybnMgVGhlIGJ5dGUgbGVuZ3RoIG9mIHRoZSB0eXBlLlxuICovXG5jb25zdCBnZXRCeXRlTGVuZ3RoID0gKHR5cGUpID0+IHtcbiAgICBjb25zdCBieXRlcyA9IHR5cGUubWF0Y2goQllURVNfUkVHRVgpPy5bMV07XG4gICAgKDAsIHV0aWxzXzEuYXNzZXJ0KShieXRlcywgYEludmFsaWQgYnl0ZSBsZW5ndGguIEV4cGVjdGVkIGEgbnVtYmVyIGJldHdlZW4gMSBhbmQgMzIsIGJ1dCByZWNlaXZlZCBcIiR7dHlwZX1cIi5gKTtcbiAgICBjb25zdCBsZW5ndGggPSBOdW1iZXIoYnl0ZXMpO1xuICAgICgwLCB1dGlsc18xLmFzc2VydCkobGVuZ3RoID4gMCAmJiBsZW5ndGggPD0gMzIsIG5ldyBlcnJvcnNfMS5QYXJzZXJFcnJvcihgSW52YWxpZCBieXRlIGxlbmd0aC4gRXhwZWN0ZWQgYSBudW1iZXIgYmV0d2VlbiAxIGFuZCAzMiwgYnV0IHJlY2VpdmVkIFwiJHt0eXBlfVwiLmApKTtcbiAgICByZXR1cm4gbGVuZ3RoO1xufTtcbmV4cG9ydHMuZ2V0Qnl0ZUxlbmd0aCA9IGdldEJ5dGVMZW5ndGg7XG5leHBvcnRzLmZpeGVkQnl0ZXMgPSB7XG4gICAgaXNEeW5hbWljOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHR5cGUgaXMgYSBmaXhlZCBieXRlcyB0eXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB0eXBlIGlzIGEgZml4ZWQgYnl0ZXMgdHlwZS5cbiAgICAgKi9cbiAgICBpc1R5cGUodHlwZSkge1xuICAgICAgICByZXR1cm4gQllURVNfUkVHRVgudGVzdCh0eXBlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYnl0ZSBsZW5ndGggb2YgYW4gZW5jb2RlZCBmaXhlZCBieXRlcyB0eXBlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGJ5dGUgbGVuZ3RoIG9mIHRoZSB0eXBlLlxuICAgICAqL1xuICAgIGdldEJ5dGVMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiAzMjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEVuY29kZSBhIGZpeGVkIGJ5dGVzIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIHRvIGVuY29kZS5cbiAgICAgKiBAcGFyYW0gYXJncy50eXBlIC0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlLlxuICAgICAqIEBwYXJhbSBhcmdzLmJ1ZmZlciAtIFRoZSBieXRlIGFycmF5IHRvIGFkZCB0by5cbiAgICAgKiBAcGFyYW0gYXJncy52YWx1ZSAtIFRoZSB2YWx1ZSB0byBlbmNvZGUuXG4gICAgICogQHBhcmFtIGFyZ3MucGFja2VkIC0gV2hldGhlciB0byB1c2UgcGFja2VkIGVuY29kaW5nLlxuICAgICAqIEByZXR1cm5zIFRoZSBieXRlcyB3aXRoIHRoZSBlbmNvZGVkIHZhbHVlIGFkZGVkIHRvIGl0LlxuICAgICAqL1xuICAgIGVuY29kZSh7IHR5cGUsIGJ1ZmZlciwgdmFsdWUsIHBhY2tlZCB9KSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9ICgwLCBleHBvcnRzLmdldEJ5dGVMZW5ndGgpKHR5cGUpO1xuICAgICAgICBjb25zdCBidWZmZXJWYWx1ZSA9ICgwLCB1dGlsc18xLmNyZWF0ZUJ5dGVzKSh2YWx1ZSk7XG4gICAgICAgICgwLCB1dGlsc18xLmFzc2VydCkoYnVmZmVyVmFsdWUubGVuZ3RoIDw9IGxlbmd0aCwgbmV3IGVycm9yc18xLlBhcnNlckVycm9yKGBFeHBlY3RlZCBhIHZhbHVlIG9mIGxlbmd0aCAke2xlbmd0aH0sIGJ1dCByZWNlaXZlZCBhIHZhbHVlIG9mIGxlbmd0aCAke2J1ZmZlclZhbHVlLmxlbmd0aH0uYCkpO1xuICAgICAgICAvLyBGb3IgcGFja2VkIGVuY29kaW5nLCB0aGUgdmFsdWUgaXMgcGFkZGVkIHRvIHRoZSBsZW5ndGggb2YgdGhlIHR5cGUsIGFuZFxuICAgICAgICAvLyB0aGVuIGFkZGVkIHRvIHRoZSBieXRlIGFycmF5LlxuICAgICAgICBpZiAocGFja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuY29uY2F0Qnl0ZXMpKFtidWZmZXIsICgwLCB1dGlsc18yLnBhZEVuZCkoYnVmZmVyVmFsdWUsIGxlbmd0aCldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuY29uY2F0Qnl0ZXMpKFtidWZmZXIsICgwLCB1dGlsc18yLnBhZEVuZCkoYnVmZmVyVmFsdWUpXSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEZWNvZGUgYSBmaXhlZCBieXRlcyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB0byBkZWNvZGUuXG4gICAgICogQHBhcmFtIGFyZ3MudHlwZSAtIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gYXJncy52YWx1ZSAtIFRoZSB2YWx1ZSB0byBkZWNvZGUuXG4gICAgICogQHJldHVybnMgVGhlIGRlY29kZWQgdmFsdWUgYXMgYSBgVWludDhBcnJheWAuXG4gICAgICovXG4gICAgZGVjb2RlKHsgdHlwZSwgdmFsdWUgfSkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSAoMCwgZXhwb3J0cy5nZXRCeXRlTGVuZ3RoKSh0eXBlKTtcbiAgICAgICAgLy8gU2luY2Ugd2UncmUgcmV0dXJuaW5nIGEgYFVpbnQ4QXJyYXlgLCB3ZSB1c2UgYHNsaWNlYCB0byBjb3B5IHRoZSBieXRlc1xuICAgICAgICAvLyBpbnRvIGEgbmV3IGFycmF5LlxuICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpeGVkLWJ5dGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/fixed-bytes.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/function.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@metamask/abi-utils/dist/parsers/function.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fn = exports.getFunction = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(rsc)/../../node_modules/@metamask/superstruct/dist/index.cjs\");\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(rsc)/../../node_modules/@metamask/utils/dist/index.cjs\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/errors.js\");\nconst fixed_bytes_1 = __webpack_require__(/*! ./fixed-bytes */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/fixed-bytes.js\");\n/**\n * A struct that represents a Solidity function. The value must be a hex string\n * or a byte array. The created value will always be an object with an `address`\n * and `selector` property.\n */\nconst FunctionStruct = (0, superstruct_1.coerce)((0, superstruct_1.object)({\n    address: utils_1.StrictHexStruct,\n    selector: utils_1.StrictHexStruct,\n}), (0, superstruct_1.union)([utils_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array)]), (value) => {\n    const bytes = (0, utils_1.createBytes)(value);\n    (0, utils_1.assert)(bytes.length === 24, new errors_1.ParserError(`Invalid Solidity function. Expected function to be 24 bytes long, but received ${bytes.length} bytes.`));\n    return {\n        address: (0, utils_1.bytesToHex)(bytes.subarray(0, 20)),\n        selector: (0, utils_1.bytesToHex)(bytes.subarray(20, 24)),\n    };\n});\n/**\n * Normalize a function. This accepts the function as:\n *\n * - A {@link SolidityFunction} object.\n * - A hexadecimal string.\n * - A byte array.\n *\n * @param input - The function-like input.\n * @returns The function as buffer.\n */\nconst getFunction = (input) => {\n    const value = (0, superstruct_1.create)(input, FunctionStruct);\n    return (0, utils_1.concatBytes)([(0, utils_1.hexToBytes)(value.address), (0, utils_1.hexToBytes)(value.selector)]);\n};\nexports.getFunction = getFunction;\nexports.fn = {\n    isDynamic: false,\n    /**\n     * Check if a type is a function type. Since `function` is a simple type, this\n     * is just a check that the type is \"function\".\n     *\n     * @param type - The type to check.\n     * @returns Whether the type is a function type.\n     */\n    isType: (type) => type === 'function',\n    /**\n     * Get the byte length of an encoded function. Since `function` is a simple\n     * type, this always returns 32.\n     *\n     * Note that actual functions are only 24 bytes long, but the encoding of\n     * the `function` type is always 32 bytes long.\n     *\n     * @returns The byte length of an encoded function.\n     */\n    getByteLength() {\n        return 32;\n    },\n    /**\n     * Encode the given function to a byte array.\n     *\n     * @param args - The encoding arguments.\n     * @param args.buffer - The byte array to add to.\n     * @param args.value - The function to encode.\n     * @param args.packed - Whether to use packed encoding.\n     * @param args.tight - Whether to use non-standard tight encoding.\n     * @returns The bytes with the encoded function added to it.\n     */\n    encode({ buffer, value, packed, tight }) {\n        const fnValue = (0, exports.getFunction)(value);\n        // Functions are encoded as `bytes24`, so we use the fixedBytes parser to\n        // encode the function.\n        return fixed_bytes_1.fixedBytes.encode({\n            type: 'bytes24',\n            buffer,\n            value: fnValue,\n            packed,\n            tight,\n        });\n    },\n    /**\n     * Decode the given byte array to a function.\n     *\n     * @param args - The decoding arguments.\n     * @param args.value - The byte array to decode.\n     * @returns The decoded function as a {@link SolidityFunction} object.\n     */\n    decode({ value }) {\n        return {\n            address: (0, utils_1.bytesToHex)(value.slice(0, 20)),\n            selector: (0, utils_1.bytesToHex)(value.slice(20, 24)),\n        };\n    },\n};\n//# sourceMappingURL=function.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC9wYXJzZXJzL2Z1bmN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFVBQVUsR0FBRyxtQkFBbUI7QUFDaEMsc0JBQXNCLG1CQUFPLENBQUMsNEZBQXVCO0FBQ3JELGdCQUFnQixtQkFBTyxDQUFDLGdGQUFpQjtBQUN6QyxpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBVztBQUNwQyxzQkFBc0IsbUJBQU8sQ0FBQywrRkFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esd0pBQXdKLGNBQWM7QUFDdEs7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3QkFBd0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDhCQUE4QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsd0JBQXdCO0FBQ25FO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC9wYXJzZXJzL2Z1bmN0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mbiA9IGV4cG9ydHMuZ2V0RnVuY3Rpb24gPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcIkBtZXRhbWFzay9zdXBlcnN0cnVjdFwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL3V0aWxzXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgZml4ZWRfYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2ZpeGVkLWJ5dGVzXCIpO1xuLyoqXG4gKiBBIHN0cnVjdCB0aGF0IHJlcHJlc2VudHMgYSBTb2xpZGl0eSBmdW5jdGlvbi4gVGhlIHZhbHVlIG11c3QgYmUgYSBoZXggc3RyaW5nXG4gKiBvciBhIGJ5dGUgYXJyYXkuIFRoZSBjcmVhdGVkIHZhbHVlIHdpbGwgYWx3YXlzIGJlIGFuIG9iamVjdCB3aXRoIGFuIGBhZGRyZXNzYFxuICogYW5kIGBzZWxlY3RvcmAgcHJvcGVydHkuXG4gKi9cbmNvbnN0IEZ1bmN0aW9uU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEuY29lcmNlKSgoMCwgc3VwZXJzdHJ1Y3RfMS5vYmplY3QpKHtcbiAgICBhZGRyZXNzOiB1dGlsc18xLlN0cmljdEhleFN0cnVjdCxcbiAgICBzZWxlY3RvcjogdXRpbHNfMS5TdHJpY3RIZXhTdHJ1Y3QsXG59KSwgKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFt1dGlsc18xLlN0cmljdEhleFN0cnVjdCwgKDAsIHN1cGVyc3RydWN0XzEuaW5zdGFuY2UpKFVpbnQ4QXJyYXkpXSksICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGJ5dGVzID0gKDAsIHV0aWxzXzEuY3JlYXRlQnl0ZXMpKHZhbHVlKTtcbiAgICAoMCwgdXRpbHNfMS5hc3NlcnQpKGJ5dGVzLmxlbmd0aCA9PT0gMjQsIG5ldyBlcnJvcnNfMS5QYXJzZXJFcnJvcihgSW52YWxpZCBTb2xpZGl0eSBmdW5jdGlvbi4gRXhwZWN0ZWQgZnVuY3Rpb24gdG8gYmUgMjQgYnl0ZXMgbG9uZywgYnV0IHJlY2VpdmVkICR7Ynl0ZXMubGVuZ3RofSBieXRlcy5gKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogKDAsIHV0aWxzXzEuYnl0ZXNUb0hleCkoYnl0ZXMuc3ViYXJyYXkoMCwgMjApKSxcbiAgICAgICAgc2VsZWN0b3I6ICgwLCB1dGlsc18xLmJ5dGVzVG9IZXgpKGJ5dGVzLnN1YmFycmF5KDIwLCAyNCkpLFxuICAgIH07XG59KTtcbi8qKlxuICogTm9ybWFsaXplIGEgZnVuY3Rpb24uIFRoaXMgYWNjZXB0cyB0aGUgZnVuY3Rpb24gYXM6XG4gKlxuICogLSBBIHtAbGluayBTb2xpZGl0eUZ1bmN0aW9ufSBvYmplY3QuXG4gKiAtIEEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICogLSBBIGJ5dGUgYXJyYXkuXG4gKlxuICogQHBhcmFtIGlucHV0IC0gVGhlIGZ1bmN0aW9uLWxpa2UgaW5wdXQuXG4gKiBAcmV0dXJucyBUaGUgZnVuY3Rpb24gYXMgYnVmZmVyLlxuICovXG5jb25zdCBnZXRGdW5jdGlvbiA9IChpbnB1dCkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gKDAsIHN1cGVyc3RydWN0XzEuY3JlYXRlKShpbnB1dCwgRnVuY3Rpb25TdHJ1Y3QpO1xuICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoWygwLCB1dGlsc18xLmhleFRvQnl0ZXMpKHZhbHVlLmFkZHJlc3MpLCAoMCwgdXRpbHNfMS5oZXhUb0J5dGVzKSh2YWx1ZS5zZWxlY3RvcildKTtcbn07XG5leHBvcnRzLmdldEZ1bmN0aW9uID0gZ2V0RnVuY3Rpb247XG5leHBvcnRzLmZuID0ge1xuICAgIGlzRHluYW1pYzogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB0eXBlIGlzIGEgZnVuY3Rpb24gdHlwZS4gU2luY2UgYGZ1bmN0aW9uYCBpcyBhIHNpbXBsZSB0eXBlLCB0aGlzXG4gICAgICogaXMganVzdCBhIGNoZWNrIHRoYXQgdGhlIHR5cGUgaXMgXCJmdW5jdGlvblwiLlxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB0eXBlIGlzIGEgZnVuY3Rpb24gdHlwZS5cbiAgICAgKi9cbiAgICBpc1R5cGU6ICh0eXBlKSA9PiB0eXBlID09PSAnZnVuY3Rpb24nLFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYnl0ZSBsZW5ndGggb2YgYW4gZW5jb2RlZCBmdW5jdGlvbi4gU2luY2UgYGZ1bmN0aW9uYCBpcyBhIHNpbXBsZVxuICAgICAqIHR5cGUsIHRoaXMgYWx3YXlzIHJldHVybnMgMzIuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgYWN0dWFsIGZ1bmN0aW9ucyBhcmUgb25seSAyNCBieXRlcyBsb25nLCBidXQgdGhlIGVuY29kaW5nIG9mXG4gICAgICogdGhlIGBmdW5jdGlvbmAgdHlwZSBpcyBhbHdheXMgMzIgYnl0ZXMgbG9uZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBieXRlIGxlbmd0aCBvZiBhbiBlbmNvZGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGdldEJ5dGVMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiAzMjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEVuY29kZSB0aGUgZ2l2ZW4gZnVuY3Rpb24gdG8gYSBieXRlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgZW5jb2RpbmcgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSBhcmdzLmJ1ZmZlciAtIFRoZSBieXRlIGFycmF5IHRvIGFkZCB0by5cbiAgICAgKiBAcGFyYW0gYXJncy52YWx1ZSAtIFRoZSBmdW5jdGlvbiB0byBlbmNvZGUuXG4gICAgICogQHBhcmFtIGFyZ3MucGFja2VkIC0gV2hldGhlciB0byB1c2UgcGFja2VkIGVuY29kaW5nLlxuICAgICAqIEBwYXJhbSBhcmdzLnRpZ2h0IC0gV2hldGhlciB0byB1c2Ugbm9uLXN0YW5kYXJkIHRpZ2h0IGVuY29kaW5nLlxuICAgICAqIEByZXR1cm5zIFRoZSBieXRlcyB3aXRoIHRoZSBlbmNvZGVkIGZ1bmN0aW9uIGFkZGVkIHRvIGl0LlxuICAgICAqL1xuICAgIGVuY29kZSh7IGJ1ZmZlciwgdmFsdWUsIHBhY2tlZCwgdGlnaHQgfSkge1xuICAgICAgICBjb25zdCBmblZhbHVlID0gKDAsIGV4cG9ydHMuZ2V0RnVuY3Rpb24pKHZhbHVlKTtcbiAgICAgICAgLy8gRnVuY3Rpb25zIGFyZSBlbmNvZGVkIGFzIGBieXRlczI0YCwgc28gd2UgdXNlIHRoZSBmaXhlZEJ5dGVzIHBhcnNlciB0b1xuICAgICAgICAvLyBlbmNvZGUgdGhlIGZ1bmN0aW9uLlxuICAgICAgICByZXR1cm4gZml4ZWRfYnl0ZXNfMS5maXhlZEJ5dGVzLmVuY29kZSh7XG4gICAgICAgICAgICB0eXBlOiAnYnl0ZXMyNCcsXG4gICAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgICB2YWx1ZTogZm5WYWx1ZSxcbiAgICAgICAgICAgIHBhY2tlZCxcbiAgICAgICAgICAgIHRpZ2h0LFxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERlY29kZSB0aGUgZ2l2ZW4gYnl0ZSBhcnJheSB0byBhIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgZGVjb2RpbmcgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSBhcmdzLnZhbHVlIC0gVGhlIGJ5dGUgYXJyYXkgdG8gZGVjb2RlLlxuICAgICAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIGZ1bmN0aW9uIGFzIGEge0BsaW5rIFNvbGlkaXR5RnVuY3Rpb259IG9iamVjdC5cbiAgICAgKi9cbiAgICBkZWNvZGUoeyB2YWx1ZSB9KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRyZXNzOiAoMCwgdXRpbHNfMS5ieXRlc1RvSGV4KSh2YWx1ZS5zbGljZSgwLCAyMCkpLFxuICAgICAgICAgICAgc2VsZWN0b3I6ICgwLCB1dGlsc18xLmJ5dGVzVG9IZXgpKHZhbHVlLnNsaWNlKDIwLCAyNCkpLFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnVuY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/function.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/index.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@metamask/abi-utils/dist/parsers/index.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./address */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/address.js\"), exports);\n__exportStar(__webpack_require__(/*! ./array */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/array.js\"), exports);\n__exportStar(__webpack_require__(/*! ./bool */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/bool.js\"), exports);\n__exportStar(__webpack_require__(/*! ./bytes */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/bytes.js\"), exports);\n__exportStar(__webpack_require__(/*! ./fixed-bytes */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/fixed-bytes.js\"), exports);\n__exportStar(__webpack_require__(/*! ./function */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/function.js\"), exports);\n__exportStar(__webpack_require__(/*! ./number */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/number.js\"), exports);\n__exportStar(__webpack_require__(/*! ./parser */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/parser.js\"), exports);\n__exportStar(__webpack_require__(/*! ./string */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/string.js\"), exports);\n__exportStar(__webpack_require__(/*! ./tuple */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/tuple.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC9wYXJzZXJzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyx1RkFBVztBQUNoQyxhQUFhLG1CQUFPLENBQUMsbUZBQVM7QUFDOUIsYUFBYSxtQkFBTyxDQUFDLGlGQUFRO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyxtRkFBUztBQUM5QixhQUFhLG1CQUFPLENBQUMsK0ZBQWU7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLHlGQUFZO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxxRkFBVTtBQUMvQixhQUFhLG1CQUFPLENBQUMscUZBQVU7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLHFGQUFVO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyxtRkFBUztBQUM5QiIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hZGRyZXNzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hcnJheVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYm9vbFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYnl0ZXNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2ZpeGVkLWJ5dGVzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9mdW5jdGlvblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbnVtYmVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wYXJzZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3N0cmluZ1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHVwbGVcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/number.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@metamask/abi-utils/dist/parsers/number.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.number = exports.getBigInt = exports.assertNumberLength = exports.getLength = exports.isSigned = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(rsc)/../../node_modules/@metamask/utils/dist/index.cjs\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/errors.js\");\nconst utils_2 = __webpack_require__(/*! ../utils */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/utils/index.js\");\nconst NUMBER_REGEX = /^u?int(?<length>[0-9]*)?$/u;\n/**\n * Check if a number type is signed.\n *\n * @param type - The type to check.\n * @returns Whether the type is signed.\n */\nconst isSigned = (type) => {\n    return !type.startsWith('u');\n};\nexports.isSigned = isSigned;\n/**\n * Get the length of the specified type. If a length is not specified, if the\n * length is out of range (8 <= n <= 256), or if the length is not a multiple of\n * 8, this will throw an error.\n *\n * @param type - The type to get the length for.\n * @returns The bit length of the type.\n */\nconst getLength = (type) => {\n    if (type === 'int' || type === 'uint') {\n        return 256;\n    }\n    const match = type.match(NUMBER_REGEX);\n    (0, utils_1.assert)(match?.groups?.length, new errors_1.ParserError(`Invalid number type. Expected a number type, but received \"${type}\".`));\n    const length = parseInt(match.groups.length, 10);\n    (0, utils_1.assert)(length >= 8 && length <= 256, new errors_1.ParserError(`Invalid number length. Expected a number between 8 and 256, but received \"${type}\".`));\n    (0, utils_1.assert)(length % 8 === 0, new errors_1.ParserError(`Invalid number length. Expected a multiple of 8, but received \"${type}\".`));\n    return length;\n};\nexports.getLength = getLength;\n/**\n * Assert that the byte length of the given value is in range for the given\n * number type.\n *\n * @param value - The value to check.\n * @param type - The type of the value.\n * @throws If the value is out of range for the type.\n */\nconst assertNumberLength = (value, type) => {\n    const length = (0, exports.getLength)(type);\n    const maxValue = BigInt(2) ** BigInt(length - ((0, exports.isSigned)(type) ? 1 : 0)) - BigInt(1);\n    if ((0, exports.isSigned)(type)) {\n        // Signed types must be in the range of `-(2^(length - 1))` to\n        // `2^(length - 1) - 1`.\n        (0, utils_1.assert)(value >= -(maxValue + BigInt(1)) && value <= maxValue, new errors_1.ParserError(`Number \"${value}\" is out of range for type \"${type}\".`));\n        return;\n    }\n    // Unsigned types must be in the range of `0` to `2^length - 1`.\n    (0, utils_1.assert)(value <= maxValue, new errors_1.ParserError(`Number \"${value}\" is out of range for type \"${type}\".`));\n};\nexports.assertNumberLength = assertNumberLength;\n/**\n * Normalize a `bigint` value. This accepts the value as:\n *\n * - A `bigint`.\n * - A `number`.\n * - A decimal string, i.e., a string that does not start with \"0x\".\n * - A hexadecimal string, i.e., a string that starts with \"0x\".\n *\n * @param value - The number-like value to parse.\n * @returns The value parsed as bigint.\n */\nconst getBigInt = (value) => {\n    try {\n        return (0, utils_1.createBigInt)(value);\n    }\n    catch {\n        throw new errors_1.ParserError(`Invalid number. Expected a valid number value, but received \"${value}\".`);\n    }\n};\nexports.getBigInt = getBigInt;\nexports.number = {\n    isDynamic: false,\n    /**\n     * Check if a type is a number type.\n     *\n     * @param type - The type to check.\n     * @returns Whether the type is a number type.\n     */\n    isType(type) {\n        return NUMBER_REGEX.test(type);\n    },\n    /**\n     * Get the byte length of an encoded number type. Since `int` and `uint` are\n     * simple types, this will always return 32.\n     *\n     * @returns The byte length of the type.\n     */\n    getByteLength() {\n        return 32;\n    },\n    /**\n     * Encode a number value.\n     *\n     * @param args - The arguments to encode.\n     * @param args.type - The type of the value.\n     * @param args.buffer - The byte array to add to.\n     * @param args.value - The value to encode.\n     * @param args.packed - Whether to use packed encoding.\n     * @returns The bytes with the encoded value added to it.\n     */\n    encode({ type, buffer, value, packed }) {\n        const bigIntValue = (0, exports.getBigInt)(value);\n        (0, exports.assertNumberLength)(bigIntValue, type);\n        if ((0, exports.isSigned)(type)) {\n            // For packed encoding, the value is padded to the length of the type, and\n            // then added to the byte array.\n            if (packed) {\n                const length = (0, exports.getLength)(type) / 8;\n                return (0, utils_1.concatBytes)([buffer, (0, utils_1.signedBigIntToBytes)(bigIntValue, length)]);\n            }\n            return (0, utils_1.concatBytes)([\n                buffer,\n                (0, utils_2.padStart)((0, utils_1.signedBigIntToBytes)(bigIntValue, 32)),\n            ]);\n        }\n        // For packed encoding, the value is padded to the length of the type, and\n        // then added to the byte array.\n        if (packed) {\n            const length = (0, exports.getLength)(type) / 8;\n            return (0, utils_1.concatBytes)([\n                buffer,\n                (0, utils_2.padStart)((0, utils_1.bigIntToBytes)(bigIntValue), length),\n            ]);\n        }\n        return (0, utils_1.concatBytes)([buffer, (0, utils_2.padStart)((0, utils_1.bigIntToBytes)(bigIntValue))]);\n    },\n    /**\n     * Decode a number value.\n     *\n     * @param args - The decoding arguments.\n     * @param args.type - The type of the value.\n     * @param args.value - The value to decode.\n     * @returns The decoded value.\n     */\n    decode({ type, value }) {\n        const buffer = value.subarray(0, 32);\n        if ((0, exports.isSigned)(type)) {\n            const numberValue = (0, utils_1.bytesToSignedBigInt)(buffer);\n            (0, exports.assertNumberLength)(numberValue, type);\n            return numberValue;\n        }\n        const numberValue = (0, utils_1.bytesToBigInt)(buffer);\n        (0, exports.assertNumberLength)(numberValue, type);\n        return numberValue;\n    },\n};\n//# sourceMappingURL=number.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC9wYXJzZXJzL251bWJlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsaUJBQWlCLEdBQUcsMEJBQTBCLEdBQUcsaUJBQWlCLEdBQUcsZ0JBQWdCO0FBQ3RHLGdCQUFnQixtQkFBTyxDQUFDLGdGQUFpQjtBQUN6QyxpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBVztBQUNwQyxnQkFBZ0IsbUJBQU8sQ0FBQyxrRkFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNJQUFzSSxLQUFLO0FBQzNJO0FBQ0EsNEpBQTRKLEtBQUs7QUFDaksscUlBQXFJLEtBQUs7QUFDMUk7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUhBQXVILE1BQU0sOEJBQThCLEtBQUs7QUFDaEs7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLE1BQU0sOEJBQThCLEtBQUs7QUFDeEg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUcsTUFBTTtBQUM3RztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkJBQTZCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWJpLXV0aWxzL2Rpc3QvcGFyc2Vycy9udW1iZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm51bWJlciA9IGV4cG9ydHMuZ2V0QmlnSW50ID0gZXhwb3J0cy5hc3NlcnROdW1iZXJMZW5ndGggPSBleHBvcnRzLmdldExlbmd0aCA9IGV4cG9ydHMuaXNTaWduZWQgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay91dGlsc1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IHV0aWxzXzIgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBOVU1CRVJfUkVHRVggPSAvXnU/aW50KD88bGVuZ3RoPlswLTldKik/JC91O1xuLyoqXG4gKiBDaGVjayBpZiBhIG51bWJlciB0eXBlIGlzIHNpZ25lZC5cbiAqXG4gKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdHlwZSBpcyBzaWduZWQuXG4gKi9cbmNvbnN0IGlzU2lnbmVkID0gKHR5cGUpID0+IHtcbiAgICByZXR1cm4gIXR5cGUuc3RhcnRzV2l0aCgndScpO1xufTtcbmV4cG9ydHMuaXNTaWduZWQgPSBpc1NpZ25lZDtcbi8qKlxuICogR2V0IHRoZSBsZW5ndGggb2YgdGhlIHNwZWNpZmllZCB0eXBlLiBJZiBhIGxlbmd0aCBpcyBub3Qgc3BlY2lmaWVkLCBpZiB0aGVcbiAqIGxlbmd0aCBpcyBvdXQgb2YgcmFuZ2UgKDggPD0gbiA8PSAyNTYpLCBvciBpZiB0aGUgbGVuZ3RoIGlzIG5vdCBhIG11bHRpcGxlIG9mXG4gKiA4LCB0aGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSB0byBnZXQgdGhlIGxlbmd0aCBmb3IuXG4gKiBAcmV0dXJucyBUaGUgYml0IGxlbmd0aCBvZiB0aGUgdHlwZS5cbiAqL1xuY29uc3QgZ2V0TGVuZ3RoID0gKHR5cGUpID0+IHtcbiAgICBpZiAodHlwZSA9PT0gJ2ludCcgfHwgdHlwZSA9PT0gJ3VpbnQnKSB7XG4gICAgICAgIHJldHVybiAyNTY7XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaChOVU1CRVJfUkVHRVgpO1xuICAgICgwLCB1dGlsc18xLmFzc2VydCkobWF0Y2g/Lmdyb3Vwcz8ubGVuZ3RoLCBuZXcgZXJyb3JzXzEuUGFyc2VyRXJyb3IoYEludmFsaWQgbnVtYmVyIHR5cGUuIEV4cGVjdGVkIGEgbnVtYmVyIHR5cGUsIGJ1dCByZWNlaXZlZCBcIiR7dHlwZX1cIi5gKSk7XG4gICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQobWF0Y2guZ3JvdXBzLmxlbmd0aCwgMTApO1xuICAgICgwLCB1dGlsc18xLmFzc2VydCkobGVuZ3RoID49IDggJiYgbGVuZ3RoIDw9IDI1NiwgbmV3IGVycm9yc18xLlBhcnNlckVycm9yKGBJbnZhbGlkIG51bWJlciBsZW5ndGguIEV4cGVjdGVkIGEgbnVtYmVyIGJldHdlZW4gOCBhbmQgMjU2LCBidXQgcmVjZWl2ZWQgXCIke3R5cGV9XCIuYCkpO1xuICAgICgwLCB1dGlsc18xLmFzc2VydCkobGVuZ3RoICUgOCA9PT0gMCwgbmV3IGVycm9yc18xLlBhcnNlckVycm9yKGBJbnZhbGlkIG51bWJlciBsZW5ndGguIEV4cGVjdGVkIGEgbXVsdGlwbGUgb2YgOCwgYnV0IHJlY2VpdmVkIFwiJHt0eXBlfVwiLmApKTtcbiAgICByZXR1cm4gbGVuZ3RoO1xufTtcbmV4cG9ydHMuZ2V0TGVuZ3RoID0gZ2V0TGVuZ3RoO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgYnl0ZSBsZW5ndGggb2YgdGhlIGdpdmVuIHZhbHVlIGlzIGluIHJhbmdlIGZvciB0aGUgZ2l2ZW5cbiAqIG51bWJlciB0eXBlLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgb3V0IG9mIHJhbmdlIGZvciB0aGUgdHlwZS5cbiAqL1xuY29uc3QgYXNzZXJ0TnVtYmVyTGVuZ3RoID0gKHZhbHVlLCB0eXBlKSA9PiB7XG4gICAgY29uc3QgbGVuZ3RoID0gKDAsIGV4cG9ydHMuZ2V0TGVuZ3RoKSh0eXBlKTtcbiAgICBjb25zdCBtYXhWYWx1ZSA9IEJpZ0ludCgyKSAqKiBCaWdJbnQobGVuZ3RoIC0gKCgwLCBleHBvcnRzLmlzU2lnbmVkKSh0eXBlKSA/IDEgOiAwKSkgLSBCaWdJbnQoMSk7XG4gICAgaWYgKCgwLCBleHBvcnRzLmlzU2lnbmVkKSh0eXBlKSkge1xuICAgICAgICAvLyBTaWduZWQgdHlwZXMgbXVzdCBiZSBpbiB0aGUgcmFuZ2Ugb2YgYC0oMl4obGVuZ3RoIC0gMSkpYCB0b1xuICAgICAgICAvLyBgMl4obGVuZ3RoIC0gMSkgLSAxYC5cbiAgICAgICAgKDAsIHV0aWxzXzEuYXNzZXJ0KSh2YWx1ZSA+PSAtKG1heFZhbHVlICsgQmlnSW50KDEpKSAmJiB2YWx1ZSA8PSBtYXhWYWx1ZSwgbmV3IGVycm9yc18xLlBhcnNlckVycm9yKGBOdW1iZXIgXCIke3ZhbHVlfVwiIGlzIG91dCBvZiByYW5nZSBmb3IgdHlwZSBcIiR7dHlwZX1cIi5gKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVW5zaWduZWQgdHlwZXMgbXVzdCBiZSBpbiB0aGUgcmFuZ2Ugb2YgYDBgIHRvIGAyXmxlbmd0aCAtIDFgLlxuICAgICgwLCB1dGlsc18xLmFzc2VydCkodmFsdWUgPD0gbWF4VmFsdWUsIG5ldyBlcnJvcnNfMS5QYXJzZXJFcnJvcihgTnVtYmVyIFwiJHt2YWx1ZX1cIiBpcyBvdXQgb2YgcmFuZ2UgZm9yIHR5cGUgXCIke3R5cGV9XCIuYCkpO1xufTtcbmV4cG9ydHMuYXNzZXJ0TnVtYmVyTGVuZ3RoID0gYXNzZXJ0TnVtYmVyTGVuZ3RoO1xuLyoqXG4gKiBOb3JtYWxpemUgYSBgYmlnaW50YCB2YWx1ZS4gVGhpcyBhY2NlcHRzIHRoZSB2YWx1ZSBhczpcbiAqXG4gKiAtIEEgYGJpZ2ludGAuXG4gKiAtIEEgYG51bWJlcmAuXG4gKiAtIEEgZGVjaW1hbCBzdHJpbmcsIGkuZS4sIGEgc3RyaW5nIHRoYXQgZG9lcyBub3Qgc3RhcnQgd2l0aCBcIjB4XCIuXG4gKiAtIEEgaGV4YWRlY2ltYWwgc3RyaW5nLCBpLmUuLCBhIHN0cmluZyB0aGF0IHN0YXJ0cyB3aXRoIFwiMHhcIi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyLWxpa2UgdmFsdWUgdG8gcGFyc2UuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgcGFyc2VkIGFzIGJpZ2ludC5cbiAqL1xuY29uc3QgZ2V0QmlnSW50ID0gKHZhbHVlKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmNyZWF0ZUJpZ0ludCkodmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5QYXJzZXJFcnJvcihgSW52YWxpZCBudW1iZXIuIEV4cGVjdGVkIGEgdmFsaWQgbnVtYmVyIHZhbHVlLCBidXQgcmVjZWl2ZWQgXCIke3ZhbHVlfVwiLmApO1xuICAgIH1cbn07XG5leHBvcnRzLmdldEJpZ0ludCA9IGdldEJpZ0ludDtcbmV4cG9ydHMubnVtYmVyID0ge1xuICAgIGlzRHluYW1pYzogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB0eXBlIGlzIGEgbnVtYmVyIHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHR5cGUgaXMgYSBudW1iZXIgdHlwZS5cbiAgICAgKi9cbiAgICBpc1R5cGUodHlwZSkge1xuICAgICAgICByZXR1cm4gTlVNQkVSX1JFR0VYLnRlc3QodHlwZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJ5dGUgbGVuZ3RoIG9mIGFuIGVuY29kZWQgbnVtYmVyIHR5cGUuIFNpbmNlIGBpbnRgIGFuZCBgdWludGAgYXJlXG4gICAgICogc2ltcGxlIHR5cGVzLCB0aGlzIHdpbGwgYWx3YXlzIHJldHVybiAzMi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBieXRlIGxlbmd0aCBvZiB0aGUgdHlwZS5cbiAgICAgKi9cbiAgICBnZXRCeXRlTGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gMzI7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBFbmNvZGUgYSBudW1iZXIgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgdG8gZW5jb2RlLlxuICAgICAqIEBwYXJhbSBhcmdzLnR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUuXG4gICAgICogQHBhcmFtIGFyZ3MuYnVmZmVyIC0gVGhlIGJ5dGUgYXJyYXkgdG8gYWRkIHRvLlxuICAgICAqIEBwYXJhbSBhcmdzLnZhbHVlIC0gVGhlIHZhbHVlIHRvIGVuY29kZS5cbiAgICAgKiBAcGFyYW0gYXJncy5wYWNrZWQgLSBXaGV0aGVyIHRvIHVzZSBwYWNrZWQgZW5jb2RpbmcuXG4gICAgICogQHJldHVybnMgVGhlIGJ5dGVzIHdpdGggdGhlIGVuY29kZWQgdmFsdWUgYWRkZWQgdG8gaXQuXG4gICAgICovXG4gICAgZW5jb2RlKHsgdHlwZSwgYnVmZmVyLCB2YWx1ZSwgcGFja2VkIH0pIHtcbiAgICAgICAgY29uc3QgYmlnSW50VmFsdWUgPSAoMCwgZXhwb3J0cy5nZXRCaWdJbnQpKHZhbHVlKTtcbiAgICAgICAgKDAsIGV4cG9ydHMuYXNzZXJ0TnVtYmVyTGVuZ3RoKShiaWdJbnRWYWx1ZSwgdHlwZSk7XG4gICAgICAgIGlmICgoMCwgZXhwb3J0cy5pc1NpZ25lZCkodHlwZSkpIHtcbiAgICAgICAgICAgIC8vIEZvciBwYWNrZWQgZW5jb2RpbmcsIHRoZSB2YWx1ZSBpcyBwYWRkZWQgdG8gdGhlIGxlbmd0aCBvZiB0aGUgdHlwZSwgYW5kXG4gICAgICAgICAgICAvLyB0aGVuIGFkZGVkIHRvIHRoZSBieXRlIGFycmF5LlxuICAgICAgICAgICAgaWYgKHBhY2tlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9ICgwLCBleHBvcnRzLmdldExlbmd0aCkodHlwZSkgLyA4O1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoW2J1ZmZlciwgKDAsIHV0aWxzXzEuc2lnbmVkQmlnSW50VG9CeXRlcykoYmlnSW50VmFsdWUsIGxlbmd0aCldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoW1xuICAgICAgICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMi5wYWRTdGFydCkoKDAsIHV0aWxzXzEuc2lnbmVkQmlnSW50VG9CeXRlcykoYmlnSW50VmFsdWUsIDMyKSksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgcGFja2VkIGVuY29kaW5nLCB0aGUgdmFsdWUgaXMgcGFkZGVkIHRvIHRoZSBsZW5ndGggb2YgdGhlIHR5cGUsIGFuZFxuICAgICAgICAvLyB0aGVuIGFkZGVkIHRvIHRoZSBieXRlIGFycmF5LlxuICAgICAgICBpZiAocGFja2VkKSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSAoMCwgZXhwb3J0cy5nZXRMZW5ndGgpKHR5cGUpIC8gODtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoW1xuICAgICAgICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMi5wYWRTdGFydCkoKDAsIHV0aWxzXzEuYmlnSW50VG9CeXRlcykoYmlnSW50VmFsdWUpLCBsZW5ndGgpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShbYnVmZmVyLCAoMCwgdXRpbHNfMi5wYWRTdGFydCkoKDAsIHV0aWxzXzEuYmlnSW50VG9CeXRlcykoYmlnSW50VmFsdWUpKV0pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGVjb2RlIGEgbnVtYmVyIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgZGVjb2RpbmcgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSBhcmdzLnR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUuXG4gICAgICogQHBhcmFtIGFyZ3MudmFsdWUgLSBUaGUgdmFsdWUgdG8gZGVjb2RlLlxuICAgICAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGRlY29kZSh7IHR5cGUsIHZhbHVlIH0pIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdmFsdWUuc3ViYXJyYXkoMCwgMzIpO1xuICAgICAgICBpZiAoKDAsIGV4cG9ydHMuaXNTaWduZWQpKHR5cGUpKSB7XG4gICAgICAgICAgICBjb25zdCBudW1iZXJWYWx1ZSA9ICgwLCB1dGlsc18xLmJ5dGVzVG9TaWduZWRCaWdJbnQpKGJ1ZmZlcik7XG4gICAgICAgICAgICAoMCwgZXhwb3J0cy5hc3NlcnROdW1iZXJMZW5ndGgpKG51bWJlclZhbHVlLCB0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBudW1iZXJWYWx1ZSA9ICgwLCB1dGlsc18xLmJ5dGVzVG9CaWdJbnQpKGJ1ZmZlcik7XG4gICAgICAgICgwLCBleHBvcnRzLmFzc2VydE51bWJlckxlbmd0aCkobnVtYmVyVmFsdWUsIHR5cGUpO1xuICAgICAgICByZXR1cm4gbnVtYmVyVmFsdWU7XG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1iZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/number.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/parser.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@metamask/abi-utils/dist/parsers/parser.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC9wYXJzZXJzL3BhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvcGFyc2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/parser.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/string.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@metamask/abi-utils/dist/parsers/string.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.string = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(rsc)/../../node_modules/@metamask/utils/dist/index.cjs\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/bytes.js\");\nexports.string = {\n    isDynamic: true,\n    /**\n     * Check if a type is a string type. Since `string` is a simple type, this\n     * is just a check if the type is \"string\".\n     *\n     * @param type - The type to check.\n     * @returns Whether the type is a string type.\n     */\n    isType: (type) => type === 'string',\n    /**\n     * Get the byte length of an encoded string type. Since `string` is a simple\n     * type, this will always return 32.\n     *\n     * Note that actual strings are variable in length, but the encoded static\n     * value (pointer) is always 32 bytes long.\n     *\n     * @returns The byte length of an encoded string.\n     */\n    getByteLength() {\n        return 32;\n    },\n    /**\n     * Encode the given string value to a byte array.\n     *\n     * @param args - The encoding arguments.\n     * @param args.buffer - The byte array to add to.\n     * @param args.value - The string value to encode.\n     * @param args.packed - Whether to use packed encoding.\n     * @param args.tight - Whether to use non-standard tight encoding.\n     * @returns The bytes with the encoded string value added to it.\n     */\n    encode({ buffer, value, packed, tight }) {\n        // Strings are encoded as UTF-8 bytes, so we use the bytes parser to encode\n        // the string as bytes.\n        return bytes_1.bytes.encode({\n            type: 'bytes',\n            buffer,\n            value: (0, utils_1.stringToBytes)(value),\n            packed,\n            tight,\n        });\n    },\n    /**\n     * Decode the given byte array to a string value.\n     *\n     * @param args - The decoding arguments.\n     * @returns The decoded string value.\n     */\n    decode(args) {\n        // Strings are encoded as UTF-8 bytes, so we use the bytes parser to decode\n        // the bytes, and convert them to a string.\n        return (0, utils_1.bytesToString)(bytes_1.bytes.decode(args));\n    },\n};\n//# sourceMappingURL=string.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC9wYXJzZXJzL3N0cmluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsZ0JBQWdCLG1CQUFPLENBQUMsZ0ZBQWlCO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFTO0FBQ2pDLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4QkFBOEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvc3RyaW5nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdHJpbmcgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay91dGlsc1wiKTtcbmNvbnN0IGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlc1wiKTtcbmV4cG9ydHMuc3RyaW5nID0ge1xuICAgIGlzRHluYW1pYzogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHR5cGUgaXMgYSBzdHJpbmcgdHlwZS4gU2luY2UgYHN0cmluZ2AgaXMgYSBzaW1wbGUgdHlwZSwgdGhpc1xuICAgICAqIGlzIGp1c3QgYSBjaGVjayBpZiB0aGUgdHlwZSBpcyBcInN0cmluZ1wiLlxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB0eXBlIGlzIGEgc3RyaW5nIHR5cGUuXG4gICAgICovXG4gICAgaXNUeXBlOiAodHlwZSkgPT4gdHlwZSA9PT0gJ3N0cmluZycsXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBieXRlIGxlbmd0aCBvZiBhbiBlbmNvZGVkIHN0cmluZyB0eXBlLiBTaW5jZSBgc3RyaW5nYCBpcyBhIHNpbXBsZVxuICAgICAqIHR5cGUsIHRoaXMgd2lsbCBhbHdheXMgcmV0dXJuIDMyLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGFjdHVhbCBzdHJpbmdzIGFyZSB2YXJpYWJsZSBpbiBsZW5ndGgsIGJ1dCB0aGUgZW5jb2RlZCBzdGF0aWNcbiAgICAgKiB2YWx1ZSAocG9pbnRlcikgaXMgYWx3YXlzIDMyIGJ5dGVzIGxvbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYnl0ZSBsZW5ndGggb2YgYW4gZW5jb2RlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZ2V0Qnl0ZUxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIDMyO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRW5jb2RlIHRoZSBnaXZlbiBzdHJpbmcgdmFsdWUgdG8gYSBieXRlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgZW5jb2RpbmcgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSBhcmdzLmJ1ZmZlciAtIFRoZSBieXRlIGFycmF5IHRvIGFkZCB0by5cbiAgICAgKiBAcGFyYW0gYXJncy52YWx1ZSAtIFRoZSBzdHJpbmcgdmFsdWUgdG8gZW5jb2RlLlxuICAgICAqIEBwYXJhbSBhcmdzLnBhY2tlZCAtIFdoZXRoZXIgdG8gdXNlIHBhY2tlZCBlbmNvZGluZy5cbiAgICAgKiBAcGFyYW0gYXJncy50aWdodCAtIFdoZXRoZXIgdG8gdXNlIG5vbi1zdGFuZGFyZCB0aWdodCBlbmNvZGluZy5cbiAgICAgKiBAcmV0dXJucyBUaGUgYnl0ZXMgd2l0aCB0aGUgZW5jb2RlZCBzdHJpbmcgdmFsdWUgYWRkZWQgdG8gaXQuXG4gICAgICovXG4gICAgZW5jb2RlKHsgYnVmZmVyLCB2YWx1ZSwgcGFja2VkLCB0aWdodCB9KSB7XG4gICAgICAgIC8vIFN0cmluZ3MgYXJlIGVuY29kZWQgYXMgVVRGLTggYnl0ZXMsIHNvIHdlIHVzZSB0aGUgYnl0ZXMgcGFyc2VyIHRvIGVuY29kZVxuICAgICAgICAvLyB0aGUgc3RyaW5nIGFzIGJ5dGVzLlxuICAgICAgICByZXR1cm4gYnl0ZXNfMS5ieXRlcy5lbmNvZGUoe1xuICAgICAgICAgICAgdHlwZTogJ2J5dGVzJyxcbiAgICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICAgIHZhbHVlOiAoMCwgdXRpbHNfMS5zdHJpbmdUb0J5dGVzKSh2YWx1ZSksXG4gICAgICAgICAgICBwYWNrZWQsXG4gICAgICAgICAgICB0aWdodCxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEZWNvZGUgdGhlIGdpdmVuIGJ5dGUgYXJyYXkgdG8gYSBzdHJpbmcgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBkZWNvZGluZyBhcmd1bWVudHMuXG4gICAgICogQHJldHVybnMgVGhlIGRlY29kZWQgc3RyaW5nIHZhbHVlLlxuICAgICAqL1xuICAgIGRlY29kZShhcmdzKSB7XG4gICAgICAgIC8vIFN0cmluZ3MgYXJlIGVuY29kZWQgYXMgVVRGLTggYnl0ZXMsIHNvIHdlIHVzZSB0aGUgYnl0ZXMgcGFyc2VyIHRvIGRlY29kZVxuICAgICAgICAvLyB0aGUgYnl0ZXMsIGFuZCBjb252ZXJ0IHRoZW0gdG8gYSBzdHJpbmcuXG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5ieXRlc1RvU3RyaW5nKShieXRlc18xLmJ5dGVzLmRlY29kZShhcmdzKSk7XG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmcuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/string.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/tuple.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@metamask/abi-utils/dist/parsers/tuple.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.tuple = exports.getTupleElements = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(rsc)/../../node_modules/@metamask/utils/dist/index.cjs\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/errors.js\");\nconst packer_1 = __webpack_require__(/*! ../packer */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/packer.js\");\nconst TUPLE_REGEX = /^\\((.+)\\)$/u;\nconst isTupleType = (type) => TUPLE_REGEX.test(type);\n/**\n * Get elements from a tuple type.\n *\n * @param type - The tuple type to get the types for.\n * @returns The elements of the tuple as string array.\n */\nconst getTupleElements = (type) => {\n    (0, utils_1.assert)(type.startsWith('(') && type.endsWith(')'), new errors_1.ParserError(`Invalid tuple type. Expected tuple type, but received \"${type}\".`));\n    const elements = [];\n    let current = '';\n    let depth = 0;\n    for (let i = 1; i < type.length - 1; i++) {\n        const char = type[i];\n        if (char === ',' && depth === 0) {\n            elements.push(current.trim());\n            current = '';\n        }\n        else {\n            current += char;\n            if (char === '(') {\n                depth += 1;\n            }\n            else if (char === ')') {\n                depth -= 1;\n            }\n        }\n    }\n    if (current.trim()) {\n        elements.push(current.trim());\n    }\n    return elements;\n};\nexports.getTupleElements = getTupleElements;\nexports.tuple = {\n    /**\n     * Check if the tuple is dynamic. Tuples are dynamic if one or more elements\n     * of the tuple are dynamic.\n     *\n     * @param type - The type to check.\n     * @returns Whether the tuple is dynamic.\n     */\n    isDynamic(type) {\n        const elements = (0, exports.getTupleElements)(type);\n        return elements.some((element) => {\n            const parser = (0, packer_1.getParser)(element);\n            return (0, packer_1.isDynamicParser)(parser, element);\n        });\n    },\n    /**\n     * Check if a type is a tuple type.\n     *\n     * @param type - The type to check.\n     * @returns Whether the type is a tuple type.\n     */\n    isType(type) {\n        return isTupleType(type);\n    },\n    /**\n     * Get the byte length of a tuple type. If the tuple is dynamic, this will\n     * always return 32. If the tuple is static, this will return the sum of the\n     * byte lengths of the tuple elements.\n     *\n     * @param type - The type to get the byte length for.\n     * @returns The byte length of the tuple type.\n     */\n    getByteLength(type) {\n        if ((0, packer_1.isDynamicParser)(this, type)) {\n            return 32;\n        }\n        const elements = (0, exports.getTupleElements)(type);\n        return elements.reduce((total, element) => {\n            return total + (0, packer_1.getParser)(element).getByteLength(element);\n        }, 0);\n    },\n    /**\n     * Encode a tuple value.\n     *\n     * @param args - The encoding arguments.\n     * @param args.type - The type of the value.\n     * @param args.buffer - The byte array to add to.\n     * @param args.value - The value to encode.\n     * @param args.packed - Whether to use non-standard packed encoding.\n     * @param args.tight - Whether to use non-standard tight encoding.\n     * @returns The bytes with the encoded value added to it.\n     */\n    encode({ type, buffer, value, packed, tight }) {\n        const elements = (0, exports.getTupleElements)(type);\n        return (0, packer_1.pack)({\n            types: elements,\n            values: value,\n            byteArray: buffer,\n            packed,\n            tight,\n        });\n    },\n    /**\n     * Decode a tuple value.\n     *\n     * @param args - The decoding arguments.\n     * @param args.type - The type of the value.\n     * @param args.value - The value to decode.\n     * @param args.skip - A function to skip a number of bytes.\n     * @returns The decoded value.\n     */\n    decode({ type, value, skip }) {\n        const elements = (0, exports.getTupleElements)(type);\n        const length = this.getByteLength(type) - 32;\n        skip(length);\n        return (0, packer_1.unpack)(elements, value);\n    },\n};\n//# sourceMappingURL=tuple.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC9wYXJzZXJzL3R1cGxlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsR0FBRyx3QkFBd0I7QUFDeEMsZ0JBQWdCLG1CQUFPLENBQUMsZ0ZBQWlCO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLDhFQUFXO0FBQ3BDLGlCQUFpQixtQkFBTyxDQUFDLDhFQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVKQUF1SixLQUFLO0FBQzVKO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0NBQW9DO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWJpLXV0aWxzL2Rpc3QvcGFyc2Vycy90dXBsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudHVwbGUgPSBleHBvcnRzLmdldFR1cGxlRWxlbWVudHMgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay91dGlsc1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IHBhY2tlcl8xID0gcmVxdWlyZShcIi4uL3BhY2tlclwiKTtcbmNvbnN0IFRVUExFX1JFR0VYID0gL15cXCgoLispXFwpJC91O1xuY29uc3QgaXNUdXBsZVR5cGUgPSAodHlwZSkgPT4gVFVQTEVfUkVHRVgudGVzdCh0eXBlKTtcbi8qKlxuICogR2V0IGVsZW1lbnRzIGZyb20gYSB0dXBsZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB0eXBlIC0gVGhlIHR1cGxlIHR5cGUgdG8gZ2V0IHRoZSB0eXBlcyBmb3IuXG4gKiBAcmV0dXJucyBUaGUgZWxlbWVudHMgb2YgdGhlIHR1cGxlIGFzIHN0cmluZyBhcnJheS5cbiAqL1xuY29uc3QgZ2V0VHVwbGVFbGVtZW50cyA9ICh0eXBlKSA9PiB7XG4gICAgKDAsIHV0aWxzXzEuYXNzZXJ0KSh0eXBlLnN0YXJ0c1dpdGgoJygnKSAmJiB0eXBlLmVuZHNXaXRoKCcpJyksIG5ldyBlcnJvcnNfMS5QYXJzZXJFcnJvcihgSW52YWxpZCB0dXBsZSB0eXBlLiBFeHBlY3RlZCB0dXBsZSB0eXBlLCBidXQgcmVjZWl2ZWQgXCIke3R5cGV9XCIuYCkpO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgbGV0IGN1cnJlbnQgPSAnJztcbiAgICBsZXQgZGVwdGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdHlwZS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hhciA9IHR5cGVbaV07XG4gICAgICAgIGlmIChjaGFyID09PSAnLCcgJiYgZGVwdGggPT09IDApIHtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goY3VycmVudC50cmltKCkpO1xuICAgICAgICAgICAgY3VycmVudCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudCArPSBjaGFyO1xuICAgICAgICAgICAgaWYgKGNoYXIgPT09ICcoJykge1xuICAgICAgICAgICAgICAgIGRlcHRoICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICBkZXB0aCAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjdXJyZW50LnRyaW0oKSkge1xuICAgICAgICBlbGVtZW50cy5wdXNoKGN1cnJlbnQudHJpbSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnRzO1xufTtcbmV4cG9ydHMuZ2V0VHVwbGVFbGVtZW50cyA9IGdldFR1cGxlRWxlbWVudHM7XG5leHBvcnRzLnR1cGxlID0ge1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSB0dXBsZSBpcyBkeW5hbWljLiBUdXBsZXMgYXJlIGR5bmFtaWMgaWYgb25lIG9yIG1vcmUgZWxlbWVudHNcbiAgICAgKiBvZiB0aGUgdHVwbGUgYXJlIGR5bmFtaWMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHR1cGxlIGlzIGR5bmFtaWMuXG4gICAgICovXG4gICAgaXNEeW5hbWljKHR5cGUpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSAoMCwgZXhwb3J0cy5nZXRUdXBsZUVsZW1lbnRzKSh0eXBlKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzLnNvbWUoKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlciA9ICgwLCBwYWNrZXJfMS5nZXRQYXJzZXIpKGVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBwYWNrZXJfMS5pc0R5bmFtaWNQYXJzZXIpKHBhcnNlciwgZWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB0eXBlIGlzIGEgdHVwbGUgdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgdHlwZSBpcyBhIHR1cGxlIHR5cGUuXG4gICAgICovXG4gICAgaXNUeXBlKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGlzVHVwbGVUeXBlKHR5cGUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBieXRlIGxlbmd0aCBvZiBhIHR1cGxlIHR5cGUuIElmIHRoZSB0dXBsZSBpcyBkeW5hbWljLCB0aGlzIHdpbGxcbiAgICAgKiBhbHdheXMgcmV0dXJuIDMyLiBJZiB0aGUgdHVwbGUgaXMgc3RhdGljLCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBzdW0gb2YgdGhlXG4gICAgICogYnl0ZSBsZW5ndGhzIG9mIHRoZSB0dXBsZSBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgdG8gZ2V0IHRoZSBieXRlIGxlbmd0aCBmb3IuXG4gICAgICogQHJldHVybnMgVGhlIGJ5dGUgbGVuZ3RoIG9mIHRoZSB0dXBsZSB0eXBlLlxuICAgICAqL1xuICAgIGdldEJ5dGVMZW5ndGgodHlwZSkge1xuICAgICAgICBpZiAoKDAsIHBhY2tlcl8xLmlzRHluYW1pY1BhcnNlcikodGhpcywgdHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAzMjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGVtZW50cyA9ICgwLCBleHBvcnRzLmdldFR1cGxlRWxlbWVudHMpKHR5cGUpO1xuICAgICAgICByZXR1cm4gZWxlbWVudHMucmVkdWNlKCh0b3RhbCwgZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRvdGFsICsgKDAsIHBhY2tlcl8xLmdldFBhcnNlcikoZWxlbWVudCkuZ2V0Qnl0ZUxlbmd0aChlbGVtZW50KTtcbiAgICAgICAgfSwgMCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBFbmNvZGUgYSB0dXBsZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGVuY29kaW5nIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0gYXJncy50eXBlIC0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlLlxuICAgICAqIEBwYXJhbSBhcmdzLmJ1ZmZlciAtIFRoZSBieXRlIGFycmF5IHRvIGFkZCB0by5cbiAgICAgKiBAcGFyYW0gYXJncy52YWx1ZSAtIFRoZSB2YWx1ZSB0byBlbmNvZGUuXG4gICAgICogQHBhcmFtIGFyZ3MucGFja2VkIC0gV2hldGhlciB0byB1c2Ugbm9uLXN0YW5kYXJkIHBhY2tlZCBlbmNvZGluZy5cbiAgICAgKiBAcGFyYW0gYXJncy50aWdodCAtIFdoZXRoZXIgdG8gdXNlIG5vbi1zdGFuZGFyZCB0aWdodCBlbmNvZGluZy5cbiAgICAgKiBAcmV0dXJucyBUaGUgYnl0ZXMgd2l0aCB0aGUgZW5jb2RlZCB2YWx1ZSBhZGRlZCB0byBpdC5cbiAgICAgKi9cbiAgICBlbmNvZGUoeyB0eXBlLCBidWZmZXIsIHZhbHVlLCBwYWNrZWQsIHRpZ2h0IH0pIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSAoMCwgZXhwb3J0cy5nZXRUdXBsZUVsZW1lbnRzKSh0eXBlKTtcbiAgICAgICAgcmV0dXJuICgwLCBwYWNrZXJfMS5wYWNrKSh7XG4gICAgICAgICAgICB0eXBlczogZWxlbWVudHMsXG4gICAgICAgICAgICB2YWx1ZXM6IHZhbHVlLFxuICAgICAgICAgICAgYnl0ZUFycmF5OiBidWZmZXIsXG4gICAgICAgICAgICBwYWNrZWQsXG4gICAgICAgICAgICB0aWdodCxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEZWNvZGUgYSB0dXBsZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGRlY29kaW5nIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0gYXJncy50eXBlIC0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlLlxuICAgICAqIEBwYXJhbSBhcmdzLnZhbHVlIC0gVGhlIHZhbHVlIHRvIGRlY29kZS5cbiAgICAgKiBAcGFyYW0gYXJncy5za2lwIC0gQSBmdW5jdGlvbiB0byBza2lwIGEgbnVtYmVyIG9mIGJ5dGVzLlxuICAgICAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGRlY29kZSh7IHR5cGUsIHZhbHVlLCBza2lwIH0pIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSAoMCwgZXhwb3J0cy5nZXRUdXBsZUVsZW1lbnRzKSh0eXBlKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5nZXRCeXRlTGVuZ3RoKHR5cGUpIC0gMzI7XG4gICAgICAgIHNraXAobGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuICgwLCBwYWNrZXJfMS51bnBhY2spKGVsZW1lbnRzLCB2YWx1ZSk7XG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10dXBsZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/tuple.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/abi-utils/dist/types/abi.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@metamask/abi-utils/dist/types/abi.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=abi.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC90eXBlcy9hYmkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC90eXBlcy9hYmkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYmkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/abi-utils/dist/types/abi.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/abi-utils/dist/types/index.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@metamask/abi-utils/dist/types/index.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./abi */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/types/abi.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC90eXBlcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsNkVBQU87QUFDNUIiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC90eXBlcy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FiaVwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/abi-utils/dist/types/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/abi-utils/dist/utils/buffer.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@metamask/abi-utils/dist/utils/buffer.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.padEnd = exports.padStart = exports.set = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(rsc)/../../node_modules/@metamask/utils/dist/index.cjs\");\nconst BUFFER_WIDTH = 32;\n/**\n * Set `buffer` in `target` at the specified position.\n *\n * @param target - The buffer to set to.\n * @param buffer - The buffer to set in the target.\n * @param position - The position at which to set the target.\n * @returns The combined buffer.\n */\nconst set = (target, buffer, position) => {\n    return (0, utils_1.concatBytes)([\n        target.subarray(0, position),\n        buffer,\n        target.subarray(position + buffer.length),\n    ]);\n};\nexports.set = set;\n/**\n * Add padding to a buffer. If the buffer is larger than `length`, this function won't do anything. If it's smaller, the\n * buffer will be padded to the specified length, with extra zeroes at the start.\n *\n * @param buffer - The buffer to add padding to.\n * @param length - The number of bytes to pad the buffer to.\n * @returns The padded buffer.\n */\nconst padStart = (buffer, length = BUFFER_WIDTH) => {\n    const padding = new Uint8Array(Math.max(length - buffer.length, 0)).fill(0x00);\n    return (0, utils_1.concatBytes)([padding, buffer]);\n};\nexports.padStart = padStart;\n/**\n * Add padding to a buffer. If the buffer is larger than `length`, this function won't do anything. If it's smaller, the\n * buffer will be padded to the specified length, with extra zeroes at the end.\n *\n * @param buffer - The buffer to add padding to.\n * @param length - The number of bytes to pad the buffer to.\n * @returns The padded buffer.\n */\nconst padEnd = (buffer, length = BUFFER_WIDTH) => {\n    const padding = new Uint8Array(Math.max(length - buffer.length, 0)).fill(0x00);\n    return (0, utils_1.concatBytes)([buffer, padding]);\n};\nexports.padEnd = padEnd;\n//# sourceMappingURL=buffer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC91dGlscy9idWZmZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLGdCQUFnQixHQUFHLFdBQVc7QUFDL0MsZ0JBQWdCLG1CQUFPLENBQUMsZ0ZBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC91dGlscy9idWZmZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhZEVuZCA9IGV4cG9ydHMucGFkU3RhcnQgPSBleHBvcnRzLnNldCA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL3V0aWxzXCIpO1xuY29uc3QgQlVGRkVSX1dJRFRIID0gMzI7XG4vKipcbiAqIFNldCBgYnVmZmVyYCBpbiBgdGFyZ2V0YCBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgYnVmZmVyIHRvIHNldCB0by5cbiAqIEBwYXJhbSBidWZmZXIgLSBUaGUgYnVmZmVyIHRvIHNldCBpbiB0aGUgdGFyZ2V0LlxuICogQHBhcmFtIHBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIGF0IHdoaWNoIHRvIHNldCB0aGUgdGFyZ2V0LlxuICogQHJldHVybnMgVGhlIGNvbWJpbmVkIGJ1ZmZlci5cbiAqL1xuY29uc3Qgc2V0ID0gKHRhcmdldCwgYnVmZmVyLCBwb3NpdGlvbikgPT4ge1xuICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoW1xuICAgICAgICB0YXJnZXQuc3ViYXJyYXkoMCwgcG9zaXRpb24pLFxuICAgICAgICBidWZmZXIsXG4gICAgICAgIHRhcmdldC5zdWJhcnJheShwb3NpdGlvbiArIGJ1ZmZlci5sZW5ndGgpLFxuICAgIF0pO1xufTtcbmV4cG9ydHMuc2V0ID0gc2V0O1xuLyoqXG4gKiBBZGQgcGFkZGluZyB0byBhIGJ1ZmZlci4gSWYgdGhlIGJ1ZmZlciBpcyBsYXJnZXIgdGhhbiBgbGVuZ3RoYCwgdGhpcyBmdW5jdGlvbiB3b24ndCBkbyBhbnl0aGluZy4gSWYgaXQncyBzbWFsbGVyLCB0aGVcbiAqIGJ1ZmZlciB3aWxsIGJlIHBhZGRlZCB0byB0aGUgc3BlY2lmaWVkIGxlbmd0aCwgd2l0aCBleHRyYSB6ZXJvZXMgYXQgdGhlIHN0YXJ0LlxuICpcbiAqIEBwYXJhbSBidWZmZXIgLSBUaGUgYnVmZmVyIHRvIGFkZCBwYWRkaW5nIHRvLlxuICogQHBhcmFtIGxlbmd0aCAtIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcGFkIHRoZSBidWZmZXIgdG8uXG4gKiBAcmV0dXJucyBUaGUgcGFkZGVkIGJ1ZmZlci5cbiAqL1xuY29uc3QgcGFkU3RhcnQgPSAoYnVmZmVyLCBsZW5ndGggPSBCVUZGRVJfV0lEVEgpID0+IHtcbiAgICBjb25zdCBwYWRkaW5nID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5tYXgobGVuZ3RoIC0gYnVmZmVyLmxlbmd0aCwgMCkpLmZpbGwoMHgwMCk7XG4gICAgcmV0dXJuICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShbcGFkZGluZywgYnVmZmVyXSk7XG59O1xuZXhwb3J0cy5wYWRTdGFydCA9IHBhZFN0YXJ0O1xuLyoqXG4gKiBBZGQgcGFkZGluZyB0byBhIGJ1ZmZlci4gSWYgdGhlIGJ1ZmZlciBpcyBsYXJnZXIgdGhhbiBgbGVuZ3RoYCwgdGhpcyBmdW5jdGlvbiB3b24ndCBkbyBhbnl0aGluZy4gSWYgaXQncyBzbWFsbGVyLCB0aGVcbiAqIGJ1ZmZlciB3aWxsIGJlIHBhZGRlZCB0byB0aGUgc3BlY2lmaWVkIGxlbmd0aCwgd2l0aCBleHRyYSB6ZXJvZXMgYXQgdGhlIGVuZC5cbiAqXG4gKiBAcGFyYW0gYnVmZmVyIC0gVGhlIGJ1ZmZlciB0byBhZGQgcGFkZGluZyB0by5cbiAqIEBwYXJhbSBsZW5ndGggLSBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHBhZCB0aGUgYnVmZmVyIHRvLlxuICogQHJldHVybnMgVGhlIHBhZGRlZCBidWZmZXIuXG4gKi9cbmNvbnN0IHBhZEVuZCA9IChidWZmZXIsIGxlbmd0aCA9IEJVRkZFUl9XSURUSCkgPT4ge1xuICAgIGNvbnN0IHBhZGRpbmcgPSBuZXcgVWludDhBcnJheShNYXRoLm1heChsZW5ndGggLSBidWZmZXIubGVuZ3RoLCAwKSkuZmlsbCgweDAwKTtcbiAgICByZXR1cm4gKDAsIHV0aWxzXzEuY29uY2F0Qnl0ZXMpKFtidWZmZXIsIHBhZGRpbmddKTtcbn07XG5leHBvcnRzLnBhZEVuZCA9IHBhZEVuZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1ZmZlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/abi-utils/dist/utils/buffer.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/abi-utils/dist/utils/index.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@metamask/abi-utils/dist/utils/index.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./buffer */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/utils/buffer.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC91dGlscy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsbUZBQVU7QUFDL0IiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC91dGlscy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2J1ZmZlclwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/abi-utils/dist/utils/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/dist/encryption.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/dist/encryption.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getEncryptionPublicKey = exports.decryptSafely = exports.decrypt = exports.encryptSafely = exports.encrypt = void 0;\nconst base_1 = __webpack_require__(/*! @scure/base */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@scure/base/lib/index.js\");\nconst nacl = __importStar(__webpack_require__(/*! tweetnacl */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/tweetnacl/nacl-fast.js\"));\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/dist/utils.js\");\n/**\n * Encrypt a message.\n *\n * @param options - The encryption options.\n * @param options.publicKey - The public key of the message recipient.\n * @param options.data - The message data.\n * @param options.version - The type of encryption to use.\n * @returns The encrypted data.\n */\nfunction encrypt({ publicKey, data, version, }) {\n    if ((0, utils_1.isNullish)(publicKey)) {\n        throw new Error('Missing publicKey parameter');\n    }\n    else if ((0, utils_1.isNullish)(data)) {\n        throw new Error('Missing data parameter');\n    }\n    else if ((0, utils_1.isNullish)(version)) {\n        throw new Error('Missing version parameter');\n    }\n    switch (version) {\n        case 'x25519-xsalsa20-poly1305': {\n            if (typeof data !== 'string') {\n                throw new Error('Message data must be given as a string');\n            }\n            // generate ephemeral keypair\n            const ephemeralKeyPair = nacl.box.keyPair();\n            // assemble encryption parameters - from string to UInt8\n            let pubKeyUInt8Array;\n            try {\n                pubKeyUInt8Array = base_1.base64.decode(publicKey);\n            }\n            catch (err) {\n                throw new Error('Bad public key');\n            }\n            const msgParamsUInt8Array = base_1.utf8.decode(data);\n            const nonce = nacl.randomBytes(nacl.box.nonceLength);\n            // encrypt\n            const encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey);\n            // handle encrypted data\n            const output = {\n                version: 'x25519-xsalsa20-poly1305',\n                nonce: base_1.base64.encode(nonce),\n                ephemPublicKey: base_1.base64.encode(ephemeralKeyPair.publicKey),\n                ciphertext: base_1.base64.encode(encryptedMessage),\n            };\n            // return encrypted msg data\n            return output;\n        }\n        default:\n            throw new Error('Encryption type/version not supported');\n    }\n}\nexports.encrypt = encrypt;\n/**\n * Encrypt a message in a way that obscures the message length.\n *\n * The message is padded to a multiple of 2048 before being encrypted so that the length of the\n * resulting encrypted message can't be used to guess the exact length of the original message.\n *\n * @param options - The encryption options.\n * @param options.publicKey - The public key of the message recipient.\n * @param options.data - The message data.\n * @param options.version - The type of encryption to use.\n * @returns The encrypted data.\n */\nfunction encryptSafely({ publicKey, data, version, }) {\n    if ((0, utils_1.isNullish)(publicKey)) {\n        throw new Error('Missing publicKey parameter');\n    }\n    else if ((0, utils_1.isNullish)(data)) {\n        throw new Error('Missing data parameter');\n    }\n    else if ((0, utils_1.isNullish)(version)) {\n        throw new Error('Missing version parameter');\n    }\n    const DEFAULT_PADDING_LENGTH = 2 ** 11;\n    const NACL_EXTRA_BYTES = 16;\n    if (typeof data === 'object' && data && 'toJSON' in data) {\n        // remove toJSON attack vector\n        // TODO, check all possible children\n        throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property');\n    }\n    // add padding\n    const dataWithPadding = {\n        data,\n        padding: '',\n    };\n    // calculate padding\n    const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), 'utf-8');\n    const modVal = dataLength % DEFAULT_PADDING_LENGTH;\n    let padLength = 0;\n    // Only pad if necessary\n    if (modVal > 0) {\n        padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES; // nacl extra bytes\n    }\n    dataWithPadding.padding = '0'.repeat(padLength);\n    const paddedMessage = JSON.stringify(dataWithPadding);\n    return encrypt({ publicKey, data: paddedMessage, version });\n}\nexports.encryptSafely = encryptSafely;\n/**\n * Decrypt a message.\n *\n * @param options - The decryption options.\n * @param options.encryptedData - The encrypted data.\n * @param options.privateKey - The private key to decrypt with.\n * @returns The decrypted message.\n */\nfunction decrypt({ encryptedData, privateKey, }) {\n    if ((0, utils_1.isNullish)(encryptedData)) {\n        throw new Error('Missing encryptedData parameter');\n    }\n    else if ((0, utils_1.isNullish)(privateKey)) {\n        throw new Error('Missing privateKey parameter');\n    }\n    switch (encryptedData.version) {\n        case 'x25519-xsalsa20-poly1305': {\n            const receiverPrivateKeyUint8Array = Buffer.from(privateKey, 'hex');\n            const receiverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(receiverPrivateKeyUint8Array).secretKey;\n            // assemble decryption parameters\n            const nonce = base_1.base64.decode(encryptedData.nonce);\n            const ciphertext = base_1.base64.decode(encryptedData.ciphertext);\n            const ephemPublicKey = base_1.base64.decode(encryptedData.ephemPublicKey);\n            // decrypt\n            const decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, receiverEncryptionPrivateKey);\n            // return decrypted msg data\n            try {\n                if (!decryptedMessage) {\n                    throw new Error();\n                }\n                const output = base_1.utf8.encode(decryptedMessage);\n                // TODO: This is probably extraneous but was kept to minimize changes during refactor\n                if (!output) {\n                    throw new Error();\n                }\n                return output;\n            }\n            catch (err) {\n                if (err && typeof err.message === 'string' && err.message.length) {\n                    throw new Error(`Decryption failed: ${err.message}`);\n                }\n                throw new Error(`Decryption failed.`);\n            }\n        }\n        default:\n            throw new Error('Encryption type/version not supported.');\n    }\n}\nexports.decrypt = decrypt;\n/**\n * Decrypt a message that has been encrypted using `encryptSafely`.\n *\n * @param options - The decryption options.\n * @param options.encryptedData - The encrypted data.\n * @param options.privateKey - The private key to decrypt with.\n * @returns The decrypted message.\n */\nfunction decryptSafely({ encryptedData, privateKey, }) {\n    if ((0, utils_1.isNullish)(encryptedData)) {\n        throw new Error('Missing encryptedData parameter');\n    }\n    else if ((0, utils_1.isNullish)(privateKey)) {\n        throw new Error('Missing privateKey parameter');\n    }\n    const dataWithPadding = JSON.parse(decrypt({ encryptedData, privateKey }));\n    return dataWithPadding.data;\n}\nexports.decryptSafely = decryptSafely;\n/**\n * Get the encryption public key for the given key.\n *\n * @param privateKey - The private key to generate the encryption public key with.\n * @returns The encryption public key.\n */\nfunction getEncryptionPublicKey(privateKey) {\n    const privateKeyUint8Array = Buffer.from(privateKey, 'hex');\n    const encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;\n    return base_1.base64.encode(encryptionPublicKey);\n}\nexports.getEncryptionPublicKey = getEncryptionPublicKey;\n//# sourceMappingURL=encryption.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvZGlzdC9lbmNyeXB0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEIsR0FBRyxxQkFBcUIsR0FBRyxlQUFlLEdBQUcscUJBQXFCLEdBQUcsZUFBZTtBQUNsSCxlQUFlLG1CQUFPLENBQUMsMEdBQWE7QUFDcEMsMEJBQTBCLG1CQUFPLENBQUMsc0dBQVc7QUFDN0MsZ0JBQWdCLG1CQUFPLENBQUMsOEVBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDJCQUEyQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlDQUF5QztBQUM5RDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsWUFBWTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNEJBQTRCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwyQkFBMkI7QUFDNUU7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXNpZy11dGlsL2Rpc3QvZW5jcnlwdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRFbmNyeXB0aW9uUHVibGljS2V5ID0gZXhwb3J0cy5kZWNyeXB0U2FmZWx5ID0gZXhwb3J0cy5kZWNyeXB0ID0gZXhwb3J0cy5lbmNyeXB0U2FmZWx5ID0gZXhwb3J0cy5lbmNyeXB0ID0gdm9pZCAwO1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIkBzY3VyZS9iYXNlXCIpO1xuY29uc3QgbmFjbCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwidHdlZXRuYWNsXCIpKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qKlxuICogRW5jcnlwdCBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgZW5jcnlwdGlvbiBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMucHVibGljS2V5IC0gVGhlIHB1YmxpYyBrZXkgb2YgdGhlIG1lc3NhZ2UgcmVjaXBpZW50LlxuICogQHBhcmFtIG9wdGlvbnMuZGF0YSAtIFRoZSBtZXNzYWdlIGRhdGEuXG4gKiBAcGFyYW0gb3B0aW9ucy52ZXJzaW9uIC0gVGhlIHR5cGUgb2YgZW5jcnlwdGlvbiB0byB1c2UuXG4gKiBAcmV0dXJucyBUaGUgZW5jcnlwdGVkIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGVuY3J5cHQoeyBwdWJsaWNLZXksIGRhdGEsIHZlcnNpb24sIH0pIHtcbiAgICBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShwdWJsaWNLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwdWJsaWNLZXkgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkoZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGRhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkodmVyc2lvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHZlcnNpb24gcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIHN3aXRjaCAodmVyc2lvbikge1xuICAgICAgICBjYXNlICd4MjU1MTkteHNhbHNhMjAtcG9seTEzMDUnOiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXNzYWdlIGRhdGEgbXVzdCBiZSBnaXZlbiBhcyBhIHN0cmluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZ2VuZXJhdGUgZXBoZW1lcmFsIGtleXBhaXJcbiAgICAgICAgICAgIGNvbnN0IGVwaGVtZXJhbEtleVBhaXIgPSBuYWNsLmJveC5rZXlQYWlyKCk7XG4gICAgICAgICAgICAvLyBhc3NlbWJsZSBlbmNyeXB0aW9uIHBhcmFtZXRlcnMgLSBmcm9tIHN0cmluZyB0byBVSW50OFxuICAgICAgICAgICAgbGV0IHB1YktleVVJbnQ4QXJyYXk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHB1YktleVVJbnQ4QXJyYXkgPSBiYXNlXzEuYmFzZTY0LmRlY29kZShwdWJsaWNLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIHB1YmxpYyBrZXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1zZ1BhcmFtc1VJbnQ4QXJyYXkgPSBiYXNlXzEudXRmOC5kZWNvZGUoZGF0YSk7XG4gICAgICAgICAgICBjb25zdCBub25jZSA9IG5hY2wucmFuZG9tQnl0ZXMobmFjbC5ib3gubm9uY2VMZW5ndGgpO1xuICAgICAgICAgICAgLy8gZW5jcnlwdFxuICAgICAgICAgICAgY29uc3QgZW5jcnlwdGVkTWVzc2FnZSA9IG5hY2wuYm94KG1zZ1BhcmFtc1VJbnQ4QXJyYXksIG5vbmNlLCBwdWJLZXlVSW50OEFycmF5LCBlcGhlbWVyYWxLZXlQYWlyLnNlY3JldEtleSk7XG4gICAgICAgICAgICAvLyBoYW5kbGUgZW5jcnlwdGVkIGRhdGFcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiAneDI1NTE5LXhzYWxzYTIwLXBvbHkxMzA1JyxcbiAgICAgICAgICAgICAgICBub25jZTogYmFzZV8xLmJhc2U2NC5lbmNvZGUobm9uY2UpLFxuICAgICAgICAgICAgICAgIGVwaGVtUHVibGljS2V5OiBiYXNlXzEuYmFzZTY0LmVuY29kZShlcGhlbWVyYWxLZXlQYWlyLnB1YmxpY0tleSksXG4gICAgICAgICAgICAgICAgY2lwaGVydGV4dDogYmFzZV8xLmJhc2U2NC5lbmNvZGUoZW5jcnlwdGVkTWVzc2FnZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gcmV0dXJuIGVuY3J5cHRlZCBtc2cgZGF0YVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIHR5cGUvdmVyc2lvbiBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxufVxuZXhwb3J0cy5lbmNyeXB0ID0gZW5jcnlwdDtcbi8qKlxuICogRW5jcnlwdCBhIG1lc3NhZ2UgaW4gYSB3YXkgdGhhdCBvYnNjdXJlcyB0aGUgbWVzc2FnZSBsZW5ndGguXG4gKlxuICogVGhlIG1lc3NhZ2UgaXMgcGFkZGVkIHRvIGEgbXVsdGlwbGUgb2YgMjA0OCBiZWZvcmUgYmVpbmcgZW5jcnlwdGVkIHNvIHRoYXQgdGhlIGxlbmd0aCBvZiB0aGVcbiAqIHJlc3VsdGluZyBlbmNyeXB0ZWQgbWVzc2FnZSBjYW4ndCBiZSB1c2VkIHRvIGd1ZXNzIHRoZSBleGFjdCBsZW5ndGggb2YgdGhlIG9yaWdpbmFsIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgZW5jcnlwdGlvbiBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMucHVibGljS2V5IC0gVGhlIHB1YmxpYyBrZXkgb2YgdGhlIG1lc3NhZ2UgcmVjaXBpZW50LlxuICogQHBhcmFtIG9wdGlvbnMuZGF0YSAtIFRoZSBtZXNzYWdlIGRhdGEuXG4gKiBAcGFyYW0gb3B0aW9ucy52ZXJzaW9uIC0gVGhlIHR5cGUgb2YgZW5jcnlwdGlvbiB0byB1c2UuXG4gKiBAcmV0dXJucyBUaGUgZW5jcnlwdGVkIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGVuY3J5cHRTYWZlbHkoeyBwdWJsaWNLZXksIGRhdGEsIHZlcnNpb24sIH0pIHtcbiAgICBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShwdWJsaWNLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwdWJsaWNLZXkgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkoZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGRhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkodmVyc2lvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHZlcnNpb24gcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGNvbnN0IERFRkFVTFRfUEFERElOR19MRU5HVEggPSAyICoqIDExO1xuICAgIGNvbnN0IE5BQ0xfRVhUUkFfQllURVMgPSAxNjtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIGRhdGEgJiYgJ3RvSlNPTicgaW4gZGF0YSkge1xuICAgICAgICAvLyByZW1vdmUgdG9KU09OIGF0dGFjayB2ZWN0b3JcbiAgICAgICAgLy8gVE9ETywgY2hlY2sgYWxsIHBvc3NpYmxlIGNoaWxkcmVuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGVuY3J5cHQgd2l0aCB0b0pTT04gcHJvcGVydHkuICBQbGVhc2UgcmVtb3ZlIHRvSlNPTiBwcm9wZXJ0eScpO1xuICAgIH1cbiAgICAvLyBhZGQgcGFkZGluZ1xuICAgIGNvbnN0IGRhdGFXaXRoUGFkZGluZyA9IHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgcGFkZGluZzogJycsXG4gICAgfTtcbiAgICAvLyBjYWxjdWxhdGUgcGFkZGluZ1xuICAgIGNvbnN0IGRhdGFMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChKU09OLnN0cmluZ2lmeShkYXRhV2l0aFBhZGRpbmcpLCAndXRmLTgnKTtcbiAgICBjb25zdCBtb2RWYWwgPSBkYXRhTGVuZ3RoICUgREVGQVVMVF9QQURESU5HX0xFTkdUSDtcbiAgICBsZXQgcGFkTGVuZ3RoID0gMDtcbiAgICAvLyBPbmx5IHBhZCBpZiBuZWNlc3NhcnlcbiAgICBpZiAobW9kVmFsID4gMCkge1xuICAgICAgICBwYWRMZW5ndGggPSBERUZBVUxUX1BBRERJTkdfTEVOR1RIIC0gbW9kVmFsIC0gTkFDTF9FWFRSQV9CWVRFUzsgLy8gbmFjbCBleHRyYSBieXRlc1xuICAgIH1cbiAgICBkYXRhV2l0aFBhZGRpbmcucGFkZGluZyA9ICcwJy5yZXBlYXQocGFkTGVuZ3RoKTtcbiAgICBjb25zdCBwYWRkZWRNZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoZGF0YVdpdGhQYWRkaW5nKTtcbiAgICByZXR1cm4gZW5jcnlwdCh7IHB1YmxpY0tleSwgZGF0YTogcGFkZGVkTWVzc2FnZSwgdmVyc2lvbiB9KTtcbn1cbmV4cG9ydHMuZW5jcnlwdFNhZmVseSA9IGVuY3J5cHRTYWZlbHk7XG4vKipcbiAqIERlY3J5cHQgYSBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIGRlY3J5cHRpb24gb3B0aW9ucy5cbiAqIEBwYXJhbSBvcHRpb25zLmVuY3J5cHRlZERhdGEgLSBUaGUgZW5jcnlwdGVkIGRhdGEuXG4gKiBAcGFyYW0gb3B0aW9ucy5wcml2YXRlS2V5IC0gVGhlIHByaXZhdGUga2V5IHRvIGRlY3J5cHQgd2l0aC5cbiAqIEByZXR1cm5zIFRoZSBkZWNyeXB0ZWQgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gZGVjcnlwdCh7IGVuY3J5cHRlZERhdGEsIHByaXZhdGVLZXksIH0pIHtcbiAgICBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShlbmNyeXB0ZWREYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZW5jcnlwdGVkRGF0YSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShwcml2YXRlS2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcHJpdmF0ZUtleSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgc3dpdGNoIChlbmNyeXB0ZWREYXRhLnZlcnNpb24pIHtcbiAgICAgICAgY2FzZSAneDI1NTE5LXhzYWxzYTIwLXBvbHkxMzA1Jzoge1xuICAgICAgICAgICAgY29uc3QgcmVjZWl2ZXJQcml2YXRlS2V5VWludDhBcnJheSA9IEJ1ZmZlci5mcm9tKHByaXZhdGVLZXksICdoZXgnKTtcbiAgICAgICAgICAgIGNvbnN0IHJlY2VpdmVyRW5jcnlwdGlvblByaXZhdGVLZXkgPSBuYWNsLmJveC5rZXlQYWlyLmZyb21TZWNyZXRLZXkocmVjZWl2ZXJQcml2YXRlS2V5VWludDhBcnJheSkuc2VjcmV0S2V5O1xuICAgICAgICAgICAgLy8gYXNzZW1ibGUgZGVjcnlwdGlvbiBwYXJhbWV0ZXJzXG4gICAgICAgICAgICBjb25zdCBub25jZSA9IGJhc2VfMS5iYXNlNjQuZGVjb2RlKGVuY3J5cHRlZERhdGEubm9uY2UpO1xuICAgICAgICAgICAgY29uc3QgY2lwaGVydGV4dCA9IGJhc2VfMS5iYXNlNjQuZGVjb2RlKGVuY3J5cHRlZERhdGEuY2lwaGVydGV4dCk7XG4gICAgICAgICAgICBjb25zdCBlcGhlbVB1YmxpY0tleSA9IGJhc2VfMS5iYXNlNjQuZGVjb2RlKGVuY3J5cHRlZERhdGEuZXBoZW1QdWJsaWNLZXkpO1xuICAgICAgICAgICAgLy8gZGVjcnlwdFxuICAgICAgICAgICAgY29uc3QgZGVjcnlwdGVkTWVzc2FnZSA9IG5hY2wuYm94Lm9wZW4oY2lwaGVydGV4dCwgbm9uY2UsIGVwaGVtUHVibGljS2V5LCByZWNlaXZlckVuY3J5cHRpb25Qcml2YXRlS2V5KTtcbiAgICAgICAgICAgIC8vIHJldHVybiBkZWNyeXB0ZWQgbXNnIGRhdGFcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkZWNyeXB0ZWRNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBiYXNlXzEudXRmOC5lbmNvZGUoZGVjcnlwdGVkTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBpcyBwcm9iYWJseSBleHRyYW5lb3VzIGJ1dCB3YXMga2VwdCB0byBtaW5pbWl6ZSBjaGFuZ2VzIGR1cmluZyByZWZhY3RvclxuICAgICAgICAgICAgICAgIGlmICghb3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgdHlwZW9mIGVyci5tZXNzYWdlID09PSAnc3RyaW5nJyAmJiBlcnIubWVzc2FnZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEZWNyeXB0aW9uIGZhaWxlZDogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEZWNyeXB0aW9uIGZhaWxlZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIHR5cGUvdmVyc2lvbiBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVjcnlwdCA9IGRlY3J5cHQ7XG4vKipcbiAqIERlY3J5cHQgYSBtZXNzYWdlIHRoYXQgaGFzIGJlZW4gZW5jcnlwdGVkIHVzaW5nIGBlbmNyeXB0U2FmZWx5YC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBkZWNyeXB0aW9uIG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0aW9ucy5lbmNyeXB0ZWREYXRhIC0gVGhlIGVuY3J5cHRlZCBkYXRhLlxuICogQHBhcmFtIG9wdGlvbnMucHJpdmF0ZUtleSAtIFRoZSBwcml2YXRlIGtleSB0byBkZWNyeXB0IHdpdGguXG4gKiBAcmV0dXJucyBUaGUgZGVjcnlwdGVkIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIGRlY3J5cHRTYWZlbHkoeyBlbmNyeXB0ZWREYXRhLCBwcml2YXRlS2V5LCB9KSB7XG4gICAgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkoZW5jcnlwdGVkRGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGVuY3J5cHRlZERhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkocHJpdmF0ZUtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHByaXZhdGVLZXkgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGFXaXRoUGFkZGluZyA9IEpTT04ucGFyc2UoZGVjcnlwdCh7IGVuY3J5cHRlZERhdGEsIHByaXZhdGVLZXkgfSkpO1xuICAgIHJldHVybiBkYXRhV2l0aFBhZGRpbmcuZGF0YTtcbn1cbmV4cG9ydHMuZGVjcnlwdFNhZmVseSA9IGRlY3J5cHRTYWZlbHk7XG4vKipcbiAqIEdldCB0aGUgZW5jcnlwdGlvbiBwdWJsaWMga2V5IGZvciB0aGUgZ2l2ZW4ga2V5LlxuICpcbiAqIEBwYXJhbSBwcml2YXRlS2V5IC0gVGhlIHByaXZhdGUga2V5IHRvIGdlbmVyYXRlIHRoZSBlbmNyeXB0aW9uIHB1YmxpYyBrZXkgd2l0aC5cbiAqIEByZXR1cm5zIFRoZSBlbmNyeXB0aW9uIHB1YmxpYyBrZXkuXG4gKi9cbmZ1bmN0aW9uIGdldEVuY3J5cHRpb25QdWJsaWNLZXkocHJpdmF0ZUtleSkge1xuICAgIGNvbnN0IHByaXZhdGVLZXlVaW50OEFycmF5ID0gQnVmZmVyLmZyb20ocHJpdmF0ZUtleSwgJ2hleCcpO1xuICAgIGNvbnN0IGVuY3J5cHRpb25QdWJsaWNLZXkgPSBuYWNsLmJveC5rZXlQYWlyLmZyb21TZWNyZXRLZXkocHJpdmF0ZUtleVVpbnQ4QXJyYXkpLnB1YmxpY0tleTtcbiAgICByZXR1cm4gYmFzZV8xLmJhc2U2NC5lbmNvZGUoZW5jcnlwdGlvblB1YmxpY0tleSk7XG59XG5leHBvcnRzLmdldEVuY3J5cHRpb25QdWJsaWNLZXkgPSBnZXRFbmNyeXB0aW9uUHVibGljS2V5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5jcnlwdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/dist/encryption.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/dist/index.js":
/*!***************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/dist/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.normalize = exports.concatSig = void 0;\n__exportStar(__webpack_require__(/*! ./personal-sign */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/dist/personal-sign.js\"), exports);\n__exportStar(__webpack_require__(/*! ./sign-typed-data */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/dist/sign-typed-data.js\"), exports);\n__exportStar(__webpack_require__(/*! ./encryption */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/dist/encryption.js\"), exports);\n__exportStar(__webpack_require__(/*! ./sign-eip7702-authorization */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/dist/sign-eip7702-authorization.js\"), exports);\nvar utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/dist/utils.js\");\nObject.defineProperty(exports, \"concatSig\", ({ enumerable: true, get: function () { return utils_1.concatSig; } }));\nObject.defineProperty(exports, \"normalize\", ({ enumerable: true, get: function () { return utils_1.normalize; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyxpQkFBaUI7QUFDckMsYUFBYSxtQkFBTyxDQUFDLDhGQUFpQjtBQUN0QyxhQUFhLG1CQUFPLENBQUMsa0dBQW1CO0FBQ3hDLGFBQWEsbUJBQU8sQ0FBQyx3RkFBYztBQUNuQyxhQUFhLG1CQUFPLENBQUMsd0hBQThCO0FBQ25ELGNBQWMsbUJBQU8sQ0FBQyw4RUFBUztBQUMvQiw2Q0FBNEMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDakgsNkNBQTRDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQ2pIIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXNpZy11dGlsL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubm9ybWFsaXplID0gZXhwb3J0cy5jb25jYXRTaWcgPSB2b2lkIDA7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcGVyc29uYWwtc2lnblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2lnbi10eXBlZC1kYXRhXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lbmNyeXB0aW9uXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zaWduLWVpcDc3MDItYXV0aG9yaXphdGlvblwiKSwgZXhwb3J0cyk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29uY2F0U2lnXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLmNvbmNhdFNpZzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5vcm1hbGl6ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5ub3JtYWxpemU7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/dist/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/dist/personal-sign.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/dist/personal-sign.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.extractPublicKey = exports.recoverPersonalSignature = exports.personalSign = void 0;\nconst util_1 = __webpack_require__(/*! @ethereumjs/util */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/index.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/dist/utils.js\");\n/**\n * Create an Ethereum-specific signature for a message.\n *\n * This function is equivalent to the `eth_sign` Ethereum JSON-RPC method as specified in EIP-1417,\n * as well as the MetaMask's `personal_sign` method.\n *\n * @param options - The personal sign options.\n * @param options.privateKey - The key to sign with.\n * @param options.data - The hex data to sign.\n * @returns The '0x'-prefixed hex encoded signature.\n */\nfunction personalSign({ privateKey, data, }) {\n    if ((0, utils_1.isNullish)(data)) {\n        throw new Error('Missing data parameter');\n    }\n    else if ((0, utils_1.isNullish)(privateKey)) {\n        throw new Error('Missing privateKey parameter');\n    }\n    const message = (0, utils_1.legacyToBuffer)(data);\n    const msgHash = (0, util_1.hashPersonalMessage)(message);\n    const sig = (0, util_1.ecsign)(msgHash, privateKey);\n    const serialized = (0, utils_1.concatSig)((0, util_1.toBuffer)(sig.v), sig.r, sig.s);\n    return serialized;\n}\nexports.personalSign = personalSign;\n/**\n * Recover the address of the account used to create the given Ethereum signature. The message\n * must have been signed using the `personalSign` function, or an equivalent function.\n *\n * @param options - The signature recovery options.\n * @param options.data - The hex data that was signed.\n * @param options.signature - The '0x'-prefixed hex encoded message signature.\n * @returns The '0x'-prefixed hex encoded address of the message signer.\n */\nfunction recoverPersonalSignature({ data, signature, }) {\n    if ((0, utils_1.isNullish)(data)) {\n        throw new Error('Missing data parameter');\n    }\n    else if ((0, utils_1.isNullish)(signature)) {\n        throw new Error('Missing signature parameter');\n    }\n    const publicKey = getPublicKeyFor(data, signature);\n    const sender = (0, util_1.publicToAddress)(publicKey);\n    const senderHex = (0, util_1.bufferToHex)(sender);\n    return senderHex;\n}\nexports.recoverPersonalSignature = recoverPersonalSignature;\n/**\n * Recover the public key of the account used to create the given Ethereum signature. The message\n * must have been signed using the `personalSign` function, or an equivalent function.\n *\n * @param options - The public key recovery options.\n * @param options.data - The hex data that was signed.\n * @param options.signature - The '0x'-prefixed hex encoded message signature.\n * @returns The '0x'-prefixed hex encoded public key of the message signer.\n */\nfunction extractPublicKey({ data, signature, }) {\n    if ((0, utils_1.isNullish)(data)) {\n        throw new Error('Missing data parameter');\n    }\n    else if ((0, utils_1.isNullish)(signature)) {\n        throw new Error('Missing signature parameter');\n    }\n    const publicKey = getPublicKeyFor(data, signature);\n    return `0x${publicKey.toString('hex')}`;\n}\nexports.extractPublicKey = extractPublicKey;\n/**\n * Get the public key for the given signature and message.\n *\n * @param message - The message that was signed.\n * @param signature - The '0x'-prefixed hex encoded message signature.\n * @returns The public key of the signer.\n */\nfunction getPublicKeyFor(message, signature) {\n    const messageHash = (0, util_1.hashPersonalMessage)((0, utils_1.legacyToBuffer)(message));\n    return (0, utils_1.recoverPublicKey)(messageHash, signature);\n}\n//# sourceMappingURL=personal-sign.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvZGlzdC9wZXJzb25hbC1zaWduLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QixHQUFHLGdDQUFnQyxHQUFHLG9CQUFvQjtBQUNsRixlQUFlLG1CQUFPLENBQUMscUhBQWtCO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLDhFQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXNpZy11dGlsL2Rpc3QvcGVyc29uYWwtc2lnbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0cmFjdFB1YmxpY0tleSA9IGV4cG9ydHMucmVjb3ZlclBlcnNvbmFsU2lnbmF0dXJlID0gZXhwb3J0cy5wZXJzb25hbFNpZ24gPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiQGV0aGVyZXVtanMvdXRpbFwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qKlxuICogQ3JlYXRlIGFuIEV0aGVyZXVtLXNwZWNpZmljIHNpZ25hdHVyZSBmb3IgYSBtZXNzYWdlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgZXF1aXZhbGVudCB0byB0aGUgYGV0aF9zaWduYCBFdGhlcmV1bSBKU09OLVJQQyBtZXRob2QgYXMgc3BlY2lmaWVkIGluIEVJUC0xNDE3LFxuICogYXMgd2VsbCBhcyB0aGUgTWV0YU1hc2sncyBgcGVyc29uYWxfc2lnbmAgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHBlcnNvbmFsIHNpZ24gb3B0aW9ucy5cbiAqIEBwYXJhbSBvcHRpb25zLnByaXZhdGVLZXkgLSBUaGUga2V5IHRvIHNpZ24gd2l0aC5cbiAqIEBwYXJhbSBvcHRpb25zLmRhdGEgLSBUaGUgaGV4IGRhdGEgdG8gc2lnbi5cbiAqIEByZXR1cm5zIFRoZSAnMHgnLXByZWZpeGVkIGhleCBlbmNvZGVkIHNpZ25hdHVyZS5cbiAqL1xuZnVuY3Rpb24gcGVyc29uYWxTaWduKHsgcHJpdmF0ZUtleSwgZGF0YSwgfSkge1xuICAgIGlmICgoMCwgdXRpbHNfMS5pc051bGxpc2gpKGRhdGEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBkYXRhIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgdXRpbHNfMS5pc051bGxpc2gpKHByaXZhdGVLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwcml2YXRlS2V5IHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlID0gKDAsIHV0aWxzXzEubGVnYWN5VG9CdWZmZXIpKGRhdGEpO1xuICAgIGNvbnN0IG1zZ0hhc2ggPSAoMCwgdXRpbF8xLmhhc2hQZXJzb25hbE1lc3NhZ2UpKG1lc3NhZ2UpO1xuICAgIGNvbnN0IHNpZyA9ICgwLCB1dGlsXzEuZWNzaWduKShtc2dIYXNoLCBwcml2YXRlS2V5KTtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gKDAsIHV0aWxzXzEuY29uY2F0U2lnKSgoMCwgdXRpbF8xLnRvQnVmZmVyKShzaWcudiksIHNpZy5yLCBzaWcucyk7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59XG5leHBvcnRzLnBlcnNvbmFsU2lnbiA9IHBlcnNvbmFsU2lnbjtcbi8qKlxuICogUmVjb3ZlciB0aGUgYWRkcmVzcyBvZiB0aGUgYWNjb3VudCB1c2VkIHRvIGNyZWF0ZSB0aGUgZ2l2ZW4gRXRoZXJldW0gc2lnbmF0dXJlLiBUaGUgbWVzc2FnZVxuICogbXVzdCBoYXZlIGJlZW4gc2lnbmVkIHVzaW5nIHRoZSBgcGVyc29uYWxTaWduYCBmdW5jdGlvbiwgb3IgYW4gZXF1aXZhbGVudCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBzaWduYXR1cmUgcmVjb3Zlcnkgb3B0aW9ucy5cbiAqIEBwYXJhbSBvcHRpb25zLmRhdGEgLSBUaGUgaGV4IGRhdGEgdGhhdCB3YXMgc2lnbmVkLlxuICogQHBhcmFtIG9wdGlvbnMuc2lnbmF0dXJlIC0gVGhlICcweCctcHJlZml4ZWQgaGV4IGVuY29kZWQgbWVzc2FnZSBzaWduYXR1cmUuXG4gKiBAcmV0dXJucyBUaGUgJzB4Jy1wcmVmaXhlZCBoZXggZW5jb2RlZCBhZGRyZXNzIG9mIHRoZSBtZXNzYWdlIHNpZ25lci5cbiAqL1xuZnVuY3Rpb24gcmVjb3ZlclBlcnNvbmFsU2lnbmF0dXJlKHsgZGF0YSwgc2lnbmF0dXJlLCB9KSB7XG4gICAgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkoZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGRhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkoc2lnbmF0dXJlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3Npbmcgc2lnbmF0dXJlIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBjb25zdCBwdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXlGb3IoZGF0YSwgc2lnbmF0dXJlKTtcbiAgICBjb25zdCBzZW5kZXIgPSAoMCwgdXRpbF8xLnB1YmxpY1RvQWRkcmVzcykocHVibGljS2V5KTtcbiAgICBjb25zdCBzZW5kZXJIZXggPSAoMCwgdXRpbF8xLmJ1ZmZlclRvSGV4KShzZW5kZXIpO1xuICAgIHJldHVybiBzZW5kZXJIZXg7XG59XG5leHBvcnRzLnJlY292ZXJQZXJzb25hbFNpZ25hdHVyZSA9IHJlY292ZXJQZXJzb25hbFNpZ25hdHVyZTtcbi8qKlxuICogUmVjb3ZlciB0aGUgcHVibGljIGtleSBvZiB0aGUgYWNjb3VudCB1c2VkIHRvIGNyZWF0ZSB0aGUgZ2l2ZW4gRXRoZXJldW0gc2lnbmF0dXJlLiBUaGUgbWVzc2FnZVxuICogbXVzdCBoYXZlIGJlZW4gc2lnbmVkIHVzaW5nIHRoZSBgcGVyc29uYWxTaWduYCBmdW5jdGlvbiwgb3IgYW4gZXF1aXZhbGVudCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBwdWJsaWMga2V5IHJlY292ZXJ5IG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0aW9ucy5kYXRhIC0gVGhlIGhleCBkYXRhIHRoYXQgd2FzIHNpZ25lZC5cbiAqIEBwYXJhbSBvcHRpb25zLnNpZ25hdHVyZSAtIFRoZSAnMHgnLXByZWZpeGVkIGhleCBlbmNvZGVkIG1lc3NhZ2Ugc2lnbmF0dXJlLlxuICogQHJldHVybnMgVGhlICcweCctcHJlZml4ZWQgaGV4IGVuY29kZWQgcHVibGljIGtleSBvZiB0aGUgbWVzc2FnZSBzaWduZXIuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RQdWJsaWNLZXkoeyBkYXRhLCBzaWduYXR1cmUsIH0pIHtcbiAgICBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShkYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZGF0YSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShzaWduYXR1cmUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBzaWduYXR1cmUgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGNvbnN0IHB1YmxpY0tleSA9IGdldFB1YmxpY0tleUZvcihkYXRhLCBzaWduYXR1cmUpO1xuICAgIHJldHVybiBgMHgke3B1YmxpY0tleS50b1N0cmluZygnaGV4Jyl9YDtcbn1cbmV4cG9ydHMuZXh0cmFjdFB1YmxpY0tleSA9IGV4dHJhY3RQdWJsaWNLZXk7XG4vKipcbiAqIEdldCB0aGUgcHVibGljIGtleSBmb3IgdGhlIGdpdmVuIHNpZ25hdHVyZSBhbmQgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIHRoYXQgd2FzIHNpZ25lZC5cbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgJzB4Jy1wcmVmaXhlZCBoZXggZW5jb2RlZCBtZXNzYWdlIHNpZ25hdHVyZS5cbiAqIEByZXR1cm5zIFRoZSBwdWJsaWMga2V5IG9mIHRoZSBzaWduZXIuXG4gKi9cbmZ1bmN0aW9uIGdldFB1YmxpY0tleUZvcihtZXNzYWdlLCBzaWduYXR1cmUpIHtcbiAgICBjb25zdCBtZXNzYWdlSGFzaCA9ICgwLCB1dGlsXzEuaGFzaFBlcnNvbmFsTWVzc2FnZSkoKDAsIHV0aWxzXzEubGVnYWN5VG9CdWZmZXIpKG1lc3NhZ2UpKTtcbiAgICByZXR1cm4gKDAsIHV0aWxzXzEucmVjb3ZlclB1YmxpY0tleSkobWVzc2FnZUhhc2gsIHNpZ25hdHVyZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wZXJzb25hbC1zaWduLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/dist/personal-sign.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/dist/sign-eip7702-authorization.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/dist/sign-eip7702-authorization.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hashEIP7702Authorization = exports.recoverEIP7702Authorization = exports.signEIP7702Authorization = void 0;\nconst rlp_1 = __webpack_require__(/*! @ethereumjs/rlp */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/rlp/dist/index.js\");\nconst util_1 = __webpack_require__(/*! @ethereumjs/util */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/index.js\");\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(rsc)/../../node_modules/@metamask/utils/dist/index.cjs\");\nconst keccak_1 = __webpack_require__(/*! ethereum-cryptography/keccak */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/ethereum-cryptography/keccak.js\");\nconst utils_2 = __webpack_require__(/*! ./utils */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/dist/utils.js\");\n/**\n * Sign an authorization message with the provided private key.\n *\n * @param options - The signing options.\n * @param options.privateKey - The private key to sign with.\n * @param options.authorization - The authorization data to sign.\n * @returns The '0x'-prefixed hex encoded signature.\n */\nfunction signEIP7702Authorization({ privateKey, authorization, }) {\n    validateEIP7702Authorization(authorization);\n    if ((0, utils_2.isNullish)(privateKey)) {\n        throw new Error('Missing privateKey parameter');\n    }\n    const messageHash = hashEIP7702Authorization(authorization);\n    const { r, s, v } = (0, util_1.ecsign)(messageHash, privateKey);\n    // v is either 27n or 28n so is guaranteed to be a single byte\n    const vBuffer = (0, util_1.toBuffer)(v);\n    return (0, utils_2.concatSig)(vBuffer, r, s);\n}\nexports.signEIP7702Authorization = signEIP7702Authorization;\n/**\n * Recover the address of the account that created the given authorization\n * signature.\n *\n * @param options - The signature recovery options.\n * @param options.signature - The '0x'-prefixed hex encoded message signature.\n * @param options.authorization - The authorization data that was signed.\n * @returns The '0x'-prefixed hex address of the signer.\n */\nfunction recoverEIP7702Authorization({ signature, authorization, }) {\n    validateEIP7702Authorization(authorization);\n    if ((0, utils_2.isNullish)(signature)) {\n        throw new Error('Missing signature parameter');\n    }\n    const messageHash = hashEIP7702Authorization(authorization);\n    const publicKey = (0, utils_2.recoverPublicKey)(messageHash, signature);\n    const sender = (0, util_1.publicToAddress)(publicKey);\n    return (0, utils_1.bytesToHex)(sender);\n}\nexports.recoverEIP7702Authorization = recoverEIP7702Authorization;\n/**\n * Hash an authorization message according to the signing scheme.\n * The message is encoded according to EIP-7702.\n *\n * @param authorization - The authorization data to hash.\n * @returns The hash of the authorization message as a Buffer.\n */\nfunction hashEIP7702Authorization(authorization) {\n    validateEIP7702Authorization(authorization);\n    const encodedAuthorization = (0, rlp_1.encode)(authorization);\n    const message = Buffer.concat([\n        Buffer.from('05', 'hex'),\n        encodedAuthorization,\n    ]);\n    return Buffer.from((0, keccak_1.keccak256)(message));\n}\nexports.hashEIP7702Authorization = hashEIP7702Authorization;\n/**\n * Validates an authorization object to ensure all required parameters are present.\n *\n * @param authorization - The authorization object to validate.\n * @throws {Error} If the authorization object or any of its required parameters are missing.\n */\nfunction validateEIP7702Authorization(authorization) {\n    if ((0, utils_2.isNullish)(authorization)) {\n        throw new Error('Missing authorization parameter');\n    }\n    const [chainId, contractAddress, nonce] = authorization;\n    if ((0, utils_2.isNullish)(chainId)) {\n        throw new Error('Missing chainId parameter');\n    }\n    if ((0, utils_2.isNullish)(contractAddress)) {\n        throw new Error('Missing contractAddress parameter');\n    }\n    if ((0, utils_2.isNullish)(nonce)) {\n        throw new Error('Missing nonce parameter');\n    }\n}\n//# sourceMappingURL=sign-eip7702-authorization.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvZGlzdC9zaWduLWVpcDc3MDItYXV0aG9yaXphdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0MsR0FBRyxtQ0FBbUMsR0FBRyxnQ0FBZ0M7QUFDekcsY0FBYyxtQkFBTyxDQUFDLG1IQUFpQjtBQUN2QyxlQUFlLG1CQUFPLENBQUMscUhBQWtCO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLGdGQUFpQjtBQUN6QyxpQkFBaUIsbUJBQU8sQ0FBQyxrSUFBOEI7QUFDdkQsZ0JBQWdCLG1CQUFPLENBQUMsOEVBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkJBQTJCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXNpZy11dGlsL2Rpc3Qvc2lnbi1laXA3NzAyLWF1dGhvcml6YXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhhc2hFSVA3NzAyQXV0aG9yaXphdGlvbiA9IGV4cG9ydHMucmVjb3ZlckVJUDc3MDJBdXRob3JpemF0aW9uID0gZXhwb3J0cy5zaWduRUlQNzcwMkF1dGhvcml6YXRpb24gPSB2b2lkIDA7XG5jb25zdCBybHBfMSA9IHJlcXVpcmUoXCJAZXRoZXJldW1qcy9ybHBcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiQGV0aGVyZXVtanMvdXRpbFwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL3V0aWxzXCIpO1xuY29uc3Qga2VjY2FrXzEgPSByZXF1aXJlKFwiZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2Nha1wiKTtcbmNvbnN0IHV0aWxzXzIgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qKlxuICogU2lnbiBhbiBhdXRob3JpemF0aW9uIG1lc3NhZ2Ugd2l0aCB0aGUgcHJvdmlkZWQgcHJpdmF0ZSBrZXkuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgc2lnbmluZyBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMucHJpdmF0ZUtleSAtIFRoZSBwcml2YXRlIGtleSB0byBzaWduIHdpdGguXG4gKiBAcGFyYW0gb3B0aW9ucy5hdXRob3JpemF0aW9uIC0gVGhlIGF1dGhvcml6YXRpb24gZGF0YSB0byBzaWduLlxuICogQHJldHVybnMgVGhlICcweCctcHJlZml4ZWQgaGV4IGVuY29kZWQgc2lnbmF0dXJlLlxuICovXG5mdW5jdGlvbiBzaWduRUlQNzcwMkF1dGhvcml6YXRpb24oeyBwcml2YXRlS2V5LCBhdXRob3JpemF0aW9uLCB9KSB7XG4gICAgdmFsaWRhdGVFSVA3NzAyQXV0aG9yaXphdGlvbihhdXRob3JpemF0aW9uKTtcbiAgICBpZiAoKDAsIHV0aWxzXzIuaXNOdWxsaXNoKShwcml2YXRlS2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcHJpdmF0ZUtleSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZUhhc2ggPSBoYXNoRUlQNzcwMkF1dGhvcml6YXRpb24oYXV0aG9yaXphdGlvbik7XG4gICAgY29uc3QgeyByLCBzLCB2IH0gPSAoMCwgdXRpbF8xLmVjc2lnbikobWVzc2FnZUhhc2gsIHByaXZhdGVLZXkpO1xuICAgIC8vIHYgaXMgZWl0aGVyIDI3biBvciAyOG4gc28gaXMgZ3VhcmFudGVlZCB0byBiZSBhIHNpbmdsZSBieXRlXG4gICAgY29uc3QgdkJ1ZmZlciA9ICgwLCB1dGlsXzEudG9CdWZmZXIpKHYpO1xuICAgIHJldHVybiAoMCwgdXRpbHNfMi5jb25jYXRTaWcpKHZCdWZmZXIsIHIsIHMpO1xufVxuZXhwb3J0cy5zaWduRUlQNzcwMkF1dGhvcml6YXRpb24gPSBzaWduRUlQNzcwMkF1dGhvcml6YXRpb247XG4vKipcbiAqIFJlY292ZXIgdGhlIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdGhhdCBjcmVhdGVkIHRoZSBnaXZlbiBhdXRob3JpemF0aW9uXG4gKiBzaWduYXR1cmUuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgc2lnbmF0dXJlIHJlY292ZXJ5IG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0aW9ucy5zaWduYXR1cmUgLSBUaGUgJzB4Jy1wcmVmaXhlZCBoZXggZW5jb2RlZCBtZXNzYWdlIHNpZ25hdHVyZS5cbiAqIEBwYXJhbSBvcHRpb25zLmF1dGhvcml6YXRpb24gLSBUaGUgYXV0aG9yaXphdGlvbiBkYXRhIHRoYXQgd2FzIHNpZ25lZC5cbiAqIEByZXR1cm5zIFRoZSAnMHgnLXByZWZpeGVkIGhleCBhZGRyZXNzIG9mIHRoZSBzaWduZXIuXG4gKi9cbmZ1bmN0aW9uIHJlY292ZXJFSVA3NzAyQXV0aG9yaXphdGlvbih7IHNpZ25hdHVyZSwgYXV0aG9yaXphdGlvbiwgfSkge1xuICAgIHZhbGlkYXRlRUlQNzcwMkF1dGhvcml6YXRpb24oYXV0aG9yaXphdGlvbik7XG4gICAgaWYgKCgwLCB1dGlsc18yLmlzTnVsbGlzaCkoc2lnbmF0dXJlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3Npbmcgc2lnbmF0dXJlIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlSGFzaCA9IGhhc2hFSVA3NzAyQXV0aG9yaXphdGlvbihhdXRob3JpemF0aW9uKTtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSAoMCwgdXRpbHNfMi5yZWNvdmVyUHVibGljS2V5KShtZXNzYWdlSGFzaCwgc2lnbmF0dXJlKTtcbiAgICBjb25zdCBzZW5kZXIgPSAoMCwgdXRpbF8xLnB1YmxpY1RvQWRkcmVzcykocHVibGljS2V5KTtcbiAgICByZXR1cm4gKDAsIHV0aWxzXzEuYnl0ZXNUb0hleCkoc2VuZGVyKTtcbn1cbmV4cG9ydHMucmVjb3ZlckVJUDc3MDJBdXRob3JpemF0aW9uID0gcmVjb3ZlckVJUDc3MDJBdXRob3JpemF0aW9uO1xuLyoqXG4gKiBIYXNoIGFuIGF1dGhvcml6YXRpb24gbWVzc2FnZSBhY2NvcmRpbmcgdG8gdGhlIHNpZ25pbmcgc2NoZW1lLlxuICogVGhlIG1lc3NhZ2UgaXMgZW5jb2RlZCBhY2NvcmRpbmcgdG8gRUlQLTc3MDIuXG4gKlxuICogQHBhcmFtIGF1dGhvcml6YXRpb24gLSBUaGUgYXV0aG9yaXphdGlvbiBkYXRhIHRvIGhhc2guXG4gKiBAcmV0dXJucyBUaGUgaGFzaCBvZiB0aGUgYXV0aG9yaXphdGlvbiBtZXNzYWdlIGFzIGEgQnVmZmVyLlxuICovXG5mdW5jdGlvbiBoYXNoRUlQNzcwMkF1dGhvcml6YXRpb24oYXV0aG9yaXphdGlvbikge1xuICAgIHZhbGlkYXRlRUlQNzcwMkF1dGhvcml6YXRpb24oYXV0aG9yaXphdGlvbik7XG4gICAgY29uc3QgZW5jb2RlZEF1dGhvcml6YXRpb24gPSAoMCwgcmxwXzEuZW5jb2RlKShhdXRob3JpemF0aW9uKTtcbiAgICBjb25zdCBtZXNzYWdlID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgIEJ1ZmZlci5mcm9tKCcwNScsICdoZXgnKSxcbiAgICAgICAgZW5jb2RlZEF1dGhvcml6YXRpb24sXG4gICAgXSk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKCgwLCBrZWNjYWtfMS5rZWNjYWsyNTYpKG1lc3NhZ2UpKTtcbn1cbmV4cG9ydHMuaGFzaEVJUDc3MDJBdXRob3JpemF0aW9uID0gaGFzaEVJUDc3MDJBdXRob3JpemF0aW9uO1xuLyoqXG4gKiBWYWxpZGF0ZXMgYW4gYXV0aG9yaXphdGlvbiBvYmplY3QgdG8gZW5zdXJlIGFsbCByZXF1aXJlZCBwYXJhbWV0ZXJzIGFyZSBwcmVzZW50LlxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gVGhlIGF1dGhvcml6YXRpb24gb2JqZWN0IHRvIHZhbGlkYXRlLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBhdXRob3JpemF0aW9uIG9iamVjdCBvciBhbnkgb2YgaXRzIHJlcXVpcmVkIHBhcmFtZXRlcnMgYXJlIG1pc3NpbmcuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRUlQNzcwMkF1dGhvcml6YXRpb24oYXV0aG9yaXphdGlvbikge1xuICAgIGlmICgoMCwgdXRpbHNfMi5pc051bGxpc2gpKGF1dGhvcml6YXRpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBhdXRob3JpemF0aW9uIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBjb25zdCBbY2hhaW5JZCwgY29udHJhY3RBZGRyZXNzLCBub25jZV0gPSBhdXRob3JpemF0aW9uO1xuICAgIGlmICgoMCwgdXRpbHNfMi5pc051bGxpc2gpKGNoYWluSWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBjaGFpbklkIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBpZiAoKDAsIHV0aWxzXzIuaXNOdWxsaXNoKShjb250cmFjdEFkZHJlc3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBjb250cmFjdEFkZHJlc3MgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGlmICgoMCwgdXRpbHNfMi5pc051bGxpc2gpKG5vbmNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3Npbmcgbm9uY2UgcGFyYW1ldGVyJyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbi1laXA3NzAyLWF1dGhvcml6YXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/dist/sign-eip7702-authorization.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/dist/sign-typed-data.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/dist/sign-typed-data.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.recoverTypedSignature = exports.signTypedData = exports.typedSignatureHash = exports.TypedDataUtils = exports.TYPED_MESSAGE_SCHEMA = exports.SignTypedDataVersion = void 0;\nconst util_1 = __webpack_require__(/*! @ethereumjs/util */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/index.js\");\nconst abi_utils_1 = __webpack_require__(/*! @metamask/abi-utils */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/index.js\");\nconst parsers_1 = __webpack_require__(/*! @metamask/abi-utils/dist/parsers */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/parsers/index.js\");\nconst utils_1 = __webpack_require__(/*! @metamask/abi-utils/dist/utils */ \"(rsc)/../../node_modules/@metamask/abi-utils/dist/utils/index.js\");\nconst utils_2 = __webpack_require__(/*! @metamask/utils */ \"(rsc)/../../node_modules/@metamask/utils/dist/index.cjs\");\nconst keccak_1 = __webpack_require__(/*! ethereum-cryptography/keccak */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/ethereum-cryptography/keccak.js\");\nconst utils_3 = __webpack_require__(/*! ./utils */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/dist/utils.js\");\n/**\n * Represents the version of `signTypedData` being used.\n *\n * V1 is based upon [an early version of\n * EIP-712](https://github.com/ethereum/EIPs/pull/712/commits/21abe254fe0452d8583d5b132b1d7be87c0439ca)\n * that lacked some later security improvements, and should generally be neglected in favor of\n * later versions.\n *\n * V3 is based on EIP-712, except that arrays and recursive data structures are not supported.\n *\n * V4 is based on EIP-712, and includes full support of arrays and recursive data structures.\n */\nvar SignTypedDataVersion;\n(function (SignTypedDataVersion) {\n    SignTypedDataVersion[\"V1\"] = \"V1\";\n    SignTypedDataVersion[\"V3\"] = \"V3\";\n    SignTypedDataVersion[\"V4\"] = \"V4\";\n})(SignTypedDataVersion = exports.SignTypedDataVersion || (exports.SignTypedDataVersion = {}));\nexports.TYPED_MESSAGE_SCHEMA = {\n    type: 'object',\n    properties: {\n        types: {\n            type: 'object',\n            additionalProperties: {\n                type: 'array',\n                items: {\n                    type: 'object',\n                    properties: {\n                        name: { type: 'string' },\n                        type: { type: 'string' },\n                    },\n                    required: ['name', 'type'],\n                },\n            },\n        },\n        primaryType: { type: 'string' },\n        domain: { type: 'object' },\n        message: { type: 'object' },\n    },\n    required: ['types', 'primaryType', 'domain', 'message'],\n};\n/**\n * Validate that the given value is a valid version string.\n *\n * @param version - The version value to validate.\n * @param allowedVersions - A list of allowed versions. If omitted, all versions are assumed to be\n * allowed.\n */\nfunction validateVersion(version, allowedVersions) {\n    if (!Object.keys(SignTypedDataVersion).includes(version)) {\n        throw new Error(`Invalid version: '${version}'`);\n    }\n    else if (allowedVersions && !allowedVersions.includes(version)) {\n        throw new Error(`SignTypedDataVersion not allowed: '${version}'. Allowed versions are: ${allowedVersions.join(', ')}`);\n    }\n}\n/**\n * Parse a string, number, or bigint value into a `Uint8Array`.\n *\n * @param type - The type of the value.\n * @param value - The value to parse.\n * @returns The parsed value.\n */\nfunction parseNumber(type, value) {\n    (0, utils_2.assert)(value !== null, `Unable to encode value: Invalid number. Expected a valid number value, but received \"${value}\".`);\n    const bigIntValue = BigInt(value);\n    const length = (0, parsers_1.getLength)(type);\n    const maxValue = BigInt(2) ** BigInt(length) - BigInt(1);\n    // Note that this is not accurate, since the actual maximum value for unsigned\n    // integers is `2 ^ (length - 1) - 1`, but this is required for backwards\n    // compatibility with the old implementation.\n    (0, utils_2.assert)(bigIntValue >= -maxValue && bigIntValue <= maxValue, `Unable to encode value: Number \"${value}\" is out of range for type \"${type}\".`);\n    return bigIntValue;\n}\n/**\n * Parse an address string to a `Uint8Array`. The behaviour of this is quite\n * strange, in that it does not parse the address as hexadecimal string, nor as\n * UTF-8. It does some weird stuff with the string and char codes, and then\n * returns the result as a `Uint8Array`.\n *\n * This is based on the old `ethereumjs-abi` implementation, which essentially\n * calls `new BN(address, 10)` on the address string, the equivalent of calling\n * `parseInt(address, 10)` in JavaScript. This is not a valid way to parse an\n * address and would result in `NaN` in plain JavaScript, but it is the\n * behaviour of the old implementation, and so we must preserve it for backwards\n * compatibility.\n *\n * @param address - The address to parse.\n * @returns The parsed address.\n */\nfunction reallyStrangeAddressToBytes(address) {\n    let addressValue = BigInt(0);\n    for (let i = 0; i < address.length; i++) {\n        const character = BigInt(address.charCodeAt(i) - 48);\n        addressValue *= BigInt(10);\n        // 'a'\n        if (character >= 49) {\n            addressValue += character - BigInt(49) + BigInt(0xa);\n            // 'A'\n        }\n        else if (character >= 17) {\n            addressValue += character - BigInt(17) + BigInt(0xa);\n            // '0' - '9'\n        }\n        else {\n            addressValue += character;\n        }\n    }\n    return (0, utils_1.padStart)((0, utils_2.bigIntToBytes)(addressValue), 20);\n}\n/**\n * Encode a single field.\n *\n * @param types - All type definitions.\n * @param name - The name of the field to encode.\n * @param type - The type of the field being encoded.\n * @param value - The value to encode.\n * @param version - The EIP-712 version the encoding should comply with.\n * @returns Encoded representation of the field.\n */\nfunction encodeField(types, name, type, \n// TODO: constrain type on `value`\nvalue, version) {\n    validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);\n    if (types[type] !== undefined) {\n        return [\n            'bytes32',\n            // TODO: return Buffer, remove string from return type\n            version === SignTypedDataVersion.V4 && value == null // eslint-disable-line no-eq-null\n                ? '0x0000000000000000000000000000000000000000000000000000000000000000'\n                : (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(encodeData(type, value, types, version))),\n        ];\n    }\n    // `function` is supported in `@metamask/abi-utils`, but not allowed by\n    // EIP-712, so we throw an error here.\n    if (type === 'function') {\n        throw new Error('Unsupported or invalid type: \"function\"');\n    }\n    if (value === undefined) {\n        throw new Error(`missing value for field ${name} of type ${type}`);\n    }\n    if (type === 'address') {\n        if (typeof value === 'number') {\n            return ['address', (0, utils_1.padStart)((0, utils_2.numberToBytes)(value), 20)];\n        }\n        else if ((0, utils_2.isStrictHexString)(value)) {\n            return ['address', (0, utils_2.add0x)(value)];\n        }\n        else if (typeof value === 'string') {\n            return ['address', reallyStrangeAddressToBytes(value).subarray(0, 20)];\n        }\n    }\n    if (type === 'bool') {\n        return ['bool', Boolean(value)];\n    }\n    if (type === 'bytes') {\n        if (typeof value === 'number') {\n            value = (0, utils_2.numberToBytes)(value);\n        }\n        else if ((0, utils_2.isStrictHexString)(value) || value === '0x') {\n            value = (0, utils_2.hexToBytes)(value);\n        }\n        else if (typeof value === 'string') {\n            value = (0, utils_2.stringToBytes)(value);\n        }\n        return ['bytes32', (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(value))];\n    }\n    if (type.startsWith('bytes') && type !== 'bytes' && !type.includes('[')) {\n        if (typeof value === 'number') {\n            if (value < 0) {\n                return ['bytes32', new Uint8Array(32)];\n            }\n            return ['bytes32', (0, utils_2.bigIntToBytes)(BigInt(value))];\n        }\n        else if ((0, utils_2.isStrictHexString)(value)) {\n            return ['bytes32', (0, utils_2.hexToBytes)(value)];\n        }\n        return ['bytes32', value];\n    }\n    if (type.startsWith('int') && !type.includes('[')) {\n        const bigIntValue = parseNumber(type, value);\n        if (bigIntValue >= BigInt(0)) {\n            return ['uint256', bigIntValue];\n        }\n        return ['int256', bigIntValue];\n    }\n    if (type === 'string') {\n        if (typeof value === 'number') {\n            value = (0, utils_2.numberToBytes)(value);\n        }\n        else {\n            value = (0, utils_2.stringToBytes)(value !== null && value !== void 0 ? value : '');\n        }\n        return ['bytes32', (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(value))];\n    }\n    if (type.endsWith(']')) {\n        if (version === SignTypedDataVersion.V3) {\n            throw new Error('Arrays are unimplemented in encodeData; use V4 extension');\n        }\n        const parsedType = type.slice(0, type.lastIndexOf('['));\n        const typeValuePairs = value.map((item) => encodeField(types, name, parsedType, item, version));\n        return [\n            'bytes32',\n            (0, util_1.arrToBufArr)((0, keccak_1.keccak256)((0, abi_utils_1.encode)(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v)))),\n        ];\n    }\n    return [type, value];\n}\n/**\n * Encodes an object by encoding and concatenating each of its members.\n *\n * @param primaryType - The root type.\n * @param data - The object to encode.\n * @param types - Type definitions for all types included in the message.\n * @param version - The EIP-712 version the encoding should comply with.\n * @returns An encoded representation of an object.\n */\nfunction encodeData(primaryType, data, types, version) {\n    validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);\n    const encodedTypes = ['bytes32'];\n    const encodedValues = [\n        hashType(primaryType, types),\n    ];\n    for (const field of types[primaryType]) {\n        if (version === SignTypedDataVersion.V3 && data[field.name] === undefined) {\n            continue;\n        }\n        const [type, value] = encodeField(types, field.name, field.type, data[field.name], version);\n        encodedTypes.push(type);\n        encodedValues.push(value);\n    }\n    return (0, util_1.arrToBufArr)((0, abi_utils_1.encode)(encodedTypes, encodedValues));\n}\n/**\n * Encodes the type of an object by encoding a comma delimited list of its members.\n *\n * @param primaryType - The root type to encode.\n * @param types - Type definitions for all types included in the message.\n * @returns An encoded representation of the primary type.\n */\nfunction encodeType(primaryType, types) {\n    let result = '';\n    const unsortedDeps = findTypeDependencies(primaryType, types);\n    unsortedDeps.delete(primaryType);\n    const deps = [primaryType, ...Array.from(unsortedDeps).sort()];\n    for (const type of deps) {\n        const children = types[type];\n        if (!children) {\n            throw new Error(`No type definition specified: ${type}`);\n        }\n        result += `${type}(${types[type]\n            .map(({ name, type: t }) => `${t} ${name}`)\n            .join(',')})`;\n    }\n    return result;\n}\n/**\n * Finds all types within a type definition object.\n *\n * @param primaryType - The root type.\n * @param types - Type definitions for all types included in the message.\n * @param results - The current set of accumulated types.\n * @returns The set of all types found in the type definition.\n */\nfunction findTypeDependencies(primaryType, types, results = new Set()) {\n    if (typeof primaryType !== 'string') {\n        throw new Error(`Invalid findTypeDependencies input ${JSON.stringify(primaryType)}`);\n    }\n    const match = primaryType.match(/^\\w*/u);\n    [primaryType] = match;\n    if (results.has(primaryType) || types[primaryType] === undefined) {\n        return results;\n    }\n    results.add(primaryType);\n    for (const field of types[primaryType]) {\n        findTypeDependencies(field.type, types, results);\n    }\n    return results;\n}\n/**\n * Hashes an object.\n *\n * @param primaryType - The root type.\n * @param data - The object to hash.\n * @param types - Type definitions for all types included in the message.\n * @param version - The EIP-712 version the encoding should comply with.\n * @returns The hash of the object.\n */\nfunction hashStruct(primaryType, data, types, version) {\n    validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);\n    const encoded = encodeData(primaryType, data, types, version);\n    const hashed = (0, keccak_1.keccak256)(encoded);\n    const buf = (0, util_1.arrToBufArr)(hashed);\n    return buf;\n}\n/**\n * Hashes the type of an object.\n *\n * @param primaryType - The root type to hash.\n * @param types - Type definitions for all types included in the message.\n * @returns The hash of the object type.\n */\nfunction hashType(primaryType, types) {\n    const encodedHashType = (0, utils_2.stringToBytes)(encodeType(primaryType, types));\n    return (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(encodedHashType));\n}\n/**\n * Removes properties from a message object that are not defined per EIP-712.\n *\n * @param data - The typed message object.\n * @returns The typed message object with only allowed fields.\n */\nfunction sanitizeData(data) {\n    const sanitizedData = {};\n    for (const key in exports.TYPED_MESSAGE_SCHEMA.properties) {\n        if (data[key]) {\n            sanitizedData[key] = data[key];\n        }\n    }\n    if ('types' in sanitizedData) {\n        // TODO: Fix types\n        sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types);\n    }\n    return sanitizedData;\n}\n/**\n * Create a EIP-712 Domain Hash.\n * This hash is used at the top of the EIP-712 encoding.\n *\n * @param typedData - The typed message to hash.\n * @param version - The EIP-712 version the encoding should comply with.\n * @returns The hash of the domain object.\n */\nfunction eip712DomainHash(typedData, version) {\n    validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);\n    const sanitizedData = sanitizeData(typedData);\n    const { domain } = sanitizedData;\n    const domainType = { EIP712Domain: sanitizedData.types.EIP712Domain };\n    return hashStruct('EIP712Domain', domain, domainType, version);\n}\n/**\n * Hash a typed message according to EIP-712. The returned message starts with the EIP-712 prefix,\n * which is \"1901\", followed by the hash of the domain separator, then the data (if any).\n * The result is hashed again and returned.\n *\n * This function does not sign the message. The resulting hash must still be signed to create an\n * EIP-712 signature.\n *\n * @param typedData - The typed message to hash.\n * @param version - The EIP-712 version the encoding should comply with.\n * @returns The hash of the typed message.\n */\nfunction eip712Hash(typedData, version) {\n    validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);\n    const sanitizedData = sanitizeData(typedData);\n    const parts = [(0, utils_2.hexToBytes)('1901')];\n    parts.push(eip712DomainHash(typedData, version));\n    if (sanitizedData.primaryType !== 'EIP712Domain') {\n        parts.push(hashStruct(\n        // TODO: Validate that this is a string, so this type cast can be removed.\n        sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, version));\n    }\n    return (0, util_1.arrToBufArr)((0, keccak_1.keccak256)((0, utils_2.concatBytes)(parts)));\n}\n/**\n * A collection of utility functions used for signing typed data.\n */\nexports.TypedDataUtils = {\n    encodeData,\n    encodeType,\n    findTypeDependencies,\n    hashStruct,\n    hashType,\n    sanitizeData,\n    eip712Hash,\n    eip712DomainHash,\n};\n/**\n * Generate the \"V1\" hash for the provided typed message.\n *\n * The hash will be generated in accordance with an earlier version of the EIP-712\n * specification. This hash is used in `signTypedData_v1`.\n *\n * @param typedData - The typed message.\n * @returns The '0x'-prefixed hex encoded hash representing the type of the provided message.\n */\nfunction typedSignatureHash(typedData) {\n    const hashBuffer = _typedSignatureHash(typedData);\n    return (0, utils_2.bytesToHex)(hashBuffer);\n}\nexports.typedSignatureHash = typedSignatureHash;\n/**\n * Normalize a value, so that `@metamask/abi-utils` can handle it. This\n * matches the behaviour of the `ethereumjs-abi` library.\n *\n * @param type - The type of the value to normalize.\n * @param value - The value to normalize.\n * @returns The normalized value.\n */\nfunction normalizeValue(type, value) {\n    if ((0, parsers_1.isArrayType)(type) && Array.isArray(value)) {\n        const [innerType] = (0, parsers_1.getArrayType)(type);\n        return value.map((item) => normalizeValue(innerType, item));\n    }\n    if (type === 'address') {\n        if ((0, utils_2.isStrictHexString)(value)) {\n            return (0, utils_1.padStart)((0, utils_2.hexToBytes)(value).subarray(0, 20), 20);\n        }\n        if (value instanceof Uint8Array) {\n            return (0, utils_1.padStart)(value.subarray(0, 20), 20);\n        }\n    }\n    if (type === 'bool') {\n        return Boolean(value);\n    }\n    if (type.startsWith('bytes') && type !== 'bytes') {\n        const length = (0, parsers_1.getByteLength)(type);\n        if (typeof value === 'number') {\n            if (value < 0) {\n                // `solidityPack(['bytesN'], [-1])` returns `0x00..00`.\n                return new Uint8Array();\n            }\n            return (0, utils_2.numberToBytes)(value).subarray(0, length);\n        }\n        if ((0, utils_2.isStrictHexString)(value)) {\n            return (0, utils_2.hexToBytes)(value).subarray(0, length);\n        }\n        if (value instanceof Uint8Array) {\n            return value.subarray(0, length);\n        }\n    }\n    if (type.startsWith('uint')) {\n        if (typeof value === 'number') {\n            return Math.abs(value);\n        }\n    }\n    if (type.startsWith('int')) {\n        if (typeof value === 'number') {\n            const length = (0, parsers_1.getLength)(type);\n            return BigInt.asIntN(length, BigInt(value));\n        }\n    }\n    return value;\n}\n/**\n * For some reason `ethereumjs-abi` treats `address` and `address[]` differently\n * so we need to normalize `address[]` differently.\n *\n * @param values - The values to normalize.\n * @returns The normalized values.\n */\nfunction normalizeAddresses(values) {\n    return values.map((value) => {\n        if (typeof value === 'number') {\n            return (0, utils_1.padStart)((0, utils_2.numberToBytes)(value), 32);\n        }\n        if ((0, utils_2.isStrictHexString)(value)) {\n            return (0, utils_1.padStart)((0, utils_2.hexToBytes)(value).subarray(0, 32), 32);\n        }\n        if (value instanceof Uint8Array) {\n            return (0, utils_1.padStart)(value.subarray(0, 32), 32);\n        }\n        return value;\n    });\n}\n/**\n * For some reason `ethereumjs-abi` treats `intN` and `intN[]` differently\n * so we need to normalize `intN[]` differently.\n *\n * @param type - The type of the value to normalize.\n * @param values - The values to normalize.\n * @returns The normalized values.\n */\nfunction normalizeIntegers(type, values) {\n    return values.map((value) => {\n        if (typeof value === 'string' ||\n            typeof value === 'number' ||\n            typeof value === 'bigint') {\n            const bigIntValue = parseNumber(type, value);\n            if (bigIntValue >= BigInt(0)) {\n                return (0, utils_1.padStart)((0, utils_2.bigIntToBytes)(bigIntValue), 32);\n            }\n            const length = (0, parsers_1.getLength)(type);\n            const asIntN = BigInt.asIntN(length, bigIntValue);\n            return (0, utils_2.signedBigIntToBytes)(asIntN, 32);\n        }\n        return value;\n    });\n}\n/**\n * Generate the \"V1\" hash for the provided typed message.\n *\n * The hash will be generated in accordance with an earlier version of the EIP-712\n * specification. This hash is used in `signTypedData_v1`.\n *\n * @param typedData - The typed message.\n * @returns The hash representing the type of the provided message.\n */\nfunction _typedSignatureHash(typedData) {\n    const error = new Error('Expect argument to be non-empty array');\n    if (typeof typedData !== 'object' ||\n        !('length' in typedData) ||\n        !typedData.length) {\n        throw error;\n    }\n    const normalizedData = typedData.map(({ name, type, value }) => {\n        // Handle an edge case with `address[]` types.\n        if (type === 'address[]') {\n            return {\n                name,\n                type: 'bytes32[]',\n                value: normalizeAddresses(value),\n            };\n        }\n        // Handle an edge case with `intN[]` types.\n        if (type.startsWith('int') && (0, parsers_1.isArrayType)(type)) {\n            const [innerType, length] = (0, parsers_1.getArrayType)(type);\n            return {\n                name,\n                type: `bytes32[${length !== null && length !== void 0 ? length : ''}]`,\n                value: normalizeIntegers(innerType, value),\n            };\n        }\n        return {\n            name,\n            type,\n            value: normalizeValue(type, value),\n        };\n    });\n    const data = normalizedData.map((e) => {\n        if (e.type !== 'bytes') {\n            return e.value;\n        }\n        return (0, utils_3.legacyToBuffer)(e.value);\n    });\n    const types = normalizedData.map((e) => {\n        if (e.type === 'function') {\n            throw new Error('Unsupported or invalid type: \"function\"');\n        }\n        return e.type;\n    });\n    const schema = typedData.map((e) => {\n        if (!e.name) {\n            throw error;\n        }\n        return `${e.type} ${e.name}`;\n    });\n    return (0, util_1.arrToBufArr)((0, keccak_1.keccak256)((0, abi_utils_1.encodePacked)(['bytes32', 'bytes32'], [\n        (0, keccak_1.keccak256)((0, abi_utils_1.encodePacked)(['string[]'], [schema], true)),\n        (0, keccak_1.keccak256)((0, abi_utils_1.encodePacked)(types, data, true)),\n    ])));\n}\n/**\n * Sign typed data according to EIP-712. The signing differs based upon the `version`.\n *\n * V1 is based upon [an early version of\n * EIP-712](https://github.com/ethereum/EIPs/pull/712/commits/21abe254fe0452d8583d5b132b1d7be87c0439ca)\n * that lacked some later security improvements, and should generally be neglected in favor of\n * later versions.\n *\n * V3 is based on [EIP-712](https://eips.ethereum.org/EIPS/eip-712), except that arrays and\n * recursive data structures are not supported.\n *\n * V4 is based on [EIP-712](https://eips.ethereum.org/EIPS/eip-712), and includes full support of\n * arrays and recursive data structures.\n *\n * @param options - The signing options.\n * @param options.privateKey - The private key to sign with.\n * @param options.data - The typed data to sign.\n * @param options.version - The signing version to use.\n * @returns The '0x'-prefixed hex encoded signature.\n */\nfunction signTypedData({ privateKey, data, version, }) {\n    validateVersion(version);\n    if ((0, utils_3.isNullish)(data)) {\n        throw new Error('Missing data parameter');\n    }\n    else if ((0, utils_3.isNullish)(privateKey)) {\n        throw new Error('Missing private key parameter');\n    }\n    const messageHash = version === SignTypedDataVersion.V1\n        ? _typedSignatureHash(data)\n        : exports.TypedDataUtils.eip712Hash(data, version);\n    const sig = (0, util_1.ecsign)(messageHash, privateKey);\n    return (0, utils_3.concatSig)((0, util_1.arrToBufArr)((0, utils_2.bigIntToBytes)(sig.v)), sig.r, sig.s);\n}\nexports.signTypedData = signTypedData;\n/**\n * Recover the address of the account that created the given EIP-712\n * signature. The version provided must match the version used to\n * create the signature.\n *\n * @param options - The signature recovery options.\n * @param options.data - The typed data that was signed.\n * @param options.signature - The '0x-prefixed hex encoded message signature.\n * @param options.version - The signing version to use.\n * @returns The '0x'-prefixed hex address of the signer.\n */\nfunction recoverTypedSignature({ data, signature, version, }) {\n    validateVersion(version);\n    if ((0, utils_3.isNullish)(data)) {\n        throw new Error('Missing data parameter');\n    }\n    else if ((0, utils_3.isNullish)(signature)) {\n        throw new Error('Missing signature parameter');\n    }\n    const messageHash = version === SignTypedDataVersion.V1\n        ? _typedSignatureHash(data)\n        : exports.TypedDataUtils.eip712Hash(data, version);\n    const publicKey = (0, utils_3.recoverPublicKey)(messageHash, signature);\n    const sender = (0, util_1.publicToAddress)(publicKey);\n    return (0, utils_2.bytesToHex)(sender);\n}\nexports.recoverTypedSignature = recoverTypedSignature;\n//# sourceMappingURL=sign-typed-data.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvZGlzdC9zaWduLXR5cGVkLWRhdGEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLEdBQUcscUJBQXFCLEdBQUcsMEJBQTBCLEdBQUcsc0JBQXNCLEdBQUcsNEJBQTRCLEdBQUcsNEJBQTRCO0FBQ3pLLGVBQWUsbUJBQU8sQ0FBQyxxSEFBa0I7QUFDekMsb0JBQW9CLG1CQUFPLENBQUMsdUZBQXFCO0FBQ2pELGtCQUFrQixtQkFBTyxDQUFDLDRHQUFrQztBQUM1RCxnQkFBZ0IsbUJBQU8sQ0FBQyx3R0FBZ0M7QUFDeEQsZ0JBQWdCLG1CQUFPLENBQUMsZ0ZBQWlCO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLGtJQUE4QjtBQUN2RCxnQkFBZ0IsbUJBQU8sQ0FBQyw4RUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwREFBMEQsNEJBQTRCLEtBQUs7QUFDNUYsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQsZ0NBQWdDLGdCQUFnQjtBQUNoRCxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVCx1QkFBdUIsZ0JBQWdCO0FBQ3ZDLGtCQUFrQixnQkFBZ0I7QUFDbEMsbUJBQW1CLGdCQUFnQjtBQUNuQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQSw4REFBOEQsUUFBUSwyQkFBMkIsMkJBQTJCO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0lBQWdJLE1BQU07QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0hBQWdILE1BQU0sOEJBQThCLEtBQUs7QUFDeko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsTUFBTSxVQUFVLEtBQUs7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsS0FBSztBQUNsRTtBQUNBLHFCQUFxQixLQUFLLEdBQUc7QUFDN0Isb0JBQW9CLGVBQWUsUUFBUSxHQUFHLEVBQUUsS0FBSztBQUNyRCx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsNEJBQTRCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxrQkFBa0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG1CQUFtQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtREFBbUQ7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUSxFQUFFLE9BQU87QUFDbkMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRCQUE0QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDJCQUEyQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXNpZy11dGlsL2Rpc3Qvc2lnbi10eXBlZC1kYXRhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZWNvdmVyVHlwZWRTaWduYXR1cmUgPSBleHBvcnRzLnNpZ25UeXBlZERhdGEgPSBleHBvcnRzLnR5cGVkU2lnbmF0dXJlSGFzaCA9IGV4cG9ydHMuVHlwZWREYXRhVXRpbHMgPSBleHBvcnRzLlRZUEVEX01FU1NBR0VfU0NIRU1BID0gZXhwb3J0cy5TaWduVHlwZWREYXRhVmVyc2lvbiA9IHZvaWQgMDtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCJAZXRoZXJldW1qcy91dGlsXCIpO1xuY29uc3QgYWJpX3V0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL2FiaS11dGlsc1wiKTtcbmNvbnN0IHBhcnNlcnNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svYWJpLXV0aWxzL2Rpc3QvcGFyc2Vyc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3V0aWxzXCIpO1xuY29uc3QgdXRpbHNfMiA9IHJlcXVpcmUoXCJAbWV0YW1hc2svdXRpbHNcIik7XG5jb25zdCBrZWNjYWtfMSA9IHJlcXVpcmUoXCJldGhlcmV1bS1jcnlwdG9ncmFwaHkva2VjY2FrXCIpO1xuY29uc3QgdXRpbHNfMyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSB2ZXJzaW9uIG9mIGBzaWduVHlwZWREYXRhYCBiZWluZyB1c2VkLlxuICpcbiAqIFYxIGlzIGJhc2VkIHVwb24gW2FuIGVhcmx5IHZlcnNpb24gb2ZcbiAqIEVJUC03MTJdKGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9FSVBzL3B1bGwvNzEyL2NvbW1pdHMvMjFhYmUyNTRmZTA0NTJkODU4M2Q1YjEzMmIxZDdiZTg3YzA0MzljYSlcbiAqIHRoYXQgbGFja2VkIHNvbWUgbGF0ZXIgc2VjdXJpdHkgaW1wcm92ZW1lbnRzLCBhbmQgc2hvdWxkIGdlbmVyYWxseSBiZSBuZWdsZWN0ZWQgaW4gZmF2b3Igb2ZcbiAqIGxhdGVyIHZlcnNpb25zLlxuICpcbiAqIFYzIGlzIGJhc2VkIG9uIEVJUC03MTIsIGV4Y2VwdCB0aGF0IGFycmF5cyBhbmQgcmVjdXJzaXZlIGRhdGEgc3RydWN0dXJlcyBhcmUgbm90IHN1cHBvcnRlZC5cbiAqXG4gKiBWNCBpcyBiYXNlZCBvbiBFSVAtNzEyLCBhbmQgaW5jbHVkZXMgZnVsbCBzdXBwb3J0IG9mIGFycmF5cyBhbmQgcmVjdXJzaXZlIGRhdGEgc3RydWN0dXJlcy5cbiAqL1xudmFyIFNpZ25UeXBlZERhdGFWZXJzaW9uO1xuKGZ1bmN0aW9uIChTaWduVHlwZWREYXRhVmVyc2lvbikge1xuICAgIFNpZ25UeXBlZERhdGFWZXJzaW9uW1wiVjFcIl0gPSBcIlYxXCI7XG4gICAgU2lnblR5cGVkRGF0YVZlcnNpb25bXCJWM1wiXSA9IFwiVjNcIjtcbiAgICBTaWduVHlwZWREYXRhVmVyc2lvbltcIlY0XCJdID0gXCJWNFwiO1xufSkoU2lnblR5cGVkRGF0YVZlcnNpb24gPSBleHBvcnRzLlNpZ25UeXBlZERhdGFWZXJzaW9uIHx8IChleHBvcnRzLlNpZ25UeXBlZERhdGFWZXJzaW9uID0ge30pKTtcbmV4cG9ydHMuVFlQRURfTUVTU0FHRV9TQ0hFTUEgPSB7XG4gICAgdHlwZTogJ29iamVjdCcsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICB0eXBlczoge1xuICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFsnbmFtZScsICd0eXBlJ10sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHByaW1hcnlUeXBlOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgIGRvbWFpbjogeyB0eXBlOiAnb2JqZWN0JyB9LFxuICAgICAgICBtZXNzYWdlOiB7IHR5cGU6ICdvYmplY3QnIH0sXG4gICAgfSxcbiAgICByZXF1aXJlZDogWyd0eXBlcycsICdwcmltYXJ5VHlwZScsICdkb21haW4nLCAnbWVzc2FnZSddLFxufTtcbi8qKlxuICogVmFsaWRhdGUgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB2ZXJzaW9uIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdmVyc2lvbiAtIFRoZSB2ZXJzaW9uIHZhbHVlIHRvIHZhbGlkYXRlLlxuICogQHBhcmFtIGFsbG93ZWRWZXJzaW9ucyAtIEEgbGlzdCBvZiBhbGxvd2VkIHZlcnNpb25zLiBJZiBvbWl0dGVkLCBhbGwgdmVyc2lvbnMgYXJlIGFzc3VtZWQgdG8gYmVcbiAqIGFsbG93ZWQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlVmVyc2lvbih2ZXJzaW9uLCBhbGxvd2VkVmVyc2lvbnMpIHtcbiAgICBpZiAoIU9iamVjdC5rZXlzKFNpZ25UeXBlZERhdGFWZXJzaW9uKS5pbmNsdWRlcyh2ZXJzaW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmVyc2lvbjogJyR7dmVyc2lvbn0nYCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFsbG93ZWRWZXJzaW9ucyAmJiAhYWxsb3dlZFZlcnNpb25zLmluY2x1ZGVzKHZlcnNpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2lnblR5cGVkRGF0YVZlcnNpb24gbm90IGFsbG93ZWQ6ICcke3ZlcnNpb259Jy4gQWxsb3dlZCB2ZXJzaW9ucyBhcmU6ICR7YWxsb3dlZFZlcnNpb25zLmpvaW4oJywgJyl9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZywgbnVtYmVyLCBvciBiaWdpbnQgdmFsdWUgaW50byBhIGBVaW50OEFycmF5YC5cbiAqXG4gKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBwYXJzZS5cbiAqIEByZXR1cm5zIFRoZSBwYXJzZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlTnVtYmVyKHR5cGUsIHZhbHVlKSB7XG4gICAgKDAsIHV0aWxzXzIuYXNzZXJ0KSh2YWx1ZSAhPT0gbnVsbCwgYFVuYWJsZSB0byBlbmNvZGUgdmFsdWU6IEludmFsaWQgbnVtYmVyLiBFeHBlY3RlZCBhIHZhbGlkIG51bWJlciB2YWx1ZSwgYnV0IHJlY2VpdmVkIFwiJHt2YWx1ZX1cIi5gKTtcbiAgICBjb25zdCBiaWdJbnRWYWx1ZSA9IEJpZ0ludCh2YWx1ZSk7XG4gICAgY29uc3QgbGVuZ3RoID0gKDAsIHBhcnNlcnNfMS5nZXRMZW5ndGgpKHR5cGUpO1xuICAgIGNvbnN0IG1heFZhbHVlID0gQmlnSW50KDIpICoqIEJpZ0ludChsZW5ndGgpIC0gQmlnSW50KDEpO1xuICAgIC8vIE5vdGUgdGhhdCB0aGlzIGlzIG5vdCBhY2N1cmF0ZSwgc2luY2UgdGhlIGFjdHVhbCBtYXhpbXVtIHZhbHVlIGZvciB1bnNpZ25lZFxuICAgIC8vIGludGVnZXJzIGlzIGAyIF4gKGxlbmd0aCAtIDEpIC0gMWAsIGJ1dCB0aGlzIGlzIHJlcXVpcmVkIGZvciBiYWNrd2FyZHNcbiAgICAvLyBjb21wYXRpYmlsaXR5IHdpdGggdGhlIG9sZCBpbXBsZW1lbnRhdGlvbi5cbiAgICAoMCwgdXRpbHNfMi5hc3NlcnQpKGJpZ0ludFZhbHVlID49IC1tYXhWYWx1ZSAmJiBiaWdJbnRWYWx1ZSA8PSBtYXhWYWx1ZSwgYFVuYWJsZSB0byBlbmNvZGUgdmFsdWU6IE51bWJlciBcIiR7dmFsdWV9XCIgaXMgb3V0IG9mIHJhbmdlIGZvciB0eXBlIFwiJHt0eXBlfVwiLmApO1xuICAgIHJldHVybiBiaWdJbnRWYWx1ZTtcbn1cbi8qKlxuICogUGFyc2UgYW4gYWRkcmVzcyBzdHJpbmcgdG8gYSBgVWludDhBcnJheWAuIFRoZSBiZWhhdmlvdXIgb2YgdGhpcyBpcyBxdWl0ZVxuICogc3RyYW5nZSwgaW4gdGhhdCBpdCBkb2VzIG5vdCBwYXJzZSB0aGUgYWRkcmVzcyBhcyBoZXhhZGVjaW1hbCBzdHJpbmcsIG5vciBhc1xuICogVVRGLTguIEl0IGRvZXMgc29tZSB3ZWlyZCBzdHVmZiB3aXRoIHRoZSBzdHJpbmcgYW5kIGNoYXIgY29kZXMsIGFuZCB0aGVuXG4gKiByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBgVWludDhBcnJheWAuXG4gKlxuICogVGhpcyBpcyBiYXNlZCBvbiB0aGUgb2xkIGBldGhlcmV1bWpzLWFiaWAgaW1wbGVtZW50YXRpb24sIHdoaWNoIGVzc2VudGlhbGx5XG4gKiBjYWxscyBgbmV3IEJOKGFkZHJlc3MsIDEwKWAgb24gdGhlIGFkZHJlc3Mgc3RyaW5nLCB0aGUgZXF1aXZhbGVudCBvZiBjYWxsaW5nXG4gKiBgcGFyc2VJbnQoYWRkcmVzcywgMTApYCBpbiBKYXZhU2NyaXB0LiBUaGlzIGlzIG5vdCBhIHZhbGlkIHdheSB0byBwYXJzZSBhblxuICogYWRkcmVzcyBhbmQgd291bGQgcmVzdWx0IGluIGBOYU5gIGluIHBsYWluIEphdmFTY3JpcHQsIGJ1dCBpdCBpcyB0aGVcbiAqIGJlaGF2aW91ciBvZiB0aGUgb2xkIGltcGxlbWVudGF0aW9uLCBhbmQgc28gd2UgbXVzdCBwcmVzZXJ2ZSBpdCBmb3IgYmFja3dhcmRzXG4gKiBjb21wYXRpYmlsaXR5LlxuICpcbiAqIEBwYXJhbSBhZGRyZXNzIC0gVGhlIGFkZHJlc3MgdG8gcGFyc2UuXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIGFkZHJlc3MuXG4gKi9cbmZ1bmN0aW9uIHJlYWxseVN0cmFuZ2VBZGRyZXNzVG9CeXRlcyhhZGRyZXNzKSB7XG4gICAgbGV0IGFkZHJlc3NWYWx1ZSA9IEJpZ0ludCgwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFkZHJlc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hhcmFjdGVyID0gQmlnSW50KGFkZHJlc3MuY2hhckNvZGVBdChpKSAtIDQ4KTtcbiAgICAgICAgYWRkcmVzc1ZhbHVlICo9IEJpZ0ludCgxMCk7XG4gICAgICAgIC8vICdhJ1xuICAgICAgICBpZiAoY2hhcmFjdGVyID49IDQ5KSB7XG4gICAgICAgICAgICBhZGRyZXNzVmFsdWUgKz0gY2hhcmFjdGVyIC0gQmlnSW50KDQ5KSArIEJpZ0ludCgweGEpO1xuICAgICAgICAgICAgLy8gJ0EnXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyID49IDE3KSB7XG4gICAgICAgICAgICBhZGRyZXNzVmFsdWUgKz0gY2hhcmFjdGVyIC0gQmlnSW50KDE3KSArIEJpZ0ludCgweGEpO1xuICAgICAgICAgICAgLy8gJzAnIC0gJzknXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhZGRyZXNzVmFsdWUgKz0gY2hhcmFjdGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoMCwgdXRpbHNfMS5wYWRTdGFydCkoKDAsIHV0aWxzXzIuYmlnSW50VG9CeXRlcykoYWRkcmVzc1ZhbHVlKSwgMjApO1xufVxuLyoqXG4gKiBFbmNvZGUgYSBzaW5nbGUgZmllbGQuXG4gKlxuICogQHBhcmFtIHR5cGVzIC0gQWxsIHR5cGUgZGVmaW5pdGlvbnMuXG4gKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBlbmNvZGUuXG4gKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBmaWVsZCBiZWluZyBlbmNvZGVkLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSB2ZXJzaW9uIC0gVGhlIEVJUC03MTIgdmVyc2lvbiB0aGUgZW5jb2Rpbmcgc2hvdWxkIGNvbXBseSB3aXRoLlxuICogQHJldHVybnMgRW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZmllbGQuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZUZpZWxkKHR5cGVzLCBuYW1lLCB0eXBlLCBcbi8vIFRPRE86IGNvbnN0cmFpbiB0eXBlIG9uIGB2YWx1ZWBcbnZhbHVlLCB2ZXJzaW9uKSB7XG4gICAgdmFsaWRhdGVWZXJzaW9uKHZlcnNpb24sIFtTaWduVHlwZWREYXRhVmVyc2lvbi5WMywgU2lnblR5cGVkRGF0YVZlcnNpb24uVjRdKTtcbiAgICBpZiAodHlwZXNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ2J5dGVzMzInLFxuICAgICAgICAgICAgLy8gVE9ETzogcmV0dXJuIEJ1ZmZlciwgcmVtb3ZlIHN0cmluZyBmcm9tIHJldHVybiB0eXBlXG4gICAgICAgICAgICB2ZXJzaW9uID09PSBTaWduVHlwZWREYXRhVmVyc2lvbi5WNCAmJiB2YWx1ZSA9PSBudWxsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXEtbnVsbFxuICAgICAgICAgICAgICAgID8gJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcbiAgICAgICAgICAgICAgICA6ICgwLCB1dGlsXzEuYXJyVG9CdWZBcnIpKCgwLCBrZWNjYWtfMS5rZWNjYWsyNTYpKGVuY29kZURhdGEodHlwZSwgdmFsdWUsIHR5cGVzLCB2ZXJzaW9uKSkpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICAvLyBgZnVuY3Rpb25gIGlzIHN1cHBvcnRlZCBpbiBgQG1ldGFtYXNrL2FiaS11dGlsc2AsIGJ1dCBub3QgYWxsb3dlZCBieVxuICAgIC8vIEVJUC03MTIsIHNvIHdlIHRocm93IGFuIGVycm9yIGhlcmUuXG4gICAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBvciBpbnZhbGlkIHR5cGU6IFwiZnVuY3Rpb25cIicpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1pc3NpbmcgdmFsdWUgZm9yIGZpZWxkICR7bmFtZX0gb2YgdHlwZSAke3R5cGV9YCk7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnYWRkcmVzcycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ2FkZHJlc3MnLCAoMCwgdXRpbHNfMS5wYWRTdGFydCkoKDAsIHV0aWxzXzIubnVtYmVyVG9CeXRlcykodmFsdWUpLCAyMCldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgwLCB1dGlsc18yLmlzU3RyaWN0SGV4U3RyaW5nKSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ2FkZHJlc3MnLCAoMCwgdXRpbHNfMi5hZGQweCkodmFsdWUpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gWydhZGRyZXNzJywgcmVhbGx5U3RyYW5nZUFkZHJlc3NUb0J5dGVzKHZhbHVlKS5zdWJhcnJheSgwLCAyMCldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgcmV0dXJuIFsnYm9vbCcsIEJvb2xlYW4odmFsdWUpXTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdieXRlcycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gKDAsIHV0aWxzXzIubnVtYmVyVG9CeXRlcykodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgwLCB1dGlsc18yLmlzU3RyaWN0SGV4U3RyaW5nKSh2YWx1ZSkgfHwgdmFsdWUgPT09ICcweCcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gKDAsIHV0aWxzXzIuaGV4VG9CeXRlcykodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gKDAsIHV0aWxzXzIuc3RyaW5nVG9CeXRlcykodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbJ2J5dGVzMzInLCAoMCwgdXRpbF8xLmFyclRvQnVmQXJyKSgoMCwga2VjY2FrXzEua2VjY2FrMjU2KSh2YWx1ZSkpXTtcbiAgICB9XG4gICAgaWYgKHR5cGUuc3RhcnRzV2l0aCgnYnl0ZXMnKSAmJiB0eXBlICE9PSAnYnl0ZXMnICYmICF0eXBlLmluY2x1ZGVzKCdbJykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydieXRlczMyJywgbmV3IFVpbnQ4QXJyYXkoMzIpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbJ2J5dGVzMzInLCAoMCwgdXRpbHNfMi5iaWdJbnRUb0J5dGVzKShCaWdJbnQodmFsdWUpKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKDAsIHV0aWxzXzIuaXNTdHJpY3RIZXhTdHJpbmcpKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFsnYnl0ZXMzMicsICgwLCB1dGlsc18yLmhleFRvQnl0ZXMpKHZhbHVlKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsnYnl0ZXMzMicsIHZhbHVlXTtcbiAgICB9XG4gICAgaWYgKHR5cGUuc3RhcnRzV2l0aCgnaW50JykgJiYgIXR5cGUuaW5jbHVkZXMoJ1snKSkge1xuICAgICAgICBjb25zdCBiaWdJbnRWYWx1ZSA9IHBhcnNlTnVtYmVyKHR5cGUsIHZhbHVlKTtcbiAgICAgICAgaWYgKGJpZ0ludFZhbHVlID49IEJpZ0ludCgwKSkge1xuICAgICAgICAgICAgcmV0dXJuIFsndWludDI1NicsIGJpZ0ludFZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWydpbnQyNTYnLCBiaWdJbnRWYWx1ZV07XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdmFsdWUgPSAoMCwgdXRpbHNfMi5udW1iZXJUb0J5dGVzKSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICgwLCB1dGlsc18yLnN0cmluZ1RvQnl0ZXMpKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDAgPyB2YWx1ZSA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWydieXRlczMyJywgKDAsIHV0aWxfMS5hcnJUb0J1ZkFycikoKDAsIGtlY2Nha18xLmtlY2NhazI1NikodmFsdWUpKV07XG4gICAgfVxuICAgIGlmICh0eXBlLmVuZHNXaXRoKCddJykpIHtcbiAgICAgICAgaWYgKHZlcnNpb24gPT09IFNpZ25UeXBlZERhdGFWZXJzaW9uLlYzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FycmF5cyBhcmUgdW5pbXBsZW1lbnRlZCBpbiBlbmNvZGVEYXRhOyB1c2UgVjQgZXh0ZW5zaW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHR5cGUuc2xpY2UoMCwgdHlwZS5sYXN0SW5kZXhPZignWycpKTtcbiAgICAgICAgY29uc3QgdHlwZVZhbHVlUGFpcnMgPSB2YWx1ZS5tYXAoKGl0ZW0pID0+IGVuY29kZUZpZWxkKHR5cGVzLCBuYW1lLCBwYXJzZWRUeXBlLCBpdGVtLCB2ZXJzaW9uKSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnYnl0ZXMzMicsXG4gICAgICAgICAgICAoMCwgdXRpbF8xLmFyclRvQnVmQXJyKSgoMCwga2VjY2FrXzEua2VjY2FrMjU2KSgoMCwgYWJpX3V0aWxzXzEuZW5jb2RlKSh0eXBlVmFsdWVQYWlycy5tYXAoKFt0XSkgPT4gdCksIHR5cGVWYWx1ZVBhaXJzLm1hcCgoWywgdl0pID0+IHYpKSkpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gW3R5cGUsIHZhbHVlXTtcbn1cbi8qKlxuICogRW5jb2RlcyBhbiBvYmplY3QgYnkgZW5jb2RpbmcgYW5kIGNvbmNhdGVuYXRpbmcgZWFjaCBvZiBpdHMgbWVtYmVycy5cbiAqXG4gKiBAcGFyYW0gcHJpbWFyeVR5cGUgLSBUaGUgcm9vdCB0eXBlLlxuICogQHBhcmFtIGRhdGEgLSBUaGUgb2JqZWN0IHRvIGVuY29kZS5cbiAqIEBwYXJhbSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnMgZm9yIGFsbCB0eXBlcyBpbmNsdWRlZCBpbiB0aGUgbWVzc2FnZS5cbiAqIEBwYXJhbSB2ZXJzaW9uIC0gVGhlIEVJUC03MTIgdmVyc2lvbiB0aGUgZW5jb2Rpbmcgc2hvdWxkIGNvbXBseSB3aXRoLlxuICogQHJldHVybnMgQW4gZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiBhbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZURhdGEocHJpbWFyeVR5cGUsIGRhdGEsIHR5cGVzLCB2ZXJzaW9uKSB7XG4gICAgdmFsaWRhdGVWZXJzaW9uKHZlcnNpb24sIFtTaWduVHlwZWREYXRhVmVyc2lvbi5WMywgU2lnblR5cGVkRGF0YVZlcnNpb24uVjRdKTtcbiAgICBjb25zdCBlbmNvZGVkVHlwZXMgPSBbJ2J5dGVzMzInXTtcbiAgICBjb25zdCBlbmNvZGVkVmFsdWVzID0gW1xuICAgICAgICBoYXNoVHlwZShwcmltYXJ5VHlwZSwgdHlwZXMpLFxuICAgIF07XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlc1twcmltYXJ5VHlwZV0pIHtcbiAgICAgICAgaWYgKHZlcnNpb24gPT09IFNpZ25UeXBlZERhdGFWZXJzaW9uLlYzICYmIGRhdGFbZmllbGQubmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3R5cGUsIHZhbHVlXSA9IGVuY29kZUZpZWxkKHR5cGVzLCBmaWVsZC5uYW1lLCBmaWVsZC50eXBlLCBkYXRhW2ZpZWxkLm5hbWVdLCB2ZXJzaW9uKTtcbiAgICAgICAgZW5jb2RlZFR5cGVzLnB1c2godHlwZSk7XG4gICAgICAgIGVuY29kZWRWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgdXRpbF8xLmFyclRvQnVmQXJyKSgoMCwgYWJpX3V0aWxzXzEuZW5jb2RlKShlbmNvZGVkVHlwZXMsIGVuY29kZWRWYWx1ZXMpKTtcbn1cbi8qKlxuICogRW5jb2RlcyB0aGUgdHlwZSBvZiBhbiBvYmplY3QgYnkgZW5jb2RpbmcgYSBjb21tYSBkZWxpbWl0ZWQgbGlzdCBvZiBpdHMgbWVtYmVycy5cbiAqXG4gKiBAcGFyYW0gcHJpbWFyeVR5cGUgLSBUaGUgcm9vdCB0eXBlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnMgZm9yIGFsbCB0eXBlcyBpbmNsdWRlZCBpbiB0aGUgbWVzc2FnZS5cbiAqIEByZXR1cm5zIEFuIGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHByaW1hcnkgdHlwZS5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlVHlwZShwcmltYXJ5VHlwZSwgdHlwZXMpIHtcbiAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgY29uc3QgdW5zb3J0ZWREZXBzID0gZmluZFR5cGVEZXBlbmRlbmNpZXMocHJpbWFyeVR5cGUsIHR5cGVzKTtcbiAgICB1bnNvcnRlZERlcHMuZGVsZXRlKHByaW1hcnlUeXBlKTtcbiAgICBjb25zdCBkZXBzID0gW3ByaW1hcnlUeXBlLCAuLi5BcnJheS5mcm9tKHVuc29ydGVkRGVwcykuc29ydCgpXTtcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgZGVwcykge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHR5cGVzW3R5cGVdO1xuICAgICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHR5cGUgZGVmaW5pdGlvbiBzcGVjaWZpZWQ6ICR7dHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gYCR7dHlwZX0oJHt0eXBlc1t0eXBlXVxuICAgICAgICAgICAgLm1hcCgoeyBuYW1lLCB0eXBlOiB0IH0pID0+IGAke3R9ICR7bmFtZX1gKVxuICAgICAgICAgICAgLmpvaW4oJywnKX0pYDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogRmluZHMgYWxsIHR5cGVzIHdpdGhpbiBhIHR5cGUgZGVmaW5pdGlvbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHByaW1hcnlUeXBlIC0gVGhlIHJvb3QgdHlwZS5cbiAqIEBwYXJhbSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnMgZm9yIGFsbCB0eXBlcyBpbmNsdWRlZCBpbiB0aGUgbWVzc2FnZS5cbiAqIEBwYXJhbSByZXN1bHRzIC0gVGhlIGN1cnJlbnQgc2V0IG9mIGFjY3VtdWxhdGVkIHR5cGVzLlxuICogQHJldHVybnMgVGhlIHNldCBvZiBhbGwgdHlwZXMgZm91bmQgaW4gdGhlIHR5cGUgZGVmaW5pdGlvbi5cbiAqL1xuZnVuY3Rpb24gZmluZFR5cGVEZXBlbmRlbmNpZXMocHJpbWFyeVR5cGUsIHR5cGVzLCByZXN1bHRzID0gbmV3IFNldCgpKSB7XG4gICAgaWYgKHR5cGVvZiBwcmltYXJ5VHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZpbmRUeXBlRGVwZW5kZW5jaWVzIGlucHV0ICR7SlNPTi5zdHJpbmdpZnkocHJpbWFyeVR5cGUpfWApO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaCA9IHByaW1hcnlUeXBlLm1hdGNoKC9eXFx3Ki91KTtcbiAgICBbcHJpbWFyeVR5cGVdID0gbWF0Y2g7XG4gICAgaWYgKHJlc3VsdHMuaGFzKHByaW1hcnlUeXBlKSB8fCB0eXBlc1twcmltYXJ5VHlwZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgcmVzdWx0cy5hZGQocHJpbWFyeVR5cGUpO1xuICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZXNbcHJpbWFyeVR5cGVdKSB7XG4gICAgICAgIGZpbmRUeXBlRGVwZW5kZW5jaWVzKGZpZWxkLnR5cGUsIHR5cGVzLCByZXN1bHRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG4vKipcbiAqIEhhc2hlcyBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHByaW1hcnlUeXBlIC0gVGhlIHJvb3QgdHlwZS5cbiAqIEBwYXJhbSBkYXRhIC0gVGhlIG9iamVjdCB0byBoYXNoLlxuICogQHBhcmFtIHR5cGVzIC0gVHlwZSBkZWZpbml0aW9ucyBmb3IgYWxsIHR5cGVzIGluY2x1ZGVkIGluIHRoZSBtZXNzYWdlLlxuICogQHBhcmFtIHZlcnNpb24gLSBUaGUgRUlQLTcxMiB2ZXJzaW9uIHRoZSBlbmNvZGluZyBzaG91bGQgY29tcGx5IHdpdGguXG4gKiBAcmV0dXJucyBUaGUgaGFzaCBvZiB0aGUgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBoYXNoU3RydWN0KHByaW1hcnlUeXBlLCBkYXRhLCB0eXBlcywgdmVyc2lvbikge1xuICAgIHZhbGlkYXRlVmVyc2lvbih2ZXJzaW9uLCBbU2lnblR5cGVkRGF0YVZlcnNpb24uVjMsIFNpZ25UeXBlZERhdGFWZXJzaW9uLlY0XSk7XG4gICAgY29uc3QgZW5jb2RlZCA9IGVuY29kZURhdGEocHJpbWFyeVR5cGUsIGRhdGEsIHR5cGVzLCB2ZXJzaW9uKTtcbiAgICBjb25zdCBoYXNoZWQgPSAoMCwga2VjY2FrXzEua2VjY2FrMjU2KShlbmNvZGVkKTtcbiAgICBjb25zdCBidWYgPSAoMCwgdXRpbF8xLmFyclRvQnVmQXJyKShoYXNoZWQpO1xuICAgIHJldHVybiBidWY7XG59XG4vKipcbiAqIEhhc2hlcyB0aGUgdHlwZSBvZiBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHByaW1hcnlUeXBlIC0gVGhlIHJvb3QgdHlwZSB0byBoYXNoLlxuICogQHBhcmFtIHR5cGVzIC0gVHlwZSBkZWZpbml0aW9ucyBmb3IgYWxsIHR5cGVzIGluY2x1ZGVkIGluIHRoZSBtZXNzYWdlLlxuICogQHJldHVybnMgVGhlIGhhc2ggb2YgdGhlIG9iamVjdCB0eXBlLlxuICovXG5mdW5jdGlvbiBoYXNoVHlwZShwcmltYXJ5VHlwZSwgdHlwZXMpIHtcbiAgICBjb25zdCBlbmNvZGVkSGFzaFR5cGUgPSAoMCwgdXRpbHNfMi5zdHJpbmdUb0J5dGVzKShlbmNvZGVUeXBlKHByaW1hcnlUeXBlLCB0eXBlcykpO1xuICAgIHJldHVybiAoMCwgdXRpbF8xLmFyclRvQnVmQXJyKSgoMCwga2VjY2FrXzEua2VjY2FrMjU2KShlbmNvZGVkSGFzaFR5cGUpKTtcbn1cbi8qKlxuICogUmVtb3ZlcyBwcm9wZXJ0aWVzIGZyb20gYSBtZXNzYWdlIG9iamVjdCB0aGF0IGFyZSBub3QgZGVmaW5lZCBwZXIgRUlQLTcxMi5cbiAqXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSB0eXBlZCBtZXNzYWdlIG9iamVjdC5cbiAqIEByZXR1cm5zIFRoZSB0eXBlZCBtZXNzYWdlIG9iamVjdCB3aXRoIG9ubHkgYWxsb3dlZCBmaWVsZHMuXG4gKi9cbmZ1bmN0aW9uIHNhbml0aXplRGF0YShkYXRhKSB7XG4gICAgY29uc3Qgc2FuaXRpemVkRGF0YSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGV4cG9ydHMuVFlQRURfTUVTU0FHRV9TQ0hFTUEucHJvcGVydGllcykge1xuICAgICAgICBpZiAoZGF0YVtrZXldKSB7XG4gICAgICAgICAgICBzYW5pdGl6ZWREYXRhW2tleV0gPSBkYXRhW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCd0eXBlcycgaW4gc2FuaXRpemVkRGF0YSkge1xuICAgICAgICAvLyBUT0RPOiBGaXggdHlwZXNcbiAgICAgICAgc2FuaXRpemVkRGF0YS50eXBlcyA9IE9iamVjdC5hc3NpZ24oeyBFSVA3MTJEb21haW46IFtdIH0sIHNhbml0aXplZERhdGEudHlwZXMpO1xuICAgIH1cbiAgICByZXR1cm4gc2FuaXRpemVkRGF0YTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgRUlQLTcxMiBEb21haW4gSGFzaC5cbiAqIFRoaXMgaGFzaCBpcyB1c2VkIGF0IHRoZSB0b3Agb2YgdGhlIEVJUC03MTIgZW5jb2RpbmcuXG4gKlxuICogQHBhcmFtIHR5cGVkRGF0YSAtIFRoZSB0eXBlZCBtZXNzYWdlIHRvIGhhc2guXG4gKiBAcGFyYW0gdmVyc2lvbiAtIFRoZSBFSVAtNzEyIHZlcnNpb24gdGhlIGVuY29kaW5nIHNob3VsZCBjb21wbHkgd2l0aC5cbiAqIEByZXR1cm5zIFRoZSBoYXNoIG9mIHRoZSBkb21haW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBlaXA3MTJEb21haW5IYXNoKHR5cGVkRGF0YSwgdmVyc2lvbikge1xuICAgIHZhbGlkYXRlVmVyc2lvbih2ZXJzaW9uLCBbU2lnblR5cGVkRGF0YVZlcnNpb24uVjMsIFNpZ25UeXBlZERhdGFWZXJzaW9uLlY0XSk7XG4gICAgY29uc3Qgc2FuaXRpemVkRGF0YSA9IHNhbml0aXplRGF0YSh0eXBlZERhdGEpO1xuICAgIGNvbnN0IHsgZG9tYWluIH0gPSBzYW5pdGl6ZWREYXRhO1xuICAgIGNvbnN0IGRvbWFpblR5cGUgPSB7IEVJUDcxMkRvbWFpbjogc2FuaXRpemVkRGF0YS50eXBlcy5FSVA3MTJEb21haW4gfTtcbiAgICByZXR1cm4gaGFzaFN0cnVjdCgnRUlQNzEyRG9tYWluJywgZG9tYWluLCBkb21haW5UeXBlLCB2ZXJzaW9uKTtcbn1cbi8qKlxuICogSGFzaCBhIHR5cGVkIG1lc3NhZ2UgYWNjb3JkaW5nIHRvIEVJUC03MTIuIFRoZSByZXR1cm5lZCBtZXNzYWdlIHN0YXJ0cyB3aXRoIHRoZSBFSVAtNzEyIHByZWZpeCxcbiAqIHdoaWNoIGlzIFwiMTkwMVwiLCBmb2xsb3dlZCBieSB0aGUgaGFzaCBvZiB0aGUgZG9tYWluIHNlcGFyYXRvciwgdGhlbiB0aGUgZGF0YSAoaWYgYW55KS5cbiAqIFRoZSByZXN1bHQgaXMgaGFzaGVkIGFnYWluIGFuZCByZXR1cm5lZC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHNpZ24gdGhlIG1lc3NhZ2UuIFRoZSByZXN1bHRpbmcgaGFzaCBtdXN0IHN0aWxsIGJlIHNpZ25lZCB0byBjcmVhdGUgYW5cbiAqIEVJUC03MTIgc2lnbmF0dXJlLlxuICpcbiAqIEBwYXJhbSB0eXBlZERhdGEgLSBUaGUgdHlwZWQgbWVzc2FnZSB0byBoYXNoLlxuICogQHBhcmFtIHZlcnNpb24gLSBUaGUgRUlQLTcxMiB2ZXJzaW9uIHRoZSBlbmNvZGluZyBzaG91bGQgY29tcGx5IHdpdGguXG4gKiBAcmV0dXJucyBUaGUgaGFzaCBvZiB0aGUgdHlwZWQgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gZWlwNzEySGFzaCh0eXBlZERhdGEsIHZlcnNpb24pIHtcbiAgICB2YWxpZGF0ZVZlcnNpb24odmVyc2lvbiwgW1NpZ25UeXBlZERhdGFWZXJzaW9uLlYzLCBTaWduVHlwZWREYXRhVmVyc2lvbi5WNF0pO1xuICAgIGNvbnN0IHNhbml0aXplZERhdGEgPSBzYW5pdGl6ZURhdGEodHlwZWREYXRhKTtcbiAgICBjb25zdCBwYXJ0cyA9IFsoMCwgdXRpbHNfMi5oZXhUb0J5dGVzKSgnMTkwMScpXTtcbiAgICBwYXJ0cy5wdXNoKGVpcDcxMkRvbWFpbkhhc2godHlwZWREYXRhLCB2ZXJzaW9uKSk7XG4gICAgaWYgKHNhbml0aXplZERhdGEucHJpbWFyeVR5cGUgIT09ICdFSVA3MTJEb21haW4nKSB7XG4gICAgICAgIHBhcnRzLnB1c2goaGFzaFN0cnVjdChcbiAgICAgICAgLy8gVE9ETzogVmFsaWRhdGUgdGhhdCB0aGlzIGlzIGEgc3RyaW5nLCBzbyB0aGlzIHR5cGUgY2FzdCBjYW4gYmUgcmVtb3ZlZC5cbiAgICAgICAgc2FuaXRpemVkRGF0YS5wcmltYXJ5VHlwZSwgc2FuaXRpemVkRGF0YS5tZXNzYWdlLCBzYW5pdGl6ZWREYXRhLnR5cGVzLCB2ZXJzaW9uKSk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgdXRpbF8xLmFyclRvQnVmQXJyKSgoMCwga2VjY2FrXzEua2VjY2FrMjU2KSgoMCwgdXRpbHNfMi5jb25jYXRCeXRlcykocGFydHMpKSk7XG59XG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiB1dGlsaXR5IGZ1bmN0aW9ucyB1c2VkIGZvciBzaWduaW5nIHR5cGVkIGRhdGEuXG4gKi9cbmV4cG9ydHMuVHlwZWREYXRhVXRpbHMgPSB7XG4gICAgZW5jb2RlRGF0YSxcbiAgICBlbmNvZGVUeXBlLFxuICAgIGZpbmRUeXBlRGVwZW5kZW5jaWVzLFxuICAgIGhhc2hTdHJ1Y3QsXG4gICAgaGFzaFR5cGUsXG4gICAgc2FuaXRpemVEYXRhLFxuICAgIGVpcDcxMkhhc2gsXG4gICAgZWlwNzEyRG9tYWluSGFzaCxcbn07XG4vKipcbiAqIEdlbmVyYXRlIHRoZSBcIlYxXCIgaGFzaCBmb3IgdGhlIHByb3ZpZGVkIHR5cGVkIG1lc3NhZ2UuXG4gKlxuICogVGhlIGhhc2ggd2lsbCBiZSBnZW5lcmF0ZWQgaW4gYWNjb3JkYW5jZSB3aXRoIGFuIGVhcmxpZXIgdmVyc2lvbiBvZiB0aGUgRUlQLTcxMlxuICogc3BlY2lmaWNhdGlvbi4gVGhpcyBoYXNoIGlzIHVzZWQgaW4gYHNpZ25UeXBlZERhdGFfdjFgLlxuICpcbiAqIEBwYXJhbSB0eXBlZERhdGEgLSBUaGUgdHlwZWQgbWVzc2FnZS5cbiAqIEByZXR1cm5zIFRoZSAnMHgnLXByZWZpeGVkIGhleCBlbmNvZGVkIGhhc2ggcmVwcmVzZW50aW5nIHRoZSB0eXBlIG9mIHRoZSBwcm92aWRlZCBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiB0eXBlZFNpZ25hdHVyZUhhc2godHlwZWREYXRhKSB7XG4gICAgY29uc3QgaGFzaEJ1ZmZlciA9IF90eXBlZFNpZ25hdHVyZUhhc2godHlwZWREYXRhKTtcbiAgICByZXR1cm4gKDAsIHV0aWxzXzIuYnl0ZXNUb0hleCkoaGFzaEJ1ZmZlcik7XG59XG5leHBvcnRzLnR5cGVkU2lnbmF0dXJlSGFzaCA9IHR5cGVkU2lnbmF0dXJlSGFzaDtcbi8qKlxuICogTm9ybWFsaXplIGEgdmFsdWUsIHNvIHRoYXQgYEBtZXRhbWFzay9hYmktdXRpbHNgIGNhbiBoYW5kbGUgaXQuIFRoaXNcbiAqIG1hdGNoZXMgdGhlIGJlaGF2aW91ciBvZiB0aGUgYGV0aGVyZXVtanMtYWJpYCBsaWJyYXJ5LlxuICpcbiAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlIHRvIG5vcm1hbGl6ZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBub3JtYWxpemUuXG4gKiBAcmV0dXJucyBUaGUgbm9ybWFsaXplZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAoKDAsIHBhcnNlcnNfMS5pc0FycmF5VHlwZSkodHlwZSkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgW2lubmVyVHlwZV0gPSAoMCwgcGFyc2Vyc18xLmdldEFycmF5VHlwZSkodHlwZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKGl0ZW0pID0+IG5vcm1hbGl6ZVZhbHVlKGlubmVyVHlwZSwgaXRlbSkpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ2FkZHJlc3MnKSB7XG4gICAgICAgIGlmICgoMCwgdXRpbHNfMi5pc1N0cmljdEhleFN0cmluZykodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEucGFkU3RhcnQpKCgwLCB1dGlsc18yLmhleFRvQnl0ZXMpKHZhbHVlKS5zdWJhcnJheSgwLCAyMCksIDIwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEucGFkU3RhcnQpKHZhbHVlLnN1YmFycmF5KDAsIDIwKSwgMjApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZS5zdGFydHNXaXRoKCdieXRlcycpICYmIHR5cGUgIT09ICdieXRlcycpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gKDAsIHBhcnNlcnNfMS5nZXRCeXRlTGVuZ3RoKSh0eXBlKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBgc29saWRpdHlQYWNrKFsnYnl0ZXNOJ10sIFstMV0pYCByZXR1cm5zIGAweDAwLi4wMGAuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzIubnVtYmVyVG9CeXRlcykodmFsdWUpLnN1YmFycmF5KDAsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCB1dGlsc18yLmlzU3RyaWN0SGV4U3RyaW5nKSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMi5oZXhUb0J5dGVzKSh2YWx1ZSkuc3ViYXJyYXkoMCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc3ViYXJyYXkoMCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZS5zdGFydHNXaXRoKCd1aW50JykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGUuc3RhcnRzV2l0aCgnaW50JykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9ICgwLCBwYXJzZXJzXzEuZ2V0TGVuZ3RoKSh0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQuYXNJbnROKGxlbmd0aCwgQmlnSW50KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBGb3Igc29tZSByZWFzb24gYGV0aGVyZXVtanMtYWJpYCB0cmVhdHMgYGFkZHJlc3NgIGFuZCBgYWRkcmVzc1tdYCBkaWZmZXJlbnRseVxuICogc28gd2UgbmVlZCB0byBub3JtYWxpemUgYGFkZHJlc3NbXWAgZGlmZmVyZW50bHkuXG4gKlxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgdG8gbm9ybWFsaXplLlxuICogQHJldHVybnMgVGhlIG5vcm1hbGl6ZWQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVBZGRyZXNzZXModmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAoKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEucGFkU3RhcnQpKCgwLCB1dGlsc18yLm51bWJlclRvQnl0ZXMpKHZhbHVlKSwgMzIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgdXRpbHNfMi5pc1N0cmljdEhleFN0cmluZykodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEucGFkU3RhcnQpKCgwLCB1dGlsc18yLmhleFRvQnl0ZXMpKHZhbHVlKS5zdWJhcnJheSgwLCAzMiksIDMyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEucGFkU3RhcnQpKHZhbHVlLnN1YmFycmF5KDAsIDMyKSwgMzIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcbn1cbi8qKlxuICogRm9yIHNvbWUgcmVhc29uIGBldGhlcmV1bWpzLWFiaWAgdHJlYXRzIGBpbnROYCBhbmQgYGludE5bXWAgZGlmZmVyZW50bHlcbiAqIHNvIHdlIG5lZWQgdG8gbm9ybWFsaXplIGBpbnROW11gIGRpZmZlcmVudGx5LlxuICpcbiAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlIHRvIG5vcm1hbGl6ZS5cbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIG5vcm1hbGl6ZS5cbiAqIEByZXR1cm5zIFRoZSBub3JtYWxpemVkIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplSW50ZWdlcnModHlwZSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAoKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICBjb25zdCBiaWdJbnRWYWx1ZSA9IHBhcnNlTnVtYmVyKHR5cGUsIHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChiaWdJbnRWYWx1ZSA+PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEucGFkU3RhcnQpKCgwLCB1dGlsc18yLmJpZ0ludFRvQnl0ZXMpKGJpZ0ludFZhbHVlKSwgMzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gKDAsIHBhcnNlcnNfMS5nZXRMZW5ndGgpKHR5cGUpO1xuICAgICAgICAgICAgY29uc3QgYXNJbnROID0gQmlnSW50LmFzSW50TihsZW5ndGgsIGJpZ0ludFZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMi5zaWduZWRCaWdJbnRUb0J5dGVzKShhc0ludE4sIDMyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG59XG4vKipcbiAqIEdlbmVyYXRlIHRoZSBcIlYxXCIgaGFzaCBmb3IgdGhlIHByb3ZpZGVkIHR5cGVkIG1lc3NhZ2UuXG4gKlxuICogVGhlIGhhc2ggd2lsbCBiZSBnZW5lcmF0ZWQgaW4gYWNjb3JkYW5jZSB3aXRoIGFuIGVhcmxpZXIgdmVyc2lvbiBvZiB0aGUgRUlQLTcxMlxuICogc3BlY2lmaWNhdGlvbi4gVGhpcyBoYXNoIGlzIHVzZWQgaW4gYHNpZ25UeXBlZERhdGFfdjFgLlxuICpcbiAqIEBwYXJhbSB0eXBlZERhdGEgLSBUaGUgdHlwZWQgbWVzc2FnZS5cbiAqIEByZXR1cm5zIFRoZSBoYXNoIHJlcHJlc2VudGluZyB0aGUgdHlwZSBvZiB0aGUgcHJvdmlkZWQgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gX3R5cGVkU2lnbmF0dXJlSGFzaCh0eXBlZERhdGEpIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignRXhwZWN0IGFyZ3VtZW50IHRvIGJlIG5vbi1lbXB0eSBhcnJheScpO1xuICAgIGlmICh0eXBlb2YgdHlwZWREYXRhICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAhKCdsZW5ndGgnIGluIHR5cGVkRGF0YSkgfHxcbiAgICAgICAgIXR5cGVkRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IG5vcm1hbGl6ZWREYXRhID0gdHlwZWREYXRhLm1hcCgoeyBuYW1lLCB0eXBlLCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgIC8vIEhhbmRsZSBhbiBlZGdlIGNhc2Ugd2l0aCBgYWRkcmVzc1tdYCB0eXBlcy5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdhZGRyZXNzW10nKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2J5dGVzMzJbXScsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5vcm1hbGl6ZUFkZHJlc3Nlcyh2YWx1ZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBhbiBlZGdlIGNhc2Ugd2l0aCBgaW50TltdYCB0eXBlcy5cbiAgICAgICAgaWYgKHR5cGUuc3RhcnRzV2l0aCgnaW50JykgJiYgKDAsIHBhcnNlcnNfMS5pc0FycmF5VHlwZSkodHlwZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IFtpbm5lclR5cGUsIGxlbmd0aF0gPSAoMCwgcGFyc2Vyc18xLmdldEFycmF5VHlwZSkodHlwZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgdHlwZTogYGJ5dGVzMzJbJHtsZW5ndGggIT09IG51bGwgJiYgbGVuZ3RoICE9PSB2b2lkIDAgPyBsZW5ndGggOiAnJ31dYCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbm9ybWFsaXplSW50ZWdlcnMoaW5uZXJUeXBlLCB2YWx1ZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiBub3JtYWxpemVWYWx1ZSh0eXBlLCB2YWx1ZSksXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgZGF0YSA9IG5vcm1hbGl6ZWREYXRhLm1hcCgoZSkgPT4ge1xuICAgICAgICBpZiAoZS50eXBlICE9PSAnYnl0ZXMnKSB7XG4gICAgICAgICAgICByZXR1cm4gZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzMubGVnYWN5VG9CdWZmZXIpKGUudmFsdWUpO1xuICAgIH0pO1xuICAgIGNvbnN0IHR5cGVzID0gbm9ybWFsaXplZERhdGEubWFwKChlKSA9PiB7XG4gICAgICAgIGlmIChlLnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgb3IgaW52YWxpZCB0eXBlOiBcImZ1bmN0aW9uXCInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZS50eXBlO1xuICAgIH0pO1xuICAgIGNvbnN0IHNjaGVtYSA9IHR5cGVkRGF0YS5tYXAoKGUpID0+IHtcbiAgICAgICAgaWYgKCFlLm5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtlLnR5cGV9ICR7ZS5uYW1lfWA7XG4gICAgfSk7XG4gICAgcmV0dXJuICgwLCB1dGlsXzEuYXJyVG9CdWZBcnIpKCgwLCBrZWNjYWtfMS5rZWNjYWsyNTYpKCgwLCBhYmlfdXRpbHNfMS5lbmNvZGVQYWNrZWQpKFsnYnl0ZXMzMicsICdieXRlczMyJ10sIFtcbiAgICAgICAgKDAsIGtlY2Nha18xLmtlY2NhazI1NikoKDAsIGFiaV91dGlsc18xLmVuY29kZVBhY2tlZCkoWydzdHJpbmdbXSddLCBbc2NoZW1hXSwgdHJ1ZSkpLFxuICAgICAgICAoMCwga2VjY2FrXzEua2VjY2FrMjU2KSgoMCwgYWJpX3V0aWxzXzEuZW5jb2RlUGFja2VkKSh0eXBlcywgZGF0YSwgdHJ1ZSkpLFxuICAgIF0pKSk7XG59XG4vKipcbiAqIFNpZ24gdHlwZWQgZGF0YSBhY2NvcmRpbmcgdG8gRUlQLTcxMi4gVGhlIHNpZ25pbmcgZGlmZmVycyBiYXNlZCB1cG9uIHRoZSBgdmVyc2lvbmAuXG4gKlxuICogVjEgaXMgYmFzZWQgdXBvbiBbYW4gZWFybHkgdmVyc2lvbiBvZlxuICogRUlQLTcxMl0oaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL0VJUHMvcHVsbC83MTIvY29tbWl0cy8yMWFiZTI1NGZlMDQ1MmQ4NTgzZDViMTMyYjFkN2JlODdjMDQzOWNhKVxuICogdGhhdCBsYWNrZWQgc29tZSBsYXRlciBzZWN1cml0eSBpbXByb3ZlbWVudHMsIGFuZCBzaG91bGQgZ2VuZXJhbGx5IGJlIG5lZ2xlY3RlZCBpbiBmYXZvciBvZlxuICogbGF0ZXIgdmVyc2lvbnMuXG4gKlxuICogVjMgaXMgYmFzZWQgb24gW0VJUC03MTJdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzEyKSwgZXhjZXB0IHRoYXQgYXJyYXlzIGFuZFxuICogcmVjdXJzaXZlIGRhdGEgc3RydWN0dXJlcyBhcmUgbm90IHN1cHBvcnRlZC5cbiAqXG4gKiBWNCBpcyBiYXNlZCBvbiBbRUlQLTcxMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03MTIpLCBhbmQgaW5jbHVkZXMgZnVsbCBzdXBwb3J0IG9mXG4gKiBhcnJheXMgYW5kIHJlY3Vyc2l2ZSBkYXRhIHN0cnVjdHVyZXMuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgc2lnbmluZyBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMucHJpdmF0ZUtleSAtIFRoZSBwcml2YXRlIGtleSB0byBzaWduIHdpdGguXG4gKiBAcGFyYW0gb3B0aW9ucy5kYXRhIC0gVGhlIHR5cGVkIGRhdGEgdG8gc2lnbi5cbiAqIEBwYXJhbSBvcHRpb25zLnZlcnNpb24gLSBUaGUgc2lnbmluZyB2ZXJzaW9uIHRvIHVzZS5cbiAqIEByZXR1cm5zIFRoZSAnMHgnLXByZWZpeGVkIGhleCBlbmNvZGVkIHNpZ25hdHVyZS5cbiAqL1xuZnVuY3Rpb24gc2lnblR5cGVkRGF0YSh7IHByaXZhdGVLZXksIGRhdGEsIHZlcnNpb24sIH0pIHtcbiAgICB2YWxpZGF0ZVZlcnNpb24odmVyc2lvbik7XG4gICAgaWYgKCgwLCB1dGlsc18zLmlzTnVsbGlzaCkoZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGRhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18zLmlzTnVsbGlzaCkocHJpdmF0ZUtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHByaXZhdGUga2V5IHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlSGFzaCA9IHZlcnNpb24gPT09IFNpZ25UeXBlZERhdGFWZXJzaW9uLlYxXG4gICAgICAgID8gX3R5cGVkU2lnbmF0dXJlSGFzaChkYXRhKVxuICAgICAgICA6IGV4cG9ydHMuVHlwZWREYXRhVXRpbHMuZWlwNzEySGFzaChkYXRhLCB2ZXJzaW9uKTtcbiAgICBjb25zdCBzaWcgPSAoMCwgdXRpbF8xLmVjc2lnbikobWVzc2FnZUhhc2gsIHByaXZhdGVLZXkpO1xuICAgIHJldHVybiAoMCwgdXRpbHNfMy5jb25jYXRTaWcpKCgwLCB1dGlsXzEuYXJyVG9CdWZBcnIpKCgwLCB1dGlsc18yLmJpZ0ludFRvQnl0ZXMpKHNpZy52KSksIHNpZy5yLCBzaWcucyk7XG59XG5leHBvcnRzLnNpZ25UeXBlZERhdGEgPSBzaWduVHlwZWREYXRhO1xuLyoqXG4gKiBSZWNvdmVyIHRoZSBhZGRyZXNzIG9mIHRoZSBhY2NvdW50IHRoYXQgY3JlYXRlZCB0aGUgZ2l2ZW4gRUlQLTcxMlxuICogc2lnbmF0dXJlLiBUaGUgdmVyc2lvbiBwcm92aWRlZCBtdXN0IG1hdGNoIHRoZSB2ZXJzaW9uIHVzZWQgdG9cbiAqIGNyZWF0ZSB0aGUgc2lnbmF0dXJlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHNpZ25hdHVyZSByZWNvdmVyeSBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMuZGF0YSAtIFRoZSB0eXBlZCBkYXRhIHRoYXQgd2FzIHNpZ25lZC5cbiAqIEBwYXJhbSBvcHRpb25zLnNpZ25hdHVyZSAtIFRoZSAnMHgtcHJlZml4ZWQgaGV4IGVuY29kZWQgbWVzc2FnZSBzaWduYXR1cmUuXG4gKiBAcGFyYW0gb3B0aW9ucy52ZXJzaW9uIC0gVGhlIHNpZ25pbmcgdmVyc2lvbiB0byB1c2UuXG4gKiBAcmV0dXJucyBUaGUgJzB4Jy1wcmVmaXhlZCBoZXggYWRkcmVzcyBvZiB0aGUgc2lnbmVyLlxuICovXG5mdW5jdGlvbiByZWNvdmVyVHlwZWRTaWduYXR1cmUoeyBkYXRhLCBzaWduYXR1cmUsIHZlcnNpb24sIH0pIHtcbiAgICB2YWxpZGF0ZVZlcnNpb24odmVyc2lvbik7XG4gICAgaWYgKCgwLCB1dGlsc18zLmlzTnVsbGlzaCkoZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGRhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18zLmlzTnVsbGlzaCkoc2lnbmF0dXJlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3Npbmcgc2lnbmF0dXJlIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlSGFzaCA9IHZlcnNpb24gPT09IFNpZ25UeXBlZERhdGFWZXJzaW9uLlYxXG4gICAgICAgID8gX3R5cGVkU2lnbmF0dXJlSGFzaChkYXRhKVxuICAgICAgICA6IGV4cG9ydHMuVHlwZWREYXRhVXRpbHMuZWlwNzEySGFzaChkYXRhLCB2ZXJzaW9uKTtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSAoMCwgdXRpbHNfMy5yZWNvdmVyUHVibGljS2V5KShtZXNzYWdlSGFzaCwgc2lnbmF0dXJlKTtcbiAgICBjb25zdCBzZW5kZXIgPSAoMCwgdXRpbF8xLnB1YmxpY1RvQWRkcmVzcykocHVibGljS2V5KTtcbiAgICByZXR1cm4gKDAsIHV0aWxzXzIuYnl0ZXNUb0hleCkoc2VuZGVyKTtcbn1cbmV4cG9ydHMucmVjb3ZlclR5cGVkU2lnbmF0dXJlID0gcmVjb3ZlclR5cGVkU2lnbmF0dXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbi10eXBlZC1kYXRhLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/dist/sign-typed-data.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/dist/utils.js":
/*!***************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/dist/utils.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.normalize = exports.recoverPublicKey = exports.concatSig = exports.legacyToBuffer = exports.isNullish = exports.padWithZeroes = void 0;\nconst util_1 = __webpack_require__(/*! @ethereumjs/util */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/index.js\");\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(rsc)/../../node_modules/@metamask/utils/dist/index.cjs\");\n/**\n * Pads the front of the given hex string with zeroes until it reaches the\n * target length. If the input string is already longer than or equal to the\n * target length, it is returned unmodified.\n *\n * If the input string is \"0x\"-prefixed or not a hex string, an error will be\n * thrown.\n *\n * @param hexString - The hexadecimal string to pad with zeroes.\n * @param targetLength - The target length of the hexadecimal string.\n * @returns The input string front-padded with zeroes, or the original string\n * if it was already greater than or equal to to the target length.\n */\nfunction padWithZeroes(hexString, targetLength) {\n    if (hexString !== '' && !/^[a-f0-9]+$/iu.test(hexString)) {\n        throw new Error(`Expected an unprefixed hex string. Received: ${hexString}`);\n    }\n    if (targetLength < 0) {\n        throw new Error(`Expected a non-negative integer target length. Received: ${targetLength}`);\n    }\n    return String.prototype.padStart.call(hexString, targetLength, '0');\n}\nexports.padWithZeroes = padWithZeroes;\n/**\n * Returns `true` if the given value is nullish.\n *\n * @param value - The value being checked.\n * @returns Whether the value is nullish.\n */\nfunction isNullish(value) {\n    return value === null || value === undefined;\n}\nexports.isNullish = isNullish;\n/**\n * Convert a value to a Buffer. This function should be equivalent to the `toBuffer` function in\n * `ethereumjs-util@5.2.1`.\n *\n * @param value - The value to convert to a Buffer.\n * @returns The given value as a Buffer.\n */\nfunction legacyToBuffer(value) {\n    return typeof value === 'string' && !(0, util_1.isHexString)(value)\n        ? Buffer.from(value)\n        : (0, util_1.toBuffer)(value);\n}\nexports.legacyToBuffer = legacyToBuffer;\n/**\n * Concatenate an extended ECDSA signature into a single '0x'-prefixed hex string.\n *\n * @param v - The 'v' portion of the signature.\n * @param r - The 'r' portion of the signature.\n * @param s - The 's' portion of the signature.\n * @returns The concatenated ECDSA signature as a '0x'-prefixed string.\n */\nfunction concatSig(v, r, s) {\n    const rSig = (0, util_1.fromSigned)(r);\n    const sSig = (0, util_1.fromSigned)(s);\n    const vSig = (0, util_1.bufferToInt)(v);\n    const rStr = padWithZeroes((0, util_1.toUnsigned)(rSig).toString('hex'), 64);\n    const sStr = padWithZeroes((0, util_1.toUnsigned)(sSig).toString('hex'), 64);\n    const vStr = (0, utils_1.remove0x)((0, utils_1.numberToHex)(vSig));\n    return (0, utils_1.add0x)(rStr.concat(sStr, vStr));\n}\nexports.concatSig = concatSig;\n/**\n * Recover the public key from the given signature and message hash.\n *\n * @param messageHash - The hash of the signed message.\n * @param signature - The signature.\n * @returns The public key of the signer.\n */\nfunction recoverPublicKey(messageHash, signature) {\n    const sigParams = (0, util_1.fromRpcSig)(signature);\n    return (0, util_1.ecrecover)(messageHash, sigParams.v, sigParams.r, sigParams.s);\n}\nexports.recoverPublicKey = recoverPublicKey;\n/**\n * Normalize the input to a lower-cased '0x'-prefixed hex string.\n *\n * @param input - The value to normalize.\n * @returns The normalized value.\n */\nfunction normalize(input) {\n    if (isNullish(input)) {\n        return undefined;\n    }\n    if (typeof input === 'number') {\n        if (input < 0) {\n            return '0x';\n        }\n        const buffer = (0, utils_1.numberToBytes)(input);\n        input = (0, utils_1.bytesToHex)(buffer);\n    }\n    if (typeof input !== 'string') {\n        let msg = 'eth-sig-util.normalize() requires hex string or integer input.';\n        msg += ` received ${typeof input}: ${input}`;\n        throw new Error(msg);\n    }\n    return (0, utils_1.add0x)(input.toLowerCase());\n}\nexports.normalize = normalize;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvZGlzdC91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyx3QkFBd0IsR0FBRyxpQkFBaUIsR0FBRyxzQkFBc0IsR0FBRyxpQkFBaUIsR0FBRyxxQkFBcUI7QUFDckksZUFBZSxtQkFBTyxDQUFDLHFIQUFrQjtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxnRkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLFVBQVU7QUFDbEY7QUFDQTtBQUNBLG9GQUFvRixhQUFhO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhLElBQUksTUFBTTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9kaXN0L3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ub3JtYWxpemUgPSBleHBvcnRzLnJlY292ZXJQdWJsaWNLZXkgPSBleHBvcnRzLmNvbmNhdFNpZyA9IGV4cG9ydHMubGVnYWN5VG9CdWZmZXIgPSBleHBvcnRzLmlzTnVsbGlzaCA9IGV4cG9ydHMucGFkV2l0aFplcm9lcyA9IHZvaWQgMDtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCJAZXRoZXJldW1qcy91dGlsXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svdXRpbHNcIik7XG4vKipcbiAqIFBhZHMgdGhlIGZyb250IG9mIHRoZSBnaXZlbiBoZXggc3RyaW5nIHdpdGggemVyb2VzIHVudGlsIGl0IHJlYWNoZXMgdGhlXG4gKiB0YXJnZXQgbGVuZ3RoLiBJZiB0aGUgaW5wdXQgc3RyaW5nIGlzIGFscmVhZHkgbG9uZ2VyIHRoYW4gb3IgZXF1YWwgdG8gdGhlXG4gKiB0YXJnZXQgbGVuZ3RoLCBpdCBpcyByZXR1cm5lZCB1bm1vZGlmaWVkLlxuICpcbiAqIElmIHRoZSBpbnB1dCBzdHJpbmcgaXMgXCIweFwiLXByZWZpeGVkIG9yIG5vdCBhIGhleCBzdHJpbmcsIGFuIGVycm9yIHdpbGwgYmVcbiAqIHRocm93bi5cbiAqXG4gKiBAcGFyYW0gaGV4U3RyaW5nIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBwYWQgd2l0aCB6ZXJvZXMuXG4gKiBAcGFyYW0gdGFyZ2V0TGVuZ3RoIC0gVGhlIHRhcmdldCBsZW5ndGggb2YgdGhlIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBpbnB1dCBzdHJpbmcgZnJvbnQtcGFkZGVkIHdpdGggemVyb2VzLCBvciB0aGUgb3JpZ2luYWwgc3RyaW5nXG4gKiBpZiBpdCB3YXMgYWxyZWFkeSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdG8gdGhlIHRhcmdldCBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIHBhZFdpdGhaZXJvZXMoaGV4U3RyaW5nLCB0YXJnZXRMZW5ndGgpIHtcbiAgICBpZiAoaGV4U3RyaW5nICE9PSAnJyAmJiAhL15bYS1mMC05XSskL2l1LnRlc3QoaGV4U3RyaW5nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGFuIHVucHJlZml4ZWQgaGV4IHN0cmluZy4gUmVjZWl2ZWQ6ICR7aGV4U3RyaW5nfWApO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0TGVuZ3RoIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIgdGFyZ2V0IGxlbmd0aC4gUmVjZWl2ZWQ6ICR7dGFyZ2V0TGVuZ3RofWApO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nLnByb3RvdHlwZS5wYWRTdGFydC5jYWxsKGhleFN0cmluZywgdGFyZ2V0TGVuZ3RoLCAnMCcpO1xufVxuZXhwb3J0cy5wYWRXaXRoWmVyb2VzID0gcGFkV2l0aFplcm9lcztcbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG51bGxpc2guXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIGJlaW5nIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBudWxsaXNoLlxuICovXG5mdW5jdGlvbiBpc051bGxpc2godmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuaXNOdWxsaXNoID0gaXNOdWxsaXNoO1xuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBCdWZmZXIuIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGVxdWl2YWxlbnQgdG8gdGhlIGB0b0J1ZmZlcmAgZnVuY3Rpb24gaW5cbiAqIGBldGhlcmV1bWpzLXV0aWxANS4yLjFgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgQnVmZmVyLlxuICogQHJldHVybnMgVGhlIGdpdmVuIHZhbHVlIGFzIGEgQnVmZmVyLlxuICovXG5mdW5jdGlvbiBsZWdhY3lUb0J1ZmZlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmICEoMCwgdXRpbF8xLmlzSGV4U3RyaW5nKSh2YWx1ZSlcbiAgICAgICAgPyBCdWZmZXIuZnJvbSh2YWx1ZSlcbiAgICAgICAgOiAoMCwgdXRpbF8xLnRvQnVmZmVyKSh2YWx1ZSk7XG59XG5leHBvcnRzLmxlZ2FjeVRvQnVmZmVyID0gbGVnYWN5VG9CdWZmZXI7XG4vKipcbiAqIENvbmNhdGVuYXRlIGFuIGV4dGVuZGVkIEVDRFNBIHNpZ25hdHVyZSBpbnRvIGEgc2luZ2xlICcweCctcHJlZml4ZWQgaGV4IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdiAtIFRoZSAndicgcG9ydGlvbiBvZiB0aGUgc2lnbmF0dXJlLlxuICogQHBhcmFtIHIgLSBUaGUgJ3InIHBvcnRpb24gb2YgdGhlIHNpZ25hdHVyZS5cbiAqIEBwYXJhbSBzIC0gVGhlICdzJyBwb3J0aW9uIG9mIHRoZSBzaWduYXR1cmUuXG4gKiBAcmV0dXJucyBUaGUgY29uY2F0ZW5hdGVkIEVDRFNBIHNpZ25hdHVyZSBhcyBhICcweCctcHJlZml4ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBjb25jYXRTaWcodiwgciwgcykge1xuICAgIGNvbnN0IHJTaWcgPSAoMCwgdXRpbF8xLmZyb21TaWduZWQpKHIpO1xuICAgIGNvbnN0IHNTaWcgPSAoMCwgdXRpbF8xLmZyb21TaWduZWQpKHMpO1xuICAgIGNvbnN0IHZTaWcgPSAoMCwgdXRpbF8xLmJ1ZmZlclRvSW50KSh2KTtcbiAgICBjb25zdCByU3RyID0gcGFkV2l0aFplcm9lcygoMCwgdXRpbF8xLnRvVW5zaWduZWQpKHJTaWcpLnRvU3RyaW5nKCdoZXgnKSwgNjQpO1xuICAgIGNvbnN0IHNTdHIgPSBwYWRXaXRoWmVyb2VzKCgwLCB1dGlsXzEudG9VbnNpZ25lZCkoc1NpZykudG9TdHJpbmcoJ2hleCcpLCA2NCk7XG4gICAgY29uc3QgdlN0ciA9ICgwLCB1dGlsc18xLnJlbW92ZTB4KSgoMCwgdXRpbHNfMS5udW1iZXJUb0hleCkodlNpZykpO1xuICAgIHJldHVybiAoMCwgdXRpbHNfMS5hZGQweCkoclN0ci5jb25jYXQoc1N0ciwgdlN0cikpO1xufVxuZXhwb3J0cy5jb25jYXRTaWcgPSBjb25jYXRTaWc7XG4vKipcbiAqIFJlY292ZXIgdGhlIHB1YmxpYyBrZXkgZnJvbSB0aGUgZ2l2ZW4gc2lnbmF0dXJlIGFuZCBtZXNzYWdlIGhhc2guXG4gKlxuICogQHBhcmFtIG1lc3NhZ2VIYXNoIC0gVGhlIGhhc2ggb2YgdGhlIHNpZ25lZCBtZXNzYWdlLlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUuXG4gKiBAcmV0dXJucyBUaGUgcHVibGljIGtleSBvZiB0aGUgc2lnbmVyLlxuICovXG5mdW5jdGlvbiByZWNvdmVyUHVibGljS2V5KG1lc3NhZ2VIYXNoLCBzaWduYXR1cmUpIHtcbiAgICBjb25zdCBzaWdQYXJhbXMgPSAoMCwgdXRpbF8xLmZyb21ScGNTaWcpKHNpZ25hdHVyZSk7XG4gICAgcmV0dXJuICgwLCB1dGlsXzEuZWNyZWNvdmVyKShtZXNzYWdlSGFzaCwgc2lnUGFyYW1zLnYsIHNpZ1BhcmFtcy5yLCBzaWdQYXJhbXMucyk7XG59XG5leHBvcnRzLnJlY292ZXJQdWJsaWNLZXkgPSByZWNvdmVyUHVibGljS2V5O1xuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGlucHV0IHRvIGEgbG93ZXItY2FzZWQgJzB4Jy1wcmVmaXhlZCBoZXggc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSB2YWx1ZSB0byBub3JtYWxpemUuXG4gKiBAcmV0dXJucyBUaGUgbm9ybWFsaXplZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKGlucHV0KSB7XG4gICAgaWYgKGlzTnVsbGlzaChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGlucHV0IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuICcweCc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmZmVyID0gKDAsIHV0aWxzXzEubnVtYmVyVG9CeXRlcykoaW5wdXQpO1xuICAgICAgICBpbnB1dCA9ICgwLCB1dGlsc18xLmJ5dGVzVG9IZXgpKGJ1ZmZlcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGxldCBtc2cgPSAnZXRoLXNpZy11dGlsLm5vcm1hbGl6ZSgpIHJlcXVpcmVzIGhleCBzdHJpbmcgb3IgaW50ZWdlciBpbnB1dC4nO1xuICAgICAgICBtc2cgKz0gYCByZWNlaXZlZCAke3R5cGVvZiBpbnB1dH06ICR7aW5wdXR9YDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgdXRpbHNfMS5hZGQweCkoaW5wdXQudG9Mb3dlckNhc2UoKSk7XG59XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/dist/utils.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/rlp/dist/index.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/rlp/dist/index.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RLP = exports.utils = exports.decode = exports.encode = void 0;\n/**\n * RLP Encoding based on https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/\n * This function takes in data, converts it to Uint8Array if not,\n * and adds a length for recursion.\n * @param input Will be converted to Uint8Array\n * @returns Uint8Array of encoded data\n **/\nfunction encode(input) {\n    if (Array.isArray(input)) {\n        const output = [];\n        let outputLength = 0;\n        for (let i = 0; i < input.length; i++) {\n            const encoded = encode(input[i]);\n            output.push(encoded);\n            outputLength += encoded.length;\n        }\n        return concatBytes(encodeLength(outputLength, 192), ...output);\n    }\n    const inputBuf = toBytes(input);\n    if (inputBuf.length === 1 && inputBuf[0] < 128) {\n        return inputBuf;\n    }\n    return concatBytes(encodeLength(inputBuf.length, 128), inputBuf);\n}\nexports.encode = encode;\n/**\n * Slices a Uint8Array, throws if the slice goes out-of-bounds of the Uint8Array.\n * E.g. `safeSlice(hexToBytes('aa'), 1, 2)` will throw.\n * @param input\n * @param start\n * @param end\n */\nfunction safeSlice(input, start, end) {\n    if (end > input.length) {\n        throw new Error('invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds');\n    }\n    return input.slice(start, end);\n}\n/**\n * Parse integers. Check if there is no leading zeros\n * @param v The value to parse\n */\nfunction decodeLength(v) {\n    if (v[0] === 0) {\n        throw new Error('invalid RLP: extra zeros');\n    }\n    return parseHexByte(bytesToHex(v));\n}\nfunction encodeLength(len, offset) {\n    if (len < 56) {\n        return Uint8Array.from([len + offset]);\n    }\n    const hexLength = numberToHex(len);\n    const lLength = hexLength.length / 2;\n    const firstByte = numberToHex(offset + 55 + lLength);\n    return Uint8Array.from(hexToBytes(firstByte + hexLength));\n}\nfunction decode(input, stream = false) {\n    if (typeof input === 'undefined' || input === null || input.length === 0) {\n        return Uint8Array.from([]);\n    }\n    const inputBytes = toBytes(input);\n    const decoded = _decode(inputBytes);\n    if (stream) {\n        return decoded;\n    }\n    if (decoded.remainder.length !== 0) {\n        throw new Error('invalid RLP: remainder must be zero');\n    }\n    return decoded.data;\n}\nexports.decode = decode;\n/** Decode an input with RLP */\nfunction _decode(input) {\n    let length, llength, data, innerRemainder, d;\n    const decoded = [];\n    const firstByte = input[0];\n    if (firstByte <= 0x7f) {\n        // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.\n        return {\n            data: input.slice(0, 1),\n            remainder: input.slice(1),\n        };\n    }\n    else if (firstByte <= 0xb7) {\n        // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string\n        // The range of the first byte is [0x80, 0xb7]\n        length = firstByte - 0x7f;\n        // set 0x80 null to 0\n        if (firstByte === 0x80) {\n            data = Uint8Array.from([]);\n        }\n        else {\n            data = safeSlice(input, 1, length);\n        }\n        if (length === 2 && data[0] < 0x80) {\n            throw new Error('invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed');\n        }\n        return {\n            data,\n            remainder: input.slice(length),\n        };\n    }\n    else if (firstByte <= 0xbf) {\n        // string is greater than 55 bytes long. A single byte with the value (0xb7 plus the length of the length),\n        // followed by the length, followed by the string\n        llength = firstByte - 0xb6;\n        if (input.length - 1 < llength) {\n            throw new Error('invalid RLP: not enough bytes for string length');\n        }\n        length = decodeLength(safeSlice(input, 1, llength));\n        if (length <= 55) {\n            throw new Error('invalid RLP: expected string length to be greater than 55');\n        }\n        data = safeSlice(input, llength, length + llength);\n        return {\n            data,\n            remainder: input.slice(length + llength),\n        };\n    }\n    else if (firstByte <= 0xf7) {\n        // a list between 0-55 bytes long\n        length = firstByte - 0xbf;\n        innerRemainder = safeSlice(input, 1, length);\n        while (innerRemainder.length) {\n            d = _decode(innerRemainder);\n            decoded.push(d.data);\n            innerRemainder = d.remainder;\n        }\n        return {\n            data: decoded,\n            remainder: input.slice(length),\n        };\n    }\n    else {\n        // a list over 55 bytes long\n        llength = firstByte - 0xf6;\n        length = decodeLength(safeSlice(input, 1, llength));\n        if (length < 56) {\n            throw new Error('invalid RLP: encoded list too short');\n        }\n        const totalLength = llength + length;\n        if (totalLength > input.length) {\n            throw new Error('invalid RLP: total length is larger than the data');\n        }\n        innerRemainder = safeSlice(input, llength, totalLength);\n        while (innerRemainder.length) {\n            d = _decode(innerRemainder);\n            decoded.push(d.data);\n            innerRemainder = d.remainder;\n        }\n        return {\n            data: decoded,\n            remainder: input.slice(totalLength),\n        };\n    }\n}\nconst cachedHexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    // Pre-caching chars with `cachedHexes` speeds this up 6x\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += cachedHexes[uint8a[i]];\n    }\n    return hex;\n}\nfunction parseHexByte(hexByte) {\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte))\n        throw new Error('Invalid byte sequence');\n    return byte;\n}\n// Caching slows it down 2-3x\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        array[i] = parseHexByte(hex.slice(j, j + 2));\n    }\n    return array;\n}\n/** Concatenates two Uint8Arrays into one. */\nfunction concatBytes(...arrays) {\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nfunction utf8ToBytes(utf) {\n    return new TextEncoder().encode(utf);\n}\n/** Transform an integer into its hexadecimal value */\nfunction numberToHex(integer) {\n    if (integer < 0) {\n        throw new Error('Invalid integer as argument, must be unsigned!');\n    }\n    const hex = integer.toString(16);\n    return hex.length % 2 ? `0${hex}` : hex;\n}\n/** Pad a string to be even */\nfunction padToEven(a) {\n    return a.length % 2 ? `0${a}` : a;\n}\n/** Check if a string is prefixed by 0x */\nfunction isHexPrefixed(str) {\n    return str.length >= 2 && str[0] === '0' && str[1] === 'x';\n}\n/** Removes 0x from a given String */\nfunction stripHexPrefix(str) {\n    if (typeof str !== 'string') {\n        return str;\n    }\n    return isHexPrefixed(str) ? str.slice(2) : str;\n}\n/** Transform anything into a Uint8Array */\nfunction toBytes(v) {\n    if (v instanceof Uint8Array) {\n        return v;\n    }\n    if (typeof v === 'string') {\n        if (isHexPrefixed(v)) {\n            return hexToBytes(padToEven(stripHexPrefix(v)));\n        }\n        return utf8ToBytes(v);\n    }\n    if (typeof v === 'number' || typeof v === 'bigint') {\n        if (!v) {\n            return Uint8Array.from([]);\n        }\n        return hexToBytes(numberToHex(v));\n    }\n    if (v === null || v === undefined) {\n        return Uint8Array.from([]);\n    }\n    throw new Error('toBytes: received unsupported type ' + typeof v);\n}\nexports.utils = {\n    bytesToHex,\n    concatBytes,\n    hexToBytes,\n    utf8ToBytes,\n};\nexports.RLP = { encode, decode };\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3JscC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFdBQVcsR0FBRyxhQUFhLEdBQUcsY0FBYyxHQUFHLGNBQWM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGFBQWE7QUFDOUM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixFQUFFO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3JscC9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5STFAgPSBleHBvcnRzLnV0aWxzID0gZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLmVuY29kZSA9IHZvaWQgMDtcbi8qKlxuICogUkxQIEVuY29kaW5nIGJhc2VkIG9uIGh0dHBzOi8vZXRoZXJldW0ub3JnL2VuL2RldmVsb3BlcnMvZG9jcy9kYXRhLXN0cnVjdHVyZXMtYW5kLWVuY29kaW5nL3JscC9cbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgaW4gZGF0YSwgY29udmVydHMgaXQgdG8gVWludDhBcnJheSBpZiBub3QsXG4gKiBhbmQgYWRkcyBhIGxlbmd0aCBmb3IgcmVjdXJzaW9uLlxuICogQHBhcmFtIGlucHV0IFdpbGwgYmUgY29udmVydGVkIHRvIFVpbnQ4QXJyYXlcbiAqIEByZXR1cm5zIFVpbnQ4QXJyYXkgb2YgZW5jb2RlZCBkYXRhXG4gKiovXG5mdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgICAgIGxldCBvdXRwdXRMZW5ndGggPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVkID0gZW5jb2RlKGlucHV0W2ldKTtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGVuY29kZWQpO1xuICAgICAgICAgICAgb3V0cHV0TGVuZ3RoICs9IGVuY29kZWQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25jYXRCeXRlcyhlbmNvZGVMZW5ndGgob3V0cHV0TGVuZ3RoLCAxOTIpLCAuLi5vdXRwdXQpO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dEJ1ZiA9IHRvQnl0ZXMoaW5wdXQpO1xuICAgIGlmIChpbnB1dEJ1Zi5sZW5ndGggPT09IDEgJiYgaW5wdXRCdWZbMF0gPCAxMjgpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0QnVmO1xuICAgIH1cbiAgICByZXR1cm4gY29uY2F0Qnl0ZXMoZW5jb2RlTGVuZ3RoKGlucHV0QnVmLmxlbmd0aCwgMTI4KSwgaW5wdXRCdWYpO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG4vKipcbiAqIFNsaWNlcyBhIFVpbnQ4QXJyYXksIHRocm93cyBpZiB0aGUgc2xpY2UgZ29lcyBvdXQtb2YtYm91bmRzIG9mIHRoZSBVaW50OEFycmF5LlxuICogRS5nLiBgc2FmZVNsaWNlKGhleFRvQnl0ZXMoJ2FhJyksIDEsIDIpYCB3aWxsIHRocm93LlxuICogQHBhcmFtIGlucHV0XG4gKiBAcGFyYW0gc3RhcnRcbiAqIEBwYXJhbSBlbmRcbiAqL1xuZnVuY3Rpb24gc2FmZVNsaWNlKGlucHV0LCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKGVuZCA+IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUkxQIChzYWZlU2xpY2UpOiBlbmQgc2xpY2Ugb2YgVWludDhBcnJheSBvdXQtb2YtYm91bmRzJyk7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dC5zbGljZShzdGFydCwgZW5kKTtcbn1cbi8qKlxuICogUGFyc2UgaW50ZWdlcnMuIENoZWNrIGlmIHRoZXJlIGlzIG5vIGxlYWRpbmcgemVyb3NcbiAqIEBwYXJhbSB2IFRoZSB2YWx1ZSB0byBwYXJzZVxuICovXG5mdW5jdGlvbiBkZWNvZGVMZW5ndGgodikge1xuICAgIGlmICh2WzBdID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFA6IGV4dHJhIHplcm9zJyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUhleEJ5dGUoYnl0ZXNUb0hleCh2KSk7XG59XG5mdW5jdGlvbiBlbmNvZGVMZW5ndGgobGVuLCBvZmZzZXQpIHtcbiAgICBpZiAobGVuIDwgNTYpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShbbGVuICsgb2Zmc2V0XSk7XG4gICAgfVxuICAgIGNvbnN0IGhleExlbmd0aCA9IG51bWJlclRvSGV4KGxlbik7XG4gICAgY29uc3QgbExlbmd0aCA9IGhleExlbmd0aC5sZW5ndGggLyAyO1xuICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IG51bWJlclRvSGV4KG9mZnNldCArIDU1ICsgbExlbmd0aCk7XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShoZXhUb0J5dGVzKGZpcnN0Qnl0ZSArIGhleExlbmd0aCkpO1xufVxuZnVuY3Rpb24gZGVjb2RlKGlucHV0LCBzdHJlYW0gPSBmYWxzZSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICd1bmRlZmluZWQnIHx8IGlucHV0ID09PSBudWxsIHx8IGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKFtdKTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRCeXRlcyA9IHRvQnl0ZXMoaW5wdXQpO1xuICAgIGNvbnN0IGRlY29kZWQgPSBfZGVjb2RlKGlucHV0Qnl0ZXMpO1xuICAgIGlmIChzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZWQ7XG4gICAgfVxuICAgIGlmIChkZWNvZGVkLnJlbWFpbmRlci5sZW5ndGggIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFJMUDogcmVtYWluZGVyIG11c3QgYmUgemVybycpO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlZC5kYXRhO1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG4vKiogRGVjb2RlIGFuIGlucHV0IHdpdGggUkxQICovXG5mdW5jdGlvbiBfZGVjb2RlKGlucHV0KSB7XG4gICAgbGV0IGxlbmd0aCwgbGxlbmd0aCwgZGF0YSwgaW5uZXJSZW1haW5kZXIsIGQ7XG4gICAgY29uc3QgZGVjb2RlZCA9IFtdO1xuICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IGlucHV0WzBdO1xuICAgIGlmIChmaXJzdEJ5dGUgPD0gMHg3Zikge1xuICAgICAgICAvLyBhIHNpbmdsZSBieXRlIHdob3NlIHZhbHVlIGlzIGluIHRoZSBbMHgwMCwgMHg3Zl0gcmFuZ2UsIHRoYXQgYnl0ZSBpcyBpdHMgb3duIFJMUCBlbmNvZGluZy5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IGlucHV0LnNsaWNlKDAsIDEpLFxuICAgICAgICAgICAgcmVtYWluZGVyOiBpbnB1dC5zbGljZSgxKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RCeXRlIDw9IDB4YjcpIHtcbiAgICAgICAgLy8gc3RyaW5nIGlzIDAtNTUgYnl0ZXMgbG9uZy4gQSBzaW5nbGUgYnl0ZSB3aXRoIHZhbHVlIDB4ODAgcGx1cyB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgZm9sbG93ZWQgYnkgdGhlIHN0cmluZ1xuICAgICAgICAvLyBUaGUgcmFuZ2Ugb2YgdGhlIGZpcnN0IGJ5dGUgaXMgWzB4ODAsIDB4YjddXG4gICAgICAgIGxlbmd0aCA9IGZpcnN0Qnl0ZSAtIDB4N2Y7XG4gICAgICAgIC8vIHNldCAweDgwIG51bGwgdG8gMFxuICAgICAgICBpZiAoZmlyc3RCeXRlID09PSAweDgwKSB7XG4gICAgICAgICAgICBkYXRhID0gVWludDhBcnJheS5mcm9tKFtdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSBzYWZlU2xpY2UoaW5wdXQsIDEsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMiAmJiBkYXRhWzBdIDwgMHg4MCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFJMUCBlbmNvZGluZzogaW52YWxpZCBwcmVmaXgsIHNpbmdsZSBieXRlIDwgMHg4MCBhcmUgbm90IHByZWZpeGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKGxlbmd0aCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpcnN0Qnl0ZSA8PSAweGJmKSB7XG4gICAgICAgIC8vIHN0cmluZyBpcyBncmVhdGVyIHRoYW4gNTUgYnl0ZXMgbG9uZy4gQSBzaW5nbGUgYnl0ZSB3aXRoIHRoZSB2YWx1ZSAoMHhiNyBwbHVzIHRoZSBsZW5ndGggb2YgdGhlIGxlbmd0aCksXG4gICAgICAgIC8vIGZvbGxvd2VkIGJ5IHRoZSBsZW5ndGgsIGZvbGxvd2VkIGJ5IHRoZSBzdHJpbmdcbiAgICAgICAgbGxlbmd0aCA9IGZpcnN0Qnl0ZSAtIDB4YjY7XG4gICAgICAgIGlmIChpbnB1dC5sZW5ndGggLSAxIDwgbGxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFJMUDogbm90IGVub3VnaCBieXRlcyBmb3Igc3RyaW5nIGxlbmd0aCcpO1xuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCA9IGRlY29kZUxlbmd0aChzYWZlU2xpY2UoaW5wdXQsIDEsIGxsZW5ndGgpKTtcbiAgICAgICAgaWYgKGxlbmd0aCA8PSA1NSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFJMUDogZXhwZWN0ZWQgc3RyaW5nIGxlbmd0aCB0byBiZSBncmVhdGVyIHRoYW4gNTUnKTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhID0gc2FmZVNsaWNlKGlucHV0LCBsbGVuZ3RoLCBsZW5ndGggKyBsbGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKGxlbmd0aCArIGxsZW5ndGgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChmaXJzdEJ5dGUgPD0gMHhmNykge1xuICAgICAgICAvLyBhIGxpc3QgYmV0d2VlbiAwLTU1IGJ5dGVzIGxvbmdcbiAgICAgICAgbGVuZ3RoID0gZmlyc3RCeXRlIC0gMHhiZjtcbiAgICAgICAgaW5uZXJSZW1haW5kZXIgPSBzYWZlU2xpY2UoaW5wdXQsIDEsIGxlbmd0aCk7XG4gICAgICAgIHdoaWxlIChpbm5lclJlbWFpbmRlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGQgPSBfZGVjb2RlKGlubmVyUmVtYWluZGVyKTtcbiAgICAgICAgICAgIGRlY29kZWQucHVzaChkLmRhdGEpO1xuICAgICAgICAgICAgaW5uZXJSZW1haW5kZXIgPSBkLnJlbWFpbmRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogZGVjb2RlZCxcbiAgICAgICAgICAgIHJlbWFpbmRlcjogaW5wdXQuc2xpY2UobGVuZ3RoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGEgbGlzdCBvdmVyIDU1IGJ5dGVzIGxvbmdcbiAgICAgICAgbGxlbmd0aCA9IGZpcnN0Qnl0ZSAtIDB4ZjY7XG4gICAgICAgIGxlbmd0aCA9IGRlY29kZUxlbmd0aChzYWZlU2xpY2UoaW5wdXQsIDEsIGxsZW5ndGgpKTtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDU2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUkxQOiBlbmNvZGVkIGxpc3QgdG9vIHNob3J0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG90YWxMZW5ndGggPSBsbGVuZ3RoICsgbGVuZ3RoO1xuICAgICAgICBpZiAodG90YWxMZW5ndGggPiBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFA6IHRvdGFsIGxlbmd0aCBpcyBsYXJnZXIgdGhhbiB0aGUgZGF0YScpO1xuICAgICAgICB9XG4gICAgICAgIGlubmVyUmVtYWluZGVyID0gc2FmZVNsaWNlKGlucHV0LCBsbGVuZ3RoLCB0b3RhbExlbmd0aCk7XG4gICAgICAgIHdoaWxlIChpbm5lclJlbWFpbmRlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGQgPSBfZGVjb2RlKGlubmVyUmVtYWluZGVyKTtcbiAgICAgICAgICAgIGRlY29kZWQucHVzaChkLmRhdGEpO1xuICAgICAgICAgICAgaW5uZXJSZW1haW5kZXIgPSBkLnJlbWFpbmRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogZGVjb2RlZCxcbiAgICAgICAgICAgIHJlbWFpbmRlcjogaW5wdXQuc2xpY2UodG90YWxMZW5ndGgpLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmNvbnN0IGNhY2hlZEhleGVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfdiwgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG5mdW5jdGlvbiBieXRlc1RvSGV4KHVpbnQ4YSkge1xuICAgIC8vIFByZS1jYWNoaW5nIGNoYXJzIHdpdGggYGNhY2hlZEhleGVzYCBzcGVlZHMgdGhpcyB1cCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVpbnQ4YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gY2FjaGVkSGV4ZXNbdWludDhhW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmZ1bmN0aW9uIHBhcnNlSGV4Qnl0ZShoZXhCeXRlKSB7XG4gICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgaWYgKE51bWJlci5pc05hTihieXRlKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICByZXR1cm4gYnl0ZTtcbn1cbi8vIENhY2hpbmcgc2xvd3MgaXQgZG93biAyLTN4XG5mdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoZXhUb0J5dGVzOiBleHBlY3RlZCBzdHJpbmcsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgfVxuICAgIGlmIChoZXgubGVuZ3RoICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXhUb0J5dGVzOiByZWNlaXZlZCBpbnZhbGlkIHVucGFkZGVkIGhleCcpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoaGV4Lmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBhcnJheVtpXSA9IHBhcnNlSGV4Qnl0ZShoZXguc2xpY2UoaiwgaiArIDIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLyoqIENvbmNhdGVuYXRlcyB0d28gVWludDhBcnJheXMgaW50byBvbmUuICovXG5mdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBpZiAoYXJyYXlzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgcmV0dXJuIGFycmF5c1swXTtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheXMucmVkdWNlKChhLCBhcnIpID0+IGEgKyBhcnIubGVuZ3RoLCAwKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzdWx0LnNldChhcnIsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhcnIubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdXRmOFRvQnl0ZXModXRmKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh1dGYpO1xufVxuLyoqIFRyYW5zZm9ybSBhbiBpbnRlZ2VyIGludG8gaXRzIGhleGFkZWNpbWFsIHZhbHVlICovXG5mdW5jdGlvbiBudW1iZXJUb0hleChpbnRlZ2VyKSB7XG4gICAgaWYgKGludGVnZXIgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnRlZ2VyIGFzIGFyZ3VtZW50LCBtdXN0IGJlIHVuc2lnbmVkIScpO1xuICAgIH1cbiAgICBjb25zdCBoZXggPSBpbnRlZ2VyLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCAlIDIgPyBgMCR7aGV4fWAgOiBoZXg7XG59XG4vKiogUGFkIGEgc3RyaW5nIHRvIGJlIGV2ZW4gKi9cbmZ1bmN0aW9uIHBhZFRvRXZlbihhKSB7XG4gICAgcmV0dXJuIGEubGVuZ3RoICUgMiA/IGAwJHthfWAgOiBhO1xufVxuLyoqIENoZWNrIGlmIGEgc3RyaW5nIGlzIHByZWZpeGVkIGJ5IDB4ICovXG5mdW5jdGlvbiBpc0hleFByZWZpeGVkKHN0cikge1xuICAgIHJldHVybiBzdHIubGVuZ3RoID49IDIgJiYgc3RyWzBdID09PSAnMCcgJiYgc3RyWzFdID09PSAneCc7XG59XG4vKiogUmVtb3ZlcyAweCBmcm9tIGEgZ2l2ZW4gU3RyaW5nICovXG5mdW5jdGlvbiBzdHJpcEhleFByZWZpeChzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIGlzSGV4UHJlZml4ZWQoc3RyKSA/IHN0ci5zbGljZSgyKSA6IHN0cjtcbn1cbi8qKiBUcmFuc2Zvcm0gYW55dGhpbmcgaW50byBhIFVpbnQ4QXJyYXkgKi9cbmZ1bmN0aW9uIHRvQnl0ZXModikge1xuICAgIGlmICh2IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoaXNIZXhQcmVmaXhlZCh2KSkge1xuICAgICAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXMocGFkVG9FdmVuKHN0cmlwSGV4UHJlZml4KHYpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHYpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2ID09PSAnYmlnaW50Jykge1xuICAgICAgICBpZiAoIXYpIHtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oW10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXhUb0J5dGVzKG51bWJlclRvSGV4KHYpKTtcbiAgICB9XG4gICAgaWYgKHYgPT09IG51bGwgfHwgdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oW10pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvQnl0ZXM6IHJlY2VpdmVkIHVuc3VwcG9ydGVkIHR5cGUgJyArIHR5cGVvZiB2KTtcbn1cbmV4cG9ydHMudXRpbHMgPSB7XG4gICAgYnl0ZXNUb0hleCxcbiAgICBjb25jYXRCeXRlcyxcbiAgICBoZXhUb0J5dGVzLFxuICAgIHV0ZjhUb0J5dGVzLFxufTtcbmV4cG9ydHMuUkxQID0geyBlbmNvZGUsIGRlY29kZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/rlp/dist/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/account.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/account.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.accountBodyToRLP = exports.accountBodyToSlim = exports.accountBodyFromSlim = exports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\nconst rlp_1 = __webpack_require__(/*! @ethereumjs/rlp */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/rlp/dist/index.js\");\nconst keccak_1 = __webpack_require__(/*! ethereum-cryptography/keccak */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/ethereum-cryptography/keccak.js\");\nconst secp256k1_1 = __webpack_require__(/*! ethereum-cryptography/secp256k1 */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/ethereum-cryptography/secp256k1.js\");\nconst utils_1 = __webpack_require__(/*! ethereum-cryptography/utils */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/ethereum-cryptography/utils.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/bytes.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/constants.js\");\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/helpers.js\");\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/internal.js\");\nconst _0n = BigInt(0);\nclass Account {\n    /**\n     * This constructor assigns and validates the values.\n     * Use the static factory methods to assist in creating an Account from varying data types.\n     */\n    constructor(nonce = _0n, balance = _0n, storageRoot = constants_1.KECCAK256_RLP, codeHash = constants_1.KECCAK256_NULL) {\n        this.nonce = nonce;\n        this.balance = balance;\n        this.storageRoot = storageRoot;\n        this.codeHash = codeHash;\n        this._validate();\n    }\n    static fromAccountData(accountData) {\n        const { nonce, balance, storageRoot, codeHash } = accountData;\n        return new Account(nonce !== undefined ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(nonce)) : undefined, balance !== undefined ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(balance)) : undefined, storageRoot !== undefined ? (0, bytes_1.toBuffer)(storageRoot) : undefined, codeHash !== undefined ? (0, bytes_1.toBuffer)(codeHash) : undefined);\n    }\n    static fromRlpSerializedAccount(serialized) {\n        const values = (0, bytes_1.arrToBufArr)(rlp_1.RLP.decode(Uint8Array.from(serialized)));\n        if (!Array.isArray(values)) {\n            throw new Error('Invalid serialized account input. Must be array');\n        }\n        return this.fromValuesArray(values);\n    }\n    static fromValuesArray(values) {\n        const [nonce, balance, storageRoot, codeHash] = values;\n        return new Account((0, bytes_1.bufferToBigInt)(nonce), (0, bytes_1.bufferToBigInt)(balance), storageRoot, codeHash);\n    }\n    _validate() {\n        if (this.nonce < _0n) {\n            throw new Error('nonce must be greater than zero');\n        }\n        if (this.balance < _0n) {\n            throw new Error('balance must be greater than zero');\n        }\n        if (this.storageRoot.length !== 32) {\n            throw new Error('storageRoot must have a length of 32');\n        }\n        if (this.codeHash.length !== 32) {\n            throw new Error('codeHash must have a length of 32');\n        }\n    }\n    /**\n     * Returns a Buffer Array of the raw Buffers for the account, in order.\n     */\n    raw() {\n        return [\n            (0, bytes_1.bigIntToUnpaddedBuffer)(this.nonce),\n            (0, bytes_1.bigIntToUnpaddedBuffer)(this.balance),\n            this.storageRoot,\n            this.codeHash,\n        ];\n    }\n    /**\n     * Returns the RLP serialization of the account as a `Buffer`.\n     */\n    serialize() {\n        return Buffer.from(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)(this.raw())));\n    }\n    /**\n     * Returns a `Boolean` determining if the account is a contract.\n     */\n    isContract() {\n        return !this.codeHash.equals(constants_1.KECCAK256_NULL);\n    }\n    /**\n     * Returns a `Boolean` determining if the account is empty complying to the definition of\n     * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n     * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n     */\n    isEmpty() {\n        return this.balance === _0n && this.nonce === _0n && this.codeHash.equals(constants_1.KECCAK256_NULL);\n    }\n}\nexports.Account = Account;\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nconst isValidAddress = function (hexAddress) {\n    try {\n        (0, helpers_1.assertIsString)(hexAddress);\n    }\n    catch (e) {\n        return false;\n    }\n    return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\nexports.isValidAddress = isValidAddress;\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */\nconst toChecksumAddress = function (hexAddress, eip1191ChainId) {\n    (0, helpers_1.assertIsHexString)(hexAddress);\n    const address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();\n    let prefix = '';\n    if (eip1191ChainId !== undefined) {\n        const chainId = (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(eip1191ChainId));\n        prefix = chainId.toString() + '0x';\n    }\n    const buf = Buffer.from(prefix + address, 'utf8');\n    const hash = (0, utils_1.bytesToHex)((0, keccak_1.keccak256)(buf));\n    let ret = '0x';\n    for (let i = 0; i < address.length; i++) {\n        if (parseInt(hash[i], 16) >= 8) {\n            ret += address[i].toUpperCase();\n        }\n        else {\n            ret += address[i];\n        }\n    }\n    return ret;\n};\nexports.toChecksumAddress = toChecksumAddress;\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nconst isValidChecksumAddress = function (hexAddress, eip1191ChainId) {\n    return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;\n};\nexports.isValidChecksumAddress = isValidChecksumAddress;\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nconst generateAddress = function (from, nonce) {\n    (0, helpers_1.assertIsBuffer)(from);\n    (0, helpers_1.assertIsBuffer)(nonce);\n    if ((0, bytes_1.bufferToBigInt)(nonce) === BigInt(0)) {\n        // in RLP we want to encode null in the case of zero nonce\n        // read the RLP documentation for an answer if you dare\n        return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, null])))).slice(-20);\n    }\n    // Only take the lower 160bits of the hash\n    return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, nonce])))).slice(-20);\n};\nexports.generateAddress = generateAddress;\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nconst generateAddress2 = function (from, salt, initCode) {\n    (0, helpers_1.assertIsBuffer)(from);\n    (0, helpers_1.assertIsBuffer)(salt);\n    (0, helpers_1.assertIsBuffer)(initCode);\n    if (from.length !== 20) {\n        throw new Error('Expected from to be of length 20');\n    }\n    if (salt.length !== 32) {\n        throw new Error('Expected salt to be of length 32');\n    }\n    const address = (0, keccak_1.keccak256)(Buffer.concat([Buffer.from('ff', 'hex'), from, salt, (0, keccak_1.keccak256)(initCode)]));\n    return (0, bytes_1.toBuffer)(address).slice(-20);\n};\nexports.generateAddress2 = generateAddress2;\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nconst isValidPrivate = function (privateKey) {\n    return secp256k1_1.secp256k1.utils.isValidPrivateKey(privateKey);\n};\nexports.isValidPrivate = isValidPrivate;\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nconst isValidPublic = function (publicKey, sanitize = false) {\n    (0, helpers_1.assertIsBuffer)(publicKey);\n    if (publicKey.length === 64) {\n        // Convert to SEC1 for secp256k1\n        // Automatically checks whether point is on curve\n        try {\n            secp256k1_1.secp256k1.ProjectivePoint.fromHex(Buffer.concat([Buffer.from([4]), publicKey]));\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    if (!sanitize) {\n        return false;\n    }\n    try {\n        secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicKey);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n};\nexports.isValidPublic = isValidPublic;\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nconst pubToAddress = function (pubKey, sanitize = false) {\n    (0, helpers_1.assertIsBuffer)(pubKey);\n    if (sanitize && pubKey.length !== 64) {\n        pubKey = Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1));\n    }\n    if (pubKey.length !== 64) {\n        throw new Error('Expected pubKey to be of length 64');\n    }\n    // Only take the lower 160bits of the hash\n    return Buffer.from((0, keccak_1.keccak256)(pubKey)).slice(-20);\n};\nexports.pubToAddress = pubToAddress;\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nconst privateToPublic = function (privateKey) {\n    (0, helpers_1.assertIsBuffer)(privateKey);\n    // skip the type flag and use the X, Y points\n    return Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(false).slice(1));\n};\nexports.privateToPublic = privateToPublic;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nconst privateToAddress = function (privateKey) {\n    return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));\n};\nexports.privateToAddress = privateToAddress;\n/**\n * Converts a public key to the Ethereum format.\n */\nconst importPublic = function (publicKey) {\n    (0, helpers_1.assertIsBuffer)(publicKey);\n    if (publicKey.length !== 64) {\n        publicKey = Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicKey).toRawBytes(false).slice(1));\n    }\n    return publicKey;\n};\nexports.importPublic = importPublic;\n/**\n * Returns the zero address.\n */\nconst zeroAddress = function () {\n    const addressLength = 20;\n    const addr = (0, bytes_1.zeros)(addressLength);\n    return (0, bytes_1.bufferToHex)(addr);\n};\nexports.zeroAddress = zeroAddress;\n/**\n * Checks if a given address is the zero address.\n */\nconst isZeroAddress = function (hexAddress) {\n    try {\n        (0, helpers_1.assertIsString)(hexAddress);\n    }\n    catch (e) {\n        return false;\n    }\n    const zeroAddr = (0, exports.zeroAddress)();\n    return zeroAddr === hexAddress;\n};\nexports.isZeroAddress = isZeroAddress;\nfunction accountBodyFromSlim(body) {\n    const [nonce, balance, storageRoot, codeHash] = body;\n    return [\n        nonce,\n        balance,\n        (0, bytes_1.arrToBufArr)(storageRoot).length === 0 ? constants_1.KECCAK256_RLP : storageRoot,\n        (0, bytes_1.arrToBufArr)(codeHash).length === 0 ? constants_1.KECCAK256_NULL : codeHash,\n    ];\n}\nexports.accountBodyFromSlim = accountBodyFromSlim;\nconst emptyUint8Arr = new Uint8Array(0);\nfunction accountBodyToSlim(body) {\n    const [nonce, balance, storageRoot, codeHash] = body;\n    return [\n        nonce,\n        balance,\n        (0, bytes_1.arrToBufArr)(storageRoot).equals(constants_1.KECCAK256_RLP) ? emptyUint8Arr : storageRoot,\n        (0, bytes_1.arrToBufArr)(codeHash).equals(constants_1.KECCAK256_NULL) ? emptyUint8Arr : codeHash,\n    ];\n}\nexports.accountBodyToSlim = accountBodyToSlim;\n/**\n * Converts a slim account (per snap protocol spec) to the RLP encoded version of the account\n * @param body Array of 4 Buffer-like items to represent the account\n * @returns RLP encoded version of the account\n */\nfunction accountBodyToRLP(body, couldBeSlim = true) {\n    const accountBody = couldBeSlim ? accountBodyFromSlim(body) : body;\n    return (0, bytes_1.arrToBufArr)(rlp_1.RLP.encode(accountBody));\n}\nexports.accountBodyToRLP = accountBodyToRLP;\n//# sourceMappingURL=account.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9hY2NvdW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QixHQUFHLHlCQUF5QixHQUFHLDJCQUEyQixHQUFHLHFCQUFxQixHQUFHLG1CQUFtQixHQUFHLG9CQUFvQixHQUFHLHdCQUF3QixHQUFHLHVCQUF1QixHQUFHLHVCQUF1QixHQUFHLG9CQUFvQixHQUFHLHFCQUFxQixHQUFHLHNCQUFzQixHQUFHLHdCQUF3QixHQUFHLHVCQUF1QixHQUFHLDhCQUE4QixHQUFHLHlCQUF5QixHQUFHLHNCQUFzQixHQUFHLGVBQWU7QUFDM2MsY0FBYyxtQkFBTyxDQUFDLG1IQUFpQjtBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQyxrSUFBOEI7QUFDdkQsb0JBQW9CLG1CQUFPLENBQUMsd0lBQWlDO0FBQzdELGdCQUFnQixtQkFBTyxDQUFDLGdJQUE2QjtBQUNyRCxnQkFBZ0IsbUJBQU8sQ0FBQyw0R0FBUztBQUNqQyxvQkFBb0IsbUJBQU8sQ0FBQyxvSEFBYTtBQUN6QyxrQkFBa0IsbUJBQU8sQ0FBQyxnSEFBVztBQUNyQyxtQkFBbUIsbUJBQU8sQ0FBQyxrSEFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdDQUF3QztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEdBQUc7QUFDOUI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXNpZy11dGlsL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy91dGlsL2Rpc3QvYWNjb3VudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWNjb3VudEJvZHlUb1JMUCA9IGV4cG9ydHMuYWNjb3VudEJvZHlUb1NsaW0gPSBleHBvcnRzLmFjY291bnRCb2R5RnJvbVNsaW0gPSBleHBvcnRzLmlzWmVyb0FkZHJlc3MgPSBleHBvcnRzLnplcm9BZGRyZXNzID0gZXhwb3J0cy5pbXBvcnRQdWJsaWMgPSBleHBvcnRzLnByaXZhdGVUb0FkZHJlc3MgPSBleHBvcnRzLnByaXZhdGVUb1B1YmxpYyA9IGV4cG9ydHMucHVibGljVG9BZGRyZXNzID0gZXhwb3J0cy5wdWJUb0FkZHJlc3MgPSBleHBvcnRzLmlzVmFsaWRQdWJsaWMgPSBleHBvcnRzLmlzVmFsaWRQcml2YXRlID0gZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MyID0gZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MgPSBleHBvcnRzLmlzVmFsaWRDaGVja3N1bUFkZHJlc3MgPSBleHBvcnRzLnRvQ2hlY2tzdW1BZGRyZXNzID0gZXhwb3J0cy5pc1ZhbGlkQWRkcmVzcyA9IGV4cG9ydHMuQWNjb3VudCA9IHZvaWQgMDtcbmNvbnN0IHJscF8xID0gcmVxdWlyZShcIkBldGhlcmV1bWpzL3JscFwiKTtcbmNvbnN0IGtlY2Nha18xID0gcmVxdWlyZShcImV0aGVyZXVtLWNyeXB0b2dyYXBoeS9rZWNjYWtcIik7XG5jb25zdCBzZWNwMjU2azFfMSA9IHJlcXVpcmUoXCJldGhlcmV1bS1jcnlwdG9ncmFwaHkvc2VjcDI1NmsxXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJldGhlcmV1bS1jcnlwdG9ncmFwaHkvdXRpbHNcIik7XG5jb25zdCBieXRlc18xID0gcmVxdWlyZShcIi4vYnl0ZXNcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGhlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIik7XG5jb25zdCBpbnRlcm5hbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWxcIik7XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jbGFzcyBBY2NvdW50IHtcbiAgICAvKipcbiAgICAgKiBUaGlzIGNvbnN0cnVjdG9yIGFzc2lnbnMgYW5kIHZhbGlkYXRlcyB0aGUgdmFsdWVzLlxuICAgICAqIFVzZSB0aGUgc3RhdGljIGZhY3RvcnkgbWV0aG9kcyB0byBhc3Npc3QgaW4gY3JlYXRpbmcgYW4gQWNjb3VudCBmcm9tIHZhcnlpbmcgZGF0YSB0eXBlcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihub25jZSA9IF8wbiwgYmFsYW5jZSA9IF8wbiwgc3RvcmFnZVJvb3QgPSBjb25zdGFudHNfMS5LRUNDQUsyNTZfUkxQLCBjb2RlSGFzaCA9IGNvbnN0YW50c18xLktFQ0NBSzI1Nl9OVUxMKSB7XG4gICAgICAgIHRoaXMubm9uY2UgPSBub25jZTtcbiAgICAgICAgdGhpcy5iYWxhbmNlID0gYmFsYW5jZTtcbiAgICAgICAgdGhpcy5zdG9yYWdlUm9vdCA9IHN0b3JhZ2VSb290O1xuICAgICAgICB0aGlzLmNvZGVIYXNoID0gY29kZUhhc2g7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlKCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQWNjb3VudERhdGEoYWNjb3VudERhdGEpIHtcbiAgICAgICAgY29uc3QgeyBub25jZSwgYmFsYW5jZSwgc3RvcmFnZVJvb3QsIGNvZGVIYXNoIH0gPSBhY2NvdW50RGF0YTtcbiAgICAgICAgcmV0dXJuIG5ldyBBY2NvdW50KG5vbmNlICE9PSB1bmRlZmluZWQgPyAoMCwgYnl0ZXNfMS5idWZmZXJUb0JpZ0ludCkoKDAsIGJ5dGVzXzEudG9CdWZmZXIpKG5vbmNlKSkgOiB1bmRlZmluZWQsIGJhbGFuY2UgIT09IHVuZGVmaW5lZCA/ICgwLCBieXRlc18xLmJ1ZmZlclRvQmlnSW50KSgoMCwgYnl0ZXNfMS50b0J1ZmZlcikoYmFsYW5jZSkpIDogdW5kZWZpbmVkLCBzdG9yYWdlUm9vdCAhPT0gdW5kZWZpbmVkID8gKDAsIGJ5dGVzXzEudG9CdWZmZXIpKHN0b3JhZ2VSb290KSA6IHVuZGVmaW5lZCwgY29kZUhhc2ggIT09IHVuZGVmaW5lZCA/ICgwLCBieXRlc18xLnRvQnVmZmVyKShjb2RlSGFzaCkgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVJscFNlcmlhbGl6ZWRBY2NvdW50KHNlcmlhbGl6ZWQpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gKDAsIGJ5dGVzXzEuYXJyVG9CdWZBcnIpKHJscF8xLlJMUC5kZWNvZGUoVWludDhBcnJheS5mcm9tKHNlcmlhbGl6ZWQpKSk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VyaWFsaXplZCBhY2NvdW50IGlucHV0LiBNdXN0IGJlIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVZhbHVlc0FycmF5KHZhbHVlcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tVmFsdWVzQXJyYXkodmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IFtub25jZSwgYmFsYW5jZSwgc3RvcmFnZVJvb3QsIGNvZGVIYXNoXSA9IHZhbHVlcztcbiAgICAgICAgcmV0dXJuIG5ldyBBY2NvdW50KCgwLCBieXRlc18xLmJ1ZmZlclRvQmlnSW50KShub25jZSksICgwLCBieXRlc18xLmJ1ZmZlclRvQmlnSW50KShiYWxhbmNlKSwgc3RvcmFnZVJvb3QsIGNvZGVIYXNoKTtcbiAgICB9XG4gICAgX3ZhbGlkYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5ub25jZSA8IF8wbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub25jZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYmFsYW5jZSA8IF8wbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWxhbmNlIG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdG9yYWdlUm9vdC5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0b3JhZ2VSb290IG11c3QgaGF2ZSBhIGxlbmd0aCBvZiAzMicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvZGVIYXNoLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29kZUhhc2ggbXVzdCBoYXZlIGEgbGVuZ3RoIG9mIDMyJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEJ1ZmZlciBBcnJheSBvZiB0aGUgcmF3IEJ1ZmZlcnMgZm9yIHRoZSBhY2NvdW50LCBpbiBvcmRlci5cbiAgICAgKi9cbiAgICByYXcoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAoMCwgYnl0ZXNfMS5iaWdJbnRUb1VucGFkZGVkQnVmZmVyKSh0aGlzLm5vbmNlKSxcbiAgICAgICAgICAgICgwLCBieXRlc18xLmJpZ0ludFRvVW5wYWRkZWRCdWZmZXIpKHRoaXMuYmFsYW5jZSksXG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2VSb290LFxuICAgICAgICAgICAgdGhpcy5jb2RlSGFzaCxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgUkxQIHNlcmlhbGl6YXRpb24gb2YgdGhlIGFjY291bnQgYXMgYSBgQnVmZmVyYC5cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShybHBfMS5STFAuZW5jb2RlKCgwLCBieXRlc18xLmJ1ZkFyclRvQXJyKSh0aGlzLnJhdygpKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYEJvb2xlYW5gIGRldGVybWluaW5nIGlmIHRoZSBhY2NvdW50IGlzIGEgY29udHJhY3QuXG4gICAgICovXG4gICAgaXNDb250cmFjdCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNvZGVIYXNoLmVxdWFscyhjb25zdGFudHNfMS5LRUNDQUsyNTZfTlVMTCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBgQm9vbGVhbmAgZGV0ZXJtaW5pbmcgaWYgdGhlIGFjY291bnQgaXMgZW1wdHkgY29tcGx5aW5nIHRvIHRoZSBkZWZpbml0aW9uIG9mXG4gICAgICogYWNjb3VudCBlbXB0aW5lc3MgaW4gW0VJUC0xNjFdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMTYxKTpcbiAgICAgKiBcIkFuIGFjY291bnQgaXMgY29uc2lkZXJlZCBlbXB0eSB3aGVuIGl0IGhhcyBubyBjb2RlIGFuZCB6ZXJvIG5vbmNlIGFuZCB6ZXJvIGJhbGFuY2UuXCJcbiAgICAgKi9cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYWxhbmNlID09PSBfMG4gJiYgdGhpcy5ub25jZSA9PT0gXzBuICYmIHRoaXMuY29kZUhhc2guZXF1YWxzKGNvbnN0YW50c18xLktFQ0NBSzI1Nl9OVUxMKTtcbiAgICB9XG59XG5leHBvcnRzLkFjY291bnQgPSBBY2NvdW50O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGFkZHJlc3MgaXMgYSB2YWxpZC4gQWNjZXB0cyBjaGVja3N1bW1lZCBhZGRyZXNzZXMgdG9vLlxuICovXG5jb25zdCBpc1ZhbGlkQWRkcmVzcyA9IGZ1bmN0aW9uIChoZXhBZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc1N0cmluZykoaGV4QWRkcmVzcyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIC9eMHhbMC05YS1mQS1GXXs0MH0kLy50ZXN0KGhleEFkZHJlc3MpO1xufTtcbmV4cG9ydHMuaXNWYWxpZEFkZHJlc3MgPSBpc1ZhbGlkQWRkcmVzcztcbi8qKlxuICogUmV0dXJucyBhIGNoZWNrc3VtbWVkIGFkZHJlc3MuXG4gKlxuICogSWYgYW4gZWlwMTE5MUNoYWluSWQgaXMgcHJvdmlkZWQsIHRoZSBjaGFpbklkIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIGNoZWNrc3VtIGNhbGN1bGF0aW9uLiBUaGlzXG4gKiBoYXMgdGhlIGVmZmVjdCBvZiBjaGVja3N1bW1lZCBhZGRyZXNzZXMgZm9yIG9uZSBjaGFpbiBoYXZpbmcgaW52YWxpZCBjaGVja3N1bXMgZm9yIG90aGVycy5cbiAqIEZvciBtb3JlIGRldGFpbHMgc2VlIFtFSVAtMTE5MV0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xMTkxKS5cbiAqXG4gKiBXQVJOSU5HOiBDaGVja3N1bXMgd2l0aCBhbmQgd2l0aG91dCB0aGUgY2hhaW5JZCB3aWxsIGRpZmZlciBhbmQgdGhlIEVJUC0xMTkxIGNoZWNrc3VtIGlzIG5vdFxuICogYmFja3dhcmRzIGNvbXBhdGlibGUgdG8gdGhlIG9yaWdpbmFsIHdpZGVseSBhZG9wdGVkIGNoZWNrc3VtIGZvcm1hdCBzdGFuZGFyZCBpbnRyb2R1Y2VkIGluXG4gKiBbRUlQLTU1XShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTU1KSwgc28gdGhpcyB3aWxsIGJyZWFrIGluIGV4aXN0aW5nIGFwcGxpY2F0aW9ucy5cbiAqIFVzYWdlIG9mIHRoaXMgRUlQIGlzIHRoZXJlZm9yZSBkaXNjb3VyYWdlZCB1bmxlc3MgeW91IGhhdmUgYSB2ZXJ5IHRhcmdldGVkIHVzZSBjYXNlLlxuICovXG5jb25zdCB0b0NoZWNrc3VtQWRkcmVzcyA9IGZ1bmN0aW9uIChoZXhBZGRyZXNzLCBlaXAxMTkxQ2hhaW5JZCkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNIZXhTdHJpbmcpKGhleEFkZHJlc3MpO1xuICAgIGNvbnN0IGFkZHJlc3MgPSAoMCwgaW50ZXJuYWxfMS5zdHJpcEhleFByZWZpeCkoaGV4QWRkcmVzcykudG9Mb3dlckNhc2UoKTtcbiAgICBsZXQgcHJlZml4ID0gJyc7XG4gICAgaWYgKGVpcDExOTFDaGFpbklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgY2hhaW5JZCA9ICgwLCBieXRlc18xLmJ1ZmZlclRvQmlnSW50KSgoMCwgYnl0ZXNfMS50b0J1ZmZlcikoZWlwMTE5MUNoYWluSWQpKTtcbiAgICAgICAgcHJlZml4ID0gY2hhaW5JZC50b1N0cmluZygpICsgJzB4JztcbiAgICB9XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmZyb20ocHJlZml4ICsgYWRkcmVzcywgJ3V0ZjgnKTtcbiAgICBjb25zdCBoYXNoID0gKDAsIHV0aWxzXzEuYnl0ZXNUb0hleCkoKDAsIGtlY2Nha18xLmtlY2NhazI1NikoYnVmKSk7XG4gICAgbGV0IHJldCA9ICcweCc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRyZXNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwYXJzZUludChoYXNoW2ldLCAxNikgPj0gOCkge1xuICAgICAgICAgICAgcmV0ICs9IGFkZHJlc3NbaV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldCArPSBhZGRyZXNzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuZXhwb3J0cy50b0NoZWNrc3VtQWRkcmVzcyA9IHRvQ2hlY2tzdW1BZGRyZXNzO1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGFkZHJlc3MgaXMgYSB2YWxpZCBjaGVja3N1bW1lZCBhZGRyZXNzLlxuICpcbiAqIFNlZSB0b0NoZWNrc3VtQWRkcmVzcycgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlscyBhYm91dCB0aGUgZWlwMTE5MUNoYWluSWQgcGFyYW1ldGVyLlxuICovXG5jb25zdCBpc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzID0gZnVuY3Rpb24gKGhleEFkZHJlc3MsIGVpcDExOTFDaGFpbklkKSB7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLmlzVmFsaWRBZGRyZXNzKShoZXhBZGRyZXNzKSAmJiAoMCwgZXhwb3J0cy50b0NoZWNrc3VtQWRkcmVzcykoaGV4QWRkcmVzcywgZWlwMTE5MUNoYWluSWQpID09PSBoZXhBZGRyZXNzO1xufTtcbmV4cG9ydHMuaXNWYWxpZENoZWNrc3VtQWRkcmVzcyA9IGlzVmFsaWRDaGVja3N1bUFkZHJlc3M7XG4vKipcbiAqIEdlbmVyYXRlcyBhbiBhZGRyZXNzIG9mIGEgbmV3bHkgY3JlYXRlZCBjb250cmFjdC5cbiAqIEBwYXJhbSBmcm9tIFRoZSBhZGRyZXNzIHdoaWNoIGlzIGNyZWF0aW5nIHRoaXMgbmV3IGFkZHJlc3NcbiAqIEBwYXJhbSBub25jZSBUaGUgbm9uY2Ugb2YgdGhlIGZyb20gYWNjb3VudFxuICovXG5jb25zdCBnZW5lcmF0ZUFkZHJlc3MgPSBmdW5jdGlvbiAoZnJvbSwgbm9uY2UpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShmcm9tKTtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShub25jZSk7XG4gICAgaWYgKCgwLCBieXRlc18xLmJ1ZmZlclRvQmlnSW50KShub25jZSkgPT09IEJpZ0ludCgwKSkge1xuICAgICAgICAvLyBpbiBSTFAgd2Ugd2FudCB0byBlbmNvZGUgbnVsbCBpbiB0aGUgY2FzZSBvZiB6ZXJvIG5vbmNlXG4gICAgICAgIC8vIHJlYWQgdGhlIFJMUCBkb2N1bWVudGF0aW9uIGZvciBhbiBhbnN3ZXIgaWYgeW91IGRhcmVcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKCgwLCBrZWNjYWtfMS5rZWNjYWsyNTYpKHJscF8xLlJMUC5lbmNvZGUoKDAsIGJ5dGVzXzEuYnVmQXJyVG9BcnIpKFtmcm9tLCBudWxsXSkpKSkuc2xpY2UoLTIwKTtcbiAgICB9XG4gICAgLy8gT25seSB0YWtlIHRoZSBsb3dlciAxNjBiaXRzIG9mIHRoZSBoYXNoXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKCgwLCBrZWNjYWtfMS5rZWNjYWsyNTYpKHJscF8xLlJMUC5lbmNvZGUoKDAsIGJ5dGVzXzEuYnVmQXJyVG9BcnIpKFtmcm9tLCBub25jZV0pKSkpLnNsaWNlKC0yMCk7XG59O1xuZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MgPSBnZW5lcmF0ZUFkZHJlc3M7XG4vKipcbiAqIEdlbmVyYXRlcyBhbiBhZGRyZXNzIGZvciBhIGNvbnRyYWN0IGNyZWF0ZWQgdXNpbmcgQ1JFQVRFMi5cbiAqIEBwYXJhbSBmcm9tIFRoZSBhZGRyZXNzIHdoaWNoIGlzIGNyZWF0aW5nIHRoaXMgbmV3IGFkZHJlc3NcbiAqIEBwYXJhbSBzYWx0IEEgc2FsdFxuICogQHBhcmFtIGluaXRDb2RlIFRoZSBpbml0IGNvZGUgb2YgdGhlIGNvbnRyYWN0IGJlaW5nIGNyZWF0ZWRcbiAqL1xuY29uc3QgZ2VuZXJhdGVBZGRyZXNzMiA9IGZ1bmN0aW9uIChmcm9tLCBzYWx0LCBpbml0Q29kZSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKGZyb20pO1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKHNhbHQpO1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKGluaXRDb2RlKTtcbiAgICBpZiAoZnJvbS5sZW5ndGggIT09IDIwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZnJvbSB0byBiZSBvZiBsZW5ndGggMjAnKTtcbiAgICB9XG4gICAgaWYgKHNhbHQubGVuZ3RoICE9PSAzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHNhbHQgdG8gYmUgb2YgbGVuZ3RoIDMyJyk7XG4gICAgfVxuICAgIGNvbnN0IGFkZHJlc3MgPSAoMCwga2VjY2FrXzEua2VjY2FrMjU2KShCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbSgnZmYnLCAnaGV4JyksIGZyb20sIHNhbHQsICgwLCBrZWNjYWtfMS5rZWNjYWsyNTYpKGluaXRDb2RlKV0pKTtcbiAgICByZXR1cm4gKDAsIGJ5dGVzXzEudG9CdWZmZXIpKGFkZHJlc3MpLnNsaWNlKC0yMCk7XG59O1xuZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MyID0gZ2VuZXJhdGVBZGRyZXNzMjtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwcml2YXRlIGtleSBzYXRpc2ZpZXMgdGhlIHJ1bGVzIG9mIHRoZSBjdXJ2ZSBzZWNwMjU2azEuXG4gKi9cbmNvbnN0IGlzVmFsaWRQcml2YXRlID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gc2VjcDI1NmsxXzEuc2VjcDI1NmsxLnV0aWxzLmlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpO1xufTtcbmV4cG9ydHMuaXNWYWxpZFByaXZhdGUgPSBpc1ZhbGlkUHJpdmF0ZTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwdWJsaWMga2V5IHNhdGlzZmllcyB0aGUgcnVsZXMgb2YgdGhlIGN1cnZlIHNlY3AyNTZrMVxuICogYW5kIHRoZSByZXF1aXJlbWVudHMgb2YgRXRoZXJldW0uXG4gKiBAcGFyYW0gcHVibGljS2V5IFRoZSB0d28gcG9pbnRzIG9mIGFuIHVuY29tcHJlc3NlZCBrZXksIHVubGVzcyBzYW5pdGl6ZSBpcyBlbmFibGVkXG4gKiBAcGFyYW0gc2FuaXRpemUgQWNjZXB0IHB1YmxpYyBrZXlzIGluIG90aGVyIGZvcm1hdHNcbiAqL1xuY29uc3QgaXNWYWxpZFB1YmxpYyA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHNhbml0aXplID0gZmFsc2UpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShwdWJsaWNLZXkpO1xuICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAvLyBDb252ZXJ0IHRvIFNFQzEgZm9yIHNlY3AyNTZrMVxuICAgICAgICAvLyBBdXRvbWF0aWNhbGx5IGNoZWNrcyB3aGV0aGVyIHBvaW50IGlzIG9uIGN1cnZlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZWNwMjU2azFfMS5zZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21IZXgoQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oWzRdKSwgcHVibGljS2V5XSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXNhbml0aXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgc2VjcDI1NmsxXzEuc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludC5mcm9tSGV4KHB1YmxpY0tleSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbmV4cG9ydHMuaXNWYWxpZFB1YmxpYyA9IGlzVmFsaWRQdWJsaWM7XG4vKipcbiAqIFJldHVybnMgdGhlIGV0aGVyZXVtIGFkZHJlc3Mgb2YgYSBnaXZlbiBwdWJsaWMga2V5LlxuICogQWNjZXB0cyBcIkV0aGVyZXVtIHB1YmxpYyBrZXlzXCIgYW5kIFNFQzEgZW5jb2RlZCBrZXlzLlxuICogQHBhcmFtIHB1YktleSBUaGUgdHdvIHBvaW50cyBvZiBhbiB1bmNvbXByZXNzZWQga2V5LCB1bmxlc3Mgc2FuaXRpemUgaXMgZW5hYmxlZFxuICogQHBhcmFtIHNhbml0aXplIEFjY2VwdCBwdWJsaWMga2V5cyBpbiBvdGhlciBmb3JtYXRzXG4gKi9cbmNvbnN0IHB1YlRvQWRkcmVzcyA9IGZ1bmN0aW9uIChwdWJLZXksIHNhbml0aXplID0gZmFsc2UpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShwdWJLZXkpO1xuICAgIGlmIChzYW5pdGl6ZSAmJiBwdWJLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgICAgICBwdWJLZXkgPSBCdWZmZXIuZnJvbShzZWNwMjU2azFfMS5zZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21IZXgocHViS2V5KS50b1Jhd0J5dGVzKGZhbHNlKS5zbGljZSgxKSk7XG4gICAgfVxuICAgIGlmIChwdWJLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHB1YktleSB0byBiZSBvZiBsZW5ndGggNjQnKTtcbiAgICB9XG4gICAgLy8gT25seSB0YWtlIHRoZSBsb3dlciAxNjBiaXRzIG9mIHRoZSBoYXNoXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKCgwLCBrZWNjYWtfMS5rZWNjYWsyNTYpKHB1YktleSkpLnNsaWNlKC0yMCk7XG59O1xuZXhwb3J0cy5wdWJUb0FkZHJlc3MgPSBwdWJUb0FkZHJlc3M7XG5leHBvcnRzLnB1YmxpY1RvQWRkcmVzcyA9IGV4cG9ydHMucHViVG9BZGRyZXNzO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBwdWJsaWMga2V5IG9mIGEgZ2l2ZW4gcHJpdmF0ZSBrZXkuXG4gKiBAcGFyYW0gcHJpdmF0ZUtleSBBIHByaXZhdGUga2V5IG11c3QgYmUgMjU2IGJpdHMgd2lkZVxuICovXG5jb25zdCBwcml2YXRlVG9QdWJsaWMgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKHByaXZhdGVLZXkpO1xuICAgIC8vIHNraXAgdGhlIHR5cGUgZmxhZyBhbmQgdXNlIHRoZSBYLCBZIHBvaW50c1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azFfMS5zZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpLnRvUmF3Qnl0ZXMoZmFsc2UpLnNsaWNlKDEpKTtcbn07XG5leHBvcnRzLnByaXZhdGVUb1B1YmxpYyA9IHByaXZhdGVUb1B1YmxpYztcbi8qKlxuICogUmV0dXJucyB0aGUgZXRoZXJldW0gYWRkcmVzcyBvZiBhIGdpdmVuIHByaXZhdGUga2V5LlxuICogQHBhcmFtIHByaXZhdGVLZXkgQSBwcml2YXRlIGtleSBtdXN0IGJlIDI1NiBiaXRzIHdpZGVcbiAqL1xuY29uc3QgcHJpdmF0ZVRvQWRkcmVzcyA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLnB1YmxpY1RvQWRkcmVzcykoKDAsIGV4cG9ydHMucHJpdmF0ZVRvUHVibGljKShwcml2YXRlS2V5KSk7XG59O1xuZXhwb3J0cy5wcml2YXRlVG9BZGRyZXNzID0gcHJpdmF0ZVRvQWRkcmVzcztcbi8qKlxuICogQ29udmVydHMgYSBwdWJsaWMga2V5IHRvIHRoZSBFdGhlcmV1bSBmb3JtYXQuXG4gKi9cbmNvbnN0IGltcG9ydFB1YmxpYyA9IGZ1bmN0aW9uIChwdWJsaWNLZXkpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShwdWJsaWNLZXkpO1xuICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgICAgICBwdWJsaWNLZXkgPSBCdWZmZXIuZnJvbShzZWNwMjU2azFfMS5zZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21IZXgocHVibGljS2V5KS50b1Jhd0J5dGVzKGZhbHNlKS5zbGljZSgxKSk7XG4gICAgfVxuICAgIHJldHVybiBwdWJsaWNLZXk7XG59O1xuZXhwb3J0cy5pbXBvcnRQdWJsaWMgPSBpbXBvcnRQdWJsaWM7XG4vKipcbiAqIFJldHVybnMgdGhlIHplcm8gYWRkcmVzcy5cbiAqL1xuY29uc3QgemVyb0FkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgYWRkcmVzc0xlbmd0aCA9IDIwO1xuICAgIGNvbnN0IGFkZHIgPSAoMCwgYnl0ZXNfMS56ZXJvcykoYWRkcmVzc0xlbmd0aCk7XG4gICAgcmV0dXJuICgwLCBieXRlc18xLmJ1ZmZlclRvSGV4KShhZGRyKTtcbn07XG5leHBvcnRzLnplcm9BZGRyZXNzID0gemVyb0FkZHJlc3M7XG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIGFkZHJlc3MgaXMgdGhlIHplcm8gYWRkcmVzcy5cbiAqL1xuY29uc3QgaXNaZXJvQWRkcmVzcyA9IGZ1bmN0aW9uIChoZXhBZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc1N0cmluZykoaGV4QWRkcmVzcyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgemVyb0FkZHIgPSAoMCwgZXhwb3J0cy56ZXJvQWRkcmVzcykoKTtcbiAgICByZXR1cm4gemVyb0FkZHIgPT09IGhleEFkZHJlc3M7XG59O1xuZXhwb3J0cy5pc1plcm9BZGRyZXNzID0gaXNaZXJvQWRkcmVzcztcbmZ1bmN0aW9uIGFjY291bnRCb2R5RnJvbVNsaW0oYm9keSkge1xuICAgIGNvbnN0IFtub25jZSwgYmFsYW5jZSwgc3RvcmFnZVJvb3QsIGNvZGVIYXNoXSA9IGJvZHk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbm9uY2UsXG4gICAgICAgIGJhbGFuY2UsXG4gICAgICAgICgwLCBieXRlc18xLmFyclRvQnVmQXJyKShzdG9yYWdlUm9vdCkubGVuZ3RoID09PSAwID8gY29uc3RhbnRzXzEuS0VDQ0FLMjU2X1JMUCA6IHN0b3JhZ2VSb290LFxuICAgICAgICAoMCwgYnl0ZXNfMS5hcnJUb0J1ZkFycikoY29kZUhhc2gpLmxlbmd0aCA9PT0gMCA/IGNvbnN0YW50c18xLktFQ0NBSzI1Nl9OVUxMIDogY29kZUhhc2gsXG4gICAgXTtcbn1cbmV4cG9ydHMuYWNjb3VudEJvZHlGcm9tU2xpbSA9IGFjY291bnRCb2R5RnJvbVNsaW07XG5jb25zdCBlbXB0eVVpbnQ4QXJyID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG5mdW5jdGlvbiBhY2NvdW50Qm9keVRvU2xpbShib2R5KSB7XG4gICAgY29uc3QgW25vbmNlLCBiYWxhbmNlLCBzdG9yYWdlUm9vdCwgY29kZUhhc2hdID0gYm9keTtcbiAgICByZXR1cm4gW1xuICAgICAgICBub25jZSxcbiAgICAgICAgYmFsYW5jZSxcbiAgICAgICAgKDAsIGJ5dGVzXzEuYXJyVG9CdWZBcnIpKHN0b3JhZ2VSb290KS5lcXVhbHMoY29uc3RhbnRzXzEuS0VDQ0FLMjU2X1JMUCkgPyBlbXB0eVVpbnQ4QXJyIDogc3RvcmFnZVJvb3QsXG4gICAgICAgICgwLCBieXRlc18xLmFyclRvQnVmQXJyKShjb2RlSGFzaCkuZXF1YWxzKGNvbnN0YW50c18xLktFQ0NBSzI1Nl9OVUxMKSA/IGVtcHR5VWludDhBcnIgOiBjb2RlSGFzaCxcbiAgICBdO1xufVxuZXhwb3J0cy5hY2NvdW50Qm9keVRvU2xpbSA9IGFjY291bnRCb2R5VG9TbGltO1xuLyoqXG4gKiBDb252ZXJ0cyBhIHNsaW0gYWNjb3VudCAocGVyIHNuYXAgcHJvdG9jb2wgc3BlYykgdG8gdGhlIFJMUCBlbmNvZGVkIHZlcnNpb24gb2YgdGhlIGFjY291bnRcbiAqIEBwYXJhbSBib2R5IEFycmF5IG9mIDQgQnVmZmVyLWxpa2UgaXRlbXMgdG8gcmVwcmVzZW50IHRoZSBhY2NvdW50XG4gKiBAcmV0dXJucyBSTFAgZW5jb2RlZCB2ZXJzaW9uIG9mIHRoZSBhY2NvdW50XG4gKi9cbmZ1bmN0aW9uIGFjY291bnRCb2R5VG9STFAoYm9keSwgY291bGRCZVNsaW0gPSB0cnVlKSB7XG4gICAgY29uc3QgYWNjb3VudEJvZHkgPSBjb3VsZEJlU2xpbSA/IGFjY291bnRCb2R5RnJvbVNsaW0oYm9keSkgOiBib2R5O1xuICAgIHJldHVybiAoMCwgYnl0ZXNfMS5hcnJUb0J1ZkFycikocmxwXzEuUkxQLmVuY29kZShhY2NvdW50Qm9keSkpO1xufVxuZXhwb3J0cy5hY2NvdW50Qm9keVRvUkxQID0gYWNjb3VudEJvZHlUb1JMUDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjY291bnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/account.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/address.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/address.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Address = void 0;\nconst account_1 = __webpack_require__(/*! ./account */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/account.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/bytes.js\");\n/**\n * Handling and generating Ethereum addresses\n */\nclass Address {\n    constructor(buf) {\n        if (buf.length !== 20) {\n            throw new Error('Invalid address length');\n        }\n        this.buf = buf;\n    }\n    /**\n     * Returns the zero address.\n     */\n    static zero() {\n        return new Address((0, bytes_1.zeros)(20));\n    }\n    /**\n     * Returns an Address object from a hex-encoded string.\n     * @param str - Hex-encoded address\n     */\n    static fromString(str) {\n        if (!(0, account_1.isValidAddress)(str)) {\n            throw new Error('Invalid address');\n        }\n        return new Address((0, bytes_1.toBuffer)(str));\n    }\n    /**\n     * Returns an address for a given public key.\n     * @param pubKey The two points of an uncompressed key\n     */\n    static fromPublicKey(pubKey) {\n        if (!Buffer.isBuffer(pubKey)) {\n            throw new Error('Public key should be Buffer');\n        }\n        const buf = (0, account_1.pubToAddress)(pubKey);\n        return new Address(buf);\n    }\n    /**\n     * Returns an address for a given private key.\n     * @param privateKey A private key must be 256 bits wide\n     */\n    static fromPrivateKey(privateKey) {\n        if (!Buffer.isBuffer(privateKey)) {\n            throw new Error('Private key should be Buffer');\n        }\n        const buf = (0, account_1.privateToAddress)(privateKey);\n        return new Address(buf);\n    }\n    /**\n     * Generates an address for a newly created contract.\n     * @param from The address which is creating this new address\n     * @param nonce The nonce of the from account\n     */\n    static generate(from, nonce) {\n        if (typeof nonce !== 'bigint') {\n            throw new Error('Expected nonce to be a bigint');\n        }\n        return new Address((0, account_1.generateAddress)(from.buf, (0, bytes_1.bigIntToBuffer)(nonce)));\n    }\n    /**\n     * Generates an address for a contract created using CREATE2.\n     * @param from The address which is creating this new address\n     * @param salt A salt\n     * @param initCode The init code of the contract being created\n     */\n    static generate2(from, salt, initCode) {\n        if (!Buffer.isBuffer(salt)) {\n            throw new Error('Expected salt to be a Buffer');\n        }\n        if (!Buffer.isBuffer(initCode)) {\n            throw new Error('Expected initCode to be a Buffer');\n        }\n        return new Address((0, account_1.generateAddress2)(from.buf, salt, initCode));\n    }\n    /**\n     * Is address equal to another.\n     */\n    equals(address) {\n        return this.buf.equals(address.buf);\n    }\n    /**\n     * Is address zero.\n     */\n    isZero() {\n        return this.equals(Address.zero());\n    }\n    /**\n     * True if address is in the address range defined\n     * by EIP-1352\n     */\n    isPrecompileOrSystemAddress() {\n        const address = (0, bytes_1.bufferToBigInt)(this.buf);\n        const rangeMin = BigInt(0);\n        const rangeMax = BigInt('0xffff');\n        return address >= rangeMin && address <= rangeMax;\n    }\n    /**\n     * Returns hex encoding of address.\n     */\n    toString() {\n        return '0x' + this.buf.toString('hex');\n    }\n    /**\n     * Returns Buffer representation of address.\n     */\n    toBuffer() {\n        return Buffer.from(this.buf);\n    }\n}\nexports.Address = Address;\n//# sourceMappingURL=address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixrQkFBa0IsbUJBQU8sQ0FBQyxnSEFBVztBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyw0R0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L2FkZHJlc3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFkZHJlc3MgPSB2b2lkIDA7XG5jb25zdCBhY2NvdW50XzEgPSByZXF1aXJlKFwiLi9hY2NvdW50XCIpO1xuY29uc3QgYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2J5dGVzXCIpO1xuLyoqXG4gKiBIYW5kbGluZyBhbmQgZ2VuZXJhdGluZyBFdGhlcmV1bSBhZGRyZXNzZXNcbiAqL1xuY2xhc3MgQWRkcmVzcyB7XG4gICAgY29uc3RydWN0b3IoYnVmKSB7XG4gICAgICAgIGlmIChidWYubGVuZ3RoICE9PSAyMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3MgbGVuZ3RoJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWYgPSBidWY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHplcm8gYWRkcmVzcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgemVybygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzKCgwLCBieXRlc18xLnplcm9zKSgyMCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIEFkZHJlc3Mgb2JqZWN0IGZyb20gYSBoZXgtZW5jb2RlZCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHN0ciAtIEhleC1lbmNvZGVkIGFkZHJlc3NcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhzdHIpIHtcbiAgICAgICAgaWYgKCEoMCwgYWNjb3VudF8xLmlzVmFsaWRBZGRyZXNzKShzdHIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWRkcmVzcycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQWRkcmVzcygoMCwgYnl0ZXNfMS50b0J1ZmZlcikoc3RyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYWRkcmVzcyBmb3IgYSBnaXZlbiBwdWJsaWMga2V5LlxuICAgICAqIEBwYXJhbSBwdWJLZXkgVGhlIHR3byBwb2ludHMgb2YgYW4gdW5jb21wcmVzc2VkIGtleVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tUHVibGljS2V5KHB1YktleSkge1xuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwdWJLZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1B1YmxpYyBrZXkgc2hvdWxkIGJlIEJ1ZmZlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZiA9ICgwLCBhY2NvdW50XzEucHViVG9BZGRyZXNzKShwdWJLZXkpO1xuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3MoYnVmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhZGRyZXNzIGZvciBhIGdpdmVuIHByaXZhdGUga2V5LlxuICAgICAqIEBwYXJhbSBwcml2YXRlS2V5IEEgcHJpdmF0ZSBrZXkgbXVzdCBiZSAyNTYgYml0cyB3aWRlXG4gICAgICovXG4gICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocHJpdmF0ZUtleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJpdmF0ZSBrZXkgc2hvdWxkIGJlIEJ1ZmZlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZiA9ICgwLCBhY2NvdW50XzEucHJpdmF0ZVRvQWRkcmVzcykocHJpdmF0ZUtleSk7XG4gICAgICAgIHJldHVybiBuZXcgQWRkcmVzcyhidWYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYW4gYWRkcmVzcyBmb3IgYSBuZXdseSBjcmVhdGVkIGNvbnRyYWN0LlxuICAgICAqIEBwYXJhbSBmcm9tIFRoZSBhZGRyZXNzIHdoaWNoIGlzIGNyZWF0aW5nIHRoaXMgbmV3IGFkZHJlc3NcbiAgICAgKiBAcGFyYW0gbm9uY2UgVGhlIG5vbmNlIG9mIHRoZSBmcm9tIGFjY291bnRcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2VuZXJhdGUoZnJvbSwgbm9uY2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBub25jZSAhPT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgbm9uY2UgdG8gYmUgYSBiaWdpbnQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3MoKDAsIGFjY291bnRfMS5nZW5lcmF0ZUFkZHJlc3MpKGZyb20uYnVmLCAoMCwgYnl0ZXNfMS5iaWdJbnRUb0J1ZmZlcikobm9uY2UpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhbiBhZGRyZXNzIGZvciBhIGNvbnRyYWN0IGNyZWF0ZWQgdXNpbmcgQ1JFQVRFMi5cbiAgICAgKiBAcGFyYW0gZnJvbSBUaGUgYWRkcmVzcyB3aGljaCBpcyBjcmVhdGluZyB0aGlzIG5ldyBhZGRyZXNzXG4gICAgICogQHBhcmFtIHNhbHQgQSBzYWx0XG4gICAgICogQHBhcmFtIGluaXRDb2RlIFRoZSBpbml0IGNvZGUgb2YgdGhlIGNvbnRyYWN0IGJlaW5nIGNyZWF0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2VuZXJhdGUyKGZyb20sIHNhbHQsIGluaXRDb2RlKSB7XG4gICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHNhbHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHNhbHQgdG8gYmUgYSBCdWZmZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihpbml0Q29kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaW5pdENvZGUgdG8gYmUgYSBCdWZmZXInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3MoKDAsIGFjY291bnRfMS5nZW5lcmF0ZUFkZHJlc3MyKShmcm9tLmJ1Ziwgc2FsdCwgaW5pdENvZGUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgYWRkcmVzcyBlcXVhbCB0byBhbm90aGVyLlxuICAgICAqL1xuICAgIGVxdWFscyhhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Zi5lcXVhbHMoYWRkcmVzcy5idWYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJcyBhZGRyZXNzIHplcm8uXG4gICAgICovXG4gICAgaXNaZXJvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMoQWRkcmVzcy56ZXJvKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIGFkZHJlc3MgaXMgaW4gdGhlIGFkZHJlc3MgcmFuZ2UgZGVmaW5lZFxuICAgICAqIGJ5IEVJUC0xMzUyXG4gICAgICovXG4gICAgaXNQcmVjb21waWxlT3JTeXN0ZW1BZGRyZXNzKCkge1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gKDAsIGJ5dGVzXzEuYnVmZmVyVG9CaWdJbnQpKHRoaXMuYnVmKTtcbiAgICAgICAgY29uc3QgcmFuZ2VNaW4gPSBCaWdJbnQoMCk7XG4gICAgICAgIGNvbnN0IHJhbmdlTWF4ID0gQmlnSW50KCcweGZmZmYnKTtcbiAgICAgICAgcmV0dXJuIGFkZHJlc3MgPj0gcmFuZ2VNaW4gJiYgYWRkcmVzcyA8PSByYW5nZU1heDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBoZXggZW5jb2Rpbmcgb2YgYWRkcmVzcy5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICcweCcgKyB0aGlzLmJ1Zi50b1N0cmluZygnaGV4Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgQnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIGFkZHJlc3MuXG4gICAgICovXG4gICAgdG9CdWZmZXIoKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLmJ1Zik7XG4gICAgfVxufVxuZXhwb3J0cy5BZGRyZXNzID0gQWRkcmVzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZHJlc3MuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/address.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/asyncEventEmitter.js":
/*!*********************************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/asyncEventEmitter.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * Ported to Typescript from original implementation below:\n * https://github.com/ahultgren/async-eventemitter -- MIT licensed\n *\n * Type Definitions based on work by: patarapolw <https://github.com/patarapolw> -- MIT licensed\n * that was contributed to Definitely Typed below:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/async-eventemitter\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsyncEventEmitter = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nasync function runInSeries(context, tasks, data) {\n    let error;\n    for await (const task of tasks) {\n        try {\n            if (task.length < 2) {\n                //sync\n                task.call(context, data);\n            }\n            else {\n                await new Promise((resolve, reject) => {\n                    task.call(context, data, (error) => {\n                        if (error) {\n                            reject(error);\n                        }\n                        else {\n                            resolve();\n                        }\n                    });\n                });\n            }\n        }\n        catch (e) {\n            error = e;\n        }\n    }\n    if (error) {\n        throw error;\n    }\n}\nclass AsyncEventEmitter extends events_1.EventEmitter {\n    emit(event, ...args) {\n        let [data, callback] = args;\n        const self = this;\n        let listeners = self._events[event] ?? [];\n        // Optional data argument\n        if (callback === undefined && typeof data === 'function') {\n            callback = data;\n            data = undefined;\n        }\n        // Special treatment of internal newListener and removeListener events\n        if (event === 'newListener' || event === 'removeListener') {\n            data = {\n                event: data,\n                fn: callback,\n            };\n            callback = undefined;\n        }\n        // A single listener is just a function not an array...\n        listeners = Array.isArray(listeners) ? listeners : [listeners];\n        runInSeries(self, listeners.slice(), data).then(callback).catch(callback);\n        return self.listenerCount(event) > 0;\n    }\n    once(event, listener) {\n        const self = this;\n        let g;\n        if (typeof listener !== 'function') {\n            throw new TypeError('listener must be a function');\n        }\n        // Hack to support set arity\n        if (listener.length >= 2) {\n            g = function (e, next) {\n                self.removeListener(event, g);\n                void listener(e, next);\n            };\n        }\n        else {\n            g = function (e) {\n                self.removeListener(event, g);\n                void listener(e, g);\n            };\n        }\n        self.on(event, g);\n        return self;\n    }\n    first(event, listener) {\n        let listeners = this._events[event] ?? [];\n        // Contract\n        if (typeof listener !== 'function') {\n            throw new TypeError('listener must be a function');\n        }\n        // Listeners are not always an array\n        if (!Array.isArray(listeners)) {\n            ;\n            this._events[event] = listeners = [listeners];\n        }\n        listeners.unshift(listener);\n        return this;\n    }\n    before(event, target, listener) {\n        return this.beforeOrAfter(event, target, listener);\n    }\n    after(event, target, listener) {\n        return this.beforeOrAfter(event, target, listener, 'after');\n    }\n    beforeOrAfter(event, target, listener, beforeOrAfter) {\n        let listeners = this._events[event] ?? [];\n        let i;\n        let index;\n        const add = beforeOrAfter === 'after' ? 1 : 0;\n        // Contract\n        if (typeof listener !== 'function') {\n            throw new TypeError('listener must be a function');\n        }\n        if (typeof target !== 'function') {\n            throw new TypeError('target must be a function');\n        }\n        // Listeners are not always an array\n        if (!Array.isArray(listeners)) {\n            ;\n            this._events[event] = listeners = [listeners];\n        }\n        index = listeners.length;\n        for (i = listeners.length; i--;) {\n            if (listeners[i] === target) {\n                index = i + add;\n                break;\n            }\n        }\n        listeners.splice(index, 0, listener);\n        return this;\n    }\n    on(event, listener) {\n        return super.on(event, listener);\n    }\n    addListener(event, listener) {\n        return super.addListener(event, listener);\n    }\n    prependListener(event, listener) {\n        return super.prependListener(event, listener);\n    }\n    prependOnceListener(event, listener) {\n        return super.prependOnceListener(event, listener);\n    }\n    removeAllListeners(event) {\n        return super.removeAllListeners(event);\n    }\n    removeListener(event, listener) {\n        return super.removeListener(event, listener);\n    }\n    eventNames() {\n        return super.eventNames();\n    }\n    listeners(event) {\n        return super.listeners(event);\n    }\n    listenerCount(event) {\n        return super.listenerCount(event);\n    }\n    getMaxListeners() {\n        return super.getMaxListeners();\n    }\n    setMaxListeners(maxListeners) {\n        return super.setMaxListeners(maxListeners);\n    }\n}\nexports.AsyncEventEmitter = AsyncEventEmitter;\n//# sourceMappingURL=asyncEventEmitter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9hc3luY0V2ZW50RW1pdHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxJQUFJO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QiIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L2FzeW5jRXZlbnRFbWl0dGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBQb3J0ZWQgdG8gVHlwZXNjcmlwdCBmcm9tIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uIGJlbG93OlxuICogaHR0cHM6Ly9naXRodWIuY29tL2FodWx0Z3Jlbi9hc3luYy1ldmVudGVtaXR0ZXIgLS0gTUlUIGxpY2Vuc2VkXG4gKlxuICogVHlwZSBEZWZpbml0aW9ucyBiYXNlZCBvbiB3b3JrIGJ5OiBwYXRhcmFwb2x3IDxodHRwczovL2dpdGh1Yi5jb20vcGF0YXJhcG9sdz4gLS0gTUlUIGxpY2Vuc2VkXG4gKiB0aGF0IHdhcyBjb250cmlidXRlZCB0byBEZWZpbml0ZWx5IFR5cGVkIGJlbG93OlxuICogaHR0cHM6Ly9naXRodWIuY29tL0RlZmluaXRlbHlUeXBlZC9EZWZpbml0ZWx5VHlwZWQvdHJlZS9tYXN0ZXIvdHlwZXMvYXN5bmMtZXZlbnRlbWl0dGVyXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXN5bmNFdmVudEVtaXR0ZXIgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5hc3luYyBmdW5jdGlvbiBydW5JblNlcmllcyhjb250ZXh0LCB0YXNrcywgZGF0YSkge1xuICAgIGxldCBlcnJvcjtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHRhc2sgb2YgdGFza3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0YXNrLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAvL3N5bmNcbiAgICAgICAgICAgICAgICB0YXNrLmNhbGwoY29udGV4dCwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2suY2FsbChjb250ZXh0LCBkYXRhLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmNsYXNzIEFzeW5jRXZlbnRFbWl0dGVyIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIGxldCBbZGF0YSwgY2FsbGJhY2tdID0gYXJncztcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGxldCBsaXN0ZW5lcnMgPSBzZWxmLl9ldmVudHNbZXZlbnRdID8/IFtdO1xuICAgICAgICAvLyBPcHRpb25hbCBkYXRhIGFyZ3VtZW50XG4gICAgICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGRhdGE7XG4gICAgICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNwZWNpYWwgdHJlYXRtZW50IG9mIGludGVybmFsIG5ld0xpc3RlbmVyIGFuZCByZW1vdmVMaXN0ZW5lciBldmVudHNcbiAgICAgICAgaWYgKGV2ZW50ID09PSAnbmV3TGlzdGVuZXInIHx8IGV2ZW50ID09PSAncmVtb3ZlTGlzdGVuZXInKSB7XG4gICAgICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgICAgIGV2ZW50OiBkYXRhLFxuICAgICAgICAgICAgICAgIGZuOiBjYWxsYmFjayxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBIHNpbmdsZSBsaXN0ZW5lciBpcyBqdXN0IGEgZnVuY3Rpb24gbm90IGFuIGFycmF5Li4uXG4gICAgICAgIGxpc3RlbmVycyA9IEFycmF5LmlzQXJyYXkobGlzdGVuZXJzKSA/IGxpc3RlbmVycyA6IFtsaXN0ZW5lcnNdO1xuICAgICAgICBydW5JblNlcmllcyhzZWxmLCBsaXN0ZW5lcnMuc2xpY2UoKSwgZGF0YSkudGhlbihjYWxsYmFjaykuY2F0Y2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gc2VsZi5saXN0ZW5lckNvdW50KGV2ZW50KSA+IDA7XG4gICAgfVxuICAgIG9uY2UoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBsZXQgZztcbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFjayB0byBzdXBwb3J0IHNldCBhcml0eVxuICAgICAgICBpZiAobGlzdGVuZXIubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIGcgPSBmdW5jdGlvbiAoZSwgbmV4dCkge1xuICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGcpO1xuICAgICAgICAgICAgICAgIHZvaWQgbGlzdGVuZXIoZSwgbmV4dCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5yZW1vdmVMaXN0ZW5lcihldmVudCwgZyk7XG4gICAgICAgICAgICAgICAgdm9pZCBsaXN0ZW5lcihlLCBnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5vbihldmVudCwgZyk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgICBmaXJzdChldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgbGV0IGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldmVudF0gPz8gW107XG4gICAgICAgIC8vIENvbnRyYWN0XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIExpc3RlbmVycyBhcmUgbm90IGFsd2F5cyBhbiBhcnJheVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdGVuZXJzKSkge1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50XSA9IGxpc3RlbmVycyA9IFtsaXN0ZW5lcnNdO1xuICAgICAgICB9XG4gICAgICAgIGxpc3RlbmVycy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGJlZm9yZShldmVudCwgdGFyZ2V0LCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVPckFmdGVyKGV2ZW50LCB0YXJnZXQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgYWZ0ZXIoZXZlbnQsIHRhcmdldCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlT3JBZnRlcihldmVudCwgdGFyZ2V0LCBsaXN0ZW5lciwgJ2FmdGVyJyk7XG4gICAgfVxuICAgIGJlZm9yZU9yQWZ0ZXIoZXZlbnQsIHRhcmdldCwgbGlzdGVuZXIsIGJlZm9yZU9yQWZ0ZXIpIHtcbiAgICAgICAgbGV0IGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldmVudF0gPz8gW107XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgaW5kZXg7XG4gICAgICAgIGNvbnN0IGFkZCA9IGJlZm9yZU9yQWZ0ZXIgPT09ICdhZnRlcicgPyAxIDogMDtcbiAgICAgICAgLy8gQ29udHJhY3RcbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhcmdldCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMaXN0ZW5lcnMgYXJlIG5vdCBhbHdheXMgYW4gYXJyYXlcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3RlbmVycykpIHtcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50c1tldmVudF0gPSBsaXN0ZW5lcnMgPSBbbGlzdGVuZXJzXTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0gPT09IHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaSArIGFkZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAwLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIGFkZExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gc3VwZXIuYWRkTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgcHJlcGVuZExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gc3VwZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIHByZXBlbmRPbmNlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5wcmVwZW5kT25jZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICAgICAgICByZXR1cm4gc3VwZXIucmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KTtcbiAgICB9XG4gICAgcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICBldmVudE5hbWVzKCkge1xuICAgICAgICByZXR1cm4gc3VwZXIuZXZlbnROYW1lcygpO1xuICAgIH1cbiAgICBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmxpc3RlbmVycyhldmVudCk7XG4gICAgfVxuICAgIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmxpc3RlbmVyQ291bnQoZXZlbnQpO1xuICAgIH1cbiAgICBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5nZXRNYXhMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgc2V0TWF4TGlzdGVuZXJzKG1heExpc3RlbmVycykge1xuICAgICAgICByZXR1cm4gc3VwZXIuc2V0TWF4TGlzdGVuZXJzKG1heExpc3RlbmVycyk7XG4gICAgfVxufVxuZXhwb3J0cy5Bc3luY0V2ZW50RW1pdHRlciA9IEFzeW5jRXZlbnRFbWl0dGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXN5bmNFdmVudEVtaXR0ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/asyncEventEmitter.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/bytes.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/bytes.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.intToUnpaddedBuffer = exports.bigIntToUnpaddedBuffer = exports.bigIntToHex = exports.bufArrToArr = exports.arrToBufArr = exports.validateNoLeadingZeroes = exports.baToJSON = exports.toUtf8 = exports.short = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToInt = exports.bigIntToBuffer = exports.bufferToBigInt = exports.bufferToHex = exports.toBuffer = exports.unpadHexString = exports.unpadArray = exports.unpadBuffer = exports.setLengthRight = exports.setLengthLeft = exports.zeros = exports.intToBuffer = exports.intToHex = void 0;\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/helpers.js\");\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/internal.js\");\n/**\n * Converts a `Number` into a hex `String`\n * @param {Number} i\n * @return {String}\n */\nconst intToHex = function (i) {\n    if (!Number.isSafeInteger(i) || i < 0) {\n        throw new Error(`Received an invalid integer type: ${i}`);\n    }\n    return `0x${i.toString(16)}`;\n};\nexports.intToHex = intToHex;\n/**\n * Converts an `Number` to a `Buffer`\n * @param {Number} i\n * @return {Buffer}\n */\nconst intToBuffer = function (i) {\n    const hex = (0, exports.intToHex)(i);\n    return Buffer.from((0, internal_1.padToEven)(hex.slice(2)), 'hex');\n};\nexports.intToBuffer = intToBuffer;\n/**\n * Returns a buffer filled with 0s.\n * @param bytes the number of bytes the buffer should be\n */\nconst zeros = function (bytes) {\n    return Buffer.allocUnsafe(bytes).fill(0);\n};\nexports.zeros = zeros;\n/**\n * Pads a `Buffer` with zeros till it has `length` bytes.\n * Truncates the beginning or end of input if its length exceeds `length`.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @param right whether to start padding form the left or right\n * @return (Buffer)\n */\nconst setLength = function (msg, length, right) {\n    const buf = (0, exports.zeros)(length);\n    if (right) {\n        if (msg.length < length) {\n            msg.copy(buf);\n            return buf;\n        }\n        return msg.slice(0, length);\n    }\n    else {\n        if (msg.length < length) {\n            msg.copy(buf, length - msg.length);\n            return buf;\n        }\n        return msg.slice(-length);\n    }\n};\n/**\n * Left Pads a `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @return (Buffer)\n */\nconst setLengthLeft = function (msg, length) {\n    (0, helpers_1.assertIsBuffer)(msg);\n    return setLength(msg, length, false);\n};\nexports.setLengthLeft = setLengthLeft;\n/**\n * Right Pads a `Buffer` with trailing zeros till it has `length` bytes.\n * it truncates the end if it exceeds.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @return (Buffer)\n */\nconst setLengthRight = function (msg, length) {\n    (0, helpers_1.assertIsBuffer)(msg);\n    return setLength(msg, length, true);\n};\nexports.setLengthRight = setLengthRight;\n/**\n * Trims leading zeros from a `Buffer`, `String` or `Number[]`.\n * @param a (Buffer|Array|String)\n * @return (Buffer|Array|String)\n */\nconst stripZeros = function (a) {\n    let first = a[0];\n    while (a.length > 0 && first.toString() === '0') {\n        a = a.slice(1);\n        first = a[0];\n    }\n    return a;\n};\n/**\n * Trims leading zeros from a `Buffer`.\n * @param a (Buffer)\n * @return (Buffer)\n */\nconst unpadBuffer = function (a) {\n    (0, helpers_1.assertIsBuffer)(a);\n    return stripZeros(a);\n};\nexports.unpadBuffer = unpadBuffer;\n/**\n * Trims leading zeros from an `Array` (of numbers).\n * @param a (number[])\n * @return (number[])\n */\nconst unpadArray = function (a) {\n    (0, helpers_1.assertIsArray)(a);\n    return stripZeros(a);\n};\nexports.unpadArray = unpadArray;\n/**\n * Trims leading zeros from a hex-prefixed `String`.\n * @param a (String)\n * @return (String)\n */\nconst unpadHexString = function (a) {\n    (0, helpers_1.assertIsHexString)(a);\n    a = (0, internal_1.stripHexPrefix)(a);\n    return ('0x' + stripZeros(a));\n};\nexports.unpadHexString = unpadHexString;\n/**\n * Attempts to turn a value into a `Buffer`.\n * Inputs supported: `Buffer`, `String` (hex-prefixed), `Number`, null/undefined, `BigInt` and other objects\n * with a `toArray()` or `toBuffer()` method.\n * @param v the value\n */\nconst toBuffer = function (v) {\n    if (v === null || v === undefined) {\n        return Buffer.allocUnsafe(0);\n    }\n    if (Buffer.isBuffer(v)) {\n        return Buffer.from(v);\n    }\n    if (Array.isArray(v) || v instanceof Uint8Array) {\n        return Buffer.from(v);\n    }\n    if (typeof v === 'string') {\n        if (!(0, internal_1.isHexString)(v)) {\n            throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${v}`);\n        }\n        return Buffer.from((0, internal_1.padToEven)((0, internal_1.stripHexPrefix)(v)), 'hex');\n    }\n    if (typeof v === 'number') {\n        return (0, exports.intToBuffer)(v);\n    }\n    if (typeof v === 'bigint') {\n        if (v < BigInt(0)) {\n            throw new Error(`Cannot convert negative bigint to buffer. Given: ${v}`);\n        }\n        let n = v.toString(16);\n        if (n.length % 2)\n            n = '0' + n;\n        return Buffer.from(n, 'hex');\n    }\n    if (v.toArray) {\n        // converts a BN to a Buffer\n        return Buffer.from(v.toArray());\n    }\n    if (v.toBuffer) {\n        return Buffer.from(v.toBuffer());\n    }\n    throw new Error('invalid type');\n};\nexports.toBuffer = toBuffer;\n/**\n * Converts a `Buffer` into a `0x`-prefixed hex `String`.\n * @param buf `Buffer` object to convert\n */\nconst bufferToHex = function (buf) {\n    buf = (0, exports.toBuffer)(buf);\n    return '0x' + buf.toString('hex');\n};\nexports.bufferToHex = bufferToHex;\n/**\n * Converts a {@link Buffer} to a {@link bigint}\n */\nfunction bufferToBigInt(buf) {\n    const hex = (0, exports.bufferToHex)(buf);\n    if (hex === '0x') {\n        return BigInt(0);\n    }\n    return BigInt(hex);\n}\nexports.bufferToBigInt = bufferToBigInt;\n/**\n * Converts a {@link bigint} to a {@link Buffer}\n */\nfunction bigIntToBuffer(num) {\n    return (0, exports.toBuffer)('0x' + num.toString(16));\n}\nexports.bigIntToBuffer = bigIntToBuffer;\n/**\n * Converts a `Buffer` to a `Number`.\n * @param buf `Buffer` object to convert\n * @throws If the input number exceeds 53 bits.\n */\nconst bufferToInt = function (buf) {\n    const res = Number(bufferToBigInt(buf));\n    if (!Number.isSafeInteger(res))\n        throw new Error('Number exceeds 53 bits');\n    return res;\n};\nexports.bufferToInt = bufferToInt;\n/**\n * Interprets a `Buffer` as a signed integer and returns a `BigInt`. Assumes 256-bit numbers.\n * @param num Signed integer value\n */\nconst fromSigned = function (num) {\n    return BigInt.asIntN(256, bufferToBigInt(num));\n};\nexports.fromSigned = fromSigned;\n/**\n * Converts a `BigInt` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.\n * @param num\n */\nconst toUnsigned = function (num) {\n    return bigIntToBuffer(BigInt.asUintN(256, num));\n};\nexports.toUnsigned = toUnsigned;\n/**\n * Adds \"0x\" to a given `String` if it does not already start with \"0x\".\n */\nconst addHexPrefix = function (str) {\n    if (typeof str !== 'string') {\n        return str;\n    }\n    return (0, internal_1.isHexPrefixed)(str) ? str : '0x' + str;\n};\nexports.addHexPrefix = addHexPrefix;\n/**\n * Shortens a string  or buffer's hex string representation to maxLength (default 50).\n *\n * Examples:\n *\n * Input:  '657468657265756d000000000000000000000000000000000000000000000000'\n * Output: '657468657265756d0000000000000000000000000000000000…'\n */\nfunction short(buffer, maxLength = 50) {\n    const bufferStr = Buffer.isBuffer(buffer) ? buffer.toString('hex') : buffer;\n    if (bufferStr.length <= maxLength) {\n        return bufferStr;\n    }\n    return bufferStr.slice(0, maxLength) + '…';\n}\nexports.short = short;\n/**\n * Returns the utf8 string representation from a hex string.\n *\n * Examples:\n *\n * Input 1: '657468657265756d000000000000000000000000000000000000000000000000'\n * Input 2: '657468657265756d'\n * Input 3: '000000000000000000000000000000000000000000000000657468657265756d'\n *\n * Output (all 3 input variants): 'ethereum'\n *\n * Note that this method is not intended to be used with hex strings\n * representing quantities in both big endian or little endian notation.\n *\n * @param string Hex string, should be `0x` prefixed\n * @return Utf8 string\n */\nconst toUtf8 = function (hex) {\n    const zerosRegexp = /^(00)+|(00)+$/g;\n    hex = (0, internal_1.stripHexPrefix)(hex);\n    if (hex.length % 2 !== 0) {\n        throw new Error('Invalid non-even hex string input for toUtf8() provided');\n    }\n    const bufferVal = Buffer.from(hex.replace(zerosRegexp, ''), 'hex');\n    return bufferVal.toString('utf8');\n};\nexports.toUtf8 = toUtf8;\n/**\n * Converts a `Buffer` or `Array` to JSON.\n * @param ba (Buffer|Array)\n * @return (Array|String|null)\n */\nconst baToJSON = function (ba) {\n    if (Buffer.isBuffer(ba)) {\n        return `0x${ba.toString('hex')}`;\n    }\n    else if (ba instanceof Array) {\n        const array = [];\n        for (let i = 0; i < ba.length; i++) {\n            array.push((0, exports.baToJSON)(ba[i]));\n        }\n        return array;\n    }\n};\nexports.baToJSON = baToJSON;\n/**\n * Checks provided Buffers for leading zeroes and throws if found.\n *\n * Examples:\n *\n * Valid values: 0x1, 0x, 0x01, 0x1234\n * Invalid values: 0x0, 0x00, 0x001, 0x0001\n *\n * Note: This method is useful for validating that RLP encoded integers comply with the rule that all\n * integer values encoded to RLP must be in the most compact form and contain no leading zero bytes\n * @param values An object containing string keys and Buffer values\n * @throws if any provided value is found to have leading zero bytes\n */\nconst validateNoLeadingZeroes = function (values) {\n    for (const [k, v] of Object.entries(values)) {\n        if (v !== undefined && v.length > 0 && v[0] === 0) {\n            throw new Error(`${k} cannot have leading zeroes, received: ${v.toString('hex')}`);\n        }\n    }\n};\nexports.validateNoLeadingZeroes = validateNoLeadingZeroes;\nfunction arrToBufArr(arr) {\n    if (!Array.isArray(arr)) {\n        return Buffer.from(arr);\n    }\n    return arr.map((a) => arrToBufArr(a));\n}\nexports.arrToBufArr = arrToBufArr;\nfunction bufArrToArr(arr) {\n    if (!Array.isArray(arr)) {\n        return Uint8Array.from(arr ?? []);\n    }\n    return arr.map((a) => bufArrToArr(a));\n}\nexports.bufArrToArr = bufArrToArr;\n/**\n * Converts a {@link bigint} to a `0x` prefixed hex string\n */\nconst bigIntToHex = (num) => {\n    return '0x' + num.toString(16);\n};\nexports.bigIntToHex = bigIntToHex;\n/**\n * Convert value from bigint to an unpadded Buffer\n * (useful for RLP transport)\n * @param value value to convert\n */\nfunction bigIntToUnpaddedBuffer(value) {\n    return (0, exports.unpadBuffer)(bigIntToBuffer(value));\n}\nexports.bigIntToUnpaddedBuffer = bigIntToUnpaddedBuffer;\nfunction intToUnpaddedBuffer(value) {\n    return (0, exports.unpadBuffer)((0, exports.intToBuffer)(value));\n}\nexports.intToUnpaddedBuffer = intToUnpaddedBuffer;\n//# sourceMappingURL=bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9ieXRlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRyw4QkFBOEIsR0FBRyxtQkFBbUIsR0FBRyxtQkFBbUIsR0FBRyxtQkFBbUIsR0FBRywrQkFBK0IsR0FBRyxnQkFBZ0IsR0FBRyxjQUFjLEdBQUcsYUFBYSxHQUFHLG9CQUFvQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLG1CQUFtQixHQUFHLHNCQUFzQixHQUFHLHNCQUFzQixHQUFHLG1CQUFtQixHQUFHLGdCQUFnQixHQUFHLHNCQUFzQixHQUFHLGtCQUFrQixHQUFHLG1CQUFtQixHQUFHLHNCQUFzQixHQUFHLHFCQUFxQixHQUFHLGFBQWEsR0FBRyxtQkFBbUIsR0FBRyxnQkFBZ0I7QUFDcGpCLGtCQUFrQixtQkFBTyxDQUFDLGdIQUFXO0FBQ3JDLG1CQUFtQixtQkFBTyxDQUFDLGtIQUFZO0FBQ3ZDO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxFQUFFO0FBQy9EO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMElBQTBJLEVBQUU7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixFQUFFO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsZUFBZSxjQUFjLE1BQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLGVBQWUsY0FBYyxNQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEdBQUcsd0NBQXdDLGtCQUFrQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L2J5dGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbnRUb1VucGFkZGVkQnVmZmVyID0gZXhwb3J0cy5iaWdJbnRUb1VucGFkZGVkQnVmZmVyID0gZXhwb3J0cy5iaWdJbnRUb0hleCA9IGV4cG9ydHMuYnVmQXJyVG9BcnIgPSBleHBvcnRzLmFyclRvQnVmQXJyID0gZXhwb3J0cy52YWxpZGF0ZU5vTGVhZGluZ1plcm9lcyA9IGV4cG9ydHMuYmFUb0pTT04gPSBleHBvcnRzLnRvVXRmOCA9IGV4cG9ydHMuc2hvcnQgPSBleHBvcnRzLmFkZEhleFByZWZpeCA9IGV4cG9ydHMudG9VbnNpZ25lZCA9IGV4cG9ydHMuZnJvbVNpZ25lZCA9IGV4cG9ydHMuYnVmZmVyVG9JbnQgPSBleHBvcnRzLmJpZ0ludFRvQnVmZmVyID0gZXhwb3J0cy5idWZmZXJUb0JpZ0ludCA9IGV4cG9ydHMuYnVmZmVyVG9IZXggPSBleHBvcnRzLnRvQnVmZmVyID0gZXhwb3J0cy51bnBhZEhleFN0cmluZyA9IGV4cG9ydHMudW5wYWRBcnJheSA9IGV4cG9ydHMudW5wYWRCdWZmZXIgPSBleHBvcnRzLnNldExlbmd0aFJpZ2h0ID0gZXhwb3J0cy5zZXRMZW5ndGhMZWZ0ID0gZXhwb3J0cy56ZXJvcyA9IGV4cG9ydHMuaW50VG9CdWZmZXIgPSBleHBvcnRzLmludFRvSGV4ID0gdm9pZCAwO1xuY29uc3QgaGVscGVyc18xID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcbmNvbnN0IGludGVybmFsXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbFwiKTtcbi8qKlxuICogQ29udmVydHMgYSBgTnVtYmVyYCBpbnRvIGEgaGV4IGBTdHJpbmdgXG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5jb25zdCBpbnRUb0hleCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihpKSB8fCBpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlY2VpdmVkIGFuIGludmFsaWQgaW50ZWdlciB0eXBlOiAke2l9YCk7XG4gICAgfVxuICAgIHJldHVybiBgMHgke2kudG9TdHJpbmcoMTYpfWA7XG59O1xuZXhwb3J0cy5pbnRUb0hleCA9IGludFRvSGV4O1xuLyoqXG4gKiBDb252ZXJ0cyBhbiBgTnVtYmVyYCB0byBhIGBCdWZmZXJgXG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5jb25zdCBpbnRUb0J1ZmZlciA9IGZ1bmN0aW9uIChpKSB7XG4gICAgY29uc3QgaGV4ID0gKDAsIGV4cG9ydHMuaW50VG9IZXgpKGkpO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSgoMCwgaW50ZXJuYWxfMS5wYWRUb0V2ZW4pKGhleC5zbGljZSgyKSksICdoZXgnKTtcbn07XG5leHBvcnRzLmludFRvQnVmZmVyID0gaW50VG9CdWZmZXI7XG4vKipcbiAqIFJldHVybnMgYSBidWZmZXIgZmlsbGVkIHdpdGggMHMuXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIG51bWJlciBvZiBieXRlcyB0aGUgYnVmZmVyIHNob3VsZCBiZVxuICovXG5jb25zdCB6ZXJvcyA9IGZ1bmN0aW9uIChieXRlcykge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoYnl0ZXMpLmZpbGwoMCk7XG59O1xuZXhwb3J0cy56ZXJvcyA9IHplcm9zO1xuLyoqXG4gKiBQYWRzIGEgYEJ1ZmZlcmAgd2l0aCB6ZXJvcyB0aWxsIGl0IGhhcyBgbGVuZ3RoYCBieXRlcy5cbiAqIFRydW5jYXRlcyB0aGUgYmVnaW5uaW5nIG9yIGVuZCBvZiBpbnB1dCBpZiBpdHMgbGVuZ3RoIGV4Y2VlZHMgYGxlbmd0aGAuXG4gKiBAcGFyYW0gbXNnIHRoZSB2YWx1ZSB0byBwYWQgKEJ1ZmZlcilcbiAqIEBwYXJhbSBsZW5ndGggdGhlIG51bWJlciBvZiBieXRlcyB0aGUgb3V0cHV0IHNob3VsZCBiZVxuICogQHBhcmFtIHJpZ2h0IHdoZXRoZXIgdG8gc3RhcnQgcGFkZGluZyBmb3JtIHRoZSBsZWZ0IG9yIHJpZ2h0XG4gKiBAcmV0dXJuIChCdWZmZXIpXG4gKi9cbmNvbnN0IHNldExlbmd0aCA9IGZ1bmN0aW9uIChtc2csIGxlbmd0aCwgcmlnaHQpIHtcbiAgICBjb25zdCBidWYgPSAoMCwgZXhwb3J0cy56ZXJvcykobGVuZ3RoKTtcbiAgICBpZiAocmlnaHQpIHtcbiAgICAgICAgaWYgKG1zZy5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIG1zZy5jb3B5KGJ1Zik7XG4gICAgICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtc2cuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChtc2cubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBtc2cuY29weShidWYsIGxlbmd0aCAtIG1zZy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbXNnLnNsaWNlKC1sZW5ndGgpO1xuICAgIH1cbn07XG4vKipcbiAqIExlZnQgUGFkcyBhIGBCdWZmZXJgIHdpdGggbGVhZGluZyB6ZXJvcyB0aWxsIGl0IGhhcyBgbGVuZ3RoYCBieXRlcy5cbiAqIE9yIGl0IHRydW5jYXRlcyB0aGUgYmVnaW5uaW5nIGlmIGl0IGV4Y2VlZHMuXG4gKiBAcGFyYW0gbXNnIHRoZSB2YWx1ZSB0byBwYWQgKEJ1ZmZlcilcbiAqIEBwYXJhbSBsZW5ndGggdGhlIG51bWJlciBvZiBieXRlcyB0aGUgb3V0cHV0IHNob3VsZCBiZVxuICogQHJldHVybiAoQnVmZmVyKVxuICovXG5jb25zdCBzZXRMZW5ndGhMZWZ0ID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikobXNnKTtcbiAgICByZXR1cm4gc2V0TGVuZ3RoKG1zZywgbGVuZ3RoLCBmYWxzZSk7XG59O1xuZXhwb3J0cy5zZXRMZW5ndGhMZWZ0ID0gc2V0TGVuZ3RoTGVmdDtcbi8qKlxuICogUmlnaHQgUGFkcyBhIGBCdWZmZXJgIHdpdGggdHJhaWxpbmcgemVyb3MgdGlsbCBpdCBoYXMgYGxlbmd0aGAgYnl0ZXMuXG4gKiBpdCB0cnVuY2F0ZXMgdGhlIGVuZCBpZiBpdCBleGNlZWRzLlxuICogQHBhcmFtIG1zZyB0aGUgdmFsdWUgdG8gcGFkIChCdWZmZXIpXG4gKiBAcGFyYW0gbGVuZ3RoIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIG91dHB1dCBzaG91bGQgYmVcbiAqIEByZXR1cm4gKEJ1ZmZlcilcbiAqL1xuY29uc3Qgc2V0TGVuZ3RoUmlnaHQgPSBmdW5jdGlvbiAobXNnLCBsZW5ndGgpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShtc2cpO1xuICAgIHJldHVybiBzZXRMZW5ndGgobXNnLCBsZW5ndGgsIHRydWUpO1xufTtcbmV4cG9ydHMuc2V0TGVuZ3RoUmlnaHQgPSBzZXRMZW5ndGhSaWdodDtcbi8qKlxuICogVHJpbXMgbGVhZGluZyB6ZXJvcyBmcm9tIGEgYEJ1ZmZlcmAsIGBTdHJpbmdgIG9yIGBOdW1iZXJbXWAuXG4gKiBAcGFyYW0gYSAoQnVmZmVyfEFycmF5fFN0cmluZylcbiAqIEByZXR1cm4gKEJ1ZmZlcnxBcnJheXxTdHJpbmcpXG4gKi9cbmNvbnN0IHN0cmlwWmVyb3MgPSBmdW5jdGlvbiAoYSkge1xuICAgIGxldCBmaXJzdCA9IGFbMF07XG4gICAgd2hpbGUgKGEubGVuZ3RoID4gMCAmJiBmaXJzdC50b1N0cmluZygpID09PSAnMCcpIHtcbiAgICAgICAgYSA9IGEuc2xpY2UoMSk7XG4gICAgICAgIGZpcnN0ID0gYVswXTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG59O1xuLyoqXG4gKiBUcmltcyBsZWFkaW5nIHplcm9zIGZyb20gYSBgQnVmZmVyYC5cbiAqIEBwYXJhbSBhIChCdWZmZXIpXG4gKiBAcmV0dXJuIChCdWZmZXIpXG4gKi9cbmNvbnN0IHVucGFkQnVmZmVyID0gZnVuY3Rpb24gKGEpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShhKTtcbiAgICByZXR1cm4gc3RyaXBaZXJvcyhhKTtcbn07XG5leHBvcnRzLnVucGFkQnVmZmVyID0gdW5wYWRCdWZmZXI7XG4vKipcbiAqIFRyaW1zIGxlYWRpbmcgemVyb3MgZnJvbSBhbiBgQXJyYXlgIChvZiBudW1iZXJzKS5cbiAqIEBwYXJhbSBhIChudW1iZXJbXSlcbiAqIEByZXR1cm4gKG51bWJlcltdKVxuICovXG5jb25zdCB1bnBhZEFycmF5ID0gZnVuY3Rpb24gKGEpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQXJyYXkpKGEpO1xuICAgIHJldHVybiBzdHJpcFplcm9zKGEpO1xufTtcbmV4cG9ydHMudW5wYWRBcnJheSA9IHVucGFkQXJyYXk7XG4vKipcbiAqIFRyaW1zIGxlYWRpbmcgemVyb3MgZnJvbSBhIGhleC1wcmVmaXhlZCBgU3RyaW5nYC5cbiAqIEBwYXJhbSBhIChTdHJpbmcpXG4gKiBAcmV0dXJuIChTdHJpbmcpXG4gKi9cbmNvbnN0IHVucGFkSGV4U3RyaW5nID0gZnVuY3Rpb24gKGEpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzSGV4U3RyaW5nKShhKTtcbiAgICBhID0gKDAsIGludGVybmFsXzEuc3RyaXBIZXhQcmVmaXgpKGEpO1xuICAgIHJldHVybiAoJzB4JyArIHN0cmlwWmVyb3MoYSkpO1xufTtcbmV4cG9ydHMudW5wYWRIZXhTdHJpbmcgPSB1bnBhZEhleFN0cmluZztcbi8qKlxuICogQXR0ZW1wdHMgdG8gdHVybiBhIHZhbHVlIGludG8gYSBgQnVmZmVyYC5cbiAqIElucHV0cyBzdXBwb3J0ZWQ6IGBCdWZmZXJgLCBgU3RyaW5nYCAoaGV4LXByZWZpeGVkKSwgYE51bWJlcmAsIG51bGwvdW5kZWZpbmVkLCBgQmlnSW50YCBhbmQgb3RoZXIgb2JqZWN0c1xuICogd2l0aCBhIGB0b0FycmF5KClgIG9yIGB0b0J1ZmZlcigpYCBtZXRob2QuXG4gKiBAcGFyYW0gdiB0aGUgdmFsdWVcbiAqL1xuY29uc3QgdG9CdWZmZXIgPSBmdW5jdGlvbiAodikge1xuICAgIGlmICh2ID09PSBudWxsIHx8IHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuICAgIH1cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHYpKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2KTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodikgfHwgdiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHYpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghKDAsIGludGVybmFsXzEuaXNIZXhTdHJpbmcpKHYpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb252ZXJ0IHN0cmluZyB0byBidWZmZXIuIHRvQnVmZmVyIG9ubHkgc3VwcG9ydHMgMHgtcHJlZml4ZWQgaGV4IHN0cmluZ3MgYW5kIHRoaXMgc3RyaW5nIHdhcyBnaXZlbjogJHt2fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSgoMCwgaW50ZXJuYWxfMS5wYWRUb0V2ZW4pKCgwLCBpbnRlcm5hbF8xLnN0cmlwSGV4UHJlZml4KSh2KSksICdoZXgnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuaW50VG9CdWZmZXIpKHYpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHYgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIGlmICh2IDwgQmlnSW50KDApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb252ZXJ0IG5lZ2F0aXZlIGJpZ2ludCB0byBidWZmZXIuIEdpdmVuOiAke3Z9YCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG4gPSB2LnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKG4ubGVuZ3RoICUgMilcbiAgICAgICAgICAgIG4gPSAnMCcgKyBuO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20obiwgJ2hleCcpO1xuICAgIH1cbiAgICBpZiAodi50b0FycmF5KSB7XG4gICAgICAgIC8vIGNvbnZlcnRzIGEgQk4gdG8gYSBCdWZmZXJcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHYudG9BcnJheSgpKTtcbiAgICB9XG4gICAgaWYgKHYudG9CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHYudG9CdWZmZXIoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB0eXBlJyk7XG59O1xuZXhwb3J0cy50b0J1ZmZlciA9IHRvQnVmZmVyO1xuLyoqXG4gKiBDb252ZXJ0cyBhIGBCdWZmZXJgIGludG8gYSBgMHhgLXByZWZpeGVkIGhleCBgU3RyaW5nYC5cbiAqIEBwYXJhbSBidWYgYEJ1ZmZlcmAgb2JqZWN0IHRvIGNvbnZlcnRcbiAqL1xuY29uc3QgYnVmZmVyVG9IZXggPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgYnVmID0gKDAsIGV4cG9ydHMudG9CdWZmZXIpKGJ1Zik7XG4gICAgcmV0dXJuICcweCcgKyBidWYudG9TdHJpbmcoJ2hleCcpO1xufTtcbmV4cG9ydHMuYnVmZmVyVG9IZXggPSBidWZmZXJUb0hleDtcbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgQnVmZmVyfSB0byBhIHtAbGluayBiaWdpbnR9XG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlclRvQmlnSW50KGJ1Zikge1xuICAgIGNvbnN0IGhleCA9ICgwLCBleHBvcnRzLmJ1ZmZlclRvSGV4KShidWYpO1xuICAgIGlmIChoZXggPT09ICcweCcpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludCgwKTtcbiAgICB9XG4gICAgcmV0dXJuIEJpZ0ludChoZXgpO1xufVxuZXhwb3J0cy5idWZmZXJUb0JpZ0ludCA9IGJ1ZmZlclRvQmlnSW50O1xuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBiaWdpbnR9IHRvIGEge0BsaW5rIEJ1ZmZlcn1cbiAqL1xuZnVuY3Rpb24gYmlnSW50VG9CdWZmZXIobnVtKSB7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLnRvQnVmZmVyKSgnMHgnICsgbnVtLnRvU3RyaW5nKDE2KSk7XG59XG5leHBvcnRzLmJpZ0ludFRvQnVmZmVyID0gYmlnSW50VG9CdWZmZXI7XG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgdG8gYSBgTnVtYmVyYC5cbiAqIEBwYXJhbSBidWYgYEJ1ZmZlcmAgb2JqZWN0IHRvIGNvbnZlcnRcbiAqIEB0aHJvd3MgSWYgdGhlIGlucHV0IG51bWJlciBleGNlZWRzIDUzIGJpdHMuXG4gKi9cbmNvbnN0IGJ1ZmZlclRvSW50ID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgIGNvbnN0IHJlcyA9IE51bWJlcihidWZmZXJUb0JpZ0ludChidWYpKTtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHJlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTnVtYmVyIGV4Y2VlZHMgNTMgYml0cycpO1xuICAgIHJldHVybiByZXM7XG59O1xuZXhwb3J0cy5idWZmZXJUb0ludCA9IGJ1ZmZlclRvSW50O1xuLyoqXG4gKiBJbnRlcnByZXRzIGEgYEJ1ZmZlcmAgYXMgYSBzaWduZWQgaW50ZWdlciBhbmQgcmV0dXJucyBhIGBCaWdJbnRgLiBBc3N1bWVzIDI1Ni1iaXQgbnVtYmVycy5cbiAqIEBwYXJhbSBudW0gU2lnbmVkIGludGVnZXIgdmFsdWVcbiAqL1xuY29uc3QgZnJvbVNpZ25lZCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICByZXR1cm4gQmlnSW50LmFzSW50TigyNTYsIGJ1ZmZlclRvQmlnSW50KG51bSkpO1xufTtcbmV4cG9ydHMuZnJvbVNpZ25lZCA9IGZyb21TaWduZWQ7XG4vKipcbiAqIENvbnZlcnRzIGEgYEJpZ0ludGAgdG8gYW4gdW5zaWduZWQgaW50ZWdlciBhbmQgcmV0dXJucyBpdCBhcyBhIGBCdWZmZXJgLiBBc3N1bWVzIDI1Ni1iaXQgbnVtYmVycy5cbiAqIEBwYXJhbSBudW1cbiAqL1xuY29uc3QgdG9VbnNpZ25lZCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICByZXR1cm4gYmlnSW50VG9CdWZmZXIoQmlnSW50LmFzVWludE4oMjU2LCBudW0pKTtcbn07XG5leHBvcnRzLnRvVW5zaWduZWQgPSB0b1Vuc2lnbmVkO1xuLyoqXG4gKiBBZGRzIFwiMHhcIiB0byBhIGdpdmVuIGBTdHJpbmdgIGlmIGl0IGRvZXMgbm90IGFscmVhZHkgc3RhcnQgd2l0aCBcIjB4XCIuXG4gKi9cbmNvbnN0IGFkZEhleFByZWZpeCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBpbnRlcm5hbF8xLmlzSGV4UHJlZml4ZWQpKHN0cikgPyBzdHIgOiAnMHgnICsgc3RyO1xufTtcbmV4cG9ydHMuYWRkSGV4UHJlZml4ID0gYWRkSGV4UHJlZml4O1xuLyoqXG4gKiBTaG9ydGVucyBhIHN0cmluZyAgb3IgYnVmZmVyJ3MgaGV4IHN0cmluZyByZXByZXNlbnRhdGlvbiB0byBtYXhMZW5ndGggKGRlZmF1bHQgNTApLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqIElucHV0OiAgJzY1NzQ2ODY1NzI2NTc1NmQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnXG4gKiBPdXRwdXQ6ICc2NTc0Njg2NTcyNjU3NTZkMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMOKApidcbiAqL1xuZnVuY3Rpb24gc2hvcnQoYnVmZmVyLCBtYXhMZW5ndGggPSA1MCkge1xuICAgIGNvbnN0IGJ1ZmZlclN0ciA9IEJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpID8gYnVmZmVyLnRvU3RyaW5nKCdoZXgnKSA6IGJ1ZmZlcjtcbiAgICBpZiAoYnVmZmVyU3RyLmxlbmd0aCA8PSBtYXhMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlclN0cjtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlclN0ci5zbGljZSgwLCBtYXhMZW5ndGgpICsgJ+KApic7XG59XG5leHBvcnRzLnNob3J0ID0gc2hvcnQ7XG4vKipcbiAqIFJldHVybnMgdGhlIHV0Zjggc3RyaW5nIHJlcHJlc2VudGF0aW9uIGZyb20gYSBoZXggc3RyaW5nLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqIElucHV0IDE6ICc2NTc0Njg2NTcyNjU3NTZkMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJ1xuICogSW5wdXQgMjogJzY1NzQ2ODY1NzI2NTc1NmQnXG4gKiBJbnB1dCAzOiAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNjU3NDY4NjU3MjY1NzU2ZCdcbiAqXG4gKiBPdXRwdXQgKGFsbCAzIGlucHV0IHZhcmlhbnRzKTogJ2V0aGVyZXVtJ1xuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBpcyBub3QgaW50ZW5kZWQgdG8gYmUgdXNlZCB3aXRoIGhleCBzdHJpbmdzXG4gKiByZXByZXNlbnRpbmcgcXVhbnRpdGllcyBpbiBib3RoIGJpZyBlbmRpYW4gb3IgbGl0dGxlIGVuZGlhbiBub3RhdGlvbi5cbiAqXG4gKiBAcGFyYW0gc3RyaW5nIEhleCBzdHJpbmcsIHNob3VsZCBiZSBgMHhgIHByZWZpeGVkXG4gKiBAcmV0dXJuIFV0Zjggc3RyaW5nXG4gKi9cbmNvbnN0IHRvVXRmOCA9IGZ1bmN0aW9uIChoZXgpIHtcbiAgICBjb25zdCB6ZXJvc1JlZ2V4cCA9IC9eKDAwKSt8KDAwKSskL2c7XG4gICAgaGV4ID0gKDAsIGludGVybmFsXzEuc3RyaXBIZXhQcmVmaXgpKGhleCk7XG4gICAgaWYgKGhleC5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBub24tZXZlbiBoZXggc3RyaW5nIGlucHV0IGZvciB0b1V0ZjgoKSBwcm92aWRlZCcpO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXJWYWwgPSBCdWZmZXIuZnJvbShoZXgucmVwbGFjZSh6ZXJvc1JlZ2V4cCwgJycpLCAnaGV4Jyk7XG4gICAgcmV0dXJuIGJ1ZmZlclZhbC50b1N0cmluZygndXRmOCcpO1xufTtcbmV4cG9ydHMudG9VdGY4ID0gdG9VdGY4O1xuLyoqXG4gKiBDb252ZXJ0cyBhIGBCdWZmZXJgIG9yIGBBcnJheWAgdG8gSlNPTi5cbiAqIEBwYXJhbSBiYSAoQnVmZmVyfEFycmF5KVxuICogQHJldHVybiAoQXJyYXl8U3RyaW5nfG51bGwpXG4gKi9cbmNvbnN0IGJhVG9KU09OID0gZnVuY3Rpb24gKGJhKSB7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihiYSkpIHtcbiAgICAgICAgcmV0dXJuIGAweCR7YmEudG9TdHJpbmcoJ2hleCcpfWA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJyYXkucHVzaCgoMCwgZXhwb3J0cy5iYVRvSlNPTikoYmFbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxufTtcbmV4cG9ydHMuYmFUb0pTT04gPSBiYVRvSlNPTjtcbi8qKlxuICogQ2hlY2tzIHByb3ZpZGVkIEJ1ZmZlcnMgZm9yIGxlYWRpbmcgemVyb2VzIGFuZCB0aHJvd3MgaWYgZm91bmQuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogVmFsaWQgdmFsdWVzOiAweDEsIDB4LCAweDAxLCAweDEyMzRcbiAqIEludmFsaWQgdmFsdWVzOiAweDAsIDB4MDAsIDB4MDAxLCAweDAwMDFcbiAqXG4gKiBOb3RlOiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgZm9yIHZhbGlkYXRpbmcgdGhhdCBSTFAgZW5jb2RlZCBpbnRlZ2VycyBjb21wbHkgd2l0aCB0aGUgcnVsZSB0aGF0IGFsbFxuICogaW50ZWdlciB2YWx1ZXMgZW5jb2RlZCB0byBSTFAgbXVzdCBiZSBpbiB0aGUgbW9zdCBjb21wYWN0IGZvcm0gYW5kIGNvbnRhaW4gbm8gbGVhZGluZyB6ZXJvIGJ5dGVzXG4gKiBAcGFyYW0gdmFsdWVzIEFuIG9iamVjdCBjb250YWluaW5nIHN0cmluZyBrZXlzIGFuZCBCdWZmZXIgdmFsdWVzXG4gKiBAdGhyb3dzIGlmIGFueSBwcm92aWRlZCB2YWx1ZSBpcyBmb3VuZCB0byBoYXZlIGxlYWRpbmcgemVybyBieXRlc1xuICovXG5jb25zdCB2YWxpZGF0ZU5vTGVhZGluZ1plcm9lcyA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZXMpKSB7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQgJiYgdi5sZW5ndGggPiAwICYmIHZbMF0gPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtrfSBjYW5ub3QgaGF2ZSBsZWFkaW5nIHplcm9lcywgcmVjZWl2ZWQ6ICR7di50b1N0cmluZygnaGV4Jyl9YCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0cy52YWxpZGF0ZU5vTGVhZGluZ1plcm9lcyA9IHZhbGlkYXRlTm9MZWFkaW5nWmVyb2VzO1xuZnVuY3Rpb24gYXJyVG9CdWZBcnIoYXJyKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGFycik7XG4gICAgfVxuICAgIHJldHVybiBhcnIubWFwKChhKSA9PiBhcnJUb0J1ZkFycihhKSk7XG59XG5leHBvcnRzLmFyclRvQnVmQXJyID0gYXJyVG9CdWZBcnI7XG5mdW5jdGlvbiBidWZBcnJUb0FycihhcnIpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGFyciA/PyBbXSk7XG4gICAgfVxuICAgIHJldHVybiBhcnIubWFwKChhKSA9PiBidWZBcnJUb0FycihhKSk7XG59XG5leHBvcnRzLmJ1ZkFyclRvQXJyID0gYnVmQXJyVG9BcnI7XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIGJpZ2ludH0gdG8gYSBgMHhgIHByZWZpeGVkIGhleCBzdHJpbmdcbiAqL1xuY29uc3QgYmlnSW50VG9IZXggPSAobnVtKSA9PiB7XG4gICAgcmV0dXJuICcweCcgKyBudW0udG9TdHJpbmcoMTYpO1xufTtcbmV4cG9ydHMuYmlnSW50VG9IZXggPSBiaWdJbnRUb0hleDtcbi8qKlxuICogQ29udmVydCB2YWx1ZSBmcm9tIGJpZ2ludCB0byBhbiB1bnBhZGRlZCBCdWZmZXJcbiAqICh1c2VmdWwgZm9yIFJMUCB0cmFuc3BvcnQpXG4gKiBAcGFyYW0gdmFsdWUgdmFsdWUgdG8gY29udmVydFxuICovXG5mdW5jdGlvbiBiaWdJbnRUb1VucGFkZGVkQnVmZmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLnVucGFkQnVmZmVyKShiaWdJbnRUb0J1ZmZlcih2YWx1ZSkpO1xufVxuZXhwb3J0cy5iaWdJbnRUb1VucGFkZGVkQnVmZmVyID0gYmlnSW50VG9VbnBhZGRlZEJ1ZmZlcjtcbmZ1bmN0aW9uIGludFRvVW5wYWRkZWRCdWZmZXIodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMudW5wYWRCdWZmZXIpKCgwLCBleHBvcnRzLmludFRvQnVmZmVyKSh2YWx1ZSkpO1xufVxuZXhwb3J0cy5pbnRUb1VucGFkZGVkQnVmZmVyID0gaW50VG9VbnBhZGRlZEJ1ZmZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ5dGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/bytes.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/constants.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/constants.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MAX_WITHDRAWALS_PER_PAYLOAD = exports.RLP_EMPTY_STRING = exports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.SECP256K1_ORDER_DIV_2 = exports.SECP256K1_ORDER = exports.MAX_INTEGER_BIGINT = exports.MAX_INTEGER = exports.MAX_UINT64 = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\nconst secp256k1_1 = __webpack_require__(/*! ethereum-cryptography/secp256k1 */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/ethereum-cryptography/secp256k1.js\");\n/**\n * 2^64-1\n */\nexports.MAX_UINT64 = BigInt('0xffffffffffffffff');\n/**\n * The max integer that the evm can handle (2^256-1)\n */\nexports.MAX_INTEGER = BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\n/**\n * The max integer that the evm can handle (2^256-1) as a bigint\n * 2^256-1 equals to 340282366920938463463374607431768211455\n * We use literal value instead of calculated value for compatibility issue.\n */\nexports.MAX_INTEGER_BIGINT = BigInt('115792089237316195423570985008687907853269984665640564039457584007913129639935');\nexports.SECP256K1_ORDER = secp256k1_1.secp256k1.CURVE.n;\nexports.SECP256K1_ORDER_DIV_2 = secp256k1_1.secp256k1.CURVE.n / BigInt(2);\n/**\n * 2^256\n */\nexports.TWO_POW256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\n/**\n * Keccak-256 hash of null\n */\nexports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';\n/**\n * Keccak-256 hash of null\n */\nexports.KECCAK256_NULL = buffer_1.Buffer.from(exports.KECCAK256_NULL_S, 'hex');\n/**\n * Keccak-256 of an RLP of an empty array\n */\nexports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';\n/**\n * Keccak-256 of an RLP of an empty array\n */\nexports.KECCAK256_RLP_ARRAY = buffer_1.Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');\n/**\n * Keccak-256 hash of the RLP of null\n */\nexports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';\n/**\n * Keccak-256 hash of the RLP of null\n */\nexports.KECCAK256_RLP = buffer_1.Buffer.from(exports.KECCAK256_RLP_S, 'hex');\n/**\n *  RLP encoded empty string\n */\nexports.RLP_EMPTY_STRING = buffer_1.Buffer.from([0x80]);\nexports.MAX_WITHDRAWALS_PER_PAYLOAD = 16;\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUNBQW1DLEdBQUcsd0JBQXdCLEdBQUcscUJBQXFCLEdBQUcsdUJBQXVCLEdBQUcsMkJBQTJCLEdBQUcsNkJBQTZCLEdBQUcsc0JBQXNCLEdBQUcsd0JBQXdCLEdBQUcsa0JBQWtCLEdBQUcsNkJBQTZCLEdBQUcsdUJBQXVCLEdBQUcsMEJBQTBCLEdBQUcsbUJBQW1CLEdBQUcsa0JBQWtCO0FBQ3pYLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLG9CQUFvQixtQkFBTyxDQUFDLHdJQUFpQztBQUM3RDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsdUJBQXVCO0FBQ3ZCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLG1DQUFtQztBQUNuQyIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L2NvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTUFYX1dJVEhEUkFXQUxTX1BFUl9QQVlMT0FEID0gZXhwb3J0cy5STFBfRU1QVFlfU1RSSU5HID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQX1MgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVkgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUyA9IGV4cG9ydHMuS0VDQ0FLMjU2X05VTEwgPSBleHBvcnRzLktFQ0NBSzI1Nl9OVUxMX1MgPSBleHBvcnRzLlRXT19QT1cyNTYgPSBleHBvcnRzLlNFQ1AyNTZLMV9PUkRFUl9ESVZfMiA9IGV4cG9ydHMuU0VDUDI1NksxX09SREVSID0gZXhwb3J0cy5NQVhfSU5URUdFUl9CSUdJTlQgPSBleHBvcnRzLk1BWF9JTlRFR0VSID0gZXhwb3J0cy5NQVhfVUlOVDY0ID0gdm9pZCAwO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyXCIpO1xuY29uc3Qgc2VjcDI1NmsxXzEgPSByZXF1aXJlKFwiZXRoZXJldW0tY3J5cHRvZ3JhcGh5L3NlY3AyNTZrMVwiKTtcbi8qKlxuICogMl42NC0xXG4gKi9cbmV4cG9ydHMuTUFYX1VJTlQ2NCA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJyk7XG4vKipcbiAqIFRoZSBtYXggaW50ZWdlciB0aGF0IHRoZSBldm0gY2FuIGhhbmRsZSAoMl4yNTYtMSlcbiAqL1xuZXhwb3J0cy5NQVhfSU5URUdFUiA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmJyk7XG4vKipcbiAqIFRoZSBtYXggaW50ZWdlciB0aGF0IHRoZSBldm0gY2FuIGhhbmRsZSAoMl4yNTYtMSkgYXMgYSBiaWdpbnRcbiAqIDJeMjU2LTEgZXF1YWxzIHRvIDM0MDI4MjM2NjkyMDkzODQ2MzQ2MzM3NDYwNzQzMTc2ODIxMTQ1NVxuICogV2UgdXNlIGxpdGVyYWwgdmFsdWUgaW5zdGVhZCBvZiBjYWxjdWxhdGVkIHZhbHVlIGZvciBjb21wYXRpYmlsaXR5IGlzc3VlLlxuICovXG5leHBvcnRzLk1BWF9JTlRFR0VSX0JJR0lOVCA9IEJpZ0ludCgnMTE1NzkyMDg5MjM3MzE2MTk1NDIzNTcwOTg1MDA4Njg3OTA3ODUzMjY5OTg0NjY1NjQwNTY0MDM5NDU3NTg0MDA3OTEzMTI5NjM5OTM1Jyk7XG5leHBvcnRzLlNFQ1AyNTZLMV9PUkRFUiA9IHNlY3AyNTZrMV8xLnNlY3AyNTZrMS5DVVJWRS5uO1xuZXhwb3J0cy5TRUNQMjU2SzFfT1JERVJfRElWXzIgPSBzZWNwMjU2azFfMS5zZWNwMjU2azEuQ1VSVkUubiAvIEJpZ0ludCgyKTtcbi8qKlxuICogMl4yNTZcbiAqL1xuZXhwb3J0cy5UV09fUE9XMjU2ID0gQmlnSW50KCcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyk7XG4vKipcbiAqIEtlY2Nhay0yNTYgaGFzaCBvZiBudWxsXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUyA9ICdjNWQyNDYwMTg2ZjcyMzNjOTI3ZTdkYjJkY2M3MDNjMGU1MDBiNjUzY2E4MjI3M2I3YmZhZDgwNDVkODVhNDcwJztcbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIG51bGxcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfTlVMTCA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUywgJ2hleCcpO1xuLyoqXG4gKiBLZWNjYWstMjU2IG9mIGFuIFJMUCBvZiBhbiBlbXB0eSBhcnJheVxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUyA9ICcxZGNjNGRlOGRlYzc1ZDdhYWI4NWI1NjdiNmNjZDQxYWQzMTI0NTFiOTQ4YTc0MTNmMGExNDJmZDQwZDQ5MzQ3Jztcbi8qKlxuICogS2VjY2FrLTI1NiBvZiBhbiBSTFAgb2YgYW4gZW1wdHkgYXJyYXlcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1MsICdoZXgnKTtcbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBSTFAgb2YgbnVsbFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfUyA9ICc1NmU4MWYxNzFiY2M1NWE2ZmY4MzQ1ZTY5MmMwZjg2ZTViNDhlMDFiOTk2Y2FkYzAwMTYyMmZiNWUzNjNiNDIxJztcbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBSTFAgb2YgbnVsbFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFAgPSBidWZmZXJfMS5CdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9STFBfUywgJ2hleCcpO1xuLyoqXG4gKiAgUkxQIGVuY29kZWQgZW1wdHkgc3RyaW5nXG4gKi9cbmV4cG9ydHMuUkxQX0VNUFRZX1NUUklORyA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKFsweDgwXSk7XG5leHBvcnRzLk1BWF9XSVRIRFJBV0FMU19QRVJfUEFZTE9BRCA9IDE2O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/constants.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/encoding.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/encoding.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.compactBytesToNibbles = exports.bytesToNibbles = exports.nibblesToCompactBytes = exports.nibblesToBytes = exports.hasTerminator = void 0;\n// Reference: https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/\n/**\n *\n * @param s byte sequence\n * @returns boolean indicating if input hex nibble sequence has terminator indicating leaf-node\n *          terminator is represented with 16 because a nibble ranges from 0 - 15(f)\n */\nconst hasTerminator = (nibbles) => {\n    return nibbles.length > 0 && nibbles[nibbles.length - 1] === 16;\n};\nexports.hasTerminator = hasTerminator;\nconst nibblesToBytes = (nibbles, bytes) => {\n    for (let bi = 0, ni = 0; ni < nibbles.length; bi += 1, ni += 2) {\n        bytes[bi] = (nibbles[ni] << 4) | nibbles[ni + 1];\n    }\n};\nexports.nibblesToBytes = nibblesToBytes;\nconst nibblesToCompactBytes = (nibbles) => {\n    let terminator = 0;\n    if ((0, exports.hasTerminator)(nibbles)) {\n        terminator = 1;\n        // Remove the terminator from the sequence\n        nibbles = nibbles.subarray(0, nibbles.length - 1);\n    }\n    const buf = new Uint8Array(nibbles.length / 2 + 1);\n    // Shift the terminator info into the first nibble of buf[0]\n    buf[0] = terminator << 5;\n    // If odd length, then add that flag into the first nibble and put the odd nibble to\n    // second part of buf[0] which otherwise will be left padded with a 0\n    if ((nibbles.length & 1) === 1) {\n        buf[0] |= 1 << 4;\n        buf[0] |= nibbles[0];\n        nibbles = nibbles.subarray(1);\n    }\n    // create bytes out of the rest even nibbles\n    (0, exports.nibblesToBytes)(nibbles, buf.subarray(1));\n    return buf;\n};\nexports.nibblesToCompactBytes = nibblesToCompactBytes;\nconst bytesToNibbles = (str) => {\n    const l = str.length * 2 + 1;\n    const nibbles = new Uint8Array(l);\n    for (let i = 0; i < str.length; i++) {\n        const b = str[i];\n        nibbles[i * 2] = b / 16;\n        nibbles[i * 2 + 1] = b % 16;\n    }\n    // This will get removed from calling function if the first nibble\n    // indicates that terminator is not present\n    nibbles[l - 1] = 16;\n    return nibbles;\n};\nexports.bytesToNibbles = bytesToNibbles;\nconst compactBytesToNibbles = (compact) => {\n    if (compact.length === 0) {\n        return compact;\n    }\n    let base = (0, exports.bytesToNibbles)(compact);\n    // delete terminator flag if terminator flag was not in first nibble\n    if (base[0] < 2) {\n        base = base.subarray(0, base.length - 1);\n    }\n    // chop the terminator nibble and the even padding (if there is one)\n    // i.e.  chop 2 left nibbles when even else 1 when odd\n    const chop = 2 - (base[0] & 1);\n    return base.subarray(chop);\n};\nexports.compactBytesToNibbles = compactBytesToNibbles;\n/**\n * A test helper to generates compact path for a subset of key bytes\n *\n * TODO: Commenting the code for now as this seems to be helper function\n * (from geth codebase )\n *\n */\n//\n//\n// export const getPathTo = (tillBytes: number, key: Buffer) => {\n//   const hexNibbles = bytesToNibbles(key).subarray(0, tillBytes)\n//   // Remove the terminator if its there, although it would be there only if tillBytes >= key.length\n//   // This seems to be a test helper to generate paths so correctness of this isn't necessary\n//   hexNibbles[hexNibbles.length - 1] = 0\n//   const compactBytes = nibblesToCompactBytes(hexNibbles)\n//   return [Buffer.from(compactBytes)]\n// }\n//# sourceMappingURL=encoding.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9lbmNvZGluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRyxzQkFBc0IsR0FBRyw2QkFBNkIsR0FBRyxzQkFBc0IsR0FBRyxxQkFBcUI7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSw2QkFBNkIscUJBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9lbmNvZGluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29tcGFjdEJ5dGVzVG9OaWJibGVzID0gZXhwb3J0cy5ieXRlc1RvTmliYmxlcyA9IGV4cG9ydHMubmliYmxlc1RvQ29tcGFjdEJ5dGVzID0gZXhwb3J0cy5uaWJibGVzVG9CeXRlcyA9IGV4cG9ydHMuaGFzVGVybWluYXRvciA9IHZvaWQgMDtcbi8vIFJlZmVyZW5jZTogaHR0cHM6Ly9ldGhlcmV1bS5vcmcvZW4vZGV2ZWxvcGVycy9kb2NzL2RhdGEtc3RydWN0dXJlcy1hbmQtZW5jb2RpbmcvcGF0cmljaWEtbWVya2xlLXRyaWUvXG4vKipcbiAqXG4gKiBAcGFyYW0gcyBieXRlIHNlcXVlbmNlXG4gKiBAcmV0dXJucyBib29sZWFuIGluZGljYXRpbmcgaWYgaW5wdXQgaGV4IG5pYmJsZSBzZXF1ZW5jZSBoYXMgdGVybWluYXRvciBpbmRpY2F0aW5nIGxlYWYtbm9kZVxuICogICAgICAgICAgdGVybWluYXRvciBpcyByZXByZXNlbnRlZCB3aXRoIDE2IGJlY2F1c2UgYSBuaWJibGUgcmFuZ2VzIGZyb20gMCAtIDE1KGYpXG4gKi9cbmNvbnN0IGhhc1Rlcm1pbmF0b3IgPSAobmliYmxlcykgPT4ge1xuICAgIHJldHVybiBuaWJibGVzLmxlbmd0aCA+IDAgJiYgbmliYmxlc1tuaWJibGVzLmxlbmd0aCAtIDFdID09PSAxNjtcbn07XG5leHBvcnRzLmhhc1Rlcm1pbmF0b3IgPSBoYXNUZXJtaW5hdG9yO1xuY29uc3QgbmliYmxlc1RvQnl0ZXMgPSAobmliYmxlcywgYnl0ZXMpID0+IHtcbiAgICBmb3IgKGxldCBiaSA9IDAsIG5pID0gMDsgbmkgPCBuaWJibGVzLmxlbmd0aDsgYmkgKz0gMSwgbmkgKz0gMikge1xuICAgICAgICBieXRlc1tiaV0gPSAobmliYmxlc1tuaV0gPDwgNCkgfCBuaWJibGVzW25pICsgMV07XG4gICAgfVxufTtcbmV4cG9ydHMubmliYmxlc1RvQnl0ZXMgPSBuaWJibGVzVG9CeXRlcztcbmNvbnN0IG5pYmJsZXNUb0NvbXBhY3RCeXRlcyA9IChuaWJibGVzKSA9PiB7XG4gICAgbGV0IHRlcm1pbmF0b3IgPSAwO1xuICAgIGlmICgoMCwgZXhwb3J0cy5oYXNUZXJtaW5hdG9yKShuaWJibGVzKSkge1xuICAgICAgICB0ZXJtaW5hdG9yID0gMTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSB0ZXJtaW5hdG9yIGZyb20gdGhlIHNlcXVlbmNlXG4gICAgICAgIG5pYmJsZXMgPSBuaWJibGVzLnN1YmFycmF5KDAsIG5pYmJsZXMubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KG5pYmJsZXMubGVuZ3RoIC8gMiArIDEpO1xuICAgIC8vIFNoaWZ0IHRoZSB0ZXJtaW5hdG9yIGluZm8gaW50byB0aGUgZmlyc3QgbmliYmxlIG9mIGJ1ZlswXVxuICAgIGJ1ZlswXSA9IHRlcm1pbmF0b3IgPDwgNTtcbiAgICAvLyBJZiBvZGQgbGVuZ3RoLCB0aGVuIGFkZCB0aGF0IGZsYWcgaW50byB0aGUgZmlyc3QgbmliYmxlIGFuZCBwdXQgdGhlIG9kZCBuaWJibGUgdG9cbiAgICAvLyBzZWNvbmQgcGFydCBvZiBidWZbMF0gd2hpY2ggb3RoZXJ3aXNlIHdpbGwgYmUgbGVmdCBwYWRkZWQgd2l0aCBhIDBcbiAgICBpZiAoKG5pYmJsZXMubGVuZ3RoICYgMSkgPT09IDEpIHtcbiAgICAgICAgYnVmWzBdIHw9IDEgPDwgNDtcbiAgICAgICAgYnVmWzBdIHw9IG5pYmJsZXNbMF07XG4gICAgICAgIG5pYmJsZXMgPSBuaWJibGVzLnN1YmFycmF5KDEpO1xuICAgIH1cbiAgICAvLyBjcmVhdGUgYnl0ZXMgb3V0IG9mIHRoZSByZXN0IGV2ZW4gbmliYmxlc1xuICAgICgwLCBleHBvcnRzLm5pYmJsZXNUb0J5dGVzKShuaWJibGVzLCBidWYuc3ViYXJyYXkoMSkpO1xuICAgIHJldHVybiBidWY7XG59O1xuZXhwb3J0cy5uaWJibGVzVG9Db21wYWN0Qnl0ZXMgPSBuaWJibGVzVG9Db21wYWN0Qnl0ZXM7XG5jb25zdCBieXRlc1RvTmliYmxlcyA9IChzdHIpID0+IHtcbiAgICBjb25zdCBsID0gc3RyLmxlbmd0aCAqIDIgKyAxO1xuICAgIGNvbnN0IG5pYmJsZXMgPSBuZXcgVWludDhBcnJheShsKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBiID0gc3RyW2ldO1xuICAgICAgICBuaWJibGVzW2kgKiAyXSA9IGIgLyAxNjtcbiAgICAgICAgbmliYmxlc1tpICogMiArIDFdID0gYiAlIDE2O1xuICAgIH1cbiAgICAvLyBUaGlzIHdpbGwgZ2V0IHJlbW92ZWQgZnJvbSBjYWxsaW5nIGZ1bmN0aW9uIGlmIHRoZSBmaXJzdCBuaWJibGVcbiAgICAvLyBpbmRpY2F0ZXMgdGhhdCB0ZXJtaW5hdG9yIGlzIG5vdCBwcmVzZW50XG4gICAgbmliYmxlc1tsIC0gMV0gPSAxNjtcbiAgICByZXR1cm4gbmliYmxlcztcbn07XG5leHBvcnRzLmJ5dGVzVG9OaWJibGVzID0gYnl0ZXNUb05pYmJsZXM7XG5jb25zdCBjb21wYWN0Qnl0ZXNUb05pYmJsZXMgPSAoY29tcGFjdCkgPT4ge1xuICAgIGlmIChjb21wYWN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY29tcGFjdDtcbiAgICB9XG4gICAgbGV0IGJhc2UgPSAoMCwgZXhwb3J0cy5ieXRlc1RvTmliYmxlcykoY29tcGFjdCk7XG4gICAgLy8gZGVsZXRlIHRlcm1pbmF0b3IgZmxhZyBpZiB0ZXJtaW5hdG9yIGZsYWcgd2FzIG5vdCBpbiBmaXJzdCBuaWJibGVcbiAgICBpZiAoYmFzZVswXSA8IDIpIHtcbiAgICAgICAgYmFzZSA9IGJhc2Uuc3ViYXJyYXkoMCwgYmFzZS5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgLy8gY2hvcCB0aGUgdGVybWluYXRvciBuaWJibGUgYW5kIHRoZSBldmVuIHBhZGRpbmcgKGlmIHRoZXJlIGlzIG9uZSlcbiAgICAvLyBpLmUuICBjaG9wIDIgbGVmdCBuaWJibGVzIHdoZW4gZXZlbiBlbHNlIDEgd2hlbiBvZGRcbiAgICBjb25zdCBjaG9wID0gMiAtIChiYXNlWzBdICYgMSk7XG4gICAgcmV0dXJuIGJhc2Uuc3ViYXJyYXkoY2hvcCk7XG59O1xuZXhwb3J0cy5jb21wYWN0Qnl0ZXNUb05pYmJsZXMgPSBjb21wYWN0Qnl0ZXNUb05pYmJsZXM7XG4vKipcbiAqIEEgdGVzdCBoZWxwZXIgdG8gZ2VuZXJhdGVzIGNvbXBhY3QgcGF0aCBmb3IgYSBzdWJzZXQgb2Yga2V5IGJ5dGVzXG4gKlxuICogVE9ETzogQ29tbWVudGluZyB0aGUgY29kZSBmb3Igbm93IGFzIHRoaXMgc2VlbXMgdG8gYmUgaGVscGVyIGZ1bmN0aW9uXG4gKiAoZnJvbSBnZXRoIGNvZGViYXNlIClcbiAqXG4gKi9cbi8vXG4vL1xuLy8gZXhwb3J0IGNvbnN0IGdldFBhdGhUbyA9ICh0aWxsQnl0ZXM6IG51bWJlciwga2V5OiBCdWZmZXIpID0+IHtcbi8vICAgY29uc3QgaGV4TmliYmxlcyA9IGJ5dGVzVG9OaWJibGVzKGtleSkuc3ViYXJyYXkoMCwgdGlsbEJ5dGVzKVxuLy8gICAvLyBSZW1vdmUgdGhlIHRlcm1pbmF0b3IgaWYgaXRzIHRoZXJlLCBhbHRob3VnaCBpdCB3b3VsZCBiZSB0aGVyZSBvbmx5IGlmIHRpbGxCeXRlcyA+PSBrZXkubGVuZ3RoXG4vLyAgIC8vIFRoaXMgc2VlbXMgdG8gYmUgYSB0ZXN0IGhlbHBlciB0byBnZW5lcmF0ZSBwYXRocyBzbyBjb3JyZWN0bmVzcyBvZiB0aGlzIGlzbid0IG5lY2Vzc2FyeVxuLy8gICBoZXhOaWJibGVzW2hleE5pYmJsZXMubGVuZ3RoIC0gMV0gPSAwXG4vLyAgIGNvbnN0IGNvbXBhY3RCeXRlcyA9IG5pYmJsZXNUb0NvbXBhY3RCeXRlcyhoZXhOaWJibGVzKVxuLy8gICByZXR1cm4gW0J1ZmZlci5mcm9tKGNvbXBhY3RCeXRlcyldXG4vLyB9XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbmNvZGluZy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/encoding.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/helpers.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/helpers.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.assertIsString = exports.assertIsArray = exports.assertIsBuffer = exports.assertIsHexString = void 0;\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/internal.js\");\n/**\n * Throws if a string is not hex prefixed\n * @param {string} input string to check hex prefix of\n */\nconst assertIsHexString = function (input) {\n    if (!(0, internal_1.isHexString)(input)) {\n        const msg = `This method only supports 0x-prefixed hex strings but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsHexString = assertIsHexString;\n/**\n * Throws if input is not a buffer\n * @param {Buffer} input value to check\n */\nconst assertIsBuffer = function (input) {\n    if (!Buffer.isBuffer(input)) {\n        const msg = `This method only supports Buffer but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsBuffer = assertIsBuffer;\n/**\n * Throws if input is not an array\n * @param {number[]} input value to check\n */\nconst assertIsArray = function (input) {\n    if (!Array.isArray(input)) {\n        const msg = `This method only supports number arrays but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsArray = assertIsArray;\n/**\n * Throws if input is not a string\n * @param {string} input value to check\n */\nconst assertIsString = function (input) {\n    if (typeof input !== 'string') {\n        const msg = `This method only supports strings but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsString = assertIsString;\n//# sourceMappingURL=helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLHFCQUFxQixHQUFHLHNCQUFzQixHQUFHLHlCQUF5QjtBQUNuRyxtQkFBbUIsbUJBQU8sQ0FBQyxrSEFBWTtBQUN2QztBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RixNQUFNO0FBQzlGO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxNQUFNO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxNQUFNO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxNQUFNO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L2hlbHBlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFzc2VydElzU3RyaW5nID0gZXhwb3J0cy5hc3NlcnRJc0FycmF5ID0gZXhwb3J0cy5hc3NlcnRJc0J1ZmZlciA9IGV4cG9ydHMuYXNzZXJ0SXNIZXhTdHJpbmcgPSB2b2lkIDA7XG5jb25zdCBpbnRlcm5hbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWxcIik7XG4vKipcbiAqIFRocm93cyBpZiBhIHN0cmluZyBpcyBub3QgaGV4IHByZWZpeGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgc3RyaW5nIHRvIGNoZWNrIGhleCBwcmVmaXggb2ZcbiAqL1xuY29uc3QgYXNzZXJ0SXNIZXhTdHJpbmcgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpZiAoISgwLCBpbnRlcm5hbF8xLmlzSGV4U3RyaW5nKShpbnB1dCkpIHtcbiAgICAgICAgY29uc3QgbXNnID0gYFRoaXMgbWV0aG9kIG9ubHkgc3VwcG9ydHMgMHgtcHJlZml4ZWQgaGV4IHN0cmluZ3MgYnV0IGlucHV0IHdhczogJHtpbnB1dH1gO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG59O1xuZXhwb3J0cy5hc3NlcnRJc0hleFN0cmluZyA9IGFzc2VydElzSGV4U3RyaW5nO1xuLyoqXG4gKiBUaHJvd3MgaWYgaW5wdXQgaXMgbm90IGEgYnVmZmVyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaW5wdXQgdmFsdWUgdG8gY2hlY2tcbiAqL1xuY29uc3QgYXNzZXJ0SXNCdWZmZXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihpbnB1dCkpIHtcbiAgICAgICAgY29uc3QgbXNnID0gYFRoaXMgbWV0aG9kIG9ubHkgc3VwcG9ydHMgQnVmZmVyIGJ1dCBpbnB1dCB3YXM6ICR7aW5wdXR9YDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxufTtcbmV4cG9ydHMuYXNzZXJ0SXNCdWZmZXIgPSBhc3NlcnRJc0J1ZmZlcjtcbi8qKlxuICogVGhyb3dzIGlmIGlucHV0IGlzIG5vdCBhbiBhcnJheVxuICogQHBhcmFtIHtudW1iZXJbXX0gaW5wdXQgdmFsdWUgdG8gY2hlY2tcbiAqL1xuY29uc3QgYXNzZXJ0SXNBcnJheSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgY29uc3QgbXNnID0gYFRoaXMgbWV0aG9kIG9ubHkgc3VwcG9ydHMgbnVtYmVyIGFycmF5cyBidXQgaW5wdXQgd2FzOiAke2lucHV0fWA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbn07XG5leHBvcnRzLmFzc2VydElzQXJyYXkgPSBhc3NlcnRJc0FycmF5O1xuLyoqXG4gKiBUaHJvd3MgaWYgaW5wdXQgaXMgbm90IGEgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgdmFsdWUgdG8gY2hlY2tcbiAqL1xuY29uc3QgYXNzZXJ0SXNTdHJpbmcgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBtc2cgPSBgVGhpcyBtZXRob2Qgb25seSBzdXBwb3J0cyBzdHJpbmdzIGJ1dCBpbnB1dCB3YXM6ICR7aW5wdXR9YDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxufTtcbmV4cG9ydHMuYXNzZXJ0SXNTdHJpbmcgPSBhc3NlcnRJc1N0cmluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/helpers.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/index.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/index.js ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toAscii = exports.stripHexPrefix = exports.padToEven = exports.isHexString = exports.isHexPrefixed = exports.getKeys = exports.getBinarySize = exports.fromUtf8 = exports.fromAscii = exports.arrayContainsArray = void 0;\n/**\n * Constants\n */\n__exportStar(__webpack_require__(/*! ./constants */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/constants.js\"), exports);\n/**\n * Units helpers\n */\n__exportStar(__webpack_require__(/*! ./units */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/units.js\"), exports);\n/**\n * Account class and helper functions\n */\n__exportStar(__webpack_require__(/*! ./account */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/account.js\"), exports);\n/**\n * Address type\n */\n__exportStar(__webpack_require__(/*! ./address */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/address.js\"), exports);\n/**\n * Withdrawal type\n */\n__exportStar(__webpack_require__(/*! ./withdrawal */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/withdrawal.js\"), exports);\n/**\n * ECDSA signature\n */\n__exportStar(__webpack_require__(/*! ./signature */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/signature.js\"), exports);\n/**\n * Utilities for manipulating Buffers, byte arrays, etc.\n */\n__exportStar(__webpack_require__(/*! ./bytes */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/bytes.js\"), exports);\n/**\n * Helpful TypeScript types\n */\n__exportStar(__webpack_require__(/*! ./types */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/types.js\"), exports);\n/**\n * Helper function for working with compact encoding\n */\n__exportStar(__webpack_require__(/*! ./encoding */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/encoding.js\"), exports);\n/**\n * Export ethjs-util methods\n */\n__exportStar(__webpack_require__(/*! ./asyncEventEmitter */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/asyncEventEmitter.js\"), exports);\nvar internal_1 = __webpack_require__(/*! ./internal */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/internal.js\");\nObject.defineProperty(exports, \"arrayContainsArray\", ({ enumerable: true, get: function () { return internal_1.arrayContainsArray; } }));\nObject.defineProperty(exports, \"fromAscii\", ({ enumerable: true, get: function () { return internal_1.fromAscii; } }));\nObject.defineProperty(exports, \"fromUtf8\", ({ enumerable: true, get: function () { return internal_1.fromUtf8; } }));\nObject.defineProperty(exports, \"getBinarySize\", ({ enumerable: true, get: function () { return internal_1.getBinarySize; } }));\nObject.defineProperty(exports, \"getKeys\", ({ enumerable: true, get: function () { return internal_1.getKeys; } }));\nObject.defineProperty(exports, \"isHexPrefixed\", ({ enumerable: true, get: function () { return internal_1.isHexPrefixed; } }));\nObject.defineProperty(exports, \"isHexString\", ({ enumerable: true, get: function () { return internal_1.isHexString; } }));\nObject.defineProperty(exports, \"padToEven\", ({ enumerable: true, get: function () { return internal_1.padToEven; } }));\nObject.defineProperty(exports, \"stripHexPrefix\", ({ enumerable: true, get: function () { return internal_1.stripHexPrefix; } }));\nObject.defineProperty(exports, \"toAscii\", ({ enumerable: true, get: function () { return internal_1.toAscii; } }));\n__exportStar(__webpack_require__(/*! ./lock */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/lock.js\"), exports);\n__exportStar(__webpack_require__(/*! ./provider */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/provider.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLEdBQUcsc0JBQXNCLEdBQUcsaUJBQWlCLEdBQUcsbUJBQW1CLEdBQUcscUJBQXFCLEdBQUcsZUFBZSxHQUFHLHFCQUFxQixHQUFHLGdCQUFnQixHQUFHLGlCQUFpQixHQUFHLDBCQUEwQjtBQUN4TjtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsb0hBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLDRHQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxnSEFBVztBQUNoQztBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsZ0hBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLHNIQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxvSEFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsNEdBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLDRHQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxrSEFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsb0lBQXFCO0FBQzFDLGlCQUFpQixtQkFBTyxDQUFDLGtIQUFZO0FBQ3JDLHNEQUFxRCxFQUFFLHFDQUFxQyx5Q0FBeUMsRUFBQztBQUN0SSw2Q0FBNEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDcEgsNENBQTJDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQ2xILGlEQUFnRCxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUM1SCwyQ0FBMEMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDaEgsaURBQWdELEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQzVILCtDQUE4QyxFQUFFLHFDQUFxQyxrQ0FBa0MsRUFBQztBQUN4SCw2Q0FBNEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDcEgsa0RBQWlELEVBQUUscUNBQXFDLHFDQUFxQyxFQUFDO0FBQzlILDJDQUEwQyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNoSCxhQUFhLG1CQUFPLENBQUMsMEdBQVE7QUFDN0IsYUFBYSxtQkFBTyxDQUFDLGtIQUFZO0FBQ2pDIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXNpZy11dGlsL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy91dGlsL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudG9Bc2NpaSA9IGV4cG9ydHMuc3RyaXBIZXhQcmVmaXggPSBleHBvcnRzLnBhZFRvRXZlbiA9IGV4cG9ydHMuaXNIZXhTdHJpbmcgPSBleHBvcnRzLmlzSGV4UHJlZml4ZWQgPSBleHBvcnRzLmdldEtleXMgPSBleHBvcnRzLmdldEJpbmFyeVNpemUgPSBleHBvcnRzLmZyb21VdGY4ID0gZXhwb3J0cy5mcm9tQXNjaWkgPSBleHBvcnRzLmFycmF5Q29udGFpbnNBcnJheSA9IHZvaWQgMDtcbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb25zdGFudHNcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBVbml0cyBoZWxwZXJzXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi91bml0c1wiKSwgZXhwb3J0cyk7XG4vKipcbiAqIEFjY291bnQgY2xhc3MgYW5kIGhlbHBlciBmdW5jdGlvbnNcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FjY291bnRcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBBZGRyZXNzIHR5cGVcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FkZHJlc3NcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBXaXRoZHJhd2FsIHR5cGVcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3dpdGhkcmF3YWxcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBFQ0RTQSBzaWduYXR1cmVcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NpZ25hdHVyZVwiKSwgZXhwb3J0cyk7XG4vKipcbiAqIFV0aWxpdGllcyBmb3IgbWFuaXB1bGF0aW5nIEJ1ZmZlcnMsIGJ5dGUgYXJyYXlzLCBldGMuXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ieXRlc1wiKSwgZXhwb3J0cyk7XG4vKipcbiAqIEhlbHBmdWwgVHlwZVNjcmlwdCB0eXBlc1xuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXNcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gZm9yIHdvcmtpbmcgd2l0aCBjb21wYWN0IGVuY29kaW5nXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lbmNvZGluZ1wiKSwgZXhwb3J0cyk7XG4vKipcbiAqIEV4cG9ydCBldGhqcy11dGlsIG1ldGhvZHNcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FzeW5jRXZlbnRFbWl0dGVyXCIpLCBleHBvcnRzKTtcbnZhciBpbnRlcm5hbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWxcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhcnJheUNvbnRhaW5zQXJyYXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsXzEuYXJyYXlDb250YWluc0FycmF5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZnJvbUFzY2lpXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF8xLmZyb21Bc2NpaTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZyb21VdGY4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF8xLmZyb21VdGY4OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0QmluYXJ5U2l6ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfMS5nZXRCaW5hcnlTaXplOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0S2V5c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfMS5nZXRLZXlzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNIZXhQcmVmaXhlZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfMS5pc0hleFByZWZpeGVkOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNIZXhTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsXzEuaXNIZXhTdHJpbmc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYWRUb0V2ZW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsXzEucGFkVG9FdmVuOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaXBIZXhQcmVmaXhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsXzEuc3RyaXBIZXhQcmVmaXg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b0FzY2lpXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF8xLnRvQXNjaWk7IH0gfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbG9ja1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcHJvdmlkZXJcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/internal.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/internal.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\nThe MIT License\n\nCopyright (c) 2016 Nick Dodson. nickdodson.com\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isHexString = exports.getKeys = exports.fromAscii = exports.fromUtf8 = exports.toAscii = exports.arrayContainsArray = exports.getBinarySize = exports.padToEven = exports.stripHexPrefix = exports.isHexPrefixed = void 0;\n/**\n * Returns a `Boolean` on whether or not the a `String` starts with '0x'\n * @param str the string input value\n * @return a boolean if it is or is not hex prefixed\n * @throws if the str input is not a string\n */\nfunction isHexPrefixed(str) {\n    if (typeof str !== 'string') {\n        throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof str}`);\n    }\n    return str[0] === '0' && str[1] === 'x';\n}\nexports.isHexPrefixed = isHexPrefixed;\n/**\n * Removes '0x' from a given `String` if present\n * @param str the string value\n * @returns the string without 0x prefix\n */\nconst stripHexPrefix = (str) => {\n    if (typeof str !== 'string')\n        throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof str}`);\n    return isHexPrefixed(str) ? str.slice(2) : str;\n};\nexports.stripHexPrefix = stripHexPrefix;\n/**\n * Pads a `String` to have an even length\n * @param value\n * @return output\n */\nfunction padToEven(value) {\n    let a = value;\n    if (typeof a !== 'string') {\n        throw new Error(`[padToEven] value must be type 'string', received ${typeof a}`);\n    }\n    if (a.length % 2)\n        a = `0${a}`;\n    return a;\n}\nexports.padToEven = padToEven;\n/**\n * Get the binary size of a string\n * @param str\n * @returns the number of bytes contained within the string\n */\nfunction getBinarySize(str) {\n    if (typeof str !== 'string') {\n        throw new Error(`[getBinarySize] method requires input type 'string', received ${typeof str}`);\n    }\n    return Buffer.byteLength(str, 'utf8');\n}\nexports.getBinarySize = getBinarySize;\n/**\n * Returns TRUE if the first specified array contains all elements\n * from the second one. FALSE otherwise.\n *\n * @param superset\n * @param subset\n *\n */\nfunction arrayContainsArray(superset, subset, some) {\n    if (Array.isArray(superset) !== true) {\n        throw new Error(`[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof superset}'`);\n    }\n    if (Array.isArray(subset) !== true) {\n        throw new Error(`[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof subset}'`);\n    }\n    return subset[some === true ? 'some' : 'every']((value) => superset.indexOf(value) >= 0);\n}\nexports.arrayContainsArray = arrayContainsArray;\n/**\n * Should be called to get ascii from its hex representation\n *\n * @param string in hex\n * @returns ascii string representation of hex value\n */\nfunction toAscii(hex) {\n    let str = '';\n    let i = 0;\n    const l = hex.length;\n    if (hex.substring(0, 2) === '0x')\n        i = 2;\n    for (; i < l; i += 2) {\n        const code = parseInt(hex.substr(i, 2), 16);\n        str += String.fromCharCode(code);\n    }\n    return str;\n}\nexports.toAscii = toAscii;\n/**\n * Should be called to get hex representation (prefixed by 0x) of utf8 string\n *\n * @param string\n * @param optional padding\n * @returns hex representation of input string\n */\nfunction fromUtf8(stringValue) {\n    const str = Buffer.from(stringValue, 'utf8');\n    return `0x${padToEven(str.toString('hex')).replace(/^0+|0+$/g, '')}`;\n}\nexports.fromUtf8 = fromUtf8;\n/**\n * Should be called to get hex representation (prefixed by 0x) of ascii string\n *\n * @param  string\n * @param  optional padding\n * @returns  hex representation of input string\n */\nfunction fromAscii(stringValue) {\n    let hex = '';\n    for (let i = 0; i < stringValue.length; i++) {\n        const code = stringValue.charCodeAt(i);\n        const n = code.toString(16);\n        hex += n.length < 2 ? `0${n}` : n;\n    }\n    return `0x${hex}`;\n}\nexports.fromAscii = fromAscii;\n/**\n * Returns the keys from an array of objects.\n * @example\n * ```js\n * getKeys([{a: '1', b: '2'}, {a: '3', b: '4'}], 'a') => ['1', '3']\n *````\n * @param  params\n * @param  key\n * @param  allowEmpty\n * @returns output just a simple array of output keys\n */\nfunction getKeys(params, key, allowEmpty) {\n    if (!Array.isArray(params)) {\n        throw new Error(`[getKeys] method expects input 'params' to be an array, got ${typeof params}`);\n    }\n    if (typeof key !== 'string') {\n        throw new Error(`[getKeys] method expects input 'key' to be type 'string', got ${typeof params}`);\n    }\n    const result = [];\n    for (let i = 0; i < params.length; i++) {\n        let value = params[i][key];\n        if (allowEmpty === true && !value) {\n            value = '';\n        }\n        else if (typeof value !== 'string') {\n            throw new Error(`invalid abi - expected type 'string', received ${typeof value}`);\n        }\n        result.push(value);\n    }\n    return result;\n}\nexports.getKeys = getKeys;\n/**\n * Is the string a hex string.\n *\n * @param  value\n * @param  length\n * @returns  output the string is a hex string\n */\nfunction isHexString(value, length) {\n    if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/))\n        return false;\n    if (typeof length !== 'undefined' && length > 0 && value.length !== 2 + 2 * length)\n        return false;\n    return true;\n}\nexports.isHexString = isHexString;\n//# sourceMappingURL=internal.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9pbnRlcm5hbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyxlQUFlLEdBQUcsaUJBQWlCLEdBQUcsZ0JBQWdCLEdBQUcsZUFBZSxHQUFHLDBCQUEwQixHQUFHLHFCQUFxQixHQUFHLGlCQUFpQixHQUFHLHNCQUFzQixHQUFHLHFCQUFxQjtBQUN4TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLFdBQVc7QUFDakc7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLFdBQVc7QUFDN0Y7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLFNBQVM7QUFDdEY7QUFDQTtBQUNBLGdCQUFnQixFQUFFO0FBQ2xCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsV0FBVztBQUNwRztBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkcsZ0JBQWdCO0FBQzNIO0FBQ0E7QUFDQSx5R0FBeUcsY0FBYztBQUN2SDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVEQUF1RDtBQUN2RTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQSxrQ0FBa0MsRUFBRTtBQUNwQztBQUNBLGdCQUFnQixJQUFJO0FBQ3BCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlLEdBQUcsZUFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLGNBQWM7QUFDckc7QUFDQTtBQUNBLHlGQUF5RixjQUFjO0FBQ3ZHO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsYUFBYTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9pbnRlcm5hbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG5UaGUgTUlUIExpY2Vuc2VcblxuQ29weXJpZ2h0IChjKSAyMDE2IE5pY2sgRG9kc29uLiBuaWNrZG9kc29uLmNvbVxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0hleFN0cmluZyA9IGV4cG9ydHMuZ2V0S2V5cyA9IGV4cG9ydHMuZnJvbUFzY2lpID0gZXhwb3J0cy5mcm9tVXRmOCA9IGV4cG9ydHMudG9Bc2NpaSA9IGV4cG9ydHMuYXJyYXlDb250YWluc0FycmF5ID0gZXhwb3J0cy5nZXRCaW5hcnlTaXplID0gZXhwb3J0cy5wYWRUb0V2ZW4gPSBleHBvcnRzLnN0cmlwSGV4UHJlZml4ID0gZXhwb3J0cy5pc0hleFByZWZpeGVkID0gdm9pZCAwO1xuLyoqXG4gKiBSZXR1cm5zIGEgYEJvb2xlYW5gIG9uIHdoZXRoZXIgb3Igbm90IHRoZSBhIGBTdHJpbmdgIHN0YXJ0cyB3aXRoICcweCdcbiAqIEBwYXJhbSBzdHIgdGhlIHN0cmluZyBpbnB1dCB2YWx1ZVxuICogQHJldHVybiBhIGJvb2xlYW4gaWYgaXQgaXMgb3IgaXMgbm90IGhleCBwcmVmaXhlZFxuICogQHRocm93cyBpZiB0aGUgc3RyIGlucHV0IGlzIG5vdCBhIHN0cmluZ1xuICovXG5mdW5jdGlvbiBpc0hleFByZWZpeGVkKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtpc0hleFByZWZpeGVkXSBpbnB1dCBtdXN0IGJlIHR5cGUgJ3N0cmluZycsIHJlY2VpdmVkIHR5cGUgJHt0eXBlb2Ygc3RyfWApO1xuICAgIH1cbiAgICByZXR1cm4gc3RyWzBdID09PSAnMCcgJiYgc3RyWzFdID09PSAneCc7XG59XG5leHBvcnRzLmlzSGV4UHJlZml4ZWQgPSBpc0hleFByZWZpeGVkO1xuLyoqXG4gKiBSZW1vdmVzICcweCcgZnJvbSBhIGdpdmVuIGBTdHJpbmdgIGlmIHByZXNlbnRcbiAqIEBwYXJhbSBzdHIgdGhlIHN0cmluZyB2YWx1ZVxuICogQHJldHVybnMgdGhlIHN0cmluZyB3aXRob3V0IDB4IHByZWZpeFxuICovXG5jb25zdCBzdHJpcEhleFByZWZpeCA9IChzdHIpID0+IHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW3N0cmlwSGV4UHJlZml4XSBpbnB1dCBtdXN0IGJlIHR5cGUgJ3N0cmluZycsIHJlY2VpdmVkICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gaXNIZXhQcmVmaXhlZChzdHIpID8gc3RyLnNsaWNlKDIpIDogc3RyO1xufTtcbmV4cG9ydHMuc3RyaXBIZXhQcmVmaXggPSBzdHJpcEhleFByZWZpeDtcbi8qKlxuICogUGFkcyBhIGBTdHJpbmdgIHRvIGhhdmUgYW4gZXZlbiBsZW5ndGhcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHJldHVybiBvdXRwdXRcbiAqL1xuZnVuY3Rpb24gcGFkVG9FdmVuKHZhbHVlKSB7XG4gICAgbGV0IGEgPSB2YWx1ZTtcbiAgICBpZiAodHlwZW9mIGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW3BhZFRvRXZlbl0gdmFsdWUgbXVzdCBiZSB0eXBlICdzdHJpbmcnLCByZWNlaXZlZCAke3R5cGVvZiBhfWApO1xuICAgIH1cbiAgICBpZiAoYS5sZW5ndGggJSAyKVxuICAgICAgICBhID0gYDAke2F9YDtcbiAgICByZXR1cm4gYTtcbn1cbmV4cG9ydHMucGFkVG9FdmVuID0gcGFkVG9FdmVuO1xuLyoqXG4gKiBHZXQgdGhlIGJpbmFyeSBzaXplIG9mIGEgc3RyaW5nXG4gKiBAcGFyYW0gc3RyXG4gKiBAcmV0dXJucyB0aGUgbnVtYmVyIG9mIGJ5dGVzIGNvbnRhaW5lZCB3aXRoaW4gdGhlIHN0cmluZ1xuICovXG5mdW5jdGlvbiBnZXRCaW5hcnlTaXplKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtnZXRCaW5hcnlTaXplXSBtZXRob2QgcmVxdWlyZXMgaW5wdXQgdHlwZSAnc3RyaW5nJywgcmVjZWl2ZWQgJHt0eXBlb2Ygc3RyfWApO1xuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyLCAndXRmOCcpO1xufVxuZXhwb3J0cy5nZXRCaW5hcnlTaXplID0gZ2V0QmluYXJ5U2l6ZTtcbi8qKlxuICogUmV0dXJucyBUUlVFIGlmIHRoZSBmaXJzdCBzcGVjaWZpZWQgYXJyYXkgY29udGFpbnMgYWxsIGVsZW1lbnRzXG4gKiBmcm9tIHRoZSBzZWNvbmQgb25lLiBGQUxTRSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHN1cGVyc2V0XG4gKiBAcGFyYW0gc3Vic2V0XG4gKlxuICovXG5mdW5jdGlvbiBhcnJheUNvbnRhaW5zQXJyYXkoc3VwZXJzZXQsIHN1YnNldCwgc29tZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN1cGVyc2V0KSAhPT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFthcnJheUNvbnRhaW5zQXJyYXldIG1ldGhvZCByZXF1aXJlcyBpbnB1dCAnc3VwZXJzZXQnIHRvIGJlIGFuIGFycmF5LCBnb3QgdHlwZSAnJHt0eXBlb2Ygc3VwZXJzZXR9J2ApO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdWJzZXQpICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW2FycmF5Q29udGFpbnNBcnJheV0gbWV0aG9kIHJlcXVpcmVzIGlucHV0ICdzdWJzZXQnIHRvIGJlIGFuIGFycmF5LCBnb3QgdHlwZSAnJHt0eXBlb2Ygc3Vic2V0fSdgKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1YnNldFtzb21lID09PSB0cnVlID8gJ3NvbWUnIDogJ2V2ZXJ5J10oKHZhbHVlKSA9PiBzdXBlcnNldC5pbmRleE9mKHZhbHVlKSA+PSAwKTtcbn1cbmV4cG9ydHMuYXJyYXlDb250YWluc0FycmF5ID0gYXJyYXlDb250YWluc0FycmF5O1xuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBhc2NpaSBmcm9tIGl0cyBoZXggcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAcGFyYW0gc3RyaW5nIGluIGhleFxuICogQHJldHVybnMgYXNjaWkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGhleCB2YWx1ZVxuICovXG5mdW5jdGlvbiB0b0FzY2lpKGhleCkge1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3QgbCA9IGhleC5sZW5ndGg7XG4gICAgaWYgKGhleC5zdWJzdHJpbmcoMCwgMikgPT09ICcweCcpXG4gICAgICAgIGkgPSAyO1xuICAgIGZvciAoOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBwYXJzZUludChoZXguc3Vic3RyKGksIDIpLCAxNik7XG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuZXhwb3J0cy50b0FzY2lpID0gdG9Bc2NpaTtcbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaGV4IHJlcHJlc2VudGF0aW9uIChwcmVmaXhlZCBieSAweCkgb2YgdXRmOCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0gc3RyaW5nXG4gKiBAcGFyYW0gb3B0aW9uYWwgcGFkZGluZ1xuICogQHJldHVybnMgaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBmcm9tVXRmOChzdHJpbmdWYWx1ZSkge1xuICAgIGNvbnN0IHN0ciA9IEJ1ZmZlci5mcm9tKHN0cmluZ1ZhbHVlLCAndXRmOCcpO1xuICAgIHJldHVybiBgMHgke3BhZFRvRXZlbihzdHIudG9TdHJpbmcoJ2hleCcpKS5yZXBsYWNlKC9eMCt8MCskL2csICcnKX1gO1xufVxuZXhwb3J0cy5mcm9tVXRmOCA9IGZyb21VdGY4O1xuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBoZXggcmVwcmVzZW50YXRpb24gKHByZWZpeGVkIGJ5IDB4KSBvZiBhc2NpaSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0gIHN0cmluZ1xuICogQHBhcmFtICBvcHRpb25hbCBwYWRkaW5nXG4gKiBAcmV0dXJucyAgaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBmcm9tQXNjaWkoc3RyaW5nVmFsdWUpIHtcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmdWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjb2RlID0gc3RyaW5nVmFsdWUuY2hhckNvZGVBdChpKTtcbiAgICAgICAgY29uc3QgbiA9IGNvZGUudG9TdHJpbmcoMTYpO1xuICAgICAgICBoZXggKz0gbi5sZW5ndGggPCAyID8gYDAke259YCA6IG47XG4gICAgfVxuICAgIHJldHVybiBgMHgke2hleH1gO1xufVxuZXhwb3J0cy5mcm9tQXNjaWkgPSBmcm9tQXNjaWk7XG4vKipcbiAqIFJldHVybnMgdGhlIGtleXMgZnJvbSBhbiBhcnJheSBvZiBvYmplY3RzLlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBnZXRLZXlzKFt7YTogJzEnLCBiOiAnMid9LCB7YTogJzMnLCBiOiAnNCd9XSwgJ2EnKSA9PiBbJzEnLCAnMyddXG4gKmBgYGBcbiAqIEBwYXJhbSAgcGFyYW1zXG4gKiBAcGFyYW0gIGtleVxuICogQHBhcmFtICBhbGxvd0VtcHR5XG4gKiBAcmV0dXJucyBvdXRwdXQganVzdCBhIHNpbXBsZSBhcnJheSBvZiBvdXRwdXQga2V5c1xuICovXG5mdW5jdGlvbiBnZXRLZXlzKHBhcmFtcywga2V5LCBhbGxvd0VtcHR5KSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmFtcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbZ2V0S2V5c10gbWV0aG9kIGV4cGVjdHMgaW5wdXQgJ3BhcmFtcycgdG8gYmUgYW4gYXJyYXksIGdvdCAke3R5cGVvZiBwYXJhbXN9YCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtnZXRLZXlzXSBtZXRob2QgZXhwZWN0cyBpbnB1dCAna2V5JyB0byBiZSB0eXBlICdzdHJpbmcnLCBnb3QgJHt0eXBlb2YgcGFyYW1zfWApO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgdmFsdWUgPSBwYXJhbXNbaV1ba2V5XTtcbiAgICAgICAgaWYgKGFsbG93RW1wdHkgPT09IHRydWUgJiYgIXZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBhYmkgLSBleHBlY3RlZCB0eXBlICdzdHJpbmcnLCByZWNlaXZlZCAke3R5cGVvZiB2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmdldEtleXMgPSBnZXRLZXlzO1xuLyoqXG4gKiBJcyB0aGUgc3RyaW5nIGEgaGV4IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHZhbHVlXG4gKiBAcGFyYW0gIGxlbmd0aFxuICogQHJldHVybnMgIG91dHB1dCB0aGUgc3RyaW5nIGlzIGEgaGV4IHN0cmluZ1xuICovXG5mdW5jdGlvbiBpc0hleFN0cmluZyh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgIXZhbHVlLm1hdGNoKC9eMHhbMC05QS1GYS1mXSokLykpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIGxlbmd0aCAhPT0gJ3VuZGVmaW5lZCcgJiYgbGVuZ3RoID4gMCAmJiB2YWx1ZS5sZW5ndGggIT09IDIgKyAyICogbGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmlzSGV4U3RyaW5nID0gaXNIZXhTdHJpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcm5hbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/internal.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/lock.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/lock.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Lock = void 0;\n// Based on https://github.com/jsoendermann/semaphore-async-await/blob/master/src/Semaphore.ts\nclass Lock {\n    constructor() {\n        this.permits = 1;\n        this.promiseResolverQueue = [];\n    }\n    /**\n     * Returns a promise used to wait for a permit to become available. This method should be awaited on.\n     * @returns  A promise that gets resolved when execution is allowed to proceed.\n     */\n    async acquire() {\n        if (this.permits > 0) {\n            this.permits -= 1;\n            return Promise.resolve(true);\n        }\n        // If there is no permit available, we return a promise that resolves once the semaphore gets\n        // signaled enough times that permits is equal to one.\n        return new Promise((resolver) => this.promiseResolverQueue.push(resolver));\n    }\n    /**\n     * Increases the number of permits by one. If there are other functions waiting, one of them will\n     * continue to execute in a future iteration of the event loop.\n     */\n    release() {\n        this.permits += 1;\n        if (this.permits > 1 && this.promiseResolverQueue.length > 0) {\n            // eslint-disable-next-line no-console\n            console.warn('Lock.permits should never be > 0 when there is someone waiting.');\n        }\n        else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {\n            // If there is someone else waiting, immediately consume the permit that was released\n            // at the beginning of this function and let the waiting function resume.\n            this.permits -= 1;\n            const nextResolver = this.promiseResolverQueue.shift();\n            if (nextResolver) {\n                nextResolver(true);\n            }\n        }\n    }\n}\nexports.Lock = Lock;\n//# sourceMappingURL=lock.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9sb2NrLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L2xvY2suanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxvY2sgPSB2b2lkIDA7XG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vanNvZW5kZXJtYW5uL3NlbWFwaG9yZS1hc3luYy1hd2FpdC9ibG9iL21hc3Rlci9zcmMvU2VtYXBob3JlLnRzXG5jbGFzcyBMb2NrIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wZXJtaXRzID0gMTtcbiAgICAgICAgdGhpcy5wcm9taXNlUmVzb2x2ZXJRdWV1ZSA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB1c2VkIHRvIHdhaXQgZm9yIGEgcGVybWl0IHRvIGJlY29tZSBhdmFpbGFibGUuIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBhd2FpdGVkIG9uLlxuICAgICAqIEByZXR1cm5zICBBIHByb21pc2UgdGhhdCBnZXRzIHJlc29sdmVkIHdoZW4gZXhlY3V0aW9uIGlzIGFsbG93ZWQgdG8gcHJvY2VlZC5cbiAgICAgKi9cbiAgICBhc3luYyBhY3F1aXJlKCkge1xuICAgICAgICBpZiAodGhpcy5wZXJtaXRzID4gMCkge1xuICAgICAgICAgICAgdGhpcy5wZXJtaXRzIC09IDE7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHBlcm1pdCBhdmFpbGFibGUsIHdlIHJldHVybiBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBvbmNlIHRoZSBzZW1hcGhvcmUgZ2V0c1xuICAgICAgICAvLyBzaWduYWxlZCBlbm91Z2ggdGltZXMgdGhhdCBwZXJtaXRzIGlzIGVxdWFsIHRvIG9uZS5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlcikgPT4gdGhpcy5wcm9taXNlUmVzb2x2ZXJRdWV1ZS5wdXNoKHJlc29sdmVyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluY3JlYXNlcyB0aGUgbnVtYmVyIG9mIHBlcm1pdHMgYnkgb25lLiBJZiB0aGVyZSBhcmUgb3RoZXIgZnVuY3Rpb25zIHdhaXRpbmcsIG9uZSBvZiB0aGVtIHdpbGxcbiAgICAgKiBjb250aW51ZSB0byBleGVjdXRlIGluIGEgZnV0dXJlIGl0ZXJhdGlvbiBvZiB0aGUgZXZlbnQgbG9vcC5cbiAgICAgKi9cbiAgICByZWxlYXNlKCkge1xuICAgICAgICB0aGlzLnBlcm1pdHMgKz0gMTtcbiAgICAgICAgaWYgKHRoaXMucGVybWl0cyA+IDEgJiYgdGhpcy5wcm9taXNlUmVzb2x2ZXJRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdMb2NrLnBlcm1pdHMgc2hvdWxkIG5ldmVyIGJlID4gMCB3aGVuIHRoZXJlIGlzIHNvbWVvbmUgd2FpdGluZy4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnBlcm1pdHMgPT09IDEgJiYgdGhpcy5wcm9taXNlUmVzb2x2ZXJRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBzb21lb25lIGVsc2Ugd2FpdGluZywgaW1tZWRpYXRlbHkgY29uc3VtZSB0aGUgcGVybWl0IHRoYXQgd2FzIHJlbGVhc2VkXG4gICAgICAgICAgICAvLyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgZnVuY3Rpb24gYW5kIGxldCB0aGUgd2FpdGluZyBmdW5jdGlvbiByZXN1bWUuXG4gICAgICAgICAgICB0aGlzLnBlcm1pdHMgLT0gMTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRSZXNvbHZlciA9IHRoaXMucHJvbWlzZVJlc29sdmVyUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChuZXh0UmVzb2x2ZXIpIHtcbiAgICAgICAgICAgICAgICBuZXh0UmVzb2x2ZXIodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkxvY2sgPSBMb2NrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jay5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/lock.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/provider.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/provider.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getProvider = exports.fetchFromProvider = void 0;\nconst micro_ftch_1 = __webpack_require__(/*! micro-ftch */ \"(rsc)/../../node_modules/micro-ftch/index.js\");\nconst fetchFromProvider = async (url, params) => {\n    const res = await (0, micro_ftch_1.default)(url, {\n        headers: {\n            'content-type': 'application/json',\n        },\n        type: 'json',\n        data: {\n            method: params.method,\n            params: params.params,\n            jsonrpc: '2.0',\n            id: 1,\n        },\n    });\n    return res.result;\n};\nexports.fetchFromProvider = fetchFromProvider;\nconst getProvider = (provider) => {\n    if (typeof provider === 'string') {\n        return provider;\n    }\n    else if (provider?.connection?.url !== undefined) {\n        return provider.connection.url;\n    }\n    else {\n        throw new Error('Must provide valid provider URL or Web3Provider');\n    }\n};\nexports.getProvider = getProvider;\n//# sourceMappingURL=provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyx5QkFBeUI7QUFDL0MscUJBQXFCLG1CQUFPLENBQUMsZ0VBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9wcm92aWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0UHJvdmlkZXIgPSBleHBvcnRzLmZldGNoRnJvbVByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3QgbWljcm9fZnRjaF8xID0gcmVxdWlyZShcIm1pY3JvLWZ0Y2hcIik7XG5jb25zdCBmZXRjaEZyb21Qcm92aWRlciA9IGFzeW5jICh1cmwsIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0ICgwLCBtaWNyb19mdGNoXzEuZGVmYXVsdCkodXJsLCB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6ICdqc29uJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgbWV0aG9kOiBwYXJhbXMubWV0aG9kLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMucGFyYW1zLFxuICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICBpZDogMSxcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbn07XG5leHBvcnRzLmZldGNoRnJvbVByb3ZpZGVyID0gZmV0Y2hGcm9tUHJvdmlkZXI7XG5jb25zdCBnZXRQcm92aWRlciA9IChwcm92aWRlcikgPT4ge1xuICAgIGlmICh0eXBlb2YgcHJvdmlkZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBwcm92aWRlcjtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvdmlkZXI/LmNvbm5lY3Rpb24/LnVybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBwcm92aWRlci5jb25uZWN0aW9uLnVybDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIHZhbGlkIHByb3ZpZGVyIFVSTCBvciBXZWIzUHJvdmlkZXInKTtcbiAgICB9XG59O1xuZXhwb3J0cy5nZXRQcm92aWRlciA9IGdldFByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/provider.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/signature.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/signature.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toCompactSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;\nconst keccak_1 = __webpack_require__(/*! ethereum-cryptography/keccak */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/ethereum-cryptography/keccak.js\");\nconst secp256k1_1 = __webpack_require__(/*! ethereum-cryptography/secp256k1 */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/ethereum-cryptography/secp256k1.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/bytes.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/constants.js\");\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/helpers.js\");\n/**\n * Returns the ECDSA signature of a message hash.\n *\n * If `chainId` is provided assume an EIP-155-style signature and calculate the `v` value\n * accordingly, otherwise return a \"static\" `v` just derived from the `recovery` bit\n */\nfunction ecsign(msgHash, privateKey, chainId) {\n    const sig = secp256k1_1.secp256k1.sign(msgHash, privateKey);\n    const buf = sig.toCompactRawBytes();\n    const r = Buffer.from(buf.slice(0, 32));\n    const s = Buffer.from(buf.slice(32, 64));\n    const v = chainId === undefined\n        ? BigInt(sig.recovery + 27)\n        : BigInt(sig.recovery + 35) + BigInt(chainId) * BigInt(2);\n    return { r, s, v };\n}\nexports.ecsign = ecsign;\nfunction calculateSigRecovery(v, chainId) {\n    if (v === BigInt(0) || v === BigInt(1))\n        return v;\n    if (chainId === undefined) {\n        return v - BigInt(27);\n    }\n    return v - (chainId * BigInt(2) + BigInt(35));\n}\nfunction isValidSigRecovery(recovery) {\n    return recovery === BigInt(0) || recovery === BigInt(1);\n}\n/**\n * ECDSA public key recovery from signature.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Recovered public key\n */\nconst ecrecover = function (msgHash, v, r, s, chainId) {\n    const signature = Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(s, 32)], 64);\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error('Invalid signature v value');\n    }\n    const sig = secp256k1_1.secp256k1.Signature.fromCompact(signature).addRecoveryBit(Number(recovery));\n    const senderPubKey = sig.recoverPublicKey(msgHash);\n    return Buffer.from(senderPubKey.toRawBytes(false).slice(1));\n};\nexports.ecrecover = ecrecover;\n/**\n * Convert signature parameters into the format of `eth_sign` RPC method.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Signature\n */\nconst toRpcSig = function (v, r, s, chainId) {\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error('Invalid signature v value');\n    }\n    // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin\n    return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(s, 32), (0, bytes_1.toBuffer)(v)]));\n};\nexports.toRpcSig = toRpcSig;\n/**\n * Convert signature parameters into the format of Compact Signature Representation (EIP-2098).\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Signature\n */\nconst toCompactSig = function (v, r, s, chainId) {\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error('Invalid signature v value');\n    }\n    let ss = s;\n    if ((v > BigInt(28) && v % BigInt(2) === BigInt(1)) || v === BigInt(1) || v === BigInt(28)) {\n        ss = Buffer.from(s);\n        ss[0] |= 0x80;\n    }\n    return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(ss, 32)]));\n};\nexports.toCompactSig = toCompactSig;\n/**\n * Convert signature format of the `eth_sign` RPC method to signature parameters\n *\n * NOTE: For an extracted `v` value < 27 (see Geth bug https://github.com/ethereum/go-ethereum/issues/2053)\n * `v + 27` is returned for the `v` value\n * NOTE: After EIP1559, `v` could be `0` or `1` but this function assumes\n * it's a signed message (EIP-191 or EIP-712) adding `27` at the end. Remove if needed.\n */\nconst fromRpcSig = function (sig) {\n    const buf = (0, bytes_1.toBuffer)(sig);\n    let r;\n    let s;\n    let v;\n    if (buf.length >= 65) {\n        r = buf.slice(0, 32);\n        s = buf.slice(32, 64);\n        v = (0, bytes_1.bufferToBigInt)(buf.slice(64));\n    }\n    else if (buf.length === 64) {\n        // Compact Signature Representation (https://eips.ethereum.org/EIPS/eip-2098)\n        r = buf.slice(0, 32);\n        s = buf.slice(32, 64);\n        v = BigInt((0, bytes_1.bufferToInt)(buf.slice(32, 33)) >> 7);\n        s[0] &= 0x7f;\n    }\n    else {\n        throw new Error('Invalid signature length');\n    }\n    // support both versions of `eth_sign` responses\n    if (v < 27) {\n        v = v + BigInt(27);\n    }\n    return {\n        v,\n        r,\n        s,\n    };\n};\nexports.fromRpcSig = fromRpcSig;\n/**\n * Validate a ECDSA signature.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one\n */\nconst isValidSignature = function (v, r, s, homesteadOrLater = true, chainId) {\n    if (r.length !== 32 || s.length !== 32) {\n        return false;\n    }\n    if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {\n        return false;\n    }\n    const rBigInt = (0, bytes_1.bufferToBigInt)(r);\n    const sBigInt = (0, bytes_1.bufferToBigInt)(s);\n    if (rBigInt === BigInt(0) ||\n        rBigInt >= constants_1.SECP256K1_ORDER ||\n        sBigInt === BigInt(0) ||\n        sBigInt >= constants_1.SECP256K1_ORDER) {\n        return false;\n    }\n    if (homesteadOrLater && sBigInt >= constants_1.SECP256K1_ORDER_DIV_2) {\n        return false;\n    }\n    return true;\n};\nexports.isValidSignature = isValidSignature;\n/**\n * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.\n * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`\n * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key\n * used to produce the signature.\n */\nconst hashPersonalMessage = function (message) {\n    (0, helpers_1.assertIsBuffer)(message);\n    const prefix = Buffer.from(`\\u0019Ethereum Signed Message:\\n${message.length}`, 'utf-8');\n    return Buffer.from((0, keccak_1.keccak256)(Buffer.concat([prefix, message])));\n};\nexports.hashPersonalMessage = hashPersonalMessage;\n//# sourceMappingURL=signature.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9zaWduYXR1cmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCLEdBQUcsd0JBQXdCLEdBQUcsa0JBQWtCLEdBQUcsb0JBQW9CLEdBQUcsZ0JBQWdCLEdBQUcsaUJBQWlCLEdBQUcsY0FBYztBQUMxSixpQkFBaUIsbUJBQU8sQ0FBQyxrSUFBOEI7QUFDdkQsb0JBQW9CLG1CQUFPLENBQUMsd0lBQWlDO0FBQzdELGdCQUFnQixtQkFBTyxDQUFDLDRHQUFTO0FBQ2pDLG9CQUFvQixtQkFBTyxDQUFDLG9IQUFhO0FBQ3pDLGtCQUFrQixtQkFBTyxDQUFDLGdIQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxlQUFlO0FBQ2pGO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9zaWduYXR1cmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhhc2hQZXJzb25hbE1lc3NhZ2UgPSBleHBvcnRzLmlzVmFsaWRTaWduYXR1cmUgPSBleHBvcnRzLmZyb21ScGNTaWcgPSBleHBvcnRzLnRvQ29tcGFjdFNpZyA9IGV4cG9ydHMudG9ScGNTaWcgPSBleHBvcnRzLmVjcmVjb3ZlciA9IGV4cG9ydHMuZWNzaWduID0gdm9pZCAwO1xuY29uc3Qga2VjY2FrXzEgPSByZXF1aXJlKFwiZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2Nha1wiKTtcbmNvbnN0IHNlY3AyNTZrMV8xID0gcmVxdWlyZShcImV0aGVyZXVtLWNyeXB0b2dyYXBoeS9zZWNwMjU2azFcIik7XG5jb25zdCBieXRlc18xID0gcmVxdWlyZShcIi4vYnl0ZXNcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGhlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIik7XG4vKipcbiAqIFJldHVybnMgdGhlIEVDRFNBIHNpZ25hdHVyZSBvZiBhIG1lc3NhZ2UgaGFzaC5cbiAqXG4gKiBJZiBgY2hhaW5JZGAgaXMgcHJvdmlkZWQgYXNzdW1lIGFuIEVJUC0xNTUtc3R5bGUgc2lnbmF0dXJlIGFuZCBjYWxjdWxhdGUgdGhlIGB2YCB2YWx1ZVxuICogYWNjb3JkaW5nbHksIG90aGVyd2lzZSByZXR1cm4gYSBcInN0YXRpY1wiIGB2YCBqdXN0IGRlcml2ZWQgZnJvbSB0aGUgYHJlY292ZXJ5YCBiaXRcbiAqL1xuZnVuY3Rpb24gZWNzaWduKG1zZ0hhc2gsIHByaXZhdGVLZXksIGNoYWluSWQpIHtcbiAgICBjb25zdCBzaWcgPSBzZWNwMjU2azFfMS5zZWNwMjU2azEuc2lnbihtc2dIYXNoLCBwcml2YXRlS2V5KTtcbiAgICBjb25zdCBidWYgPSBzaWcudG9Db21wYWN0UmF3Qnl0ZXMoKTtcbiAgICBjb25zdCByID0gQnVmZmVyLmZyb20oYnVmLnNsaWNlKDAsIDMyKSk7XG4gICAgY29uc3QgcyA9IEJ1ZmZlci5mcm9tKGJ1Zi5zbGljZSgzMiwgNjQpKTtcbiAgICBjb25zdCB2ID0gY2hhaW5JZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gQmlnSW50KHNpZy5yZWNvdmVyeSArIDI3KVxuICAgICAgICA6IEJpZ0ludChzaWcucmVjb3ZlcnkgKyAzNSkgKyBCaWdJbnQoY2hhaW5JZCkgKiBCaWdJbnQoMik7XG4gICAgcmV0dXJuIHsgciwgcywgdiB9O1xufVxuZXhwb3J0cy5lY3NpZ24gPSBlY3NpZ247XG5mdW5jdGlvbiBjYWxjdWxhdGVTaWdSZWNvdmVyeSh2LCBjaGFpbklkKSB7XG4gICAgaWYgKHYgPT09IEJpZ0ludCgwKSB8fCB2ID09PSBCaWdJbnQoMSkpXG4gICAgICAgIHJldHVybiB2O1xuICAgIGlmIChjaGFpbklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHYgLSBCaWdJbnQoMjcpO1xuICAgIH1cbiAgICByZXR1cm4gdiAtIChjaGFpbklkICogQmlnSW50KDIpICsgQmlnSW50KDM1KSk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkU2lnUmVjb3ZlcnkocmVjb3ZlcnkpIHtcbiAgICByZXR1cm4gcmVjb3ZlcnkgPT09IEJpZ0ludCgwKSB8fCByZWNvdmVyeSA9PT0gQmlnSW50KDEpO1xufVxuLyoqXG4gKiBFQ0RTQSBwdWJsaWMga2V5IHJlY292ZXJ5IGZyb20gc2lnbmF0dXJlLlxuICogTk9URTogQWNjZXB0cyBgdiA9PT0gMCB8IHYgPT09IDFgIGZvciBFSVAxNTU5IHRyYW5zYWN0aW9uc1xuICogQHJldHVybnMgUmVjb3ZlcmVkIHB1YmxpYyBrZXlcbiAqL1xuY29uc3QgZWNyZWNvdmVyID0gZnVuY3Rpb24gKG1zZ0hhc2gsIHYsIHIsIHMsIGNoYWluSWQpIHtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBCdWZmZXIuY29uY2F0KFsoMCwgYnl0ZXNfMS5zZXRMZW5ndGhMZWZ0KShyLCAzMiksICgwLCBieXRlc18xLnNldExlbmd0aExlZnQpKHMsIDMyKV0sIDY0KTtcbiAgICBjb25zdCByZWNvdmVyeSA9IGNhbGN1bGF0ZVNpZ1JlY292ZXJ5KHYsIGNoYWluSWQpO1xuICAgIGlmICghaXNWYWxpZFNpZ1JlY292ZXJ5KHJlY292ZXJ5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIHYgdmFsdWUnKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnID0gc2VjcDI1NmsxXzEuc2VjcDI1NmsxLlNpZ25hdHVyZS5mcm9tQ29tcGFjdChzaWduYXR1cmUpLmFkZFJlY292ZXJ5Qml0KE51bWJlcihyZWNvdmVyeSkpO1xuICAgIGNvbnN0IHNlbmRlclB1YktleSA9IHNpZy5yZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gpO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZW5kZXJQdWJLZXkudG9SYXdCeXRlcyhmYWxzZSkuc2xpY2UoMSkpO1xufTtcbmV4cG9ydHMuZWNyZWNvdmVyID0gZWNyZWNvdmVyO1xuLyoqXG4gKiBDb252ZXJ0IHNpZ25hdHVyZSBwYXJhbWV0ZXJzIGludG8gdGhlIGZvcm1hdCBvZiBgZXRoX3NpZ25gIFJQQyBtZXRob2QuXG4gKiBOT1RFOiBBY2NlcHRzIGB2ID09PSAwIHwgdiA9PT0gMWAgZm9yIEVJUDE1NTkgdHJhbnNhY3Rpb25zXG4gKiBAcmV0dXJucyBTaWduYXR1cmVcbiAqL1xuY29uc3QgdG9ScGNTaWcgPSBmdW5jdGlvbiAodiwgciwgcywgY2hhaW5JZCkge1xuICAgIGNvbnN0IHJlY292ZXJ5ID0gY2FsY3VsYXRlU2lnUmVjb3ZlcnkodiwgY2hhaW5JZCk7XG4gICAgaWYgKCFpc1ZhbGlkU2lnUmVjb3ZlcnkocmVjb3ZlcnkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgdiB2YWx1ZScpO1xuICAgIH1cbiAgICAvLyBnZXRoIChhbmQgdGhlIFJQQyBldGhfc2lnbiBtZXRob2QpIHVzZXMgdGhlIDY1IGJ5dGUgZm9ybWF0IHVzZWQgYnkgQml0Y29pblxuICAgIHJldHVybiAoMCwgYnl0ZXNfMS5idWZmZXJUb0hleCkoQnVmZmVyLmNvbmNhdChbKDAsIGJ5dGVzXzEuc2V0TGVuZ3RoTGVmdCkociwgMzIpLCAoMCwgYnl0ZXNfMS5zZXRMZW5ndGhMZWZ0KShzLCAzMiksICgwLCBieXRlc18xLnRvQnVmZmVyKSh2KV0pKTtcbn07XG5leHBvcnRzLnRvUnBjU2lnID0gdG9ScGNTaWc7XG4vKipcbiAqIENvbnZlcnQgc2lnbmF0dXJlIHBhcmFtZXRlcnMgaW50byB0aGUgZm9ybWF0IG9mIENvbXBhY3QgU2lnbmF0dXJlIFJlcHJlc2VudGF0aW9uIChFSVAtMjA5OCkuXG4gKiBOT1RFOiBBY2NlcHRzIGB2ID09PSAwIHwgdiA9PT0gMWAgZm9yIEVJUDE1NTkgdHJhbnNhY3Rpb25zXG4gKiBAcmV0dXJucyBTaWduYXR1cmVcbiAqL1xuY29uc3QgdG9Db21wYWN0U2lnID0gZnVuY3Rpb24gKHYsIHIsIHMsIGNoYWluSWQpIHtcbiAgICBjb25zdCByZWNvdmVyeSA9IGNhbGN1bGF0ZVNpZ1JlY292ZXJ5KHYsIGNoYWluSWQpO1xuICAgIGlmICghaXNWYWxpZFNpZ1JlY292ZXJ5KHJlY292ZXJ5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIHYgdmFsdWUnKTtcbiAgICB9XG4gICAgbGV0IHNzID0gcztcbiAgICBpZiAoKHYgPiBCaWdJbnQoMjgpICYmIHYgJSBCaWdJbnQoMikgPT09IEJpZ0ludCgxKSkgfHwgdiA9PT0gQmlnSW50KDEpIHx8IHYgPT09IEJpZ0ludCgyOCkpIHtcbiAgICAgICAgc3MgPSBCdWZmZXIuZnJvbShzKTtcbiAgICAgICAgc3NbMF0gfD0gMHg4MDtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBieXRlc18xLmJ1ZmZlclRvSGV4KShCdWZmZXIuY29uY2F0KFsoMCwgYnl0ZXNfMS5zZXRMZW5ndGhMZWZ0KShyLCAzMiksICgwLCBieXRlc18xLnNldExlbmd0aExlZnQpKHNzLCAzMildKSk7XG59O1xuZXhwb3J0cy50b0NvbXBhY3RTaWcgPSB0b0NvbXBhY3RTaWc7XG4vKipcbiAqIENvbnZlcnQgc2lnbmF0dXJlIGZvcm1hdCBvZiB0aGUgYGV0aF9zaWduYCBSUEMgbWV0aG9kIHRvIHNpZ25hdHVyZSBwYXJhbWV0ZXJzXG4gKlxuICogTk9URTogRm9yIGFuIGV4dHJhY3RlZCBgdmAgdmFsdWUgPCAyNyAoc2VlIEdldGggYnVnIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS9pc3N1ZXMvMjA1MylcbiAqIGB2ICsgMjdgIGlzIHJldHVybmVkIGZvciB0aGUgYHZgIHZhbHVlXG4gKiBOT1RFOiBBZnRlciBFSVAxNTU5LCBgdmAgY291bGQgYmUgYDBgIG9yIGAxYCBidXQgdGhpcyBmdW5jdGlvbiBhc3N1bWVzXG4gKiBpdCdzIGEgc2lnbmVkIG1lc3NhZ2UgKEVJUC0xOTEgb3IgRUlQLTcxMikgYWRkaW5nIGAyN2AgYXQgdGhlIGVuZC4gUmVtb3ZlIGlmIG5lZWRlZC5cbiAqL1xuY29uc3QgZnJvbVJwY1NpZyA9IGZ1bmN0aW9uIChzaWcpIHtcbiAgICBjb25zdCBidWYgPSAoMCwgYnl0ZXNfMS50b0J1ZmZlcikoc2lnKTtcbiAgICBsZXQgcjtcbiAgICBsZXQgcztcbiAgICBsZXQgdjtcbiAgICBpZiAoYnVmLmxlbmd0aCA+PSA2NSkge1xuICAgICAgICByID0gYnVmLnNsaWNlKDAsIDMyKTtcbiAgICAgICAgcyA9IGJ1Zi5zbGljZSgzMiwgNjQpO1xuICAgICAgICB2ID0gKDAsIGJ5dGVzXzEuYnVmZmVyVG9CaWdJbnQpKGJ1Zi5zbGljZSg2NCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChidWYubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAvLyBDb21wYWN0IFNpZ25hdHVyZSBSZXByZXNlbnRhdGlvbiAoaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0yMDk4KVxuICAgICAgICByID0gYnVmLnNsaWNlKDAsIDMyKTtcbiAgICAgICAgcyA9IGJ1Zi5zbGljZSgzMiwgNjQpO1xuICAgICAgICB2ID0gQmlnSW50KCgwLCBieXRlc18xLmJ1ZmZlclRvSW50KShidWYuc2xpY2UoMzIsIDMzKSkgPj4gNyk7XG4gICAgICAgIHNbMF0gJj0gMHg3ZjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgbGVuZ3RoJyk7XG4gICAgfVxuICAgIC8vIHN1cHBvcnQgYm90aCB2ZXJzaW9ucyBvZiBgZXRoX3NpZ25gIHJlc3BvbnNlc1xuICAgIGlmICh2IDwgMjcpIHtcbiAgICAgICAgdiA9IHYgKyBCaWdJbnQoMjcpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB2LFxuICAgICAgICByLFxuICAgICAgICBzLFxuICAgIH07XG59O1xuZXhwb3J0cy5mcm9tUnBjU2lnID0gZnJvbVJwY1NpZztcbi8qKlxuICogVmFsaWRhdGUgYSBFQ0RTQSBzaWduYXR1cmUuXG4gKiBOT1RFOiBBY2NlcHRzIGB2ID09PSAwIHwgdiA9PT0gMWAgZm9yIEVJUDE1NTkgdHJhbnNhY3Rpb25zXG4gKiBAcGFyYW0gaG9tZXN0ZWFkT3JMYXRlciBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIGJlaW5nIHVzZWQgb24gZWl0aGVyIHRoZSBob21lc3RlYWQgaGFyZGZvcmsgb3IgYSBsYXRlciBvbmVcbiAqL1xuY29uc3QgaXNWYWxpZFNpZ25hdHVyZSA9IGZ1bmN0aW9uICh2LCByLCBzLCBob21lc3RlYWRPckxhdGVyID0gdHJ1ZSwgY2hhaW5JZCkge1xuICAgIGlmIChyLmxlbmd0aCAhPT0gMzIgfHwgcy5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFpc1ZhbGlkU2lnUmVjb3ZlcnkoY2FsY3VsYXRlU2lnUmVjb3ZlcnkodiwgY2hhaW5JZCkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgckJpZ0ludCA9ICgwLCBieXRlc18xLmJ1ZmZlclRvQmlnSW50KShyKTtcbiAgICBjb25zdCBzQmlnSW50ID0gKDAsIGJ5dGVzXzEuYnVmZmVyVG9CaWdJbnQpKHMpO1xuICAgIGlmIChyQmlnSW50ID09PSBCaWdJbnQoMCkgfHxcbiAgICAgICAgckJpZ0ludCA+PSBjb25zdGFudHNfMS5TRUNQMjU2SzFfT1JERVIgfHxcbiAgICAgICAgc0JpZ0ludCA9PT0gQmlnSW50KDApIHx8XG4gICAgICAgIHNCaWdJbnQgPj0gY29uc3RhbnRzXzEuU0VDUDI1NksxX09SREVSKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGhvbWVzdGVhZE9yTGF0ZXIgJiYgc0JpZ0ludCA+PSBjb25zdGFudHNfMS5TRUNQMjU2SzFfT1JERVJfRElWXzIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5leHBvcnRzLmlzVmFsaWRTaWduYXR1cmUgPSBpc1ZhbGlkU2lnbmF0dXJlO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBrZWNjYWstMjU2IGhhc2ggb2YgYG1lc3NhZ2VgLCBwcmVmaXhlZCB3aXRoIHRoZSBoZWFkZXIgdXNlZCBieSB0aGUgYGV0aF9zaWduYCBSUEMgY2FsbC5cbiAqIFRoZSBvdXRwdXQgb2YgdGhpcyBmdW5jdGlvbiBjYW4gYmUgZmVkIGludG8gYGVjc2lnbmAgdG8gcHJvZHVjZSB0aGUgc2FtZSBzaWduYXR1cmUgYXMgdGhlIGBldGhfc2lnbmBcbiAqIGNhbGwgZm9yIGEgZ2l2ZW4gYG1lc3NhZ2VgLCBvciBmZWQgdG8gYGVjcmVjb3ZlcmAgYWxvbmcgd2l0aCBhIHNpZ25hdHVyZSB0byByZWNvdmVyIHRoZSBwdWJsaWMga2V5XG4gKiB1c2VkIHRvIHByb2R1Y2UgdGhlIHNpZ25hdHVyZS5cbiAqL1xuY29uc3QgaGFzaFBlcnNvbmFsTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikobWVzc2FnZSk7XG4gICAgY29uc3QgcHJlZml4ID0gQnVmZmVyLmZyb20oYFxcdTAwMTlFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcXG4ke21lc3NhZ2UubGVuZ3RofWAsICd1dGYtOCcpO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSgoMCwga2VjY2FrXzEua2VjY2FrMjU2KShCdWZmZXIuY29uY2F0KFtwcmVmaXgsIG1lc3NhZ2VdKSkpO1xufTtcbmV4cG9ydHMuaGFzaFBlcnNvbmFsTWVzc2FnZSA9IGhhc2hQZXJzb25hbE1lc3NhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduYXR1cmUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/signature.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/types.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/types.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toType = exports.TypeOutput = void 0;\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/bytes.js\");\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/internal.js\");\n/**\n * Type output options\n */\nvar TypeOutput;\n(function (TypeOutput) {\n    TypeOutput[TypeOutput[\"Number\"] = 0] = \"Number\";\n    TypeOutput[TypeOutput[\"BigInt\"] = 1] = \"BigInt\";\n    TypeOutput[TypeOutput[\"Buffer\"] = 2] = \"Buffer\";\n    TypeOutput[TypeOutput[\"PrefixedHexString\"] = 3] = \"PrefixedHexString\";\n})(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));\nfunction toType(input, outputType) {\n    if (input === null) {\n        return null;\n    }\n    if (input === undefined) {\n        return undefined;\n    }\n    if (typeof input === 'string' && !(0, internal_1.isHexString)(input)) {\n        throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);\n    }\n    else if (typeof input === 'number' && !Number.isSafeInteger(input)) {\n        throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');\n    }\n    const output = (0, bytes_1.toBuffer)(input);\n    switch (outputType) {\n        case TypeOutput.Buffer:\n            return output;\n        case TypeOutput.BigInt:\n            return (0, bytes_1.bufferToBigInt)(output);\n        case TypeOutput.Number: {\n            const bigInt = (0, bytes_1.bufferToBigInt)(output);\n            if (bigInt > BigInt(Number.MAX_SAFE_INTEGER)) {\n                throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)');\n            }\n            return Number(bigInt);\n        }\n        case TypeOutput.PrefixedHexString:\n            return (0, bytes_1.bufferToHex)(output);\n        default:\n            throw new Error('unknown outputType');\n    }\n}\nexports.toType = toType;\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsa0JBQWtCO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLDRHQUFTO0FBQ2pDLG1CQUFtQixtQkFBTyxDQUFDLGtIQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDLGtCQUFrQixLQUFLO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsTUFBTTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXNpZy11dGlsL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy91dGlsL2Rpc3QvdHlwZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRvVHlwZSA9IGV4cG9ydHMuVHlwZU91dHB1dCA9IHZvaWQgMDtcbmNvbnN0IGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlc1wiKTtcbmNvbnN0IGludGVybmFsXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbFwiKTtcbi8qKlxuICogVHlwZSBvdXRwdXQgb3B0aW9uc1xuICovXG52YXIgVHlwZU91dHB1dDtcbihmdW5jdGlvbiAoVHlwZU91dHB1dCkge1xuICAgIFR5cGVPdXRwdXRbVHlwZU91dHB1dFtcIk51bWJlclwiXSA9IDBdID0gXCJOdW1iZXJcIjtcbiAgICBUeXBlT3V0cHV0W1R5cGVPdXRwdXRbXCJCaWdJbnRcIl0gPSAxXSA9IFwiQmlnSW50XCI7XG4gICAgVHlwZU91dHB1dFtUeXBlT3V0cHV0W1wiQnVmZmVyXCJdID0gMl0gPSBcIkJ1ZmZlclwiO1xuICAgIFR5cGVPdXRwdXRbVHlwZU91dHB1dFtcIlByZWZpeGVkSGV4U3RyaW5nXCJdID0gM10gPSBcIlByZWZpeGVkSGV4U3RyaW5nXCI7XG59KShUeXBlT3V0cHV0ID0gZXhwb3J0cy5UeXBlT3V0cHV0IHx8IChleHBvcnRzLlR5cGVPdXRwdXQgPSB7fSkpO1xuZnVuY3Rpb24gdG9UeXBlKGlucHV0LCBvdXRwdXRUeXBlKSB7XG4gICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyAmJiAhKDAsIGludGVybmFsXzEuaXNIZXhTdHJpbmcpKGlucHV0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgc3RyaW5nIG11c3QgYmUgcHJvdmlkZWQgd2l0aCBhIDB4LXByZWZpeCwgZ2l2ZW46ICR7aW5wdXR9YCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicgJiYgIU51bWJlci5pc1NhZmVJbnRlZ2VyKGlucHV0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwcm92aWRlZCBudW1iZXIgaXMgZ3JlYXRlciB0aGFuIE1BWF9TQUZFX0lOVEVHRVIgKHBsZWFzZSB1c2UgYW4gYWx0ZXJuYXRpdmUgaW5wdXQgdHlwZSknKTtcbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0ID0gKDAsIGJ5dGVzXzEudG9CdWZmZXIpKGlucHV0KTtcbiAgICBzd2l0Y2ggKG91dHB1dFR5cGUpIHtcbiAgICAgICAgY2FzZSBUeXBlT3V0cHV0LkJ1ZmZlcjpcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIGNhc2UgVHlwZU91dHB1dC5CaWdJbnQ6XG4gICAgICAgICAgICByZXR1cm4gKDAsIGJ5dGVzXzEuYnVmZmVyVG9CaWdJbnQpKG91dHB1dCk7XG4gICAgICAgIGNhc2UgVHlwZU91dHB1dC5OdW1iZXI6IHtcbiAgICAgICAgICAgIGNvbnN0IGJpZ0ludCA9ICgwLCBieXRlc18xLmJ1ZmZlclRvQmlnSW50KShvdXRwdXQpO1xuICAgICAgICAgICAgaWYgKGJpZ0ludCA+IEJpZ0ludChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwcm92aWRlZCBudW1iZXIgaXMgZ3JlYXRlciB0aGFuIE1BWF9TQUZFX0lOVEVHRVIgKHBsZWFzZSB1c2UgYW4gYWx0ZXJuYXRpdmUgb3V0cHV0IHR5cGUpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKGJpZ0ludCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBUeXBlT3V0cHV0LlByZWZpeGVkSGV4U3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuICgwLCBieXRlc18xLmJ1ZmZlclRvSGV4KShvdXRwdXQpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIG91dHB1dFR5cGUnKTtcbiAgICB9XG59XG5leHBvcnRzLnRvVHlwZSA9IHRvVHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/types.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/units.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/units.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GWEI_TO_WEI = void 0;\n/** Easy conversion from Gwei to wei */\nexports.GWEI_TO_WEI = BigInt(1000000000);\n//# sourceMappingURL=units.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC91bml0cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC91bml0cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR1dFSV9UT19XRUkgPSB2b2lkIDA7XG4vKiogRWFzeSBjb252ZXJzaW9uIGZyb20gR3dlaSB0byB3ZWkgKi9cbmV4cG9ydHMuR1dFSV9UT19XRUkgPSBCaWdJbnQoMTAwMDAwMDAwMCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bml0cy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/units.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/withdrawal.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/withdrawal.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Withdrawal = void 0;\nconst address_1 = __webpack_require__(/*! ./address */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/address.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/bytes.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/types.js\");\n/**\n * Representation of EIP-4895 withdrawal data\n */\nclass Withdrawal {\n    /**\n     * This constructor assigns and validates the values.\n     * Use the static factory methods to assist in creating a Withdrawal object from varying data types.\n     * Its amount is in Gwei to match CL representation and for eventual ssz withdrawalsRoot\n     */\n    constructor(index, validatorIndex, address, \n    /**\n     * withdrawal amount in Gwei to match the CL repesentation and eventually ssz withdrawalsRoot\n     */\n    amount) {\n        this.index = index;\n        this.validatorIndex = validatorIndex;\n        this.address = address;\n        this.amount = amount;\n    }\n    static fromWithdrawalData(withdrawalData) {\n        const { index: indexData, validatorIndex: validatorIndexData, address: addressData, amount: amountData, } = withdrawalData;\n        const index = (0, types_1.toType)(indexData, types_1.TypeOutput.BigInt);\n        const validatorIndex = (0, types_1.toType)(validatorIndexData, types_1.TypeOutput.BigInt);\n        const address = new address_1.Address((0, types_1.toType)(addressData, types_1.TypeOutput.Buffer));\n        const amount = (0, types_1.toType)(amountData, types_1.TypeOutput.BigInt);\n        return new Withdrawal(index, validatorIndex, address, amount);\n    }\n    static fromValuesArray(withdrawalArray) {\n        if (withdrawalArray.length !== 4) {\n            throw Error(`Invalid withdrawalArray length expected=4 actual=${withdrawalArray.length}`);\n        }\n        const [index, validatorIndex, address, amount] = withdrawalArray;\n        return Withdrawal.fromWithdrawalData({ index, validatorIndex, address, amount });\n    }\n    /**\n     * Convert a withdrawal to a buffer array\n     * @param withdrawal the withdrawal to convert\n     * @returns buffer array of the withdrawal\n     */\n    static toBufferArray(withdrawal) {\n        const { index, validatorIndex, address, amount } = withdrawal;\n        const indexBuffer = (0, types_1.toType)(index, types_1.TypeOutput.BigInt) === BigInt(0)\n            ? Buffer.alloc(0)\n            : (0, types_1.toType)(index, types_1.TypeOutput.Buffer);\n        const validatorIndexBuffer = (0, types_1.toType)(validatorIndex, types_1.TypeOutput.BigInt) === BigInt(0)\n            ? Buffer.alloc(0)\n            : (0, types_1.toType)(validatorIndex, types_1.TypeOutput.Buffer);\n        let addressBuffer;\n        if (address instanceof address_1.Address) {\n            addressBuffer = address.buf;\n        }\n        else {\n            addressBuffer = (0, types_1.toType)(address, types_1.TypeOutput.Buffer);\n        }\n        const amountBuffer = (0, types_1.toType)(amount, types_1.TypeOutput.BigInt) === BigInt(0)\n            ? Buffer.alloc(0)\n            : (0, types_1.toType)(amount, types_1.TypeOutput.Buffer);\n        return [indexBuffer, validatorIndexBuffer, addressBuffer, amountBuffer];\n    }\n    raw() {\n        return Withdrawal.toBufferArray(this);\n    }\n    toValue() {\n        return {\n            index: this.index,\n            validatorIndex: this.validatorIndex,\n            address: this.address.buf,\n            amount: this.amount,\n        };\n    }\n    toJSON() {\n        return {\n            index: (0, bytes_1.bigIntToHex)(this.index),\n            validatorIndex: (0, bytes_1.bigIntToHex)(this.validatorIndex),\n            address: '0x' + this.address.buf.toString('hex'),\n            amount: (0, bytes_1.bigIntToHex)(this.amount),\n        };\n    }\n}\nexports.Withdrawal = Withdrawal;\n//# sourceMappingURL=withdrawal.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC93aXRoZHJhd2FsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixrQkFBa0IsbUJBQU8sQ0FBQyxnSEFBVztBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyw0R0FBUztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyw0R0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtHQUFrRztBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLHVCQUF1QjtBQUNuRztBQUNBO0FBQ0EsK0NBQStDLHdDQUF3QztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5Q0FBeUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L3dpdGhkcmF3YWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldpdGhkcmF3YWwgPSB2b2lkIDA7XG5jb25zdCBhZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9hZGRyZXNzXCIpO1xuY29uc3QgYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2J5dGVzXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBFSVAtNDg5NSB3aXRoZHJhd2FsIGRhdGFcbiAqL1xuY2xhc3MgV2l0aGRyYXdhbCB7XG4gICAgLyoqXG4gICAgICogVGhpcyBjb25zdHJ1Y3RvciBhc3NpZ25zIGFuZCB2YWxpZGF0ZXMgdGhlIHZhbHVlcy5cbiAgICAgKiBVc2UgdGhlIHN0YXRpYyBmYWN0b3J5IG1ldGhvZHMgdG8gYXNzaXN0IGluIGNyZWF0aW5nIGEgV2l0aGRyYXdhbCBvYmplY3QgZnJvbSB2YXJ5aW5nIGRhdGEgdHlwZXMuXG4gICAgICogSXRzIGFtb3VudCBpcyBpbiBHd2VpIHRvIG1hdGNoIENMIHJlcHJlc2VudGF0aW9uIGFuZCBmb3IgZXZlbnR1YWwgc3N6IHdpdGhkcmF3YWxzUm9vdFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGluZGV4LCB2YWxpZGF0b3JJbmRleCwgYWRkcmVzcywgXG4gICAgLyoqXG4gICAgICogd2l0aGRyYXdhbCBhbW91bnQgaW4gR3dlaSB0byBtYXRjaCB0aGUgQ0wgcmVwZXNlbnRhdGlvbiBhbmQgZXZlbnR1YWxseSBzc3ogd2l0aGRyYXdhbHNSb290XG4gICAgICovXG4gICAgYW1vdW50KSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy52YWxpZGF0b3JJbmRleCA9IHZhbGlkYXRvckluZGV4O1xuICAgICAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICB0aGlzLmFtb3VudCA9IGFtb3VudDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21XaXRoZHJhd2FsRGF0YSh3aXRoZHJhd2FsRGF0YSkge1xuICAgICAgICBjb25zdCB7IGluZGV4OiBpbmRleERhdGEsIHZhbGlkYXRvckluZGV4OiB2YWxpZGF0b3JJbmRleERhdGEsIGFkZHJlc3M6IGFkZHJlc3NEYXRhLCBhbW91bnQ6IGFtb3VudERhdGEsIH0gPSB3aXRoZHJhd2FsRGF0YTtcbiAgICAgICAgY29uc3QgaW5kZXggPSAoMCwgdHlwZXNfMS50b1R5cGUpKGluZGV4RGF0YSwgdHlwZXNfMS5UeXBlT3V0cHV0LkJpZ0ludCk7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRvckluZGV4ID0gKDAsIHR5cGVzXzEudG9UeXBlKSh2YWxpZGF0b3JJbmRleERhdGEsIHR5cGVzXzEuVHlwZU91dHB1dC5CaWdJbnQpO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gbmV3IGFkZHJlc3NfMS5BZGRyZXNzKCgwLCB0eXBlc18xLnRvVHlwZSkoYWRkcmVzc0RhdGEsIHR5cGVzXzEuVHlwZU91dHB1dC5CdWZmZXIpKTtcbiAgICAgICAgY29uc3QgYW1vdW50ID0gKDAsIHR5cGVzXzEudG9UeXBlKShhbW91bnREYXRhLCB0eXBlc18xLlR5cGVPdXRwdXQuQmlnSW50KTtcbiAgICAgICAgcmV0dXJuIG5ldyBXaXRoZHJhd2FsKGluZGV4LCB2YWxpZGF0b3JJbmRleCwgYWRkcmVzcywgYW1vdW50KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21WYWx1ZXNBcnJheSh3aXRoZHJhd2FsQXJyYXkpIHtcbiAgICAgICAgaWYgKHdpdGhkcmF3YWxBcnJheS5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBJbnZhbGlkIHdpdGhkcmF3YWxBcnJheSBsZW5ndGggZXhwZWN0ZWQ9NCBhY3R1YWw9JHt3aXRoZHJhd2FsQXJyYXkubGVuZ3RofWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtpbmRleCwgdmFsaWRhdG9ySW5kZXgsIGFkZHJlc3MsIGFtb3VudF0gPSB3aXRoZHJhd2FsQXJyYXk7XG4gICAgICAgIHJldHVybiBXaXRoZHJhd2FsLmZyb21XaXRoZHJhd2FsRGF0YSh7IGluZGV4LCB2YWxpZGF0b3JJbmRleCwgYWRkcmVzcywgYW1vdW50IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgd2l0aGRyYXdhbCB0byBhIGJ1ZmZlciBhcnJheVxuICAgICAqIEBwYXJhbSB3aXRoZHJhd2FsIHRoZSB3aXRoZHJhd2FsIHRvIGNvbnZlcnRcbiAgICAgKiBAcmV0dXJucyBidWZmZXIgYXJyYXkgb2YgdGhlIHdpdGhkcmF3YWxcbiAgICAgKi9cbiAgICBzdGF0aWMgdG9CdWZmZXJBcnJheSh3aXRoZHJhd2FsKSB7XG4gICAgICAgIGNvbnN0IHsgaW5kZXgsIHZhbGlkYXRvckluZGV4LCBhZGRyZXNzLCBhbW91bnQgfSA9IHdpdGhkcmF3YWw7XG4gICAgICAgIGNvbnN0IGluZGV4QnVmZmVyID0gKDAsIHR5cGVzXzEudG9UeXBlKShpbmRleCwgdHlwZXNfMS5UeXBlT3V0cHV0LkJpZ0ludCkgPT09IEJpZ0ludCgwKVxuICAgICAgICAgICAgPyBCdWZmZXIuYWxsb2MoMClcbiAgICAgICAgICAgIDogKDAsIHR5cGVzXzEudG9UeXBlKShpbmRleCwgdHlwZXNfMS5UeXBlT3V0cHV0LkJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRvckluZGV4QnVmZmVyID0gKDAsIHR5cGVzXzEudG9UeXBlKSh2YWxpZGF0b3JJbmRleCwgdHlwZXNfMS5UeXBlT3V0cHV0LkJpZ0ludCkgPT09IEJpZ0ludCgwKVxuICAgICAgICAgICAgPyBCdWZmZXIuYWxsb2MoMClcbiAgICAgICAgICAgIDogKDAsIHR5cGVzXzEudG9UeXBlKSh2YWxpZGF0b3JJbmRleCwgdHlwZXNfMS5UeXBlT3V0cHV0LkJ1ZmZlcik7XG4gICAgICAgIGxldCBhZGRyZXNzQnVmZmVyO1xuICAgICAgICBpZiAoYWRkcmVzcyBpbnN0YW5jZW9mIGFkZHJlc3NfMS5BZGRyZXNzKSB7XG4gICAgICAgICAgICBhZGRyZXNzQnVmZmVyID0gYWRkcmVzcy5idWY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhZGRyZXNzQnVmZmVyID0gKDAsIHR5cGVzXzEudG9UeXBlKShhZGRyZXNzLCB0eXBlc18xLlR5cGVPdXRwdXQuQnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbW91bnRCdWZmZXIgPSAoMCwgdHlwZXNfMS50b1R5cGUpKGFtb3VudCwgdHlwZXNfMS5UeXBlT3V0cHV0LkJpZ0ludCkgPT09IEJpZ0ludCgwKVxuICAgICAgICAgICAgPyBCdWZmZXIuYWxsb2MoMClcbiAgICAgICAgICAgIDogKDAsIHR5cGVzXzEudG9UeXBlKShhbW91bnQsIHR5cGVzXzEuVHlwZU91dHB1dC5CdWZmZXIpO1xuICAgICAgICByZXR1cm4gW2luZGV4QnVmZmVyLCB2YWxpZGF0b3JJbmRleEJ1ZmZlciwgYWRkcmVzc0J1ZmZlciwgYW1vdW50QnVmZmVyXTtcbiAgICB9XG4gICAgcmF3KCkge1xuICAgICAgICByZXR1cm4gV2l0aGRyYXdhbC50b0J1ZmZlckFycmF5KHRoaXMpO1xuICAgIH1cbiAgICB0b1ZhbHVlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsXG4gICAgICAgICAgICB2YWxpZGF0b3JJbmRleDogdGhpcy52YWxpZGF0b3JJbmRleCxcbiAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuYWRkcmVzcy5idWYsXG4gICAgICAgICAgICBhbW91bnQ6IHRoaXMuYW1vdW50LFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbmRleDogKDAsIGJ5dGVzXzEuYmlnSW50VG9IZXgpKHRoaXMuaW5kZXgpLFxuICAgICAgICAgICAgdmFsaWRhdG9ySW5kZXg6ICgwLCBieXRlc18xLmJpZ0ludFRvSGV4KSh0aGlzLnZhbGlkYXRvckluZGV4KSxcbiAgICAgICAgICAgIGFkZHJlc3M6ICcweCcgKyB0aGlzLmFkZHJlc3MuYnVmLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICAgIGFtb3VudDogKDAsIGJ5dGVzXzEuYmlnSW50VG9IZXgpKHRoaXMuYW1vdW50KSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLldpdGhkcmF3YWwgPSBXaXRoZHJhd2FsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2l0aGRyYXdhbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@ethereumjs/util/dist/withdrawal.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/_shortw_utils.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/_shortw_utils.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getHash = getHash;\nexports.createCurve = createCurve;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst hmac_1 = __webpack_require__(/*! @noble/hashes/hmac */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/hmac.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/utils.js\");\nconst weierstrass_js_1 = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/abstract/weierstrass.js\");\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),\n        randomBytes: utils_1.randomBytes,\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash) });\n    return Object.freeze({ ...create(defHash), create });\n}\n//# sourceMappingURL=_shortw_utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvX3Nob3J0d191dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2YsbUJBQW1CO0FBQ25CO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDhHQUFvQjtBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQyxnSEFBcUI7QUFDN0MseUJBQXlCLG1CQUFPLENBQUMscUlBQTJCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSwrQkFBK0I7QUFDaEcsMkJBQTJCLDRCQUE0QjtBQUN2RDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXNpZy11dGlsL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL19zaG9ydHdfdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEhhc2ggPSBnZXRIYXNoO1xuZXhwb3J0cy5jcmVhdGVDdXJ2ZSA9IGNyZWF0ZUN1cnZlO1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuY29uc3QgaG1hY18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvaG1hY1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiKTtcbmNvbnN0IHdlaWVyc3RyYXNzX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qc1wiKTtcbi8vIGNvbm5lY3RzIG5vYmxlLWN1cnZlcyB0byBub2JsZS1oYXNoZXNcbmZ1bmN0aW9uIGdldEhhc2goaGFzaCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGhhc2gsXG4gICAgICAgIGhtYWM6IChrZXksIC4uLm1zZ3MpID0+ICgwLCBobWFjXzEuaG1hYykoaGFzaCwga2V5LCAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoLi4ubXNncykpLFxuICAgICAgICByYW5kb21CeXRlczogdXRpbHNfMS5yYW5kb21CeXRlcyxcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ3VydmUoY3VydmVEZWYsIGRlZkhhc2gpIHtcbiAgICBjb25zdCBjcmVhdGUgPSAoaGFzaCkgPT4gKDAsIHdlaWVyc3RyYXNzX2pzXzEud2VpZXJzdHJhc3MpKHsgLi4uY3VydmVEZWYsIC4uLmdldEhhc2goaGFzaCkgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5jcmVhdGUoZGVmSGFzaCksIGNyZWF0ZSB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaG9ydHdfdXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/_shortw_utils.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/abstract/curve.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/abstract/curve.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.wNAF = wNAF;\nexports.validateBasic = validateBasic;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\nconst modular_js_1 = __webpack_require__(/*! ./modular.js */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/abstract/modular.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/abstract/utils.js\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n         * - 𝑊 is the window size\n         * - 𝑛 is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nfunction validateBasic(curve) {\n    (0, modular_js_1.validateField)(curve.Fp);\n    (0, utils_js_1.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvY3VydmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWTtBQUNaLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsb0hBQWM7QUFDM0MsbUJBQW1CLG1CQUFPLENBQUMsZ0hBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQseUNBQXlDO0FBQ3pDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC9jdXJ2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMud05BRiA9IHdOQUY7XG5leHBvcnRzLnZhbGlkYXRlQmFzaWMgPSB2YWxpZGF0ZUJhc2ljO1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gQWJlbGlhbiBncm91cCB1dGlsaXRpZXNcbmNvbnN0IG1vZHVsYXJfanNfMSA9IHJlcXVpcmUoXCIuL21vZHVsYXIuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG4vLyBFbGxpcHRpYyBjdXJ2ZSBtdWx0aXBsaWNhdGlvbiBvZiBQb2ludCBieSBzY2FsYXIuIEZyYWdpbGUuXG4vLyBTY2FsYXJzIHNob3VsZCBhbHdheXMgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyOiB0aGlzIHNob3VsZCBiZSBjaGVja2VkIGluc2lkZSBvZiBhIGN1cnZlIGl0c2VsZi5cbi8vIENyZWF0ZXMgcHJlY29tcHV0YXRpb24gdGFibGVzIGZvciBmYXN0IG11bHRpcGxpY2F0aW9uOlxuLy8gLSBwcml2YXRlIHNjYWxhciBpcyBzcGxpdCBieSBmaXhlZCBzaXplIHdpbmRvd3Mgb2YgVyBiaXRzXG4vLyAtIGV2ZXJ5IHdpbmRvdyBwb2ludCBpcyBjb2xsZWN0ZWQgZnJvbSB3aW5kb3cncyB0YWJsZSAmIGFkZGVkIHRvIGFjY3VtdWxhdG9yXG4vLyAtIHNpbmNlIHdpbmRvd3MgYXJlIGRpZmZlcmVudCwgc2FtZSBwb2ludCBpbnNpZGUgdGFibGVzIHdvbid0IGJlIGFjY2Vzc2VkIG1vcmUgdGhhbiBvbmNlIHBlciBjYWxjXG4vLyAtIGVhY2ggbXVsdGlwbGljYXRpb24gaXMgJ01hdGguY2VpbChDVVJWRV9PUkRFUiAvIPCdkYopICsgMScgcG9pbnQgYWRkaXRpb25zIChmaXhlZCBmb3IgYW55IHNjYWxhcilcbi8vIC0gKzEgd2luZG93IGlzIG5lY2Nlc3NhcnkgZm9yIHdOQUZcbi8vIC0gd05BRiByZWR1Y2VzIHRhYmxlIHNpemU6IDJ4IGxlc3MgbWVtb3J5ICsgMnggZmFzdGVyIGdlbmVyYXRpb24sIGJ1dCAxMCUgc2xvd2VyIG11bHRpcGxpY2F0aW9uXG4vLyBUT0RPOiBSZXNlYXJjaCByZXR1cm5pbmcgMmQgSlMgYXJyYXkgb2Ygd2luZG93cywgaW5zdGVhZCBvZiBhIHNpbmdsZSB3aW5kb3cuIFRoaXMgd291bGQgYWxsb3dcbi8vIHdpbmRvd3MgdG8gYmUgaW4gZGlmZmVyZW50IG1lbW9yeSBsb2NhdGlvbnNcbmZ1bmN0aW9uIHdOQUYoYywgYml0cykge1xuICAgIGNvbnN0IGNvbnN0VGltZU5lZ2F0ZSA9IChjb25kaXRpb24sIGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgbmVnID0gaXRlbS5uZWdhdGUoKTtcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbiA/IG5lZyA6IGl0ZW07XG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0gKFcpID0+IHtcbiAgICAgICAgY29uc3Qgd2luZG93cyA9IE1hdGguY2VpbChiaXRzIC8gVykgKyAxOyAvLyArMSwgYmVjYXVzZVxuICAgICAgICBjb25zdCB3aW5kb3dTaXplID0gMiAqKiAoVyAtIDEpOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICByZXR1cm4geyB3aW5kb3dzLCB3aW5kb3dTaXplIH07XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb25zdFRpbWVOZWdhdGUsXG4gICAgICAgIC8vIG5vbi1jb25zdCB0aW1lIG11bHRpcGxpY2F0aW9uIGxhZGRlclxuICAgICAgICB1bnNhZmVMYWRkZXIoZWxtLCBuKSB7XG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgICAgICAgIGxldCBkID0gZWxtO1xuICAgICAgICAgICAgd2hpbGUgKG4gPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAobiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIG4gPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHdOQUYgcHJlY29tcHV0YXRpb24gd2luZG93LiBVc2VkIGZvciBjYWNoaW5nLlxuICAgICAgICAgKiBEZWZhdWx0IHdpbmRvdyBzaXplIGlzIHNldCBieSBgdXRpbHMucHJlY29tcHV0ZSgpYCBhbmQgaXMgZXF1YWwgdG8gOC5cbiAgICAgICAgICogTnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBkZXBlbmRzIG9uIHRoZSBjdXJ2ZSBzaXplOlxuICAgICAgICAgKiAyXijwnZGK4oiSMSkgKiAoTWF0aC5jZWlsKPCdkZsgLyDwnZGKKSArIDEpLCB3aGVyZTpcbiAgICAgICAgICogLSDwnZGKIGlzIHRoZSB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiAtIPCdkZsgaXMgdGhlIGJpdGxlbmd0aCBvZiB0aGUgY3VydmUgb3JkZXIuXG4gICAgICAgICAqIEZvciBhIDI1Ni1iaXQgY3VydmUgYW5kIHdpbmRvdyBzaXplIDgsIHRoZSBudW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGlzIDEyOCAqIDMzID0gNDIyNC5cbiAgICAgICAgICogQHJldHVybnMgcHJlY29tcHV0ZWQgcG9pbnQgdGFibGVzIGZsYXR0ZW5lZCB0byBhIHNpbmdsZSBhcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZVdpbmRvdyhlbG0sIFcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gb3B0cyhXKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgbGV0IHAgPSBlbG07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHA7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGJhc2UgPSBwO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgICAgIC8vID0xLCBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgd2luZG93U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSBiYXNlLmFkZChwKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHAgPSBiYXNlLmRvdWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudHMgZWMgbXVsdGlwbGljYXRpb24gdXNpbmcgcHJlY29tcHV0ZWQgdGFibGVzIGFuZCB3LWFyeSBub24tYWRqYWNlbnQgZm9ybS5cbiAgICAgICAgICogQHBhcmFtIFcgd2luZG93IHNpemVcbiAgICAgICAgICogQHBhcmFtIHByZWNvbXB1dGVzIHByZWNvbXB1dGVkIHRhYmxlc1xuICAgICAgICAgKiBAcGFyYW0gbiBzY2FsYXIgKHdlIGRvbid0IGNoZWNrIGhlcmUsIGJ1dCBzaG91bGQgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyKVxuICAgICAgICAgKiBAcmV0dXJucyByZWFsIGFuZCBmYWtlIChmb3IgY29uc3QtdGltZSkgcG9pbnRzXG4gICAgICAgICAqL1xuICAgICAgICB3TkFGKFcsIHByZWNvbXB1dGVzLCBuKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBtYXliZSBjaGVjayB0aGF0IHNjYWxhciBpcyBsZXNzIHRoYW4gZ3JvdXAgb3JkZXI/IHdOQUYgYmVoYXZpb3VzIGlzIHVuZGVmaW5lZCBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIEJ1dCBuZWVkIHRvIGNhcmVmdWxseSByZW1vdmUgb3RoZXIgY2hlY2tzIGJlZm9yZSB3TkFGLiBPUkRFUiA9PSBiaXRzIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gb3B0cyhXKTtcbiAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xuICAgICAgICAgICAgbGV0IGYgPSBjLkJBU0U7XG4gICAgICAgICAgICBjb25zdCBtYXNrID0gQmlnSW50KDIgKiogVyAtIDEpOyAvLyBDcmVhdGUgbWFzayB3aXRoIFcgb25lczogMGIxMTExIGZvciBXPTQgZXRjLlxuICAgICAgICAgICAgY29uc3QgbWF4TnVtYmVyID0gMiAqKiBXO1xuICAgICAgICAgICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChXKTtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd2luZG93ICogd2luZG93U2l6ZTtcbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IFcgYml0cy5cbiAgICAgICAgICAgICAgICBsZXQgd2JpdHMgPSBOdW1iZXIobiAmIG1hc2spO1xuICAgICAgICAgICAgICAgIC8vIFNoaWZ0IG51bWJlciBieSBXIGJpdHMuXG4gICAgICAgICAgICAgICAgbiA+Pj0gc2hpZnRCeTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYml0cyBhcmUgYmlnZ2VyIHRoYW4gbWF4IHNpemUsIHdlJ2xsIHNwbGl0IHRob3NlLlxuICAgICAgICAgICAgICAgIC8vICsyMjQgPT4gMjU2IC0gMzJcbiAgICAgICAgICAgICAgICBpZiAod2JpdHMgPiB3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHdiaXRzIC09IG1heE51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgbiArPSBfMW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgY29kZSB3YXMgZmlyc3Qgd3JpdHRlbiB3aXRoIGFzc3VtcHRpb24gdGhhdCAnZicgYW5kICdwJyB3aWxsIG5ldmVyIGJlIGluZmluaXR5IHBvaW50OlxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIGVhY2ggYWRkaXRpb24gaXMgbXVsdGlwbGllZCBieSAyICoqIFcsIGl0IGNhbm5vdCBjYW5jZWwgZWFjaCBvdGhlci4gSG93ZXZlcixcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBuZWdhdGUgbm93OiBpdCBpcyBwb3NzaWJsZSB0aGF0IG5lZ2F0ZWQgZWxlbWVudCBmcm9tIGxvdyB2YWx1ZVxuICAgICAgICAgICAgICAgIC8vIHdvdWxkIGJlIHRoZSBzYW1lIGFzIGhpZ2ggZWxlbWVudCwgd2hpY2ggd2lsbCBjcmVhdGUgY2FycnkgaW50byBuZXh0IHdpbmRvdy5cbiAgICAgICAgICAgICAgICAvLyBJdCdzIG5vdCBvYnZpb3VzIGhvdyB0aGlzIGNhbiBmYWlsLCBidXQgc3RpbGwgd29ydGggaW52ZXN0aWdhdGluZyBsYXRlci5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBvbnRvIFplcm8gcG9pbnQuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHJhbmRvbSBwb2ludCBpbnNpZGUgY3VycmVudCB3aW5kb3cgdG8gZi5cbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQxID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldDIgPSBvZmZzZXQgKyBNYXRoLmFicyh3Yml0cykgLSAxOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmQxID0gd2luZG93ICUgMiAhPT0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25kMiA9IHdiaXRzIDwgMDtcbiAgICAgICAgICAgICAgICBpZiAod2JpdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG1vc3QgaW1wb3J0YW50IHBhcnQgZm9yIGNvbnN0LXRpbWUgZ2V0UHVibGljS2V5XG4gICAgICAgICAgICAgICAgICAgIGYgPSBmLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDEsIHByZWNvbXB1dGVzW29mZnNldDFdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQyLCBwcmVjb21wdXRlc1tvZmZzZXQyXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEpJVC1jb21waWxlciBzaG91bGQgbm90IGVsaW1pbmF0ZSBmIGhlcmUsIHNpbmNlIGl0IHdpbGwgbGF0ZXIgYmUgdXNlZCBpbiBub3JtYWxpemVaKClcbiAgICAgICAgICAgIC8vIEV2ZW4gaWYgdGhlIHZhcmlhYmxlIGlzIHN0aWxsIHVudXNlZCwgdGhlcmUgYXJlIHNvbWUgY2hlY2tzIHdoaWNoIHdpbGxcbiAgICAgICAgICAgIC8vIHRocm93IGFuIGV4Y2VwdGlvbiwgc28gY29tcGlsZXIgbmVlZHMgdG8gcHJvdmUgdGhleSB3b24ndCBoYXBwZW4sIHdoaWNoIGlzIGhhcmQuXG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZXJlIGlzIGEgd2F5IHRvIEYgYmUgaW5maW5pdHktcG9pbnQgZXZlbiBpZiBwIGlzIG5vdCxcbiAgICAgICAgICAgIC8vIHdoaWNoIG1ha2VzIGl0IGxlc3MgY29uc3QtdGltZTogYXJvdW5kIDEgYmlnaW50IG11bHRpcGx5LlxuICAgICAgICAgICAgcmV0dXJuIHsgcCwgZiB9O1xuICAgICAgICB9LFxuICAgICAgICB3TkFGQ2FjaGVkKFAsIHByZWNvbXB1dGVzTWFwLCBuLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IFcgPSBQLl9XSU5ET1dfU0laRSB8fCAxO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHByZWNvbXB1dGVzIG9uIGEgZmlyc3QgcnVuLCByZXVzZSB0aGVtIGFmdGVyXG4gICAgICAgICAgICBsZXQgY29tcCA9IHByZWNvbXB1dGVzTWFwLmdldChQKTtcbiAgICAgICAgICAgIGlmICghY29tcCkge1xuICAgICAgICAgICAgICAgIGNvbXAgPSB0aGlzLnByZWNvbXB1dGVXaW5kb3coUCwgVyk7XG4gICAgICAgICAgICAgICAgaWYgKFcgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY29tcHV0ZXNNYXAuc2V0KFAsIHRyYW5zZm9ybShjb21wKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud05BRihXLCBjb21wLCBuKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVCYXNpYyhjdXJ2ZSkge1xuICAgICgwLCBtb2R1bGFyX2pzXzEudmFsaWRhdGVGaWVsZCkoY3VydmUuRnApO1xuICAgICgwLCB1dGlsc19qc18xLnZhbGlkYXRlT2JqZWN0KShjdXJ2ZSwge1xuICAgICAgICBuOiAnYmlnaW50JyxcbiAgICAgICAgaDogJ2JpZ2ludCcsXG4gICAgICAgIEd4OiAnZmllbGQnLFxuICAgICAgICBHeTogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIG5CaXRMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgbkJ5dGVMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9KTtcbiAgICAvLyBTZXQgZGVmYXVsdHNcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIC4uLigwLCBtb2R1bGFyX2pzXzEubkxlbmd0aCkoY3VydmUubiwgY3VydmUubkJpdExlbmd0aCksXG4gICAgICAgIC4uLmN1cnZlLFxuICAgICAgICAuLi57IHA6IGN1cnZlLkZwLk9SREVSIH0sXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/abstract/curve.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/abstract/hash-to-curve.js":
/*!******************************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/abstract/hash-to-curve.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.expand_message_xmd = expand_message_xmd;\nexports.expand_message_xof = expand_message_xof;\nexports.hash_to_field = hash_to_field;\nexports.isogenyMap = isogenyMap;\nexports.createHasher = createHasher;\nconst modular_js_1 = __webpack_require__(/*! ./modular.js */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/abstract/modular.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/abstract/utils.js\");\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = utils_js_1.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << (8 * length)) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0, utils_js_1.abytes)(msg);\n    (0, utils_js_1.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255)\n        throw new Error('Invalid xmd length');\n    const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0, utils_js_1.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0, utils_js_1.abytes)(msg);\n    (0, utils_js_1.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0, utils_js_1.validateObject)(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    (0, utils_js_1.abytes)(msg);\n    anum(count);\n    const DST = typeof _DST === 'string' ? (0, utils_js_1.utf8ToBytes)(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0, modular_js_1.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Same as encodeToCurve, but without hash\n        mapToCurve(scalars) {\n            if (!Array.isArray(scalars))\n                throw new Error('mapToCurve: expected array of bigints');\n            for (const i of scalars)\n                if (typeof i !== 'bigint')\n                    throw new Error(`mapToCurve: expected array of bigints, got ${i} in array`);\n            const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixtQkFBTyxDQUFDLG9IQUFjO0FBQzNDLG1CQUFtQixtQkFBTyxDQUFDLGdIQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTyxTQUFTLE9BQU87QUFDeEU7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQyw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhDQUE4QztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkVBQTZFO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLG1DQUFtQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxpREFBaUQ7QUFDakQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxrQ0FBa0M7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsd0NBQXdDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsR0FBRztBQUNyRjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXNpZy11dGlsL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4cGFuZF9tZXNzYWdlX3htZCA9IGV4cGFuZF9tZXNzYWdlX3htZDtcbmV4cG9ydHMuZXhwYW5kX21lc3NhZ2VfeG9mID0gZXhwYW5kX21lc3NhZ2VfeG9mO1xuZXhwb3J0cy5oYXNoX3RvX2ZpZWxkID0gaGFzaF90b19maWVsZDtcbmV4cG9ydHMuaXNvZ2VueU1hcCA9IGlzb2dlbnlNYXA7XG5leHBvcnRzLmNyZWF0ZUhhc2hlciA9IGNyZWF0ZUhhc2hlcjtcbmNvbnN0IG1vZHVsYXJfanNfMSA9IHJlcXVpcmUoXCIuL21vZHVsYXIuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vLyBPY3RldCBTdHJlYW0gdG8gSW50ZWdlci4gXCJzcGVjXCIgaW1wbGVtZW50YXRpb24gb2Ygb3MyaXAgaXMgMi41eCBzbG93ZXIgdnMgYnl0ZXNUb051bWJlckJFLlxuY29uc3Qgb3MyaXAgPSB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJCRTtcbi8vIEludGVnZXIgdG8gT2N0ZXQgU3RyZWFtIChudW1iZXJUb0J5dGVzQkUpXG5mdW5jdGlvbiBpMm9zcCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSAxIDw8ICg4ICogbGVuZ3RoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJhZCBJMk9TUCBjYWxsOiB2YWx1ZT0ke3ZhbHVlfSBsZW5ndGg9JHtsZW5ndGh9YCk7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IEFycmF5LmZyb20oeyBsZW5ndGggfSkuZmlsbCgwKTtcbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgcmVzW2ldID0gdmFsdWUgJiAweGZmO1xuICAgICAgICB2YWx1ZSA+Pj49IDg7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXMpO1xufVxuZnVuY3Rpb24gc3RyeG9yKGEsIGIpIHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShhLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGFbaV0gXiBiW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gYW51bShpdGVtKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihpdGVtKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdudW1iZXIgZXhwZWN0ZWQnKTtcbn1cbi8vIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhIGNyeXB0b2dyYXBoaWMgaGFzaCBmdW5jdGlvbiBIIHRoYXQgb3V0cHV0cyBiIGJpdHNcbi8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjFcbmZ1bmN0aW9uIGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuSW5CeXRlcywgSCkge1xuICAgICgwLCB1dGlsc19qc18xLmFieXRlcykobXNnKTtcbiAgICAoMCwgdXRpbHNfanNfMS5hYnl0ZXMpKERTVCk7XG4gICAgYW51bShsZW5JbkJ5dGVzKTtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4zXG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpXG4gICAgICAgIERTVCA9IEgoKDAsIHV0aWxzX2pzXzEuY29uY2F0Qnl0ZXMpKCgwLCB1dGlsc19qc18xLnV0ZjhUb0J5dGVzKSgnSDJDLU9WRVJTSVpFLURTVC0nKSwgRFNUKSk7XG4gICAgY29uc3QgeyBvdXRwdXRMZW46IGJfaW5fYnl0ZXMsIGJsb2NrTGVuOiByX2luX2J5dGVzIH0gPSBIO1xuICAgIGNvbnN0IGVsbCA9IE1hdGguY2VpbChsZW5JbkJ5dGVzIC8gYl9pbl9ieXRlcyk7XG4gICAgaWYgKGVsbCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHhtZCBsZW5ndGgnKTtcbiAgICBjb25zdCBEU1RfcHJpbWUgPSAoMCwgdXRpbHNfanNfMS5jb25jYXRCeXRlcykoRFNULCBpMm9zcChEU1QubGVuZ3RoLCAxKSk7XG4gICAgY29uc3QgWl9wYWQgPSBpMm9zcCgwLCByX2luX2J5dGVzKTtcbiAgICBjb25zdCBsX2lfYl9zdHIgPSBpMm9zcChsZW5JbkJ5dGVzLCAyKTsgLy8gbGVuX2luX2J5dGVzX3N0clxuICAgIGNvbnN0IGIgPSBuZXcgQXJyYXkoZWxsKTtcbiAgICBjb25zdCBiXzAgPSBIKCgwLCB1dGlsc19qc18xLmNvbmNhdEJ5dGVzKShaX3BhZCwgbXNnLCBsX2lfYl9zdHIsIGkyb3NwKDAsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBiWzBdID0gSCgoMCwgdXRpbHNfanNfMS5jb25jYXRCeXRlcykoYl8wLCBpMm9zcCgxLCAxKSwgRFNUX3ByaW1lKSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gZWxsOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXJncyA9IFtzdHJ4b3IoYl8wLCBiW2kgLSAxXSksIGkyb3NwKGkgKyAxLCAxKSwgRFNUX3ByaW1lXTtcbiAgICAgICAgYltpXSA9IEgoKDAsIHV0aWxzX2pzXzEuY29uY2F0Qnl0ZXMpKC4uLmFyZ3MpKTtcbiAgICB9XG4gICAgY29uc3QgcHNldWRvX3JhbmRvbV9ieXRlcyA9ICgwLCB1dGlsc19qc18xLmNvbmNhdEJ5dGVzKSguLi5iKTtcbiAgICByZXR1cm4gcHNldWRvX3JhbmRvbV9ieXRlcy5zbGljZSgwLCBsZW5JbkJ5dGVzKTtcbn1cbi8vIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhbiBleHRlbmRhYmxlLW91dHB1dCBmdW5jdGlvbiAoWE9GKSBILlxuLy8gMS4gVGhlIGNvbGxpc2lvbiByZXNpc3RhbmNlIG9mIEggTVVTVCBiZSBhdCBsZWFzdCBrIGJpdHMuXG4vLyAyLiBIIE1VU1QgYmUgYW4gWE9GIHRoYXQgaGFzIGJlZW4gcHJvdmVkIGluZGlmZmVyZW50aWFibGUgZnJvbVxuLy8gICAgYSByYW5kb20gb3JhY2xlIHVuZGVyIGEgcmVhc29uYWJsZSBjcnlwdG9ncmFwaGljIGFzc3VtcHRpb24uXG4vLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4yXG5mdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbkluQnl0ZXMsIGssIEgpIHtcbiAgICAoMCwgdXRpbHNfanNfMS5hYnl0ZXMpKG1zZyk7XG4gICAgKDAsIHV0aWxzX2pzXzEuYWJ5dGVzKShEU1QpO1xuICAgIGFudW0obGVuSW5CeXRlcyk7XG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuM1xuICAgIC8vIERTVCA9IEgoJ0gyQy1PVkVSU0laRS1EU1QtJyB8fCBhX3ZlcnlfbG9uZ19EU1QsIE1hdGguY2VpbCgobGVuSW5CeXRlcyAqIGspIC8gOCkpO1xuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KSB7XG4gICAgICAgIGNvbnN0IGRrTGVuID0gTWF0aC5jZWlsKCgyICogaykgLyA4KTtcbiAgICAgICAgRFNUID0gSC5jcmVhdGUoeyBka0xlbiB9KS51cGRhdGUoKDAsIHV0aWxzX2pzXzEudXRmOFRvQnl0ZXMpKCdIMkMtT1ZFUlNJWkUtRFNULScpKS51cGRhdGUoRFNUKS5kaWdlc3QoKTtcbiAgICB9XG4gICAgaWYgKGxlbkluQnl0ZXMgPiA2NTUzNSB8fCBEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZF9tZXNzYWdlX3hvZjogaW52YWxpZCBsZW5JbkJ5dGVzJyk7XG4gICAgcmV0dXJuIChILmNyZWF0ZSh7IGRrTGVuOiBsZW5JbkJ5dGVzIH0pXG4gICAgICAgIC51cGRhdGUobXNnKVxuICAgICAgICAudXBkYXRlKGkyb3NwKGxlbkluQnl0ZXMsIDIpKVxuICAgICAgICAvLyAyLiBEU1RfcHJpbWUgPSBEU1QgfHwgSTJPU1AobGVuKERTVCksIDEpXG4gICAgICAgIC51cGRhdGUoRFNUKVxuICAgICAgICAudXBkYXRlKGkyb3NwKERTVC5sZW5ndGgsIDEpKVxuICAgICAgICAuZGlnZXN0KCkpO1xufVxuLyoqXG4gKiBIYXNoZXMgYXJiaXRyYXJ5LWxlbmd0aCBieXRlIHN0cmluZ3MgdG8gYSBsaXN0IG9mIG9uZSBvciBtb3JlIGVsZW1lbnRzIG9mIGEgZmluaXRlIGZpZWxkIEZcbiAqIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4yXG4gKiBAcGFyYW0gbXNnIGEgYnl0ZSBzdHJpbmcgY29udGFpbmluZyB0aGUgbWVzc2FnZSB0byBoYXNoXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBvZiBGIHRvIG91dHB1dFxuICogQHBhcmFtIG9wdGlvbnMgYHtEU1Q6IHN0cmluZywgcDogYmlnaW50LCBtOiBudW1iZXIsIGs6IG51bWJlciwgZXhwYW5kOiAneG1kJyB8ICd4b2YnLCBoYXNoOiBIfWAsIHNlZSBhYm92ZVxuICogQHJldHVybnMgW3VfMCwgLi4uLCB1Xyhjb3VudCAtIDEpXSwgYSBsaXN0IG9mIGZpZWxkIGVsZW1lbnRzLlxuICovXG5mdW5jdGlvbiBoYXNoX3RvX2ZpZWxkKG1zZywgY291bnQsIG9wdGlvbnMpIHtcbiAgICAoMCwgdXRpbHNfanNfMS52YWxpZGF0ZU9iamVjdCkob3B0aW9ucywge1xuICAgICAgICBEU1Q6ICdzdHJpbmdPclVpbnQ4QXJyYXknLFxuICAgICAgICBwOiAnYmlnaW50JyxcbiAgICAgICAgbTogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBrOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIGhhc2g6ICdoYXNoJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IHAsIGssIG0sIGhhc2gsIGV4cGFuZCwgRFNUOiBfRFNUIH0gPSBvcHRpb25zO1xuICAgICgwLCB1dGlsc19qc18xLmFieXRlcykobXNnKTtcbiAgICBhbnVtKGNvdW50KTtcbiAgICBjb25zdCBEU1QgPSB0eXBlb2YgX0RTVCA9PT0gJ3N0cmluZycgPyAoMCwgdXRpbHNfanNfMS51dGY4VG9CeXRlcykoX0RTVCkgOiBfRFNUO1xuICAgIGNvbnN0IGxvZzJwID0gcC50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgTCA9IE1hdGguY2VpbCgobG9nMnAgKyBrKSAvIDgpOyAvLyBzZWN0aW9uIDUuMSBvZiBpZXRmIGRyYWZ0IGxpbmsgYWJvdmVcbiAgICBjb25zdCBsZW5faW5fYnl0ZXMgPSBjb3VudCAqIG0gKiBMO1xuICAgIGxldCBwcmI7IC8vIHBzZXVkb19yYW5kb21fYnl0ZXNcbiAgICBpZiAoZXhwYW5kID09PSAneG1kJykge1xuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gJ3hvZicpIHtcbiAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGssIGhhc2gpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBhbmQgPT09ICdfaW50ZXJuYWxfcGFzcycpIHtcbiAgICAgICAgLy8gZm9yIGludGVybmFsIHRlc3RzIG9ubHlcbiAgICAgICAgcHJiID0gbXNnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmQgbXVzdCBiZSBcInhtZFwiIG9yIFwieG9mXCInKTtcbiAgICB9XG4gICAgY29uc3QgdSA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGUgPSBuZXcgQXJyYXkobSk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbTsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBlbG1fb2Zmc2V0ID0gTCAqIChqICsgaSAqIG0pO1xuICAgICAgICAgICAgY29uc3QgdHYgPSBwcmIuc3ViYXJyYXkoZWxtX29mZnNldCwgZWxtX29mZnNldCArIEwpO1xuICAgICAgICAgICAgZVtqXSA9ICgwLCBtb2R1bGFyX2pzXzEubW9kKShvczJpcCh0diksIHApO1xuICAgICAgICB9XG4gICAgICAgIHVbaV0gPSBlO1xuICAgIH1cbiAgICByZXR1cm4gdTtcbn1cbmZ1bmN0aW9uIGlzb2dlbnlNYXAoZmllbGQsIG1hcCkge1xuICAgIC8vIE1ha2Ugc2FtZSBvcmRlciBhcyBpbiBzcGVjXG4gICAgY29uc3QgQ09FRkYgPSBtYXAubWFwKChpKSA9PiBBcnJheS5mcm9tKGkpLnJldmVyc2UoKSk7XG4gICAgcmV0dXJuICh4LCB5KSA9PiB7XG4gICAgICAgIGNvbnN0IFt4TnVtLCB4RGVuLCB5TnVtLCB5RGVuXSA9IENPRUZGLm1hcCgodmFsKSA9PiB2YWwucmVkdWNlKChhY2MsIGkpID0+IGZpZWxkLmFkZChmaWVsZC5tdWwoYWNjLCB4KSwgaSkpKTtcbiAgICAgICAgeCA9IGZpZWxkLmRpdih4TnVtLCB4RGVuKTsgLy8geE51bSAvIHhEZW5cbiAgICAgICAgeSA9IGZpZWxkLm11bCh5LCBmaWVsZC5kaXYoeU51bSwgeURlbikpOyAvLyB5ICogKHlOdW0gLyB5RGV2KVxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUhhc2hlcihQb2ludCwgbWFwVG9DdXJ2ZSwgZGVmKSB7XG4gICAgaWYgKHR5cGVvZiBtYXBUb0N1cnZlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmUoKSBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBFbmNvZGVzIGJ5dGUgc3RyaW5nIHRvIGVsbGlwdGljIGN1cnZlLlxuICAgICAgICAvLyBoYXNoX3RvX2N1cnZlIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi0zXG4gICAgICAgIGhhc2hUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAyLCB7IC4uLmRlZiwgRFNUOiBkZWYuRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgdTAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVswXSkpO1xuICAgICAgICAgICAgY29uc3QgdTEgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVsxXSkpO1xuICAgICAgICAgICAgY29uc3QgUCA9IHUwLmFkZCh1MSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmUuXG4gICAgICAgIC8vIGVuY29kZV90b19jdXJ2ZSBmcm9tIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tM1xuICAgICAgICBlbmNvZGVUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAxLCB7IC4uLmRlZiwgRFNUOiBkZWYuZW5jb2RlRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzBdKSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFNhbWUgYXMgZW5jb2RlVG9DdXJ2ZSwgYnV0IHdpdGhvdXQgaGFzaFxuICAgICAgICBtYXBUb0N1cnZlKHNjYWxhcnMpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2FsYXJzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmU6IGV4cGVjdGVkIGFycmF5IG9mIGJpZ2ludHMnKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBvZiBzY2FsYXJzKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbWFwVG9DdXJ2ZTogZXhwZWN0ZWQgYXJyYXkgb2YgYmlnaW50cywgZ290ICR7aX0gaW4gYXJyYXlgKTtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUoc2NhbGFycykpLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLXRvLWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/abstract/hash-to-curve.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/abstract/modular.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/abstract/modular.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isNegativeLE = void 0;\nexports.mod = mod;\nexports.pow = pow;\nexports.pow2 = pow2;\nexports.invert = invert;\nexports.tonelliShanks = tonelliShanks;\nexports.FpSqrt = FpSqrt;\nexports.validateField = validateField;\nexports.FpPow = FpPow;\nexports.FpInvertBatch = FpInvertBatch;\nexports.FpDiv = FpDiv;\nexports.FpIsSquare = FpIsSquare;\nexports.nLength = nLength;\nexports.Field = Field;\nexports.FpSqrtOdd = FpSqrtOdd;\nexports.FpSqrtEven = FpSqrtEven;\nexports.hashToPrivateScalar = hashToPrivateScalar;\nexports.getFieldBytesLength = getFieldBytesLength;\nexports.getMinHashLength = getMinHashLength;\nexports.mapHashToField = mapHashToField;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/abstract/utils.js\");\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ≡ 1    if a is a square (mod p)\n    // (a | p) ≡ -1   if a is not a square (mod p)\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P ≡ 3 (mod 4)\n    // √n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P ≡ 9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\nexports.isNegativeLE = isNegativeLE;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0, utils_js_1.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0, utils_js_1.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0, utils_js_1.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvbW9kdWxhci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEIsV0FBVztBQUNYLFdBQVc7QUFDWCxZQUFZO0FBQ1osY0FBYztBQUNkLHFCQUFxQjtBQUNyQixjQUFjO0FBQ2QscUJBQXFCO0FBQ3JCLGFBQWE7QUFDYixxQkFBcUI7QUFDckIsYUFBYTtBQUNiLGtCQUFrQjtBQUNsQixlQUFlO0FBQ2YsYUFBYTtBQUNiLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQix3QkFBd0I7QUFDeEIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyxnSEFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFFBQVEsTUFBTSxPQUFPO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0Esa0JBQWtCLDJDQUEyQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxtQ0FBbUM7QUFDbkMsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLDREQUE0RDtBQUM1RCw0QkFBNEI7QUFDNUIsK0JBQStCO0FBQy9CLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQsa0RBQWtEO0FBQ2xELGtEQUFrRDtBQUNsRDtBQUNBLGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQsa0RBQWtEO0FBQ2xELGtEQUFrRDtBQUNsRCxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELDBDQUEwQztBQUMxQywwQ0FBMEM7QUFDMUMsc0RBQXNEO0FBQ3RELDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSx5REFBeUQsTUFBTTtBQUMvRCxZQUFZLHVDQUF1QztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxXQUFXO0FBQzFGLDhDQUE4QztBQUM5QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELE1BQU0sUUFBUSxhQUFhO0FBQ3JGO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxPQUFPLDRCQUE0QixRQUFRO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPLDRCQUE0QixJQUFJO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC9tb2R1bGFyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc05lZ2F0aXZlTEUgPSB2b2lkIDA7XG5leHBvcnRzLm1vZCA9IG1vZDtcbmV4cG9ydHMucG93ID0gcG93O1xuZXhwb3J0cy5wb3cyID0gcG93MjtcbmV4cG9ydHMuaW52ZXJ0ID0gaW52ZXJ0O1xuZXhwb3J0cy50b25lbGxpU2hhbmtzID0gdG9uZWxsaVNoYW5rcztcbmV4cG9ydHMuRnBTcXJ0ID0gRnBTcXJ0O1xuZXhwb3J0cy52YWxpZGF0ZUZpZWxkID0gdmFsaWRhdGVGaWVsZDtcbmV4cG9ydHMuRnBQb3cgPSBGcFBvdztcbmV4cG9ydHMuRnBJbnZlcnRCYXRjaCA9IEZwSW52ZXJ0QmF0Y2g7XG5leHBvcnRzLkZwRGl2ID0gRnBEaXY7XG5leHBvcnRzLkZwSXNTcXVhcmUgPSBGcElzU3F1YXJlO1xuZXhwb3J0cy5uTGVuZ3RoID0gbkxlbmd0aDtcbmV4cG9ydHMuRmllbGQgPSBGaWVsZDtcbmV4cG9ydHMuRnBTcXJ0T2RkID0gRnBTcXJ0T2RkO1xuZXhwb3J0cy5GcFNxcnRFdmVuID0gRnBTcXJ0RXZlbjtcbmV4cG9ydHMuaGFzaFRvUHJpdmF0ZVNjYWxhciA9IGhhc2hUb1ByaXZhdGVTY2FsYXI7XG5leHBvcnRzLmdldEZpZWxkQnl0ZXNMZW5ndGggPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoO1xuZXhwb3J0cy5nZXRNaW5IYXNoTGVuZ3RoID0gZ2V0TWluSGFzaExlbmd0aDtcbmV4cG9ydHMubWFwSGFzaFRvRmllbGQgPSBtYXBIYXNoVG9GaWVsZDtcbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFV0aWxpdGllcyBmb3IgbW9kdWxhciBhcml0aG1ldGljcyBhbmQgZmluaXRlIGZpZWxkc1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF80biA9IEJpZ0ludCg0KSwgXzVuID0gQmlnSW50KDUpLCBfOG4gPSBCaWdJbnQoOCk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF85biA9IEJpZ0ludCg5KSwgXzE2biA9IEJpZ0ludCgxNik7XG4vLyBDYWxjdWxhdGVzIGEgbW9kdWxvIGJcbmZ1bmN0aW9uIG1vZChhLCBiKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYSAlIGI7XG4gICAgcmV0dXJuIHJlc3VsdCA+PSBfMG4gPyByZXN1bHQgOiBiICsgcmVzdWx0O1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSByYWlzZSBudW0gdG8gcG93ZXIgYW5kIGRvIG1vZHVsYXIgZGl2aXNpb24uXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKiBAZXhhbXBsZVxuICogcG93KDJuLCA2biwgMTFuKSAvLyA2NG4gJSAxMW4gPT0gOW5cbiAqL1xuLy8gVE9ETzogdXNlIGZpZWxkIHZlcnNpb24gJiYgcmVtb3ZlXG5mdW5jdGlvbiBwb3cobnVtLCBwb3dlciwgbW9kdWxvKSB7XG4gICAgaWYgKG1vZHVsbyA8PSBfMG4gfHwgcG93ZXIgPCBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG93ZXIvbW9kdWxvID4gMCcpO1xuICAgIGlmIChtb2R1bG8gPT09IF8xbilcbiAgICAgICAgcmV0dXJuIF8wbjtcbiAgICBsZXQgcmVzID0gXzFuO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICByZXMgPSAocmVzICogbnVtKSAlIG1vZHVsbztcbiAgICAgICAgbnVtID0gKG51bSAqIG51bSkgJSBtb2R1bG87XG4gICAgICAgIHBvd2VyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBEb2VzIHggXiAoMiBeIHBvd2VyKSBtb2QgcC4gcG93MigzMCwgNCkgPT0gMzAgXiAoMiBeIDQpXG5mdW5jdGlvbiBwb3cyKHgsIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBsZXQgcmVzID0geDtcbiAgICB3aGlsZSAocG93ZXItLSA+IF8wbikge1xuICAgICAgICByZXMgKj0gcmVzO1xuICAgICAgICByZXMgJT0gbW9kdWxvO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gSW52ZXJzZXMgbnVtYmVyIG92ZXIgbW9kdWxvXG5mdW5jdGlvbiBpbnZlcnQobnVtYmVyLCBtb2R1bG8pIHtcbiAgICBpZiAobnVtYmVyID09PSBfMG4gfHwgbW9kdWxvIDw9IF8wbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmVydDogZXhwZWN0ZWQgcG9zaXRpdmUgaW50ZWdlcnMsIGdvdCBuPSR7bnVtYmVyfSBtb2Q9JHttb2R1bG99YCk7XG4gICAgfVxuICAgIC8vIEV1Y2xpZGVhbiBHQ0QgaHR0cHM6Ly9icmlsbGlhbnQub3JnL3dpa2kvZXh0ZW5kZWQtZXVjbGlkZWFuLWFsZ29yaXRobS9cbiAgICAvLyBGZXJtYXQncyBsaXR0bGUgdGhlb3JlbSBcIkNULWxpa2VcIiB2ZXJzaW9uIGludihuKSA9IG5eKG0tMikgbW9kIG0gaXMgMzB4IHNsb3dlci5cbiAgICBsZXQgYSA9IG1vZChudW1iZXIsIG1vZHVsbyk7XG4gICAgbGV0IGIgPSBtb2R1bG87XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IHggPSBfMG4sIHkgPSBfMW4sIHUgPSBfMW4sIHYgPSBfMG47XG4gICAgd2hpbGUgKGEgIT09IF8wbikge1xuICAgICAgICAvLyBKSVQgYXBwbGllcyBvcHRpbWl6YXRpb24gaWYgdGhvc2UgdHdvIGxpbmVzIGZvbGxvdyBlYWNoIG90aGVyXG4gICAgICAgIGNvbnN0IHEgPSBiIC8gYTtcbiAgICAgICAgY29uc3QgciA9IGIgJSBhO1xuICAgICAgICBjb25zdCBtID0geCAtIHUgKiBxO1xuICAgICAgICBjb25zdCBuID0geSAtIHYgKiBxO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgYiA9IGEsIGEgPSByLCB4ID0gdSwgeSA9IHYsIHUgPSBtLCB2ID0gbjtcbiAgICB9XG4gICAgY29uc3QgZ2NkID0gYjtcbiAgICBpZiAoZ2NkICE9PSBfMW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBkb2VzIG5vdCBleGlzdCcpO1xuICAgIHJldHVybiBtb2QoeCwgbW9kdWxvKTtcbn1cbi8qKlxuICogVG9uZWxsaS1TaGFua3Mgc3F1YXJlIHJvb3Qgc2VhcmNoIGFsZ29yaXRobS5cbiAqIDEuIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMilcbiAqIDIuIFNxdWFyZSBSb290cyBmcm9tIDE7IDI0LCA1MSwgMTAgdG8gRGFuIFNoYW5rc1xuICogV2lsbCBzdGFydCBhbiBpbmZpbml0ZSBsb29wIGlmIGZpZWxkIG9yZGVyIFAgaXMgbm90IHByaW1lLlxuICogQHBhcmFtIFAgZmllbGQgb3JkZXJcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgdGFrZXMgZmllbGQgRnAgKGNyZWF0ZWQgZnJvbSBQKSBhbmQgbnVtYmVyIG5cbiAqL1xuZnVuY3Rpb24gdG9uZWxsaVNoYW5rcyhQKSB7XG4gICAgLy8gTGVnZW5kcmUgY29uc3RhbnQ6IHVzZWQgdG8gY2FsY3VsYXRlIExlZ2VuZHJlIHN5bWJvbCAoYSB8IHApLFxuICAgIC8vIHdoaWNoIGRlbm90ZXMgdGhlIHZhbHVlIG9mIGFeKChwLTEpLzIpIChtb2QgcCkuXG4gICAgLy8gKGEgfCBwKSDiiaEgMSAgICBpZiBhIGlzIGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAtMSAgIGlmIGEgaXMgbm90IGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAwICAgIGlmIGEg4omhIDAgKG1vZCBwKVxuICAgIGNvbnN0IGxlZ2VuZHJlQyA9IChQIC0gXzFuKSAvIF8ybjtcbiAgICBsZXQgUSwgUywgWjtcbiAgICAvLyBTdGVwIDE6IEJ5IGZhY3RvcmluZyBvdXQgcG93ZXJzIG9mIDIgZnJvbSBwIC0gMSxcbiAgICAvLyBmaW5kIHEgYW5kIHMgc3VjaCB0aGF0IHAgLSAxID0gcSooMl5zKSB3aXRoIHEgb2RkXG4gICAgZm9yIChRID0gUCAtIF8xbiwgUyA9IDA7IFEgJSBfMm4gPT09IF8wbjsgUSAvPSBfMm4sIFMrKylcbiAgICAgICAgO1xuICAgIC8vIFN0ZXAgMjogU2VsZWN0IGEgbm9uLXNxdWFyZSB6IHN1Y2ggdGhhdCAoeiB8IHApIOKJoSAtMSBhbmQgc2V0IGMg4omhIHpxXG4gICAgZm9yIChaID0gXzJuOyBaIDwgUCAmJiBwb3coWiwgbGVnZW5kcmVDLCBQKSAhPT0gUCAtIF8xbjsgWisrKVxuICAgICAgICA7XG4gICAgLy8gRmFzdC1wYXRoXG4gICAgaWYgKFMgPT09IDEpIHtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaUZhc3QoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFNsb3ctcGF0aFxuICAgIGNvbnN0IFExZGl2MiA9IChRICsgXzFuKSAvIF8ybjtcbiAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaVNsb3coRnAsIG4pIHtcbiAgICAgICAgLy8gU3RlcCAwOiBDaGVjayB0aGF0IG4gaXMgaW5kZWVkIGEgc3F1YXJlOiAobiB8IHApIHNob3VsZCBub3QgYmUg4omhIC0xXG4gICAgICAgIGlmIChGcC5wb3cobiwgbGVnZW5kcmVDKSA9PT0gRnAubmVnKEZwLk9ORSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgIGxldCByID0gUztcbiAgICAgICAgLy8gVE9ETzogd2lsbCBmYWlsIGF0IEZwMi9ldGNcbiAgICAgICAgbGV0IGcgPSBGcC5wb3coRnAubXVsKEZwLk9ORSwgWiksIFEpOyAvLyB3aWxsIHVwZGF0ZSBib3RoIHggYW5kIGJcbiAgICAgICAgbGV0IHggPSBGcC5wb3cobiwgUTFkaXYyKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIHNxdWFyZSByb290XG4gICAgICAgIGxldCBiID0gRnAucG93KG4sIFEpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgZnVkZ2UgZmFjdG9yXG4gICAgICAgIHdoaWxlICghRnAuZXFsKGIsIEZwLk9ORSkpIHtcbiAgICAgICAgICAgIGlmIChGcC5lcWwoYiwgRnAuWkVSTykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZwLlpFUk87IC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RvbmVsbGklRTIlODAlOTNTaGFua3NfYWxnb3JpdGhtICg0LiBJZiB0ID0gMCwgcmV0dXJuIHIgPSAwKVxuICAgICAgICAgICAgLy8gRmluZCBtIHN1Y2ggYl4oMl5tKT09MVxuICAgICAgICAgICAgbGV0IG0gPSAxO1xuICAgICAgICAgICAgZm9yIChsZXQgdDIgPSBGcC5zcXIoYik7IG0gPCByOyBtKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoRnAuZXFsKHQyLCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0MiA9IEZwLnNxcih0Mik7IC8vIHQyICo9IHQyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOT1RFOiByLW0tMSBjYW4gYmUgYmlnZ2VyIHRoYW4gMzIsIG5lZWQgdG8gY29udmVydCB0byBiaWdpbnQgYmVmb3JlIHNoaWZ0LCBvdGhlcndpc2UgdGhlcmUgd2lsbCBiZSBvdmVyZmxvd1xuICAgICAgICAgICAgY29uc3QgZ2UgPSBGcC5wb3coZywgXzFuIDw8IEJpZ0ludChyIC0gbSAtIDEpKTsgLy8gZ2UgPSAyXihyLW0tMSlcbiAgICAgICAgICAgIGcgPSBGcC5zcXIoZ2UpOyAvLyBnID0gZ2UgKiBnZVxuICAgICAgICAgICAgeCA9IEZwLm11bCh4LCBnZSk7IC8vIHggKj0gZ2VcbiAgICAgICAgICAgIGIgPSBGcC5tdWwoYiwgZyk7IC8vIGIgKj0gZ1xuICAgICAgICAgICAgciA9IG07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIEZwU3FydChQKSB7XG4gICAgLy8gTk9URTogZGlmZmVyZW50IGFsZ29yaXRobXMgY2FuIGdpdmUgZGlmZmVyZW50IHJvb3RzLCBpdCBpcyB1cCB0byB1c2VyIHRvIGRlY2lkZSB3aGljaCBvbmUgdGhleSB3YW50LlxuICAgIC8vIEZvciBleGFtcGxlIHRoZXJlIGlzIEZwU3FydE9kZC9GcFNxcnRFdmVuIHRvIGNob2ljZSByb290IGJhc2VkIG9uIG9kZG5lc3MgKHVzZWQgZm9yIGhhc2gtdG8tY3VydmUpLlxuICAgIC8vIFAg4omhIDMgKG1vZCA0KVxuICAgIC8vIOKImm4gPSBuXigoUCsxKS80KVxuICAgIGlmIChQICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgLy8gTm90IGFsbCByb290cyBwb3NzaWJsZSFcbiAgICAgICAgLy8gY29uc3QgT1JERVIgPVxuICAgICAgICAvLyAgIDB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFibjtcbiAgICAgICAgLy8gY29uc3QgTlVNID0gNzIwNTc1OTQwMzc5Mjc4MTZuO1xuICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0M21vZDQoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgICAgICAgIC8vIFRocm93IGlmIHJvb3QqKjIgIT0gblxuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQXRraW4gYWxnb3JpdGhtIGZvciBxIOKJoSA1IChtb2QgOCksIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMClcbiAgICBpZiAoUCAlIF84biA9PT0gXzVuKSB7XG4gICAgICAgIGNvbnN0IGMxID0gKFAgLSBfNW4pIC8gXzhuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDVtb2Q4KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCBuMiA9IEZwLm11bChuLCBfMm4pO1xuICAgICAgICAgICAgY29uc3QgdiA9IEZwLnBvdyhuMiwgYzEpO1xuICAgICAgICAgICAgY29uc3QgbnYgPSBGcC5tdWwobiwgdik7XG4gICAgICAgICAgICBjb25zdCBpID0gRnAubXVsKEZwLm11bChudiwgXzJuKSwgdik7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAubXVsKG52LCBGcC5zdWIoaSwgRnAuT05FKSk7XG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBQIOKJoSA5IChtb2QgMTYpXG4gICAgaWYgKFAgJSBfMTZuID09PSBfOW4pIHtcbiAgICAgICAgLy8gTk9URTogdG9uZWxsaSBpcyB0b28gc2xvdyBmb3IgYmxzLUZwMiBjYWxjdWxhdGlvbnMgZXZlbiBvbiBzdGFydFxuICAgICAgICAvLyBNZWFucyB3ZSBjYW5ub3QgdXNlIHNxcnQgZm9yIGNvbnN0YW50cyBhdCBhbGwhXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGNvbnN0IGMxID0gRnAuc3FydChGcC5uZWdhdGUoRnAuT05FKSk7IC8vICAxLiBjMSA9IHNxcnQoLTEpIGluIEYsIGkuZS4sIChjMV4yKSA9PSAtMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGMyID0gRnAuc3FydChjMSk7ICAgICAgICAgICAgICAgIC8vICAyLiBjMiA9IHNxcnQoYzEpIGluIEYsIGkuZS4sIChjMl4yKSA9PSBjMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGMzID0gRnAuc3FydChGcC5uZWdhdGUoYzEpKTsgICAgIC8vICAzLiBjMyA9IHNxcnQoLWMxKSBpbiBGLCBpLmUuLCAoYzNeMikgPT0gLWMxIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzQgPSAoUCArIF83bikgLyBfMTZuOyAgICAgICAgICAgLy8gIDQuIGM0ID0gKHEgKyA3KSAvIDE2ICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICAvLyBzcXJ0ID0gKHgpID0+IHtcbiAgICAgICAgLy8gICBsZXQgdHYxID0gRnAucG93KHgsIGM0KTsgICAgICAgICAgICAgLy8gIDEuIHR2MSA9IHheYzRcbiAgICAgICAgLy8gICBsZXQgdHYyID0gRnAubXVsKGMxLCB0djEpOyAgICAgICAgICAgLy8gIDIuIHR2MiA9IGMxICogdHYxXG4gICAgICAgIC8vICAgY29uc3QgdHYzID0gRnAubXVsKGMyLCB0djEpOyAgICAgICAgIC8vICAzLiB0djMgPSBjMiAqIHR2MVxuICAgICAgICAvLyAgIGxldCB0djQgPSBGcC5tdWwoYzMsIHR2MSk7ICAgICAgICAgICAvLyAgNC4gdHY0ID0gYzMgKiB0djFcbiAgICAgICAgLy8gICBjb25zdCBlMSA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYyKSwgeCk7IC8vICA1LiAgZTEgPSAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICBjb25zdCBlMiA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYzKSwgeCk7IC8vICA2LiAgZTIgPSAodHYzXjIpID09IHhcbiAgICAgICAgLy8gICB0djEgPSBGcC5jbW92KHR2MSwgdHYyLCBlMSk7IC8vICA3LiB0djEgPSBDTU9WKHR2MSwgdHYyLCBlMSkgICMgU2VsZWN0IHR2MiBpZiAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICB0djIgPSBGcC5jbW92KHR2NCwgdHYzLCBlMik7IC8vICA4LiB0djIgPSBDTU9WKHR2NCwgdHYzLCBlMikgICMgU2VsZWN0IHR2MyBpZiAodHYzXjIpID09IHhcbiAgICAgICAgLy8gICBjb25zdCBlMyA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYyKSwgeCk7IC8vICA5LiAgZTMgPSAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICByZXR1cm4gRnAuY21vdih0djEsIHR2MiwgZTMpOyAvLyAgMTAuICB6ID0gQ01PVih0djEsIHR2MiwgZTMpICAjIFNlbGVjdCB0aGUgc3FydCBmcm9tIHR2MSBhbmQgdHYyXG4gICAgICAgIC8vIH1cbiAgICB9XG4gICAgLy8gT3RoZXIgY2FzZXM6IFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobVxuICAgIHJldHVybiB0b25lbGxpU2hhbmtzKFApO1xufVxuLy8gTGl0dGxlLWVuZGlhbiBjaGVjayBmb3IgZmlyc3QgTEUgYml0IChsYXN0IEJFIGJpdCk7XG5jb25zdCBpc05lZ2F0aXZlTEUgPSAobnVtLCBtb2R1bG8pID0+IChtb2QobnVtLCBtb2R1bG8pICYgXzFuKSA9PT0gXzFuO1xuZXhwb3J0cy5pc05lZ2F0aXZlTEUgPSBpc05lZ2F0aXZlTEU7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEZJRUxEX0ZJRUxEUyA9IFtcbiAgICAnY3JlYXRlJywgJ2lzVmFsaWQnLCAnaXMwJywgJ25lZycsICdpbnYnLCAnc3FydCcsICdzcXInLFxuICAgICdlcWwnLCAnYWRkJywgJ3N1YicsICdtdWwnLCAncG93JywgJ2RpdicsXG4gICAgJ2FkZE4nLCAnc3ViTicsICdtdWxOJywgJ3Nxck4nXG5dO1xuZnVuY3Rpb24gdmFsaWRhdGVGaWVsZChmaWVsZCkge1xuICAgIGNvbnN0IGluaXRpYWwgPSB7XG4gICAgICAgIE9SREVSOiAnYmlnaW50JyxcbiAgICAgICAgTUFTSzogJ2JpZ2ludCcsXG4gICAgICAgIEJZVEVTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIEJJVFM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSBGSUVMRF9GSUVMRFMucmVkdWNlKChtYXAsIHZhbCkgPT4ge1xuICAgICAgICBtYXBbdmFsXSA9ICdmdW5jdGlvbic7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSwgaW5pdGlhbCk7XG4gICAgcmV0dXJuICgwLCB1dGlsc19qc18xLnZhbGlkYXRlT2JqZWN0KShmaWVsZCwgb3B0cyk7XG59XG4vLyBHZW5lcmljIGZpZWxkIGZ1bmN0aW9uc1xuLyoqXG4gKiBTYW1lIGFzIGBwb3dgIGJ1dCBmb3IgRnA6IG5vbi1jb25zdGFudC10aW1lLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICovXG5mdW5jdGlvbiBGcFBvdyhmLCBudW0sIHBvd2VyKSB7XG4gICAgLy8gU2hvdWxkIGhhdmUgc2FtZSBzcGVlZCBhcyBwb3cgZm9yIGJpZ2ludHNcbiAgICAvLyBUT0RPOiBiZW5jaG1hcmshXG4gICAgaWYgKHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvd2VyID4gMCcpO1xuICAgIGlmIChwb3dlciA9PT0gXzBuKVxuICAgICAgICByZXR1cm4gZi5PTkU7XG4gICAgaWYgKHBvd2VyID09PSBfMW4pXG4gICAgICAgIHJldHVybiBudW07XG4gICAgbGV0IHAgPSBmLk9ORTtcbiAgICBsZXQgZCA9IG51bTtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcCA9IGYubXVsKHAsIGQpO1xuICAgICAgICBkID0gZi5zcXIoZCk7XG4gICAgICAgIHBvd2VyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSBpbnZlcnQgYW4gYXJyYXkgb2YgRmllbGQgZWxlbWVudHMuXG4gKiBgaW52KDApYCB3aWxsIHJldHVybiBgdW5kZWZpbmVkYCBoZXJlOiBtYWtlIHN1cmUgdG8gdGhyb3cgYW4gZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIEZwSW52ZXJ0QmF0Y2goZiwgbnVtcykge1xuICAgIGNvbnN0IHRtcCA9IG5ldyBBcnJheShudW1zLmxlbmd0aCk7XG4gICAgLy8gV2FsayBmcm9tIGZpcnN0IHRvIGxhc3QsIG11bHRpcGx5IHRoZW0gYnkgZWFjaCBvdGhlciBNT0QgcFxuICAgIGNvbnN0IGxhc3RNdWx0aXBsaWVkID0gbnVtcy5yZWR1Y2UoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gYWNjO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGYuT05FKTtcbiAgICAvLyBJbnZlcnQgbGFzdCBlbGVtZW50XG4gICAgY29uc3QgaW52ZXJ0ZWQgPSBmLmludihsYXN0TXVsdGlwbGllZCk7XG4gICAgLy8gV2FsayBmcm9tIGxhc3QgdG8gZmlyc3QsIG11bHRpcGx5IHRoZW0gYnkgaW52ZXJ0ZWQgZWFjaCBvdGhlciBNT0QgcFxuICAgIG51bXMucmVkdWNlUmlnaHQoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gZi5tdWwoYWNjLCB0bXBbaV0pO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGludmVydGVkKTtcbiAgICByZXR1cm4gdG1wO1xufVxuZnVuY3Rpb24gRnBEaXYoZiwgbGhzLCByaHMpIHtcbiAgICByZXR1cm4gZi5tdWwobGhzLCB0eXBlb2YgcmhzID09PSAnYmlnaW50JyA/IGludmVydChyaHMsIGYuT1JERVIpIDogZi5pbnYocmhzKSk7XG59XG4vLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgVHJ1ZSB3aGVuZXZlciB0aGUgdmFsdWUgeCBpcyBhIHNxdWFyZSBpbiB0aGUgZmllbGQgRi5cbmZ1bmN0aW9uIEZwSXNTcXVhcmUoZikge1xuICAgIGNvbnN0IGxlZ2VuZHJlQ29uc3QgPSAoZi5PUkRFUiAtIF8xbikgLyBfMm47IC8vIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIHJldHVybiAoeCkgPT4ge1xuICAgICAgICBjb25zdCBwID0gZi5wb3coeCwgbGVnZW5kcmVDb25zdCk7XG4gICAgICAgIHJldHVybiBmLmVxbChwLCBmLlpFUk8pIHx8IGYuZXFsKHAsIGYuT05FKTtcbiAgICB9O1xufVxuLy8gQ1VSVkUubiBsZW5ndGhzXG5mdW5jdGlvbiBuTGVuZ3RoKG4sIG5CaXRMZW5ndGgpIHtcbiAgICAvLyBCaXQgc2l6ZSwgYnl0ZSBzaXplIG9mIENVUlZFLm5cbiAgICBjb25zdCBfbkJpdExlbmd0aCA9IG5CaXRMZW5ndGggIT09IHVuZGVmaW5lZCA/IG5CaXRMZW5ndGggOiBuLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBuQnl0ZUxlbmd0aCA9IE1hdGguY2VpbChfbkJpdExlbmd0aCAvIDgpO1xuICAgIHJldHVybiB7IG5CaXRMZW5ndGg6IF9uQml0TGVuZ3RoLCBuQnl0ZUxlbmd0aCB9O1xufVxuLyoqXG4gKiBJbml0aWFsaXplcyBhIGZpbml0ZSBmaWVsZCBvdmVyIHByaW1lLiAqKk5vbi1wcmltZXMgYXJlIG5vdCBzdXBwb3J0ZWQuKipcbiAqIERvIG5vdCBpbml0IGluIGxvb3A6IHNsb3cuIFZlcnkgZnJhZ2lsZTogYWx3YXlzIHJ1biBhIGJlbmNobWFyayBvbiBhIGNoYW5nZS5cbiAqIE1ham9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnM6XG4gKiAqIGEpIGRlbm9ybWFsaXplZCBvcGVyYXRpb25zIGxpa2UgbXVsTiBpbnN0ZWFkIG9mIG11bFxuICogKiBiKSBzYW1lIG9iamVjdCBzaGFwZTogbmV2ZXIgYWRkIG9yIHJlbW92ZSBrZXlzXG4gKiAqIGMpIE9iamVjdC5mcmVlemVcbiAqIEBwYXJhbSBPUkRFUiBwcmltZSBwb3NpdGl2ZSBiaWdpbnRcbiAqIEBwYXJhbSBiaXRMZW4gaG93IG1hbnkgYml0cyB0aGUgZmllbGQgY29uc3VtZXNcbiAqIEBwYXJhbSBpc0xFIChkZWY6IGZhbHNlKSBpZiBlbmNvZGluZyAvIGRlY29kaW5nIHNob3VsZCBiZSBpbiBsaXR0bGUtZW5kaWFuXG4gKiBAcGFyYW0gcmVkZWYgb3B0aW9uYWwgZmFzdGVyIHJlZGVmaW5pdGlvbnMgb2Ygc3FydCBhbmQgb3RoZXIgbWV0aG9kc1xuICovXG5mdW5jdGlvbiBGaWVsZChPUkRFUiwgYml0TGVuLCBpc0xFID0gZmFsc2UsIHJlZGVmID0ge30pIHtcbiAgICBpZiAoT1JERVIgPD0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIEZpZWxkIE9SREVSID4gMCwgZ290ICR7T1JERVJ9YCk7XG4gICAgY29uc3QgeyBuQml0TGVuZ3RoOiBCSVRTLCBuQnl0ZUxlbmd0aDogQllURVMgfSA9IG5MZW5ndGgoT1JERVIsIGJpdExlbik7XG4gICAgaWYgKEJZVEVTID4gMjA0OClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWVsZCBsZW5ndGhzIG92ZXIgMjA0OCBieXRlcyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgIGNvbnN0IHNxcnRQID0gRnBTcXJ0KE9SREVSKTtcbiAgICBjb25zdCBmID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIE9SREVSLFxuICAgICAgICBCSVRTLFxuICAgICAgICBCWVRFUyxcbiAgICAgICAgTUFTSzogKDAsIHV0aWxzX2pzXzEuYml0TWFzaykoQklUUyksXG4gICAgICAgIFpFUk86IF8wbixcbiAgICAgICAgT05FOiBfMW4sXG4gICAgICAgIGNyZWF0ZTogKG51bSkgPT4gbW9kKG51bSwgT1JERVIpLFxuICAgICAgICBpc1ZhbGlkOiAobnVtKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZpZWxkIGVsZW1lbnQ6IGV4cGVjdGVkIGJpZ2ludCwgZ290ICR7dHlwZW9mIG51bX1gKTtcbiAgICAgICAgICAgIHJldHVybiBfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSOyAvLyAwIGlzIHZhbGlkIGVsZW1lbnQsIGJ1dCBpdCdzIG5vdCBpbnZlcnRpYmxlXG4gICAgICAgIH0sXG4gICAgICAgIGlzMDogKG51bSkgPT4gbnVtID09PSBfMG4sXG4gICAgICAgIGlzT2RkOiAobnVtKSA9PiAobnVtICYgXzFuKSA9PT0gXzFuLFxuICAgICAgICBuZWc6IChudW0pID0+IG1vZCgtbnVtLCBPUkRFUiksXG4gICAgICAgIGVxbDogKGxocywgcmhzKSA9PiBsaHMgPT09IHJocyxcbiAgICAgICAgc3FyOiAobnVtKSA9PiBtb2QobnVtICogbnVtLCBPUkRFUiksXG4gICAgICAgIGFkZDogKGxocywgcmhzKSA9PiBtb2QobGhzICsgcmhzLCBPUkRFUiksXG4gICAgICAgIHN1YjogKGxocywgcmhzKSA9PiBtb2QobGhzIC0gcmhzLCBPUkRFUiksXG4gICAgICAgIG11bDogKGxocywgcmhzKSA9PiBtb2QobGhzICogcmhzLCBPUkRFUiksXG4gICAgICAgIHBvdzogKG51bSwgcG93ZXIpID0+IEZwUG93KGYsIG51bSwgcG93ZXIpLFxuICAgICAgICBkaXY6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIGludmVydChyaHMsIE9SREVSKSwgT1JERVIpLFxuICAgICAgICAvLyBTYW1lIGFzIGFib3ZlLCBidXQgZG9lc24ndCBub3JtYWxpemVcbiAgICAgICAgc3FyTjogKG51bSkgPT4gbnVtICogbnVtLFxuICAgICAgICBhZGROOiAobGhzLCByaHMpID0+IGxocyArIHJocyxcbiAgICAgICAgc3ViTjogKGxocywgcmhzKSA9PiBsaHMgLSByaHMsXG4gICAgICAgIG11bE46IChsaHMsIHJocykgPT4gbGhzICogcmhzLFxuICAgICAgICBpbnY6IChudW0pID0+IGludmVydChudW0sIE9SREVSKSxcbiAgICAgICAgc3FydDogcmVkZWYuc3FydCB8fCAoKG4pID0+IHNxcnRQKGYsIG4pKSxcbiAgICAgICAgaW52ZXJ0QmF0Y2g6IChsc3QpID0+IEZwSW52ZXJ0QmF0Y2goZiwgbHN0KSxcbiAgICAgICAgLy8gVE9ETzogZG8gd2UgcmVhbGx5IG5lZWQgY29uc3RhbnQgY21vdj9cbiAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBjb25zdC10aW1lIGJpZ2ludHMgYW55d2F5LCBzbyBwcm9iYWJseSB3aWxsIGJlIG5vdCB2ZXJ5IHVzZWZ1bFxuICAgICAgICBjbW92OiAoYSwgYiwgYykgPT4gKGMgPyBiIDogYSksXG4gICAgICAgIHRvQnl0ZXM6IChudW0pID0+IChpc0xFID8gKDAsIHV0aWxzX2pzXzEubnVtYmVyVG9CeXRlc0xFKShudW0sIEJZVEVTKSA6ICgwLCB1dGlsc19qc18xLm51bWJlclRvQnl0ZXNCRSkobnVtLCBCWVRFUykpLFxuICAgICAgICBmcm9tQnl0ZXM6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gQllURVMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGcC5mcm9tQnl0ZXM6IGV4cGVjdGVkICR7QllURVN9LCBnb3QgJHtieXRlcy5sZW5ndGh9YCk7XG4gICAgICAgICAgICByZXR1cm4gaXNMRSA/ICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJMRSkoYnl0ZXMpIDogKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckJFKShieXRlcyk7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoZik7XG59XG5mdW5jdGlvbiBGcFNxcnRPZGQoRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkYCk7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyByb290IDogRnAubmVnKHJvb3QpO1xufVxuZnVuY3Rpb24gRnBTcXJ0RXZlbihGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRgKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IEZwLm5lZyhyb290KSA6IHJvb3Q7XG59XG4vKipcbiAqIFwiQ29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIFNhbWUgYXMgbWFwS2V5VG9GaWVsZCwgYnV0IGFjY2VwdHMgbGVzcyBieXRlcyAoNDAgaW5zdGVhZCBvZiA0OCBmb3IgMzItYnl0ZSBmaWVsZCkuXG4gKiBXaGljaCBtYWtlcyBpdCBzbGlnaHRseSBtb3JlIGJpYXNlZCwgbGVzcyBzZWN1cmUuXG4gKiBAZGVwcmVjYXRlZCB1c2UgbWFwS2V5VG9GaWVsZCBpbnN0ZWFkXG4gKi9cbmZ1bmN0aW9uIGhhc2hUb1ByaXZhdGVTY2FsYXIoaGFzaCwgZ3JvdXBPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgaGFzaCA9ICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgncHJpdmF0ZUhhc2gnLCBoYXNoKTtcbiAgICBjb25zdCBoYXNoTGVuID0gaGFzaC5sZW5ndGg7XG4gICAgY29uc3QgbWluTGVuID0gbkxlbmd0aChncm91cE9yZGVyKS5uQnl0ZUxlbmd0aCArIDg7XG4gICAgaWYgKG1pbkxlbiA8IDI0IHx8IGhhc2hMZW4gPCBtaW5MZW4gfHwgaGFzaExlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaGFzaFRvUHJpdmF0ZVNjYWxhcjogZXhwZWN0ZWQgJHttaW5MZW59LTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAke2hhc2hMZW59YCk7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/ICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJMRSkoaGFzaCkgOiAoMCwgdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyQkUpKGhhc2gpO1xuICAgIHJldHVybiBtb2QobnVtLCBncm91cE9yZGVyIC0gXzFuKSArIF8xbjtcbn1cbi8qKlxuICogUmV0dXJucyB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgY29uc3VtZWQgYnkgdGhlIGZpZWxkIGVsZW1lbnQuXG4gKiBGb3IgZXhhbXBsZSwgMzIgYnl0ZXMgZm9yIHVzdWFsIDI1Ni1iaXQgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgZmllbGRcbiAqL1xuZnVuY3Rpb24gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgaWYgKHR5cGVvZiBmaWVsZE9yZGVyICE9PSAnYmlnaW50JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWVsZCBvcmRlciBtdXN0IGJlIGJpZ2ludCcpO1xuICAgIGNvbnN0IGJpdExlbmd0aCA9IGZpZWxkT3JkZXIudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIHJldHVybiBNYXRoLmNlaWwoYml0TGVuZ3RoIC8gOCk7XG59XG4vKipcbiAqIFJldHVybnMgbWluaW1hbCBhbW91bnQgb2YgYnl0ZXMgdGhhdCBjYW4gYmUgc2FmZWx5IHJlZHVjZWRcbiAqIGJ5IGZpZWxkIG9yZGVyLlxuICogU2hvdWxkIGJlIDJeLTEyOCBmb3IgMTI4LWJpdCBjdXJ2ZSBzdWNoIGFzIFAyNTYuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgdGFyZ2V0IGhhc2hcbiAqL1xuZnVuY3Rpb24gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICByZXR1cm4gbGVuZ3RoICsgTWF0aC5jZWlsKGxlbmd0aCAvIDIpO1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBDYW4gdGFrZSAobiArIG4vMikgb3IgbW9yZSBieXRlcyBvZiB1bmlmb3JtIGlucHV0IGUuZy4gZnJvbSBDU1BSTkcgb3IgS0RGXG4gKiBhbmQgY29udmVydCB0aGVtIGludG8gcHJpdmF0ZSBzY2FsYXIsIHdpdGggdGhlIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gKiBOZWVkcyBhdCBsZWFzdCA0OCBieXRlcyBvZiBpbnB1dCBmb3IgMzItYnl0ZSBwcml2YXRlIGtleS5cbiAqIGh0dHBzOi8vcmVzZWFyY2gua3VkZWxza2lzZWN1cml0eS5jb20vMjAyMC8wNy8yOC90aGUtZGVmaW5pdGl2ZS1ndWlkZS10by1tb2R1bG8tYmlhcy1hbmQtaG93LXRvLWF2b2lkLWl0L1xuICogRklQUyAxODYtNSwgQS4yIGh0dHBzOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZGV0YWlsL2ZpcHMvMTg2LzUvZmluYWxcbiAqIFJGQyA5MzgwLCBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTVcbiAqIEBwYXJhbSBoYXNoIGhhc2ggb3V0cHV0IGZyb20gU0hBMyBvciBhIHNpbWlsYXIgZnVuY3Rpb25cbiAqIEBwYXJhbSBncm91cE9yZGVyIHNpemUgb2Ygc3ViZ3JvdXAgLSAoZS5nLiBzZWNwMjU2azEuQ1VSVkUubilcbiAqIEBwYXJhbSBpc0xFIGludGVycHJldCBoYXNoIGJ5dGVzIGFzIExFIG51bVxuICogQHJldHVybnMgdmFsaWQgcHJpdmF0ZSBzY2FsYXJcbiAqL1xuZnVuY3Rpb24gbWFwSGFzaFRvRmllbGQoa2V5LCBmaWVsZE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBjb25zdCBsZW4gPSBrZXkubGVuZ3RoO1xuICAgIGNvbnN0IGZpZWxkTGVuID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICBjb25zdCBtaW5MZW4gPSBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIC8vIE5vIHNtYWxsIG51bWJlcnM6IG5lZWQgdG8gdW5kZXJzdGFuZCBiaWFzIHN0b3J5LiBObyBodWdlIG51bWJlcnM6IGVhc2llciB0byBkZXRlY3QgSlMgdGltaW5ncy5cbiAgICBpZiAobGVuIDwgMTYgfHwgbGVuIDwgbWluTGVuIHx8IGxlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHttaW5MZW59LTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAke2xlbn1gKTtcbiAgICBjb25zdCBudW0gPSBpc0xFID8gKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckJFKShrZXkpIDogKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckxFKShrZXkpO1xuICAgIC8vIGBtb2QoeCwgMTEpYCBjYW4gc29tZXRpbWVzIHByb2R1Y2UgMC4gYG1vZCh4LCAxMCkgKyAxYCBpcyB0aGUgc2FtZSwgYnV0IG5vIDBcbiAgICBjb25zdCByZWR1Y2VkID0gbW9kKG51bSwgZmllbGRPcmRlciAtIF8xbikgKyBfMW47XG4gICAgcmV0dXJuIGlzTEUgPyAoMCwgdXRpbHNfanNfMS5udW1iZXJUb0J5dGVzTEUpKHJlZHVjZWQsIGZpZWxkTGVuKSA6ICgwLCB1dGlsc19qc18xLm51bWJlclRvQnl0ZXNCRSkocmVkdWNlZCwgZmllbGRMZW4pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxhci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/abstract/modular.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/abstract/utils.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/abstract/utils.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bitMask = void 0;\nexports.isBytes = isBytes;\nexports.abytes = abytes;\nexports.bytesToHex = bytesToHex;\nexports.numberToHexUnpadded = numberToHexUnpadded;\nexports.hexToNumber = hexToNumber;\nexports.hexToBytes = hexToBytes;\nexports.bytesToNumberBE = bytesToNumberBE;\nexports.bytesToNumberLE = bytesToNumberLE;\nexports.numberToBytesBE = numberToBytesBE;\nexports.numberToBytesLE = numberToBytesLE;\nexports.numberToVarBytesBE = numberToVarBytesBE;\nexports.ensureBytes = ensureBytes;\nexports.concatBytes = concatBytes;\nexports.equalBytes = equalBytes;\nexports.utf8ToBytes = utf8ToBytes;\nexports.bitLen = bitLen;\nexports.bitGet = bitGet;\nexports.bitSet = bitSet;\nexports.createHmacDrbg = createHmacDrbg;\nexports.validateObject = validateObject;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction abytes(item) {\n    if (!isBytes(item))\n        throw new Error('Uint8Array expected');\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nfunction bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\nexports.bitMask = bitMask;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmLGVBQWU7QUFDZixjQUFjO0FBQ2Qsa0JBQWtCO0FBQ2xCLDJCQUEyQjtBQUMzQixtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QiwwQkFBMEI7QUFDMUIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CLGNBQWM7QUFDZCxjQUFjO0FBQ2QsY0FBYztBQUNkLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLElBQUk7QUFDOUM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPLGlDQUFpQyxJQUFJLFlBQVksRUFBRTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU8sV0FBVyxnQkFBZ0IsYUFBYSxJQUFJO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1CQUFtQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEtBQUs7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsa0JBQWtCLEdBQUcsS0FBSyxHQUFHLFdBQVcsY0FBYyxLQUFLO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVyxXQUFXLFlBQVksSUFBSTtBQUNwRCxrQ0FBa0Msb0JBQW9CLElBQUksYUFBYSxHQUFHO0FBQzFFO0FBQ0Esa0NBQWtDLFVBQVUsSUFBSSxTQUFTO0FBQ3pELGtDQUFrQyxvQkFBb0IsSUFBSSxTQUFTO0FBQ25FLGtDQUFrQywyQkFBMkI7QUFDN0Qsa0NBQWtDLHdCQUF3QjtBQUMxRCIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYml0TWFzayA9IHZvaWQgMDtcbmV4cG9ydHMuaXNCeXRlcyA9IGlzQnl0ZXM7XG5leHBvcnRzLmFieXRlcyA9IGFieXRlcztcbmV4cG9ydHMuYnl0ZXNUb0hleCA9IGJ5dGVzVG9IZXg7XG5leHBvcnRzLm51bWJlclRvSGV4VW5wYWRkZWQgPSBudW1iZXJUb0hleFVucGFkZGVkO1xuZXhwb3J0cy5oZXhUb051bWJlciA9IGhleFRvTnVtYmVyO1xuZXhwb3J0cy5oZXhUb0J5dGVzID0gaGV4VG9CeXRlcztcbmV4cG9ydHMuYnl0ZXNUb051bWJlckJFID0gYnl0ZXNUb051bWJlckJFO1xuZXhwb3J0cy5ieXRlc1RvTnVtYmVyTEUgPSBieXRlc1RvTnVtYmVyTEU7XG5leHBvcnRzLm51bWJlclRvQnl0ZXNCRSA9IG51bWJlclRvQnl0ZXNCRTtcbmV4cG9ydHMubnVtYmVyVG9CeXRlc0xFID0gbnVtYmVyVG9CeXRlc0xFO1xuZXhwb3J0cy5udW1iZXJUb1ZhckJ5dGVzQkUgPSBudW1iZXJUb1ZhckJ5dGVzQkU7XG5leHBvcnRzLmVuc3VyZUJ5dGVzID0gZW5zdXJlQnl0ZXM7XG5leHBvcnRzLmNvbmNhdEJ5dGVzID0gY29uY2F0Qnl0ZXM7XG5leHBvcnRzLmVxdWFsQnl0ZXMgPSBlcXVhbEJ5dGVzO1xuZXhwb3J0cy51dGY4VG9CeXRlcyA9IHV0ZjhUb0J5dGVzO1xuZXhwb3J0cy5iaXRMZW4gPSBiaXRMZW47XG5leHBvcnRzLmJpdEdldCA9IGJpdEdldDtcbmV4cG9ydHMuYml0U2V0ID0gYml0U2V0O1xuZXhwb3J0cy5jcmVhdGVIbWFjRHJiZyA9IGNyZWF0ZUhtYWNEcmJnO1xuZXhwb3J0cy52YWxpZGF0ZU9iamVjdCA9IHZhbGlkYXRlT2JqZWN0O1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gMTAwIGxpbmVzIG9mIGNvZGUgaW4gdGhlIGZpbGUgYXJlIGR1cGxpY2F0ZWQgZnJvbSBub2JsZS1oYXNoZXMgKHV0aWxzKS5cbi8vIFRoaXMgaXMgT0s6IGBhYnN0cmFjdGAgZGlyZWN0b3J5IGRvZXMgbm90IHVzZSBub2JsZS1oYXNoZXMuXG4vLyBVc2VyIG1heSBvcHQtaW4gaW50byB1c2luZyBkaWZmZXJlbnQgaGFzaGluZyBsaWJyYXJ5LiBUaGlzIHdheSwgbm9ibGUtaGFzaGVzXG4vLyB3b24ndCBiZSBpbmNsdWRlZCBpbnRvIHRoZWlyIGJ1bmRsZS5cbmNvbnN0IF8wbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyKTtcbmZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbmZ1bmN0aW9uIGFieXRlcyhpdGVtKSB7XG4gICAgaWYgKCFpc0J5dGVzKGl0ZW0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbn1cbi8vIEFycmF5IHdoZXJlIGluZGV4IDB4ZjAgKDI0MCkgaXMgbWFwcGVkIHRvIHN0cmluZyAnZjAnXG5jb25zdCBoZXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF8sIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBhYnl0ZXMoYnl0ZXMpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5mdW5jdGlvbiBudW1iZXJUb0hleFVucGFkZGVkKG51bSkge1xuICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xufVxuZnVuY3Rpb24gaGV4VG9OdW1iZXIoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgLy8gQmlnIEVuZGlhblxuICAgIHJldHVybiBCaWdJbnQoaGV4ID09PSAnJyA/ICcwJyA6IGAweCR7aGV4fWApO1xufVxuLy8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbmNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIF9BOiA2NSwgX0Y6IDcwLCBfYTogOTcsIF9mOiAxMDIgfTtcbmZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2hhcikge1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fMCAmJiBjaGFyIDw9IGFzY2lpcy5fOSlcbiAgICAgICAgcmV0dXJuIGNoYXIgLSBhc2NpaXMuXzA7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9BICYmIGNoYXIgPD0gYXNjaWlzLl9GKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX0EgLSAxMCk7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9hICYmIGNoYXIgPD0gYXNjaWlzLl9mKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX2EgLSAxMCk7XG4gICAgcmV0dXJuO1xufVxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBobCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhbCk7XG4gICAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcbiAgICAgICAgY29uc3QgbjEgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpKSk7XG4gICAgICAgIGNvbnN0IG4yID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSArIDEpKTtcbiAgICAgICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGhleFtoaV0gKyBoZXhbaGkgKyAxXTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheVthaV0gPSBuMSAqIDE2ICsgbjI7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIEJFOiBCaWcgRW5kaWFuLCBMRTogTGl0dGxlIEVuZGlhblxuZnVuY3Rpb24gYnl0ZXNUb051bWJlckJFKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoYnl0ZXMpKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJMRShieXRlcykge1xuICAgIGFieXRlcyhieXRlcyk7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKGJ5dGVzKS5yZXZlcnNlKCkpKTtcbn1cbmZ1bmN0aW9uIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhuLnRvU3RyaW5nKDE2KS5wYWRTdGFydChsZW4gKiAyLCAnMCcpKTtcbn1cbmZ1bmN0aW9uIG51bWJlclRvQnl0ZXNMRShuLCBsZW4pIHtcbiAgICByZXR1cm4gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikucmV2ZXJzZSgpO1xufVxuLy8gVW5wYWRkZWQsIHJhcmVseSB1c2VkXG5mdW5jdGlvbiBudW1iZXJUb1ZhckJ5dGVzQkUobikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG51bWJlclRvSGV4VW5wYWRkZWQobikpO1xufVxuLyoqXG4gKiBUYWtlcyBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNvbnZlcnRzIHRvIFVpbnQ4QXJyYXkuXG4gKiBWYWxpZGF0ZXMgb3V0cHV0IGxlbmd0aC5cbiAqIFdpbGwgdGhyb3cgZXJyb3IgZm9yIG90aGVyIHR5cGVzLlxuICogQHBhcmFtIHRpdGxlIGRlc2NyaXB0aXZlIHRpdGxlIGZvciBhbiBlcnJvciBlLmcuICdwcml2YXRlIGtleSdcbiAqIEBwYXJhbSBoZXggaGV4IHN0cmluZyBvciBVaW50OEFycmF5XG4gKiBAcGFyYW0gZXhwZWN0ZWRMZW5ndGggb3B0aW9uYWwsIHdpbGwgY29tcGFyZSB0byByZXN1bHQgYXJyYXkncyBsZW5ndGhcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGVuc3VyZUJ5dGVzKHRpdGxlLCBoZXgsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgbGV0IHJlcztcbiAgICBpZiAodHlwZW9mIGhleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcyA9IGhleFRvQnl0ZXMoaGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBtdXN0IGJlIHZhbGlkIGhleCBzdHJpbmcsIGdvdCBcIiR7aGV4fVwiLiBDYXVzZTogJHtlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQnl0ZXMoaGV4KSkge1xuICAgICAgICAvLyBVaW50OEFycmF5LmZyb20oKSBpbnN0ZWFkIG9mIGhhc2guc2xpY2UoKSBiZWNhdXNlIG5vZGUuanMgQnVmZmVyXG4gICAgICAgIC8vIGlzIGluc3RhbmNlIG9mIFVpbnQ4QXJyYXksIGFuZCBpdHMgc2xpY2UoKSBjcmVhdGVzICoqbXV0YWJsZSoqIGNvcHlcbiAgICAgICAgcmVzID0gVWludDhBcnJheS5mcm9tKGhleCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5YCk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IHJlcy5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZExlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuICE9PSBleHBlY3RlZExlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBleHBlY3RlZCAke2V4cGVjdGVkTGVuZ3RofSBieXRlcywgZ290ICR7bGVufWApO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5mdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICBhYnl0ZXMoYSk7XG4gICAgICAgIHN1bSArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc3VtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICByZXMuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIENvbXBhcmVzIDIgdThhLXMgaW4ga2luZGEgY29uc3RhbnQgdGltZVxuZnVuY3Rpb24gZXF1YWxCeXRlcyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBkaWZmID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGRpZmYgfD0gYVtpXSBeIGJbaV07XG4gICAgcmV0dXJuIGRpZmYgPT09IDA7XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLy8gQml0IG9wZXJhdGlvbnNcbi8qKlxuICogQ2FsY3VsYXRlcyBhbW91bnQgb2YgYml0cyBpbiBhIGJpZ2ludC5cbiAqIFNhbWUgYXMgYG4udG9TdHJpbmcoMikubGVuZ3RoYFxuICovXG5mdW5jdGlvbiBiaXRMZW4obikge1xuICAgIGxldCBsZW47XG4gICAgZm9yIChsZW4gPSAwOyBuID4gXzBuOyBuID4+PSBfMW4sIGxlbiArPSAxKVxuICAgICAgICA7XG4gICAgcmV0dXJuIGxlbjtcbn1cbi8qKlxuICogR2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICogTk9URTogZmlyc3QgYml0IHBvc2l0aW9uIGlzIDAgKHNhbWUgYXMgYXJyYXlzKVxuICogU2FtZSBhcyBgISErQXJyYXkuZnJvbShuLnRvU3RyaW5nKDIpKS5yZXZlcnNlKClbcG9zXWBcbiAqL1xuZnVuY3Rpb24gYml0R2V0KG4sIHBvcykge1xuICAgIHJldHVybiAobiA+PiBCaWdJbnQocG9zKSkgJiBfMW47XG59XG4vKipcbiAqIFNldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gYml0U2V0KG4sIHBvcywgdmFsdWUpIHtcbiAgICByZXR1cm4gbiB8ICgodmFsdWUgPyBfMW4gOiBfMG4pIDw8IEJpZ0ludChwb3MpKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIG1hc2sgZm9yIE4gYml0cy4gTm90IHVzaW5nICoqIG9wZXJhdG9yIHdpdGggYmlnaW50cyBiZWNhdXNlIG9mIG9sZCBlbmdpbmVzLlxuICogU2FtZSBhcyBCaWdJbnQoYDBiJHtBcnJheShpKS5maWxsKCcxJykuam9pbignJyl9YClcbiAqL1xuY29uc3QgYml0TWFzayA9IChuKSA9PiAoXzJuIDw8IEJpZ0ludChuIC0gMSkpIC0gXzFuO1xuZXhwb3J0cy5iaXRNYXNrID0gYml0TWFzaztcbi8vIERSQkdcbmNvbnN0IHU4biA9IChkYXRhKSA9PiBuZXcgVWludDhBcnJheShkYXRhKTsgLy8gY3JlYXRlcyBVaW50OEFycmF5XG5jb25zdCB1OGZyID0gKGFycikgPT4gVWludDhBcnJheS5mcm9tKGFycik7IC8vIGFub3RoZXIgc2hvcnRjdXRcbi8qKlxuICogTWluaW1hbCBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB3aWxsIGNhbGwgRFJCRyB1bnRpbCAybmQgYXJnIHJldHVybnMgc29tZXRoaW5nIG1lYW5pbmdmdWxcbiAqIEBleGFtcGxlXG4gKiAgIGNvbnN0IGRyYmcgPSBjcmVhdGVIbWFjRFJCRzxLZXk+KDMyLCAzMiwgaG1hYyk7XG4gKiAgIGRyYmcoc2VlZCwgYnl0ZXNUb0tleSk7IC8vIGJ5dGVzVG9LZXkgbXVzdCByZXR1cm4gS2V5IG9yIHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBjcmVhdGVIbWFjRHJiZyhoYXNoTGVuLCBxQnl0ZUxlbiwgaG1hY0ZuKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIHFCeXRlTGVuICE9PSAnbnVtYmVyJyB8fCBxQnl0ZUxlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgaG1hY0ZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2htYWNGbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAvLyBTdGVwIEIsIFN0ZXAgQzogc2V0IGhhc2hMZW4gdG8gOCpjZWlsKGhsZW4vOClcbiAgICBsZXQgdiA9IHU4bihoYXNoTGVuKTsgLy8gTWluaW1hbCBub24tZnVsbC1zcGVjIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gICAgbGV0IGsgPSB1OG4oaGFzaExlbik7IC8vIFN0ZXBzIEIgYW5kIEMgb2YgUkZDNjk3OSAzLjI6IHNldCBoYXNoTGVuLCBpbiBvdXIgY2FzZSBhbHdheXMgc2FtZVxuICAgIGxldCBpID0gMDsgLy8gSXRlcmF0aW9ucyBjb3VudGVyLCB3aWxsIHRocm93IHdoZW4gb3ZlciAxMDAwXG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHYuZmlsbCgxKTtcbiAgICAgICAgay5maWxsKDApO1xuICAgICAgICBpID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGggPSAoLi4uYikgPT4gaG1hY0ZuKGssIHYsIC4uLmIpOyAvLyBobWFjKGspKHYsIC4uLnZhbHVlcylcbiAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigpKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyByZXNlZWQoKSBmdW5jdGlvbi4gU3RlcHMgRC1HXG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDBdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAwIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBrID0gaCh1OGZyKFsweDAxXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMSB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgfTtcbiAgICBjb25zdCBnZW4gPSAoKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyBnZW5lcmF0ZSgpIGZ1bmN0aW9uXG4gICAgICAgIGlmIChpKysgPj0gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHJiZzogdHJpZWQgMTAwMCB2YWx1ZXMnKTtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICB3aGlsZSAobGVuIDwgcUJ5dGVMZW4pIHtcbiAgICAgICAgICAgIHYgPSBoKCk7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB2Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoLi4ub3V0KTtcbiAgICB9O1xuICAgIGNvbnN0IGdlblVudGlsID0gKHNlZWQsIHByZWQpID0+IHtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmVzZWVkKHNlZWQpOyAvLyBTdGVwcyBELUdcbiAgICAgICAgbGV0IHJlcyA9IHVuZGVmaW5lZDsgLy8gU3RlcCBIOiBncmluZCB1bnRpbCBrIGlzIGluIFsxLi5uLTFdXG4gICAgICAgIHdoaWxlICghKHJlcyA9IHByZWQoZ2VuKCkpKSlcbiAgICAgICAgICAgIHJlc2VlZCgpO1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIGdlblVudGlsO1xufVxuLy8gVmFsaWRhdGluZyBjdXJ2ZXMgYW5kIGZpZWxkc1xuY29uc3QgdmFsaWRhdG9yRm5zID0ge1xuICAgIGJpZ2ludDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcsXG4gICAgZnVuY3Rpb246ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXG4gICAgYm9vbGVhbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nLFxuICAgIHN0cmluZzogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycsXG4gICAgc3RyaW5nT3JVaW50OEFycmF5OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCBpc0J5dGVzKHZhbCksXG4gICAgaXNTYWZlSW50ZWdlcjogKHZhbCkgPT4gTnVtYmVyLmlzU2FmZUludGVnZXIodmFsKSxcbiAgICBhcnJheTogKHZhbCkgPT4gQXJyYXkuaXNBcnJheSh2YWwpLFxuICAgIGZpZWxkOiAodmFsLCBvYmplY3QpID0+IG9iamVjdC5GcC5pc1ZhbGlkKHZhbCksXG4gICAgaGFzaDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwub3V0cHV0TGVuKSxcbn07XG4vLyB0eXBlIFJlY29yZDxLIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sLCBUPiA9IHsgW1AgaW4gS106IFQ7IH1cbmZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0KG9iamVjdCwgdmFsaWRhdG9ycywgb3B0VmFsaWRhdG9ycyA9IHt9KSB7XG4gICAgY29uc3QgY2hlY2tGaWVsZCA9IChmaWVsZE5hbWUsIHR5cGUsIGlzT3B0aW9uYWwpID0+IHtcbiAgICAgICAgY29uc3QgY2hlY2tWYWwgPSB2YWxpZGF0b3JGbnNbdHlwZV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tWYWwgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsaWRhdG9yIFwiJHt0eXBlfVwiLCBleHBlY3RlZCBmdW5jdGlvbmApO1xuICAgICAgICBjb25zdCB2YWwgPSBvYmplY3RbZmllbGROYW1lXTtcbiAgICAgICAgaWYgKGlzT3B0aW9uYWwgJiYgdmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghY2hlY2tWYWwodmFsLCBvYmplY3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGFyYW0gJHtTdHJpbmcoZmllbGROYW1lKX09JHt2YWx9ICgke3R5cGVvZiB2YWx9KSwgZXhwZWN0ZWQgJHt0eXBlfWApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgZmFsc2UpO1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0VmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCB0cnVlKTtcbiAgICByZXR1cm4gb2JqZWN0O1xufVxuLy8gdmFsaWRhdGUgdHlwZSB0ZXN0c1xuLy8gY29uc3QgbzogeyBhOiBudW1iZXI7IGI6IG51bWJlcjsgYzogbnVtYmVyIH0gPSB7IGE6IDEsIGI6IDUsIGM6IDYgfTtcbi8vIGNvbnN0IHowID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnYmlnaW50JyB9KTsgLy8gT2shXG4vLyAvLyBTaG91bGQgZmFpbCB0eXBlLWNoZWNrXG4vLyBjb25zdCB6MSA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ3RtcCcgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejIgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MyA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgdGVzdDogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8vIGNvbnN0IHo0ID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/abstract/utils.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/abstract/weierstrass.js":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/abstract/weierstrass.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DER = void 0;\nexports.weierstrassPoints = weierstrassPoints;\nexports.weierstrass = weierstrass;\nexports.SWUFpSqrtRatio = SWUFpSqrtRatio;\nexports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y² = x³ + ax + b\nconst curve_js_1 = __webpack_require__(/*! ./curve.js */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/abstract/curve.js\");\nconst mod = __webpack_require__(/*! ./modular.js */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/abstract/modular.js\");\nconst ut = __webpack_require__(/*! ./utils.js */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/abstract/utils.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/abstract/utils.js\");\nfunction validatePointOpts(curve) {\n    const opts = (0, curve_js_1.validateBasic)(curve);\n    ut.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\nexports.DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    _parseInt(data) {\n        const { Err: E } = exports.DER;\n        if (data.length < 2 || data[0] !== 0x02)\n            throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len)\n            throw new E('Invalid signature integer: wrong length');\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 0b10000000)\n            throw new E('Invalid signature integer: negative');\n        if (res[0] === 0x00 && !(res[1] & 0b10000000))\n            throw new E('Invalid signature integer: unnecessary leading zero');\n        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E } = exports.DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        ut.abytes(data);\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30)\n            throw new E('Invalid signature tag');\n        if (data[1] !== l - 2)\n            throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = exports.DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = exports.DER._parseInt(sBytes);\n        if (rBytesLeft.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r, s };\n    },\n    hexFromSig(sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n        const h = (num) => {\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula\n     * @returns y²\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num))\n            throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (ut.isBytes(key))\n                key = ut.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = mod.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))\n                    return;\n                throw new Error('bad point: ZERO');\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('bad point: x or y not FE');\n            const left = Fp.sqr(y); // y²\n            const right = weierstrassEquation(x); // x³ + ax + b\n            if (!Fp.eql(left, right))\n                throw new Error('bad point: equation left != right');\n            if (!this.isTorsionFree())\n                throw new Error('bad point: not in prime-order subgroup');\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n)\n                return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ∋ (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null)\n                iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0)\n                return { x: Fp.ZERO, y: Fp.ZERO };\n            if (!Fp.eql(zz, Fp.ONE))\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return ut.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0, curve_js_1.validateBasic)(curve);\n    ut.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return mod.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return mod.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = ut.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = ut.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n                }\n                catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                    throw new Error('Point is not on curve' + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0, utils_js_1.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r))\n                throw new Error('r must be 0 < r < CURVE.n');\n            if (!isWithinCurveOrder(this.s))\n                throw new Error('s must be 0 < s < CURVE.n');\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0, utils_js_1.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return ut.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return exports.DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return ut.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = mod.getMinHashLength(CURVE.n);\n            return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = ut.isBytes(item);\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('bigint expected');\n        if (!(_0n <= num && num < ORDER_MASK))\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return ut.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);\n        if (prehash)\n            msgHash = (0, utils_js_1.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0, utils_js_1.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1⋅G - U2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);\n        publicKey = (0, utils_js_1.ensureBytes)('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || ut.isBytes(sg)) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof exports.DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    mod.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsV0FBVztBQUNYLHlCQUF5QjtBQUN6QixtQkFBbUI7QUFDbkIsc0JBQXNCO0FBQ3RCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsZ0hBQVk7QUFDdkMsWUFBWSxtQkFBTyxDQUFDLG9IQUFjO0FBQ2xDLFdBQVcsbUJBQU8sQ0FBQyxnSEFBWTtBQUMvQixtQkFBbUIsbUJBQU8sQ0FBQyxnSEFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQSxRQUFRLHdDQUF3QztBQUNoRCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMENBQTBDO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQixJQUFJLEdBQUcsRUFBRSxFQUFFLElBQUksR0FBRyxFQUFFLEVBQUU7QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSyxTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsOEJBQThCO0FBQzlCLGtDQUFrQztBQUNsQyxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9FQUFvRTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxhQUFhLDRCQUE0QixXQUFXO0FBQ3ZHO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsSUFBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDLDBEQUEwRDtBQUMxRCxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0Msb0JBQW9CLHlCQUF5QjtBQUM3QywwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQyxzQkFBc0IsaUJBQWlCO0FBQ3ZDLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDLHdDQUF3QztBQUN4Qyw4Q0FBOEM7QUFDOUM7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJGQUEyRjtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxtREFBbUQsS0FBSyx3QkFBd0IsZUFBZSxzQkFBc0IsaUJBQWlCO0FBQ3RJO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxzQ0FBc0M7QUFDdEMscUNBQXFDO0FBQ3JDLGtFQUFrRTtBQUNsRTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsc0JBQXNCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxpQkFBaUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQyxjQUFjLG1DQUFtQyxRQUFRO0FBQ3pEO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFLDJFQUEyRTtBQUMzRTtBQUNBLGtEQUFrRDtBQUNsRCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0Esd0JBQXdCO0FBQ3hCLGdDQUFnQztBQUNoQyx5REFBeUQ7QUFDekQsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLCtCQUErQjtBQUMvQjtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjLG1DQUFtQztBQUNqRTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsMENBQTBDO0FBQzFDLDRCQUE0QjtBQUM1QixpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0Esa0JBQWtCO0FBQ2xCLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0IsOEJBQThCO0FBQzlCLDRDQUE0QztBQUM1QztBQUNBLHNCQUFzQjtBQUN0QixpQ0FBaUM7QUFDakMsK0JBQStCO0FBQy9CLDhCQUE4QjtBQUM5QixrQ0FBa0M7QUFDbEMsK0JBQStCO0FBQy9CLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLG9DQUFvQztBQUNwQywrQkFBK0I7QUFDL0Isd0NBQXdDO0FBQ3hDLCtCQUErQjtBQUMvQixnQ0FBZ0M7QUFDaEMsdUNBQXVDO0FBQ3ZDLHVDQUF1QztBQUN2QztBQUNBLHlCQUF5QixTQUFTO0FBQ2xDLCtCQUErQjtBQUMvQixzQ0FBc0M7QUFDdEMseUNBQXlDO0FBQ3pDLDZDQUE2QztBQUM3QyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDLHFDQUFxQztBQUNyQyx5Q0FBeUM7QUFDekMsMENBQTBDO0FBQzFDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyx1Q0FBdUM7QUFDdkM7QUFDQSxpQ0FBaUM7QUFDakMsc0NBQXNDO0FBQ3RDLG9DQUFvQztBQUNwQyxzQ0FBc0M7QUFDdEMsa0NBQWtDO0FBQ2xDLHVDQUF1QztBQUN2QywrQ0FBK0Msa0JBQWtCO0FBQ2pFLHlDQUF5QztBQUN6QywyQ0FBMkM7QUFDM0MscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixtQ0FBbUM7QUFDbkMsMkJBQTJCO0FBQzNCLGdDQUFnQztBQUNoQyxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DLG1FQUFtRTtBQUNuRSxtQ0FBbUM7QUFDbkMsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQixtQ0FBbUM7QUFDbkMsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsbUNBQW1DO0FBQ25DLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsZ0JBQWdCLGlCQUFpQix1QkFBdUI7QUFDeEQsNEJBQTRCO0FBQzVCLDhCQUE4QjtBQUM5QixzQ0FBc0M7QUFDdEMsd0NBQXdDO0FBQ3hDLGdEQUFnRDtBQUNoRCx1Q0FBdUM7QUFDdkMsNEJBQTRCO0FBQzVCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRFUiA9IHZvaWQgMDtcbmV4cG9ydHMud2VpZXJzdHJhc3NQb2ludHMgPSB3ZWllcnN0cmFzc1BvaW50cztcbmV4cG9ydHMud2VpZXJzdHJhc3MgPSB3ZWllcnN0cmFzcztcbmV4cG9ydHMuU1dVRnBTcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbztcbmV4cG9ydHMubWFwVG9DdXJ2ZVNpbXBsZVNXVSA9IG1hcFRvQ3VydmVTaW1wbGVTV1U7XG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBTaG9ydCBXZWllcnN0cmFzcyBjdXJ2ZS4gVGhlIGZvcm11bGEgaXM6IHnCsiA9IHjCsyArIGF4ICsgYlxuY29uc3QgY3VydmVfanNfMSA9IHJlcXVpcmUoXCIuL2N1cnZlLmpzXCIpO1xuY29uc3QgbW9kID0gcmVxdWlyZShcIi4vbW9kdWxhci5qc1wiKTtcbmNvbnN0IHV0ID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG5mdW5jdGlvbiB2YWxpZGF0ZVBvaW50T3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSAoMCwgY3VydmVfanNfMS52YWxpZGF0ZUJhc2ljKShjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBhOiAnZmllbGQnLFxuICAgICAgICBiOiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiAnYXJyYXknLFxuICAgICAgICB3cmFwUHJpdmF0ZUtleTogJ2Jvb2xlYW4nLFxuICAgICAgICBpc1RvcnNpb25GcmVlOiAnZnVuY3Rpb24nLFxuICAgICAgICBjbGVhckNvZmFjdG9yOiAnZnVuY3Rpb24nLFxuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6ICdib29sZWFuJyxcbiAgICAgICAgZnJvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICB0b0J5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgZW5kbywgRnAsIGEgfSA9IG9wdHM7XG4gICAgaWYgKGVuZG8pIHtcbiAgICAgICAgaWYgKCFGcC5lcWwoYSwgRnAuWkVSTykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5kb21vcnBoaXNtIGNhbiBvbmx5IGJlIGRlZmluZWQgZm9yIEtvYmxpdHogY3VydmVzIHRoYXQgaGF2ZSBhPTAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVuZG8gIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5iZXRhICE9PSAnYmlnaW50JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uc3BsaXRTY2FsYXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZW5kb21vcnBoaXNtIHdpdGggYmV0YTogYmlnaW50IGFuZCBzcGxpdFNjYWxhcjogZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLm9wdHMgfSk7XG59XG4vLyBBU04uMSBERVIgZW5jb2RpbmcgdXRpbGl0aWVzXG5jb25zdCB7IGJ5dGVzVG9OdW1iZXJCRTogYjJuLCBoZXhUb0J5dGVzOiBoMmIgfSA9IHV0O1xuZXhwb3J0cy5ERVIgPSB7XG4gICAgLy8gYXNuLjEgREVSIGVuY29kaW5nIHV0aWxzXG4gICAgRXJyOiBjbGFzcyBERVJFcnIgZXh0ZW5kcyBFcnJvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG0gPSAnJykge1xuICAgICAgICAgICAgc3VwZXIobSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9wYXJzZUludChkYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBleHBvcnRzLkRFUjtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMiB8fCBkYXRhWzBdICE9PSAweDAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXIgdGFnJyk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGFbMV07XG4gICAgICAgIGNvbnN0IHJlcyA9IGRhdGEuc3ViYXJyYXkoMiwgbGVuICsgMik7XG4gICAgICAgIGlmICghbGVuIHx8IHJlcy5sZW5ndGggIT09IGxlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB3cm9uZyBsZW5ndGgnKTtcbiAgICAgICAgLy8gaHR0cHM6Ly9jcnlwdG8uc3RhY2tleGNoYW5nZS5jb20vYS81NzczNCBMZWZ0bW9zdCBiaXQgb2YgZmlyc3QgYnl0ZSBpcyAnbmVnYXRpdmUnIGZsYWcsXG4gICAgICAgIC8vIHNpbmNlIHdlIGFsd2F5cyB1c2UgcG9zaXRpdmUgaW50ZWdlcnMgaGVyZS4gSXQgbXVzdCBhbHdheXMgYmUgZW1wdHk6XG4gICAgICAgIC8vIC0gYWRkIHplcm8gYnl0ZSBpZiBleGlzdHNcbiAgICAgICAgLy8gLSBpZiBuZXh0IGJ5dGUgZG9lc24ndCBoYXZlIGEgZmxhZywgbGVhZGluZyB6ZXJvIGlzIG5vdCBhbGxvd2VkIChtaW5pbWFsIGVuY29kaW5nKVxuICAgICAgICBpZiAocmVzWzBdICYgMGIxMDAwMDAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiBuZWdhdGl2ZScpO1xuICAgICAgICBpZiAocmVzWzBdID09PSAweDAwICYmICEocmVzWzFdICYgMGIxMDAwMDAwMCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdW5uZWNlc3NhcnkgbGVhZGluZyB6ZXJvJyk7XG4gICAgICAgIHJldHVybiB7IGQ6IGIybihyZXMpLCBsOiBkYXRhLnN1YmFycmF5KGxlbiArIDIpIH07IC8vIGQgaXMgZGF0YSwgbCBpcyBsZWZ0XG4gICAgfSxcbiAgICB0b1NpZyhoZXgpIHtcbiAgICAgICAgLy8gcGFyc2UgREVSIHNpZ25hdHVyZVxuICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gZXhwb3J0cy5ERVI7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0eXBlb2YgaGV4ID09PSAnc3RyaW5nJyA/IGgyYihoZXgpIDogaGV4O1xuICAgICAgICB1dC5hYnl0ZXMoZGF0YSk7XG4gICAgICAgIGxldCBsID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGlmIChsIDwgMiB8fCBkYXRhWzBdICE9IDB4MzApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgdGFnJyk7XG4gICAgICAgIGlmIChkYXRhWzFdICE9PSBsIC0gMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogaW5jb3JyZWN0IGxlbmd0aCcpO1xuICAgICAgICBjb25zdCB7IGQ6IHIsIGw6IHNCeXRlcyB9ID0gZXhwb3J0cy5ERVIuX3BhcnNlSW50KGRhdGEuc3ViYXJyYXkoMikpO1xuICAgICAgICBjb25zdCB7IGQ6IHMsIGw6IHJCeXRlc0xlZnQgfSA9IGV4cG9ydHMuREVSLl9wYXJzZUludChzQnl0ZXMpO1xuICAgICAgICBpZiAockJ5dGVzTGVmdC5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmU6IGxlZnQgYnl0ZXMgYWZ0ZXIgcGFyc2luZycpO1xuICAgICAgICByZXR1cm4geyByLCBzIH07XG4gICAgfSxcbiAgICBoZXhGcm9tU2lnKHNpZykge1xuICAgICAgICAvLyBBZGQgbGVhZGluZyB6ZXJvIGlmIGZpcnN0IGJ5dGUgaGFzIG5lZ2F0aXZlIGJpdCBlbmFibGVkLiBNb3JlIGRldGFpbHMgaW4gJ19wYXJzZUludCdcbiAgICAgICAgY29uc3Qgc2xpY2UgPSAocykgPT4gKE51bWJlci5wYXJzZUludChzWzBdLCAxNikgJiAwYjEwMDAgPyAnMDAnICsgcyA6IHMpO1xuICAgICAgICBjb25zdCBoID0gKG51bSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIHJldHVybiBoZXgubGVuZ3RoICYgMSA/IGAwJHtoZXh9YCA6IGhleDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcyA9IHNsaWNlKGgoc2lnLnMpKTtcbiAgICAgICAgY29uc3QgciA9IHNsaWNlKGgoc2lnLnIpKTtcbiAgICAgICAgY29uc3Qgc2hsID0gcy5sZW5ndGggLyAyO1xuICAgICAgICBjb25zdCByaGwgPSByLmxlbmd0aCAvIDI7XG4gICAgICAgIGNvbnN0IHNsID0gaChzaGwpO1xuICAgICAgICBjb25zdCBybCA9IGgocmhsKTtcbiAgICAgICAgcmV0dXJuIGAzMCR7aChyaGwgKyBzaGwgKyA0KX0wMiR7cmx9JHtyfTAyJHtzbH0ke3N9YDtcbiAgICB9LFxufTtcbi8vIEJlIGZyaWVuZGx5IHRvIGJhZCBFQ01BU2NyaXB0IHBhcnNlcnMgYnkgbm90IHVzaW5nIGJpZ2ludCBsaXRlcmFsc1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyksIF80biA9IEJpZ0ludCg0KTtcbmZ1bmN0aW9uIHdlaWVyc3RyYXNzUG9pbnRzKG9wdHMpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlUG9pbnRPcHRzKG9wdHMpO1xuICAgIGNvbnN0IHsgRnAgfSA9IENVUlZFOyAvLyBBbGwgY3VydmVzIGhhcyBzYW1lIGZpZWxkIC8gZ3JvdXAgbGVuZ3RoIGFzIGZvciBub3csIGJ1dCB0aGV5IGNhbiBkaWZmZXJcbiAgICBjb25zdCB0b0J5dGVzID0gQ1VSVkUudG9CeXRlcyB8fFxuICAgICAgICAoKF9jLCBwb2ludCwgX2lzQ29tcHJlc3NlZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICByZXR1cm4gdXQuY29uY2F0Qnl0ZXMoVWludDhBcnJheS5mcm9tKFsweDA0XSksIEZwLnRvQnl0ZXMoYS54KSwgRnAudG9CeXRlcyhhLnkpKTtcbiAgICAgICAgfSk7XG4gICAgY29uc3QgZnJvbUJ5dGVzID0gQ1VSVkUuZnJvbUJ5dGVzIHx8XG4gICAgICAgICgoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIC8vIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIGlmIChoZWFkICE9PSAweDA0KSB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgbm9uLWNvbXByZXNzZWQgZW5jb2RpbmcgaXMgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgRnAuQllURVMpKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheShGcC5CWVRFUywgMiAqIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgIH0pO1xuICAgIC8qKlxuICAgICAqIHnCsiA9IHjCsyArIGF4ICsgYjogU2hvcnQgd2VpZXJzdHJhc3MgY3VydmUgZm9ybXVsYVxuICAgICAqIEByZXR1cm5zIHnCslxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdlaWVyc3RyYXNzRXF1YXRpb24oeCkge1xuICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICBjb25zdCB4MiA9IEZwLnNxcih4KTsgLy8geCAqIHhcbiAgICAgICAgY29uc3QgeDMgPSBGcC5tdWwoeDIsIHgpOyAvLyB4MiAqIHhcbiAgICAgICAgcmV0dXJuIEZwLmFkZChGcC5hZGQoeDMsIEZwLm11bCh4LCBhKSksIGIpOyAvLyB4MyArIGEgKiB4ICsgYlxuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSB3aGV0aGVyIHRoZSBwYXNzZWQgY3VydmUgcGFyYW1zIGFyZSB2YWxpZC5cbiAgICAvLyBXZSBjaGVjayBpZiBjdXJ2ZSBlcXVhdGlvbiB3b3JrcyBmb3IgZ2VuZXJhdG9yIHBvaW50LlxuICAgIC8vIGBhc3NlcnRWYWxpZGl0eSgpYCB3b24ndCB3b3JrOiBgaXNUb3JzaW9uRnJlZSgpYCBpcyBub3QgYXZhaWxhYmxlIGF0IHRoaXMgcG9pbnQgaW4gYmxzMTItMzgxLlxuICAgIC8vIFByb2plY3RpdmVQb2ludCBjbGFzcyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0LlxuICAgIGlmICghRnAuZXFsKEZwLnNxcihDVVJWRS5HeSksIHdlaWVyc3RyYXNzRXF1YXRpb24oQ1VSVkUuR3gpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgZ2VuZXJhdG9yIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgLy8gVmFsaWQgZ3JvdXAgZWxlbWVudHMgcmVzaWRlIGluIHJhbmdlIDEuLm4tMVxuICAgIGZ1bmN0aW9uIGlzV2l0aGluQ3VydmVPcmRlcihudW0pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBudW0gPT09ICdiaWdpbnQnICYmIF8wbiA8IG51bSAmJiBudW0gPCBDVVJWRS5uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnRHRShudW0pIHtcbiAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdmFsaWQgYmlnaW50OiAwIDwgYmlnaW50IDwgY3VydmUubicpO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZXMgaWYgcHJpdiBrZXkgaXMgdmFsaWQgYW5kIGNvbnZlcnRzIGl0IHRvIGJpZ2ludC5cbiAgICAvLyBTdXBwb3J0cyBvcHRpb25zIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RocyBhbmQgd3JhcFByaXZhdGVLZXkuXG4gICAgZnVuY3Rpb24gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihrZXkpIHtcbiAgICAgICAgY29uc3QgeyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6IGxlbmd0aHMsIG5CeXRlTGVuZ3RoLCB3cmFwUHJpdmF0ZUtleSwgbiB9ID0gQ1VSVkU7XG4gICAgICAgIGlmIChsZW5ndGhzICYmIHR5cGVvZiBrZXkgIT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICBpZiAodXQuaXNCeXRlcyhrZXkpKVxuICAgICAgICAgICAgICAgIGtleSA9IHV0LmJ5dGVzVG9IZXgoa2V5KTtcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0byBoZXggc3RyaW5nLCBwYWQuIEUuZy4gUDUyMSB3b3VsZCBub3JtIDEzMC0xMzIgY2hhciBoZXggdG8gMTMyLWNoYXIgYnl0ZXNcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyB8fCAhbGVuZ3Rocy5pbmNsdWRlcyhrZXkubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQga2V5Jyk7XG4gICAgICAgICAgICBrZXkgPSBrZXkucGFkU3RhcnQobkJ5dGVMZW5ndGggKiAyLCAnMCcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBudW07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBudW0gPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBrZXkgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICAgICAgICAgID8ga2V5XG4gICAgICAgICAgICAgICAgICAgIDogdXQuYnl0ZXNUb051bWJlckJFKCgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgncHJpdmF0ZSBrZXknLCBrZXksIG5CeXRlTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHByaXZhdGUga2V5IG11c3QgYmUgJHtuQnl0ZUxlbmd0aH0gYnl0ZXMsIGhleCBvciBiaWdpbnQsIG5vdCAke3R5cGVvZiBrZXl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdyYXBQcml2YXRlS2V5KVxuICAgICAgICAgICAgbnVtID0gbW9kLm1vZChudW0sIG4pOyAvLyBkaXNhYmxlZCBieSBkZWZhdWx0LCBlbmFibGVkIGZvciBCTFNcbiAgICAgICAgYXNzZXJ0R0UobnVtKTsgLy8gbnVtIGluIHJhbmdlIFsxLi5OLTFdXG4gICAgICAgIHJldHVybiBudW07XG4gICAgfVxuICAgIGNvbnN0IHBvaW50UHJlY29tcHV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gYXNzZXJ0UHJqUG9pbnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3RpdmVQb2ludCBleHBlY3RlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0aXZlIFBvaW50IHdvcmtzIGluIDNkIC8gcHJvamVjdGl2ZSAoaG9tb2dlbmVvdXMpIGNvb3JkaW5hdGVzOiAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICogRGVmYXVsdCBQb2ludCB3b3JrcyBpbiAyZCAvIGFmZmluZSBjb29yZGluYXRlczogKHgsIHkpXG4gICAgICogV2UncmUgZG9pbmcgY2FsY3VsYXRpb25zIGluIHByb2plY3RpdmUsIGJlY2F1c2UgaXRzIG9wZXJhdGlvbnMgZG9uJ3QgcmVxdWlyZSBjb3N0bHkgaW52ZXJzaW9uLlxuICAgICAqL1xuICAgIGNsYXNzIFBvaW50IHtcbiAgICAgICAgY29uc3RydWN0b3IocHgsIHB5LCBweikge1xuICAgICAgICAgICAgdGhpcy5weCA9IHB4O1xuICAgICAgICAgICAgdGhpcy5weSA9IHB5O1xuICAgICAgICAgICAgdGhpcy5weiA9IHB6O1xuICAgICAgICAgICAgaWYgKHB4ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneCByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB5ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneSByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB6ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHopKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneiByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvZXMgbm90IHZhbGlkYXRlIGlmIHRoZSBwb2ludCBpcyBvbi1jdXJ2ZS5cbiAgICAgICAgLy8gVXNlIGZyb21IZXggaW5zdGVhZCwgb3IgY2FsbCBhc3NlcnRWYWxpZGl0eSgpIGxhdGVyLlxuICAgICAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAgfHwge307XG4gICAgICAgICAgICBpZiAoIXAgfHwgIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFmZmluZSBwb2ludCcpO1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2plY3RpdmUgcG9pbnQgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IChpKSA9PiBGcC5lcWwoaSwgRnAuWkVSTyk7XG4gICAgICAgICAgICAvLyBmcm9tQWZmaW5lKHg6MCwgeTowKSB3b3VsZCBwcm9kdWNlICh4OjAsIHk6MCwgejoxKSwgYnV0IHdlIG5lZWQgKHg6MCwgeToxLCB6OjApXG4gICAgICAgICAgICBpZiAoaXMwKHgpICYmIGlzMCh5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgRnAuT05FKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYSBidW5jaCBvZiBQcm9qZWN0aXZlIFBvaW50cyBidXQgZXhlY3V0ZXMgb25seSBvbmVcbiAgICAgICAgICogaW52ZXJzaW9uIG9uIGFsbCBvZiB0aGVtLiBJbnZlcnNpb24gaXMgdmVyeSBzbG93IG9wZXJhdGlvbixcbiAgICAgICAgICogc28gdGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBtYXNzaXZlbHkuXG4gICAgICAgICAqIE9wdGltaXphdGlvbjogY29udmVydHMgYSBsaXN0IG9mIHByb2plY3RpdmUgcG9pbnRzIHRvIGEgbGlzdCBvZiBpZGVudGljYWwgcG9pbnRzIHdpdGggWj0xLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKHBvaW50cy5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBoYXNoIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFBvaW50LlxuICAgICAgICAgKiBAcGFyYW0gaGV4IHNob3J0L2xvbmcgRUNEU0EgaGV4XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKGZyb21CeXRlcygoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ3BvaW50SGV4JywgaGV4KSkpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlwbGllcyBnZW5lcmF0b3IgcG9pbnQgYnkgcHJpdmF0ZUtleS5cbiAgICAgICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5CQVNFLm11bHRpcGx5KG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiUHJpdmF0ZSBtZXRob2RcIiwgZG9uJ3QgdXNlIGl0IGRpcmVjdGx5XG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX1dJTkRPV19TSVpFID0gd2luZG93U2l6ZTtcbiAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuZGVsZXRlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEEgcG9pbnQgb24gY3VydmUgaXMgdmFsaWQgaWYgaXQgY29uZm9ybXMgdG8gZXF1YXRpb24uXG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXMwKCkpIHtcbiAgICAgICAgICAgICAgICAvLyAoMCwgMSwgMCkgYWthIFpFUk8gaXMgaW52YWxpZCBpbiBtb3N0IGNvbnRleHRzLlxuICAgICAgICAgICAgICAgIC8vIEluIEJMUywgWkVSTyBjYW4gYmUgc2VyaWFsaXplZCwgc28gd2UgYWxsb3cgaXQuXG4gICAgICAgICAgICAgICAgLy8gKDAsIDAsIDApIGlzIHdyb25nIHJlcHJlc2VudGF0aW9uIG9mIFpFUk8gYW5kIGlzIGFsd2F5cyBpbnZhbGlkLlxuICAgICAgICAgICAgICAgIGlmIChDVVJWRS5hbGxvd0luZmluaXR5UG9pbnQgJiYgIUZwLmlzMCh0aGlzLnB5KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBaRVJPJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb21lIDNyZC1wYXJ0eSB0ZXN0IHZlY3RvcnMgcmVxdWlyZSBkaWZmZXJlbnQgd29yZGluZyBiZXR3ZWVuIGhlcmUgJiBgZnJvbUNvbXByZXNzZWRIZXhgXG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHgsIHkgYXJlIHZhbGlkIGZpZWxkIGVsZW1lbnRzXG4gICAgICAgICAgICBpZiAoIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IHggb3IgeSBub3QgRkUnKTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBGcC5zcXIoeSk7IC8vIHnCslxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB4wrMgKyBheCArIGJcbiAgICAgICAgICAgIGlmICghRnAuZXFsKGxlZnQsIHJpZ2h0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVG9yc2lvbkZyZWUoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogbm90IGluIHByaW1lLW9yZGVyIHN1Ymdyb3VwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaGFzRXZlblkoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGlmIChGcC5pc09kZClcbiAgICAgICAgICAgICAgICByZXR1cm4gIUZwLmlzT2RkKHkpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBzdXBwb3J0IGlzT2RkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgY29uc3QgVTEgPSBGcC5lcWwoRnAubXVsKFgxLCBaMiksIEZwLm11bChYMiwgWjEpKTtcbiAgICAgICAgICAgIGNvbnN0IFUyID0gRnAuZXFsKEZwLm11bChZMSwgWjIpLCBGcC5tdWwoWTIsIFoxKSk7XG4gICAgICAgICAgICByZXR1cm4gVTEgJiYgVTI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsaXBzIHBvaW50IHRvIG9uZSBjb3JyZXNwb25kaW5nIHRvICh4LCAteSkgaW4gQWZmaW5lIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgbmVnYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnB4LCBGcC5uZWcodGhpcy5weSksIHRoaXMucHopO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBkb3VibGluZyBmb3JtdWxhLlxuICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDNcbiAgICAgICAgLy8gQ29zdDogOE0gKyAzUyArIDMqYSArIDIqYjMgKyAxNWFkZC5cbiAgICAgICAgZG91YmxlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKGIsIF8zbik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgxKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkxKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAubXVsKFgxLCBZMSk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgdDMpOyAvLyBzdGVwIDVcbiAgICAgICAgICAgIFozID0gRnAubXVsKFgxLCBaMSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoYjMsIHQyKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFgzLCBZMyk7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZCh0MSwgWTMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFkzKTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChiMywgWjMpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MCwgdDIpO1xuICAgICAgICAgICAgdDMgPSBGcC5tdWwoYSwgdDMpO1xuICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjBcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKFozLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDAsIHQzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChZMSwgWjEpOyAvLyBzdGVwIDI1XG4gICAgICAgICAgICB0MiA9IEZwLmFkZCh0MiwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDIsIHQzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bCh0MiwgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGFkZGl0aW9uIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gMVxuICAgICAgICAvLyBDb3N0OiAxMk0gKyAwUyArIDMqYSArIDMqYjMgKyAyM2FkZC5cbiAgICAgICAgYWRkKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgYSA9IENVUlZFLmE7XG4gICAgICAgICAgICBjb25zdCBiMyA9IEZwLm11bChDVVJWRS5iLCBfM24pO1xuICAgICAgICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMik7IC8vIHN0ZXAgMVxuICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMik7XG4gICAgICAgICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoyKTtcbiAgICAgICAgICAgIGxldCB0MyA9IEZwLmFkZChYMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQ0ID0gRnAuYWRkKFgyLCBZMik7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgdDMgPSBGcC5tdWwodDMsIHQ0KTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQwLCB0MSk7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQoWDEsIFoxKTtcbiAgICAgICAgICAgIGxldCB0NSA9IEZwLmFkZChYMiwgWjIpOyAvLyBzdGVwIDEwXG4gICAgICAgICAgICB0NCA9IEZwLm11bCh0NCwgdDUpO1xuICAgICAgICAgICAgdDUgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuc3ViKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZChZMSwgWjEpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQoWTIsIFoyKTsgLy8gc3RlcCAxNVxuICAgICAgICAgICAgdDUgPSBGcC5tdWwodDUsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICAgICAgICB0NSA9IEZwLnN1Yih0NSwgWDMpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwoYSwgdDQpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYjMsIHQyKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWDMsIFozKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFozKTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLm11bChiMywgdDQpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQyID0gRnAuc3ViKHQwLCB0Mik7IC8vIHN0ZXAgMzBcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQ0LCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MSwgdDQpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQ1LCB0NCk7IC8vIHN0ZXAgMzVcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDMsIHQxKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQ1LCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgdDApOyAvLyBzdGVwIDQwXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlzMCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhQb2ludC5aRVJPKTtcbiAgICAgICAgfVxuICAgICAgICB3TkFGKG4pIHtcbiAgICAgICAgICAgIHJldHVybiB3bmFmLndOQUZDYWNoZWQodGhpcywgcG9pbnRQcmVjb21wdXRlcywgbiwgKGNvbXApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKGNvbXAubWFwKChwKSA9PiBwLnB6KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXAubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vbi1jb25zdGFudC10aW1lIG11bHRpcGxpY2F0aW9uLiBVc2VzIGRvdWJsZS1hbmQtYWRkIGFsZ29yaXRobS5cbiAgICAgICAgICogSXQncyBmYXN0ZXIsIGJ1dCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4geW91IGRvbid0IGNhcmUgYWJvdXRcbiAgICAgICAgICogYW4gZXhwb3NlZCBwcml2YXRlIGtleSBlLmcuIHNpZyB2ZXJpZmljYXRpb24sIHdoaWNoIHdvcmtzIG92ZXIgKnB1YmxpYyoga2V5cy5cbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5VW5zYWZlKG4pIHtcbiAgICAgICAgICAgIGNvbnN0IEkgPSBQb2ludC5aRVJPO1xuICAgICAgICAgICAgaWYgKG4gPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm4gSTtcbiAgICAgICAgICAgIGFzc2VydEdFKG4pOyAvLyBXaWxsIHRocm93IG9uIDBcbiAgICAgICAgICAgIGlmIChuID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IGVuZG8gfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKCFlbmRvKVxuICAgICAgICAgICAgICAgIHJldHVybiB3bmFmLnVuc2FmZUxhZGRlcih0aGlzLCBuKTtcbiAgICAgICAgICAgIC8vIEFwcGx5IGVuZG9tb3JwaGlzbVxuICAgICAgICAgICAgbGV0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICBsZXQgazFwID0gSTtcbiAgICAgICAgICAgIGxldCBrMnAgPSBJO1xuICAgICAgICAgICAgbGV0IGQgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKGsxID4gXzBuIHx8IGsyID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGsxICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMXAgPSBrMXAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGlmIChrMiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgazJwID0gazJwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBrMSA+Pj0gXzFuO1xuICAgICAgICAgICAgICAgIGsyID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazFwID0gazFwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsycCA9IGsycC5uZWdhdGUoKTtcbiAgICAgICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XG4gICAgICAgICAgICByZXR1cm4gazFwLmFkZChrMnApO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdGFudCB0aW1lIG11bHRpcGxpY2F0aW9uLlxuICAgICAgICAgKiBVc2VzIHdOQUYgbWV0aG9kLiBXaW5kb3dlZCBtZXRob2QgbWF5IGJlIDEwJSBmYXN0ZXIsXG4gICAgICAgICAqIGJ1dCB0YWtlcyAyeCBsb25nZXIgdG8gZ2VuZXJhdGUgYW5kIGNvbnN1bWVzIDJ4IG1lbW9yeS5cbiAgICAgICAgICogVXNlcyBwcmVjb21wdXRlcyB3aGVuIGF2YWlsYWJsZS5cbiAgICAgICAgICogVXNlcyBlbmRvbW9ycGhpc20gZm9yIEtvYmxpdHogY3VydmVzLlxuICAgICAgICAgKiBAcGFyYW0gc2NhbGFyIGJ5IHdoaWNoIHRoZSBwb2ludCB3b3VsZCBiZSBtdWx0aXBsaWVkXG4gICAgICAgICAqIEByZXR1cm5zIE5ldyBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgICAgICBhc3NlcnRHRShzY2FsYXIpO1xuICAgICAgICAgICAgbGV0IG4gPSBzY2FsYXI7XG4gICAgICAgICAgICBsZXQgcG9pbnQsIGZha2U7IC8vIEZha2UgcG9pbnQgaXMgdXNlZCB0byBjb25zdC10aW1lIG11bHRcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoZW5kbykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazFwLCBmOiBmMXAgfSA9IHRoaXMud05BRihrMSk7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazJwLCBmOiBmMnAgfSA9IHRoaXMud05BRihrMik7XG4gICAgICAgICAgICAgICAgazFwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazFuZWcsIGsxcCk7XG4gICAgICAgICAgICAgICAgazJwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazJuZWcsIGsycCk7XG4gICAgICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IGsxcC5hZGQoazJwKTtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjFwLmFkZChmMnApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB0aGlzLndOQUYobik7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBwO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIGB6YCBmb3IgYm90aCBwb2ludHMsIGJ1dCByZXR1cm4gb25seSByZWFsIG9uZVxuICAgICAgICAgICAgcmV0dXJuIFBvaW50Lm5vcm1hbGl6ZVooW3BvaW50LCBmYWtlXSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVmZmljaWVudGx5IGNhbGN1bGF0ZSBgYVAgKyBiUWAuIFVuc2FmZSwgY2FuIGV4cG9zZSBwcml2YXRlIGtleSwgaWYgdXNlZCBpbmNvcnJlY3RseS5cbiAgICAgICAgICogTm90IHVzaW5nIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiBwcmVjb21wdXRhdGlvbiB0YWJsZXMgYXJlIGZhc3Rlci5cbiAgICAgICAgICogVGhlIHRyaWNrIGNvdWxkIGJlIHVzZWZ1bCBpZiBib3RoIFAgYW5kIFEgYXJlIG5vdCBHIChub3QgaW4gb3VyIGNhc2UpLlxuICAgICAgICAgKiBAcmV0dXJucyBub24temVybyBhZmZpbmUgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpIHtcbiAgICAgICAgICAgIGNvbnN0IEcgPSBQb2ludC5CQVNFOyAvLyBObyBTdHJhdXNzLVNoYW1pciB0cmljazogd2UgaGF2ZSAxMCUgZmFzdGVyIEcgcHJlY29tcHV0ZXNcbiAgICAgICAgICAgIGNvbnN0IG11bCA9IChQLCBhIC8vIFNlbGVjdCBmYXN0ZXIgbXVsdGlwbHkoKSBtZXRob2RcbiAgICAgICAgICAgICkgPT4gKGEgPT09IF8wbiB8fCBhID09PSBfMW4gfHwgIVAuZXF1YWxzKEcpID8gUC5tdWx0aXBseVVuc2FmZShhKSA6IFAubXVsdGlwbHkoYSkpO1xuICAgICAgICAgICAgY29uc3Qgc3VtID0gbXVsKHRoaXMsIGEpLmFkZChtdWwoUSwgYikpO1xuICAgICAgICAgICAgcmV0dXJuIHN1bS5pczAoKSA/IHVuZGVmaW5lZCA6IHN1bTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0cyBQcm9qZWN0aXZlIHBvaW50IHRvIGFmZmluZSAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgICAgIC8vIENhbiBhY2NlcHQgcHJlY29tcHV0ZWQgWl4tMSAtIGZvciBleGFtcGxlLCBmcm9tIGludmVydEJhdGNoLlxuICAgICAgICAvLyAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICAgIHRvQWZmaW5lKGl6KSB7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiB4LCBweTogeSwgcHo6IHogfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBpczAgPSB0aGlzLmlzMCgpO1xuICAgICAgICAgICAgLy8gSWYgaW52WiB3YXMgMCwgd2UgcmV0dXJuIHplcm8gcG9pbnQuIEhvd2V2ZXIgd2Ugc3RpbGwgd2FudCB0byBleGVjdXRlXG4gICAgICAgICAgICAvLyBhbGwgb3BlcmF0aW9ucywgc28gd2UgcmVwbGFjZSBpbnZaIHdpdGggYSByYW5kb20gbnVtYmVyLCAxLlxuICAgICAgICAgICAgaWYgKGl6ID09IG51bGwpXG4gICAgICAgICAgICAgICAgaXogPSBpczAgPyBGcC5PTkUgOiBGcC5pbnYoeik7XG4gICAgICAgICAgICBjb25zdCBheCA9IEZwLm11bCh4LCBpeik7XG4gICAgICAgICAgICBjb25zdCBheSA9IEZwLm11bCh5LCBpeik7XG4gICAgICAgICAgICBjb25zdCB6eiA9IEZwLm11bCh6LCBpeik7XG4gICAgICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IEZwLlpFUk8sIHk6IEZwLlpFUk8gfTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKHp6LCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogYXgsIHk6IGF5IH07XG4gICAgICAgIH1cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGlzVG9yc2lvbkZyZWUgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIE5vIHN1Ymdyb3VwcywgYWx3YXlzIHRvcnNpb24tZnJlZVxuICAgICAgICAgICAgaWYgKGlzVG9yc2lvbkZyZWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVG9yc2lvbkZyZWUoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpc1RvcnNpb25GcmVlKCkgaGFzIG5vdCBiZWVuIGRlY2xhcmVkIGZvciB0aGUgZWxsaXB0aWMgY3VydmUnKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgY2xlYXJDb2ZhY3RvciB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gRmFzdC1wYXRoXG4gICAgICAgICAgICBpZiAoY2xlYXJDb2ZhY3RvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xlYXJDb2ZhY3RvcihQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShDVVJWRS5oKTtcbiAgICAgICAgfVxuICAgICAgICB0b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiB0b0J5dGVzKFBvaW50LCB0aGlzLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRvSGV4KGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5ieXRlc1RvSGV4KHRoaXMudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgRnAuT05FKTtcbiAgICBQb2ludC5aRVJPID0gbmV3IFBvaW50KEZwLlpFUk8sIEZwLk9ORSwgRnAuWkVSTyk7XG4gICAgY29uc3QgX2JpdHMgPSBDVVJWRS5uQml0TGVuZ3RoO1xuICAgIGNvbnN0IHduYWYgPSAoMCwgY3VydmVfanNfMS53TkFGKShQb2ludCwgQ1VSVkUuZW5kbyA/IE1hdGguY2VpbChfYml0cyAvIDIpIDogX2JpdHMpO1xuICAgIC8vIFZhbGlkYXRlIGlmIGdlbmVyYXRvciBwb2ludCBpcyBvbiBjdXJ2ZVxuICAgIHJldHVybiB7XG4gICAgICAgIENVUlZFLFxuICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICB3ZWllcnN0cmFzc0VxdWF0aW9uLFxuICAgICAgICBpc1dpdGhpbkN1cnZlT3JkZXIsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSAoMCwgY3VydmVfanNfMS52YWxpZGF0ZUJhc2ljKShjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgICAgIGhtYWM6ICdmdW5jdGlvbicsXG4gICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0sIHtcbiAgICAgICAgYml0czJpbnQ6ICdmdW5jdGlvbicsXG4gICAgICAgIGJpdHMyaW50X21vZE46ICdmdW5jdGlvbicsXG4gICAgICAgIGxvd1M6ICdib29sZWFuJyxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGxvd1M6IHRydWUsIC4uLm9wdHMgfSk7XG59XG5mdW5jdGlvbiB3ZWllcnN0cmFzcyhjdXJ2ZURlZikge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVPcHRzKGN1cnZlRGVmKTtcbiAgICBjb25zdCB7IEZwLCBuOiBDVVJWRV9PUkRFUiB9ID0gQ1VSVkU7XG4gICAgY29uc3QgY29tcHJlc3NlZExlbiA9IEZwLkJZVEVTICsgMTsgLy8gZS5nLiAzMyBmb3IgMzJcbiAgICBjb25zdCB1bmNvbXByZXNzZWRMZW4gPSAyICogRnAuQllURVMgKyAxOyAvLyBlLmcuIDY1IGZvciAzMlxuICAgIGZ1bmN0aW9uIGlzVmFsaWRGaWVsZEVsZW1lbnQobnVtKSB7XG4gICAgICAgIHJldHVybiBfMG4gPCBudW0gJiYgbnVtIDwgRnAuT1JERVI7IC8vIDAgaXMgYmFubmVkIHNpbmNlIGl0J3Mgbm90IGludmVydGlibGUgRkVcbiAgICB9XG4gICAgZnVuY3Rpb24gbW9kTihhKSB7XG4gICAgICAgIHJldHVybiBtb2QubW9kKGEsIENVUlZFX09SREVSKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW52TihhKSB7XG4gICAgICAgIHJldHVybiBtb2QuaW52ZXJ0KGEsIENVUlZFX09SREVSKTtcbiAgICB9XG4gICAgY29uc3QgeyBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LCBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLCB3ZWllcnN0cmFzc0VxdWF0aW9uLCBpc1dpdGhpbkN1cnZlT3JkZXIsIH0gPSB3ZWllcnN0cmFzc1BvaW50cyh7XG4gICAgICAgIC4uLkNVUlZFLFxuICAgICAgICB0b0J5dGVzKF9jLCBwb2ludCwgaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC50b0J5dGVzKGEueCk7XG4gICAgICAgICAgICBjb25zdCBjYXQgPSB1dC5jb25jYXRCeXRlcztcbiAgICAgICAgICAgIGlmIChpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbcG9pbnQuaGFzRXZlblkoKSA/IDB4MDIgOiAweDAzXSksIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgeCwgRnAudG9CeXRlcyhhLnkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnJvbUJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICAgICAgICAvLyB0aGlzLmFzc2VydFZhbGlkaXR5KCkgaXMgZG9uZSBpbnNpZGUgb2YgZnJvbUhleFxuICAgICAgICAgICAgaWYgKGxlbiA9PT0gY29tcHJlc3NlZExlbiAmJiAoaGVhZCA9PT0gMHgwMiB8fCBoZWFkID09PSAweDAzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSB1dC5ieXRlc1RvTnVtYmVyQkUodGFpbCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkRmllbGRFbGVtZW50KHgpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGlzIG5vdCBvbiBjdXJ2ZScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkyID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8gecKyID0geMKzICsgYXggKyBiXG4gICAgICAgICAgICAgICAgbGV0IHk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwLnNxcnQoeTIpOyAvLyB5ID0gecKyIF4gKHArMSkvNFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoc3FydEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1ZmZpeCA9IHNxcnRFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gJzogJyArIHNxcnRFcnJvci5tZXNzYWdlIDogJyc7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQgaXMgbm90IG9uIGN1cnZlJyArIHN1ZmZpeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzWU9kZCA9ICh5ICYgXzFuKSA9PT0gXzFuO1xuICAgICAgICAgICAgICAgIC8vIEVDRFNBXG4gICAgICAgICAgICAgICAgY29uc3QgaXNIZWFkT2RkID0gKGhlYWQgJiAxKSA9PT0gMTtcbiAgICAgICAgICAgICAgICBpZiAoaXNIZWFkT2RkICE9PSBpc1lPZGQpXG4gICAgICAgICAgICAgICAgICAgIHkgPSBGcC5uZWcoeSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGVuID09PSB1bmNvbXByZXNzZWRMZW4gJiYgaGVhZCA9PT0gMHgwNCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheShGcC5CWVRFUywgMiAqIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb2ludCBvZiBsZW5ndGggJHtsZW59IHdhcyBpbnZhbGlkLiBFeHBlY3RlZCAke2NvbXByZXNzZWRMZW59IGNvbXByZXNzZWQgYnl0ZXMgb3IgJHt1bmNvbXByZXNzZWRMZW59IHVuY29tcHJlc3NlZCBieXRlc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IG51bVRvTkJ5dGVTdHIgPSAobnVtKSA9PiB1dC5ieXRlc1RvSGV4KHV0Lm51bWJlclRvQnl0ZXNCRShudW0sIENVUlZFLm5CeXRlTGVuZ3RoKSk7XG4gICAgZnVuY3Rpb24gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKG51bWJlcikge1xuICAgICAgICBjb25zdCBIQUxGID0gQ1VSVkVfT1JERVIgPj4gXzFuO1xuICAgICAgICByZXR1cm4gbnVtYmVyID4gSEFMRjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplUyhzKSB7XG4gICAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIocykgPyBtb2ROKC1zKSA6IHM7XG4gICAgfVxuICAgIC8vIHNsaWNlIGJ5dGVzIG51bVxuICAgIGNvbnN0IHNsY051bSA9IChiLCBmcm9tLCB0bykgPT4gdXQuYnl0ZXNUb051bWJlckJFKGIuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICAvKipcbiAgICAgKiBFQ0RTQSBzaWduYXR1cmUgd2l0aCBpdHMgKHIsIHMpIHByb3BlcnRpZXMuIFN1cHBvcnRzIERFUiAmIGNvbXBhY3QgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuICAgIGNsYXNzIFNpZ25hdHVyZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHIsIHMsIHJlY292ZXJ5KSB7XG4gICAgICAgICAgICB0aGlzLnIgPSByO1xuICAgICAgICAgICAgdGhpcy5zID0gcztcbiAgICAgICAgICAgIHRoaXMucmVjb3ZlcnkgPSByZWNvdmVyeTtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYWlyIChieXRlcyBvZiByLCBieXRlcyBvZiBzKVxuICAgICAgICBzdGF0aWMgZnJvbUNvbXBhY3QoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCBsID0gQ1VSVkUubkJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBoZXggPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ2NvbXBhY3RTaWduYXR1cmUnLCBoZXgsIGwgKiAyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHNsY051bShoZXgsIDAsIGwpLCBzbGNOdW0oaGV4LCBsLCAyICogbCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERFUiBlbmNvZGVkIEVDRFNBIHNpZ25hdHVyZVxuICAgICAgICAvLyBodHRwczovL2JpdGNvaW4uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzU3NjQ0L3doYXQtYXJlLXRoZS1wYXJ0cy1vZi1hLWJpdGNvaW4tdHJhbnNhY3Rpb24taW5wdXQtc2NyaXB0XG4gICAgICAgIHN0YXRpYyBmcm9tREVSKGhleCkge1xuICAgICAgICAgICAgY29uc3QgeyByLCBzIH0gPSBleHBvcnRzLkRFUi50b1NpZygoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ0RFUicsIGhleCkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICAvLyBjYW4gdXNlIGFzc2VydEdFIGhlcmVcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKHRoaXMucikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyIG11c3QgYmUgMCA8IHIgPCBDVVJWRS5uJyk7XG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcih0aGlzLnMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncyBtdXN0IGJlIDAgPCBzIDwgQ1VSVkUubicpO1xuICAgICAgICB9XG4gICAgICAgIGFkZFJlY292ZXJ5Qml0KHJlY292ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIHRoaXMucywgcmVjb3ZlcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJlY292ZXJQdWJsaWNLZXkobXNnSGFzaCkge1xuICAgICAgICAgICAgY29uc3QgeyByLCBzLCByZWNvdmVyeTogcmVjIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4oKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdtc2dIYXNoJywgbXNnSGFzaCkpOyAvLyBUcnVuY2F0ZSBoYXNoXG4gICAgICAgICAgICBpZiAocmVjID09IG51bGwgfHwgIVswLCAxLCAyLCAzXS5pbmNsdWRlcyhyZWMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcmFkaiA9IHJlYyA9PT0gMiB8fCByZWMgPT09IDMgPyByICsgQ1VSVkUubiA6IHI7XG4gICAgICAgICAgICBpZiAocmFkaiA+PSBGcC5PUkRFUilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIDIgb3IgMyBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXggPSAocmVjICYgMSkgPT09IDAgPyAnMDInIDogJzAzJztcbiAgICAgICAgICAgIGNvbnN0IFIgPSBQb2ludC5mcm9tSGV4KHByZWZpeCArIG51bVRvTkJ5dGVTdHIocmFkaikpO1xuICAgICAgICAgICAgY29uc3QgaXIgPSBpbnZOKHJhZGopOyAvLyByXi0xXG4gICAgICAgICAgICBjb25zdCB1MSA9IG1vZE4oLWggKiBpcik7IC8vIC1ocl4tMVxuICAgICAgICAgICAgY29uc3QgdTIgPSBtb2ROKHMgKiBpcik7IC8vIHNyXi0xXG4gICAgICAgICAgICBjb25zdCBRID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShSLCB1MSwgdTIpOyAvLyAoc3JeLTEpUi0oaHJeLTEpRyA9IC0oaHJeLTEpRyArIChzcl4tMSlcbiAgICAgICAgICAgIGlmICghUSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IGF0IGluZmluaWZ5Jyk7IC8vIHVuc2FmZSBpcyBmaW5lOiBubyBwcml2IGRhdGEgbGVha2VkXG4gICAgICAgICAgICBRLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaWduYXR1cmVzIHNob3VsZCBiZSBsb3ctcywgdG8gcHJldmVudCBtYWxsZWFiaWxpdHkuXG4gICAgICAgIGhhc0hpZ2hTKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgICAgIG5vcm1hbGl6ZVMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNIaWdoUygpID8gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIG1vZE4oLXRoaXMucyksIHRoaXMucmVjb3ZlcnkpIDogdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBERVItZW5jb2RlZFxuICAgICAgICB0b0RFUlJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0RFUkhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0RFUkhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkRFUi5oZXhGcm9tU2lnKHsgcjogdGhpcy5yLCBzOiB0aGlzLnMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFkZGVkIGJ5dGVzIG9mIHIsIHRoZW4gcGFkZGVkIGJ5dGVzIG9mIHNcbiAgICAgICAgdG9Db21wYWN0UmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdXQuaGV4VG9CeXRlcyh0aGlzLnRvQ29tcGFjdEhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0NvbXBhY3RIZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtVG9OQnl0ZVN0cih0aGlzLnIpICsgbnVtVG9OQnl0ZVN0cih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHV0aWxzID0ge1xuICAgICAgICBpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXI6IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlcyBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcHJpdmF0ZSBrZXkgZnJvbSByYW5kb20gb2Ygc2l6ZVxuICAgICAgICAgKiAoZ3JvdXBMZW4gKyBjZWlsKGdyb3VwTGVuIC8gMikpIHdpdGggbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlnaWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IG1vZC5nZXRNaW5IYXNoTGVuZ3RoKENVUlZFLm4pO1xuICAgICAgICAgICAgcmV0dXJuIG1vZC5tYXBIYXNoVG9GaWVsZChDVVJWRS5yYW5kb21CeXRlcyhsZW5ndGgpLCBDVVJWRS5uKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgcHJlY29tcHV0ZSB0YWJsZSBmb3IgYW4gYXJiaXRyYXJ5IEVDIHBvaW50LiBNYWtlcyBwb2ludCBcImNhY2hlZFwiLlxuICAgICAgICAgKiBBbGxvd3MgdG8gbWFzc2l2ZWx5IHNwZWVkLXVwIGBwb2ludC5tdWx0aXBseShzY2FsYXIpYC5cbiAgICAgICAgICogQHJldHVybnMgY2FjaGVkIHBvaW50XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGNvbnN0IGZhc3QgPSB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5mcm9tSGV4KHNvbWVvbmVzUHViS2V5KSk7XG4gICAgICAgICAqIGZhc3QubXVsdGlwbHkocHJpdktleSk7IC8vIG11Y2ggZmFzdGVyIEVDREggbm93XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBwb2ludCA9IFBvaW50LkJBU0UpIHtcbiAgICAgICAgICAgIHBvaW50Ll9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpO1xuICAgICAgICAgICAgcG9pbnQubXVsdGlwbHkoQmlnSW50KDMpKTsgLy8gMyBpcyBhcmJpdHJhcnksIGp1c3QgbmVlZCBhbnkgbnVtYmVyIGhlcmVcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXkuIENoZWNrcyBmb3IgdmFsaWRpdHkgb2YgdGhlIHByaXZhdGUga2V5LlxuICAgICAqIEBwYXJhbSBwcml2YXRlS2V5IHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBQdWJsaWMga2V5LCBmdWxsIHdoZW4gaXNDb21wcmVzc2VkPWZhbHNlOyBzaG9ydCB3aGVuIGlzQ29tcHJlc3NlZD10cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZhdGVLZXksIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LmZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVpY2sgYW5kIGRpcnR5IGNoZWNrIGZvciBpdGVtIGJlaW5nIHB1YmxpYyBrZXkuIERvZXMgbm90IHZhbGlkYXRlIGhleCwgb3IgYmVpbmcgb24tY3VydmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcm9iUHViKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgYXJyID0gdXQuaXNCeXRlcyhpdGVtKTtcbiAgICAgICAgY29uc3Qgc3RyID0gdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnO1xuICAgICAgICBjb25zdCBsZW4gPSAoYXJyIHx8IHN0cikgJiYgaXRlbS5sZW5ndGg7XG4gICAgICAgIGlmIChhcnIpXG4gICAgICAgICAgICByZXR1cm4gbGVuID09PSBjb21wcmVzc2VkTGVuIHx8IGxlbiA9PT0gdW5jb21wcmVzc2VkTGVuO1xuICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gMiAqIGNvbXByZXNzZWRMZW4gfHwgbGVuID09PSAyICogdW5jb21wcmVzc2VkTGVuO1xuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFBvaW50KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRUNESCAoRWxsaXB0aWMgQ3VydmUgRGlmZmllIEhlbGxtYW4pLlxuICAgICAqIENvbXB1dGVzIHNoYXJlZCBwdWJsaWMga2V5IGZyb20gcHJpdmF0ZSBrZXkgYW5kIHB1YmxpYyBrZXkuXG4gICAgICogQ2hlY2tzOiAxKSBwcml2YXRlIGtleSB2YWxpZGl0eSAyKSBzaGFyZWQga2V5IGlzIG9uLWN1cnZlLlxuICAgICAqIERvZXMgTk9UIGhhc2ggdGhlIHJlc3VsdC5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUEgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gcHVibGljQiBkaWZmZXJlbnQgcHVibGljIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgc2hhcmVkIHB1YmxpYyBrZXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTaGFyZWRTZWNyZXQocHJpdmF0ZUEsIHB1YmxpY0IsIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgaWYgKGlzUHJvYlB1Yihwcml2YXRlQSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZyBtdXN0IGJlIHByaXZhdGUga2V5Jyk7XG4gICAgICAgIGlmICghaXNQcm9iUHViKHB1YmxpY0IpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZWNvbmQgYXJnIG11c3QgYmUgcHVibGljIGtleScpO1xuICAgICAgICBjb25zdCBiID0gUG9pbnQuZnJvbUhleChwdWJsaWNCKTsgLy8gY2hlY2sgZm9yIGJlaW5nIG9uLWN1cnZlXG4gICAgICAgIHJldHVybiBiLm11bHRpcGx5KG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUEpKS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8vIFJGQzY5Nzk6IGVuc3VyZSBFQ0RTQSBtc2cgaXMgWCBieXRlcyBhbmQgPCBOLiBSRkMgc3VnZ2VzdHMgb3B0aW9uYWwgdHJ1bmNhdGluZyB2aWEgYml0czJvY3RldHMuXG4gICAgLy8gRklQUyAxODYtNCA0LjYgc3VnZ2VzdHMgdGhlIGxlZnRtb3N0IG1pbihuQml0TGVuLCBvdXRMZW4pIGJpdHMsIHdoaWNoIG1hdGNoZXMgYml0czJpbnQuXG4gICAgLy8gYml0czJpbnQgY2FuIHByb2R1Y2UgcmVzPk4sIHdlIGNhbiBkbyBtb2QocmVzLCBOKSBzaW5jZSB0aGUgYml0TGVuIGlzIHRoZSBzYW1lLlxuICAgIC8vIGludDJvY3RldHMgY2FuJ3QgYmUgdXNlZDsgcGFkcyBzbWFsbCBtc2dzIHdpdGggMDogdW5hY2NlcHRhdGJsZSBmb3IgdHJ1bmMgYXMgcGVyIFJGQyB2ZWN0b3JzXG4gICAgY29uc3QgYml0czJpbnQgPSBDVVJWRS5iaXRzMmludCB8fFxuICAgICAgICBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIEZvciBjdXJ2ZXMgd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMDogYml0czJvY3RldHMoYml0czJvY3RldHMobSkpICE9PSBiaXRzMm9jdGV0cyhtKVxuICAgICAgICAgICAgLy8gZm9yIHNvbWUgY2FzZXMsIHNpbmNlIGJ5dGVzLmxlbmd0aCAqIDggaXMgbm90IGFjdHVhbCBiaXRMZW5ndGguXG4gICAgICAgICAgICBjb25zdCBudW0gPSB1dC5ieXRlc1RvTnVtYmVyQkUoYnl0ZXMpOyAvLyBjaGVjayBmb3IgPT0gdTggZG9uZSBoZXJlXG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGJ5dGVzLmxlbmd0aCAqIDggLSBDVVJWRS5uQml0TGVuZ3RoOyAvLyB0cnVuY2F0ZSB0byBuQml0TGVuZ3RoIGxlZnRtb3N0IGJpdHNcbiAgICAgICAgICAgIHJldHVybiBkZWx0YSA+IDAgPyBudW0gPj4gQmlnSW50KGRlbHRhKSA6IG51bTtcbiAgICAgICAgfTtcbiAgICBjb25zdCBiaXRzMmludF9tb2ROID0gQ1VSVkUuYml0czJpbnRfbW9kTiB8fFxuICAgICAgICBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2ROKGJpdHMyaW50KGJ5dGVzKSk7IC8vIGNhbid0IHVzZSBieXRlc1RvTnVtYmVyQkUgaGVyZVxuICAgICAgICB9O1xuICAgIC8vIE5PVEU6IHBhZHMgb3V0cHV0IHdpdGggemVybyBhcyBwZXIgc3BlY1xuICAgIGNvbnN0IE9SREVSX01BU0sgPSB1dC5iaXRNYXNrKENVUlZFLm5CaXRMZW5ndGgpO1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRvIGJ5dGVzLiBDaGVja3MgaWYgbnVtIGluIGBbMC4uT1JERVJfTUFTSy0xXWAgZS5nLjogYFswLi4yXjI1Ni0xXWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50Mm9jdGV0cyhudW0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBudW0gIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiaWdpbnQgZXhwZWN0ZWQnKTtcbiAgICAgICAgaWYgKCEoXzBuIDw9IG51bSAmJiBudW0gPCBPUkRFUl9NQVNLKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmlnaW50IGV4cGVjdGVkIDwgMl4ke0NVUlZFLm5CaXRMZW5ndGh9YCk7XG4gICAgICAgIC8vIHdvcmtzIHdpdGggb3JkZXIsIGNhbiBoYXZlIGRpZmZlcmVudCBzaXplIHRoYW4gbnVtVG9GaWVsZCFcbiAgICAgICAgcmV0dXJuIHV0Lm51bWJlclRvQnl0ZXNCRShudW0sIENVUlZFLm5CeXRlTGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gU3RlcHMgQSwgRCBvZiBSRkM2OTc5IDMuMlxuICAgIC8vIENyZWF0ZXMgUkZDNjk3OSBzZWVkOyBjb252ZXJ0cyBtc2cvcHJpdktleSB0byBudW1iZXJzLlxuICAgIC8vIFVzZWQgb25seSBpbiBzaWduLCBub3QgaW4gdmVyaWZ5LlxuICAgIC8vIE5PVEU6IHdlIGNhbm5vdCBhc3N1bWUgaGVyZSB0aGF0IG1zZ0hhc2ggaGFzIHNhbWUgYW1vdW50IG9mIGJ5dGVzIGFzIGN1cnZlIG9yZGVyLCB0aGlzIHdpbGwgYmUgd3JvbmcgYXQgbGVhc3QgZm9yIFA1MjEuXG4gICAgLy8gQWxzbyBpdCBjYW4gYmUgYmlnZ2VyIGZvciBQMjI0ICsgU0hBMjU2XG4gICAgZnVuY3Rpb24gcHJlcFNpZyhtc2dIYXNoLCBwcml2YXRlS2V5LCBvcHRzID0gZGVmYXVsdFNpZ09wdHMpIHtcbiAgICAgICAgaWYgKFsncmVjb3ZlcmVkJywgJ2Nhbm9uaWNhbCddLnNvbWUoKGspID0+IGsgaW4gb3B0cykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24oKSBsZWdhY3kgb3B0aW9ucyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIGNvbnN0IHsgaGFzaCwgcmFuZG9tQnl0ZXMgfSA9IENVUlZFO1xuICAgICAgICBsZXQgeyBsb3dTLCBwcmVoYXNoLCBleHRyYUVudHJvcHk6IGVudCB9ID0gb3B0czsgLy8gZ2VuZXJhdGVzIGxvdy1zIHNpZ3MgYnkgZGVmYXVsdFxuICAgICAgICBpZiAobG93UyA9PSBudWxsKVxuICAgICAgICAgICAgbG93UyA9IHRydWU7IC8vIFJGQzY5NzkgMy4yOiB3ZSBza2lwIHN0ZXAgQSwgYmVjYXVzZSB3ZSBhbHJlYWR5IHByb3ZpZGUgaGFzaFxuICAgICAgICBtc2dIYXNoID0gKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdtc2dIYXNoJywgbXNnSGFzaCk7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9ICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgncHJlaGFzaGVkIG1zZ0hhc2gnLCBoYXNoKG1zZ0hhc2gpKTtcbiAgICAgICAgLy8gV2UgY2FuJ3QgbGF0ZXIgY2FsbCBiaXRzMm9jdGV0cywgc2luY2UgbmVzdGVkIGJpdHMyaW50IGlzIGJyb2tlbiBmb3IgY3VydmVzXG4gICAgICAgIC8vIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDAuIEJlY2F1c2Ugb2YgdGhhdCwgd2UgdW53cmFwIGl0IGhlcmUgYXMgaW50Mm9jdGV0cyBjYWxsLlxuICAgICAgICAvLyBjb25zdCBiaXRzMm9jdGV0cyA9IChiaXRzKSA9PiBpbnQyb2N0ZXRzKGJpdHMyaW50X21vZE4oYml0cykpXG4gICAgICAgIGNvbnN0IGgxaW50ID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgZCA9IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7IC8vIHZhbGlkYXRlIHByaXZhdGUga2V5LCBjb252ZXJ0IHRvIGJpZ2ludFxuICAgICAgICBjb25zdCBzZWVkQXJncyA9IFtpbnQyb2N0ZXRzKGQpLCBpbnQyb2N0ZXRzKGgxaW50KV07XG4gICAgICAgIC8vIGV4dHJhRW50cm9weS4gUkZDNjk3OSAzLjY6IGFkZGl0aW9uYWwgaycgKG9wdGlvbmFsKS5cbiAgICAgICAgaWYgKGVudCAhPSBudWxsICYmIGVudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIEsgPSBITUFDX0soViB8fCAweDAwIHx8IGludDJvY3RldHMoeCkgfHwgYml0czJvY3RldHMoaDEpIHx8IGsnKVxuICAgICAgICAgICAgY29uc3QgZSA9IGVudCA9PT0gdHJ1ZSA/IHJhbmRvbUJ5dGVzKEZwLkJZVEVTKSA6IGVudDsgLy8gZ2VuZXJhdGUgcmFuZG9tIGJ5dGVzIE9SIHBhc3MgYXMtaXNcbiAgICAgICAgICAgIHNlZWRBcmdzLnB1c2goKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdleHRyYUVudHJvcHknLCBlKSk7IC8vIGNoZWNrIGZvciBiZWluZyBieXRlc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWQgPSB1dC5jb25jYXRCeXRlcyguLi5zZWVkQXJncyk7IC8vIFN0ZXAgRCBvZiBSRkM2OTc5IDMuMlxuICAgICAgICBjb25zdCBtID0gaDFpbnQ7IC8vIE5PVEU6IG5vIG5lZWQgdG8gY2FsbCBiaXRzMmludCBzZWNvbmQgdGltZSBoZXJlLCBpdCBpcyBpbnNpZGUgdHJ1bmNhdGVIYXNoIVxuICAgICAgICAvLyBDb252ZXJ0cyBzaWduYXR1cmUgcGFyYW1zIGludG8gcG9pbnQgdyByL3MsIGNoZWNrcyByZXN1bHQgZm9yIHZhbGlkaXR5LlxuICAgICAgICBmdW5jdGlvbiBrMnNpZyhrQnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIFJGQyA2OTc5IFNlY3Rpb24gMy4yLCBzdGVwIDM6IGsgPSBiaXRzMmludChUKVxuICAgICAgICAgICAgY29uc3QgayA9IGJpdHMyaW50KGtCeXRlcyk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKGspKVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gSW1wb3J0YW50OiBhbGwgbW9kKCkgY2FsbHMgaGVyZSBtdXN0IGJlIGRvbmUgb3ZlciBOXG4gICAgICAgICAgICBjb25zdCBpayA9IGludk4oayk7IC8vIGteLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IHEgPSBQb2ludC5CQVNFLm11bHRpcGx5KGspLnRvQWZmaW5lKCk7IC8vIHEgPSBHa1xuICAgICAgICAgICAgY29uc3QgciA9IG1vZE4ocS54KTsgLy8gciA9IHEueCBtb2QgblxuICAgICAgICAgICAgaWYgKHIgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBDYW4gdXNlIHNjYWxhciBibGluZGluZyBiXi0xKGJtICsgYmRyKSB3aGVyZSBiIOKIiCBbMSxx4oiSMV0gYWNjb3JkaW5nIHRvXG4gICAgICAgICAgICAvLyBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvNzMzNy82NTA5LiBXZSd2ZSBkZWNpZGVkIGFnYWluc3QgaXQ6XG4gICAgICAgICAgICAvLyBhKSBkZXBlbmRlbmN5IG9uIENTUFJORyBiKSAxNSUgc2xvd2Rvd24gYykgZG9lc24ndCByZWFsbHkgaGVscCBzaW5jZSBiaWdpbnRzIGFyZSBub3QgQ1RcbiAgICAgICAgICAgIGNvbnN0IHMgPSBtb2ROKGlrICogbW9kTihtICsgciAqIGQpKTsgLy8gTm90IHVzaW5nIGJsaW5kaW5nIGhlcmVcbiAgICAgICAgICAgIGlmIChzID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gciA/IDAgOiAyKSB8IE51bWJlcihxLnkgJiBfMW4pOyAvLyByZWNvdmVyeSBiaXQgKDIgb3IgMywgd2hlbiBxLnggPiBuKVxuICAgICAgICAgICAgbGV0IG5vcm1TID0gcztcbiAgICAgICAgICAgIGlmIChsb3dTICYmIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSkge1xuICAgICAgICAgICAgICAgIG5vcm1TID0gbm9ybWFsaXplUyhzKTsgLy8gaWYgbG93UyB3YXMgcGFzc2VkLCBlbnN1cmUgcyBpcyBhbHdheXNcbiAgICAgICAgICAgICAgICByZWNvdmVyeSBePSAxOyAvLyAvLyBpbiB0aGUgYm90dG9tIGhhbGYgb2YgTlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgbm9ybVMsIHJlY292ZXJ5KTsgLy8gdXNlIG5vcm1TLCBub3Qgc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNlZWQsIGsyc2lnIH07XG4gICAgfVxuICAgIGNvbnN0IGRlZmF1bHRTaWdPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIGNvbnN0IGRlZmF1bHRWZXJPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIC8qKlxuICAgICAqIFNpZ25zIG1lc3NhZ2UgaGFzaCB3aXRoIGEgcHJpdmF0ZSBrZXkuXG4gICAgICogYGBgXG4gICAgICogc2lnbihtLCBkLCBrKSB3aGVyZVxuICAgICAqICAgKHgsIHkpID0gRyDDlyBrXG4gICAgICogICByID0geCBtb2QgblxuICAgICAqICAgcyA9IChtICsgZHIpL2sgbW9kIG5cbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gbXNnSGFzaCBOT1QgbWVzc2FnZS4gbXNnIG5lZWRzIHRvIGJlIGhhc2hlZCB0byBgbXNnSGFzaGAsIG9yIHVzZSBgcHJlaGFzaGAuXG4gICAgICogQHBhcmFtIHByaXZLZXkgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gb3B0cyBsb3dTIGZvciBub24tbWFsbGVhYmxlIHNpZ3MuIGV4dHJhRW50cm9weSBmb3IgbWl4aW5nIHJhbmRvbW5lc3MgaW50byBrLiBwcmVoYXNoIHdpbGwgaGFzaCBmaXJzdCBhcmcuXG4gICAgICogQHJldHVybnMgc2lnbmF0dXJlIHdpdGggcmVjb3ZlcnkgcGFyYW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaWduKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBjb25zdCB7IHNlZWQsIGsyc2lnIH0gPSBwcmVwU2lnKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMpOyAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yLlxuICAgICAgICBjb25zdCBDID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IGRyYmcgPSB1dC5jcmVhdGVIbWFjRHJiZyhDLmhhc2gub3V0cHV0TGVuLCBDLm5CeXRlTGVuZ3RoLCBDLmhtYWMpO1xuICAgICAgICByZXR1cm4gZHJiZyhzZWVkLCBrMnNpZyk7IC8vIFN0ZXBzIEIsIEMsIEQsIEUsIEYsIEdcbiAgICB9XG4gICAgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICAgIFBvaW50LkJBU0UuX3NldFdpbmRvd1NpemUoOCk7XG4gICAgLy8gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuQkFTRSlcbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgaGFzaCBhbmQgcHVibGljIGtleS5cbiAgICAgKiBSZWplY3RzIGxvd1Mgc2lnbmF0dXJlcyBieSBkZWZhdWx0OiB0byBvdmVycmlkZSxcbiAgICAgKiBzcGVjaWZ5IG9wdGlvbiBge2xvd1M6IGZhbHNlfWAuIEltcGxlbWVudHMgc2VjdGlvbiA0LjEuNCBmcm9tIGh0dHBzOi8vd3d3LnNlY2cub3JnL3NlYzEtdjIucGRmOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogdmVyaWZ5KHIsIHMsIGgsIFApIHdoZXJlXG4gICAgICogICBVMSA9IGhzXi0xIG1vZCBuXG4gICAgICogICBVMiA9IHJzXi0xIG1vZCBuXG4gICAgICogICBSID0gVTHii4VHIC0gVTLii4VQXG4gICAgICogICBtb2QoUi54LCBuKSA9PSByXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHVibGljS2V5LCBvcHRzID0gZGVmYXVsdFZlck9wdHMpIHtcbiAgICAgICAgY29uc3Qgc2cgPSBzaWduYXR1cmU7XG4gICAgICAgIG1zZ0hhc2ggPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ21zZ0hhc2gnLCBtc2dIYXNoKTtcbiAgICAgICAgcHVibGljS2V5ID0gKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdwdWJsaWNLZXknLCBwdWJsaWNLZXkpO1xuICAgICAgICBpZiAoJ3N0cmljdCcgaW4gb3B0cylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5zdHJpY3Qgd2FzIHJlbmFtZWQgdG8gbG93UycpO1xuICAgICAgICBjb25zdCB7IGxvd1MsIHByZWhhc2ggfSA9IG9wdHM7XG4gICAgICAgIGxldCBfc2lnID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgUDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2cgPT09ICdzdHJpbmcnIHx8IHV0LmlzQnl0ZXMoc2cpKSB7XG4gICAgICAgICAgICAgICAgLy8gU2lnbmF0dXJlIGNhbiBiZSByZXByZXNlbnRlZCBpbiAyIHdheXM6IGNvbXBhY3QgKDIqbkJ5dGVMZW5ndGgpICYgREVSICh2YXJpYWJsZS1sZW5ndGgpLlxuICAgICAgICAgICAgICAgIC8vIFNpbmNlIERFUiBjYW4gYWxzbyBiZSAyKm5CeXRlTGVuZ3RoIGJ5dGVzLCB3ZSBjaGVjayBmb3IgaXQgZmlyc3QuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgX3NpZyA9IFNpZ25hdHVyZS5mcm9tREVSKHNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGRlckVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGRlckVycm9yIGluc3RhbmNlb2YgZXhwb3J0cy5ERVIuRXJyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRlckVycm9yO1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KHNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2cgPT09ICdvYmplY3QnICYmIHR5cGVvZiBzZy5yID09PSAnYmlnaW50JyAmJiB0eXBlb2Ygc2cucyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHNnO1xuICAgICAgICAgICAgICAgIF9zaWcgPSBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQQVJTRScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUCA9IFBvaW50LmZyb21IZXgocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlID09PSAnUEFSU0UnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2lnbmF0dXJlIG11c3QgYmUgU2lnbmF0dXJlIGluc3RhbmNlLCBVaW50OEFycmF5IG9yIGhleCBzdHJpbmdgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG93UyAmJiBfc2lnLmhhc0hpZ2hTKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IENVUlZFLmhhc2gobXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gX3NpZztcbiAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgY29uc3QgaXMgPSBpbnZOKHMpOyAvLyBzXi0xXG4gICAgICAgIGNvbnN0IHUxID0gbW9kTihoICogaXMpOyAvLyB1MSA9IGhzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IHUyID0gbW9kTihyICogaXMpOyAvLyB1MiA9IHJzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IFIgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFAsIHUxLCB1Mik/LnRvQWZmaW5lKCk7IC8vIFIgPSB1MeKLhUcgKyB1MuKLhVBcbiAgICAgICAgaWYgKCFSKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCB2ID0gbW9kTihSLngpO1xuICAgICAgICByZXR1cm4gdiA9PT0gcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIGdldFB1YmxpY0tleSxcbiAgICAgICAgZ2V0U2hhcmVkU2VjcmV0LFxuICAgICAgICBzaWduLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIFNpZ25hdHVyZSxcbiAgICAgICAgdXRpbHMsXG4gICAgfTtcbn1cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYWxsdWUgYW5kIHZhbiBkZSBXb2VzdGlqbmUgbWV0aG9kIGZvciBhbnkgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBUT0RPOiBjaGVjayBpZiB0aGVyZSBpcyBhIHdheSB0byBtZXJnZSB0aGlzIHdpdGggdXZSYXRpbyBpbiBFZHdhcmRzOyBtb3ZlIHRvIG1vZHVsYXIuXG4gKiBiID0gVHJ1ZSBhbmQgeSA9IHNxcnQodSAvIHYpIGlmICh1IC8gdikgaXMgc3F1YXJlIGluIEYsIGFuZFxuICogYiA9IEZhbHNlIGFuZCB5ID0gc3FydChaICogKHUgLyB2KSkgb3RoZXJ3aXNlLlxuICogQHBhcmFtIEZwXG4gKiBAcGFyYW0gWlxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gU1dVRnBTcXJ0UmF0aW8oRnAsIFopIHtcbiAgICAvLyBHZW5lcmljIGltcGxlbWVudGF0aW9uXG4gICAgY29uc3QgcSA9IEZwLk9SREVSO1xuICAgIGxldCBsID0gXzBuO1xuICAgIGZvciAobGV0IG8gPSBxIC0gXzFuOyBvICUgXzJuID09PSBfMG47IG8gLz0gXzJuKVxuICAgICAgICBsICs9IF8xbjtcbiAgICBjb25zdCBjMSA9IGw7IC8vIDEuIGMxLCB0aGUgbGFyZ2VzdCBpbnRlZ2VyIHN1Y2ggdGhhdCAyXmMxIGRpdmlkZXMgcSAtIDEuXG4gICAgLy8gV2UgbmVlZCAybiAqKiBjMSBhbmQgMm4gKiogKGMxLTEpLiBXZSBjYW4ndCB1c2UgKio7IGJ1dCB3ZSBjYW4gdXNlIDw8LlxuICAgIC8vIDJuICoqIGMxID09IDJuIDw8IChjMS0xKVxuICAgIGNvbnN0IF8ybl9wb3dfYzFfMSA9IF8ybiA8PCAoYzEgLSBfMW4gLSBfMW4pO1xuICAgIGNvbnN0IF8ybl9wb3dfYzEgPSBfMm5fcG93X2MxXzEgKiBfMm47XG4gICAgY29uc3QgYzIgPSAocSAtIF8xbikgLyBfMm5fcG93X2MxOyAvLyAyLiBjMiA9IChxIC0gMSkgLyAoMl5jMSkgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzMgPSAoYzIgLSBfMW4pIC8gXzJuOyAvLyAzLiBjMyA9IChjMiAtIDEpIC8gMiAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzQgPSBfMm5fcG93X2MxIC0gXzFuOyAvLyA0LiBjNCA9IDJeYzEgLSAxICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzUgPSBfMm5fcG93X2MxXzE7IC8vIDUuIGM1ID0gMl4oYzEgLSAxKSAgICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzYgPSBGcC5wb3coWiwgYzIpOyAvLyA2LiBjNiA9IFpeYzJcbiAgICBjb25zdCBjNyA9IEZwLnBvdyhaLCAoYzIgKyBfMW4pIC8gXzJuKTsgLy8gNy4gYzcgPSBaXigoYzIgKyAxKSAvIDIpXG4gICAgbGV0IHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgIGxldCB0djEgPSBjNjsgLy8gMS4gdHYxID0gYzZcbiAgICAgICAgbGV0IHR2MiA9IEZwLnBvdyh2LCBjNCk7IC8vIDIuIHR2MiA9IHZeYzRcbiAgICAgICAgbGV0IHR2MyA9IEZwLnNxcih0djIpOyAvLyAzLiB0djMgPSB0djJeMlxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCB2KTsgLy8gNC4gdHYzID0gdHYzICogdlxuICAgICAgICBsZXQgdHY1ID0gRnAubXVsKHUsIHR2Myk7IC8vIDUuIHR2NSA9IHUgKiB0djNcbiAgICAgICAgdHY1ID0gRnAucG93KHR2NSwgYzMpOyAvLyA2LiB0djUgPSB0djVeYzNcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NSwgdHYyKTsgLy8gNy4gdHY1ID0gdHY1ICogdHYyXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djUsIHYpOyAvLyA4LiB0djIgPSB0djUgKiB2XG4gICAgICAgIHR2MyA9IEZwLm11bCh0djUsIHUpOyAvLyA5LiB0djMgPSB0djUgKiB1XG4gICAgICAgIGxldCB0djQgPSBGcC5tdWwodHYzLCB0djIpOyAvLyAxMC4gdHY0ID0gdHYzICogdHYyXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djQsIGM1KTsgLy8gMTEuIHR2NSA9IHR2NF5jNVxuICAgICAgICBsZXQgaXNRUiA9IEZwLmVxbCh0djUsIEZwLk9ORSk7IC8vIDEyLiBpc1FSID0gdHY1ID09IDFcbiAgICAgICAgdHYyID0gRnAubXVsKHR2MywgYzcpOyAvLyAxMy4gdHYyID0gdHYzICogYzdcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMTQuIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICB0djMgPSBGcC5jbW92KHR2MiwgdHYzLCBpc1FSKTsgLy8gMTUuIHR2MyA9IENNT1YodHYyLCB0djMsIGlzUVIpXG4gICAgICAgIHR2NCA9IEZwLmNtb3YodHY1LCB0djQsIGlzUVIpOyAvLyAxNi4gdHY0ID0gQ01PVih0djUsIHR2NCwgaXNRUilcbiAgICAgICAgLy8gMTcuIGZvciBpIGluIChjMSwgYzEgLSAxLCAuLi4sIDIpOlxuICAgICAgICBmb3IgKGxldCBpID0gYzE7IGkgPiBfMW47IGktLSkge1xuICAgICAgICAgICAgbGV0IHR2NSA9IGkgLSBfMm47IC8vIDE4LiAgICB0djUgPSBpIC0gMlxuICAgICAgICAgICAgdHY1ID0gXzJuIDw8ICh0djUgLSBfMW4pOyAvLyAxOS4gICAgdHY1ID0gMl50djVcbiAgICAgICAgICAgIGxldCB0dnY1ID0gRnAucG93KHR2NCwgdHY1KTsgLy8gMjAuICAgIHR2NSA9IHR2NF50djVcbiAgICAgICAgICAgIGNvbnN0IGUxID0gRnAuZXFsKHR2djUsIEZwLk9ORSk7IC8vIDIxLiAgICBlMSA9IHR2NSA9PSAxXG4gICAgICAgICAgICB0djIgPSBGcC5tdWwodHYzLCB0djEpOyAvLyAyMi4gICAgdHYyID0gdHYzICogdHYxXG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djEpOyAvLyAyMy4gICAgdHYxID0gdHYxICogdHYxXG4gICAgICAgICAgICB0dnY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMjQuICAgIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgZTEpOyAvLyAyNS4gICAgdHYzID0gQ01PVih0djIsIHR2MywgZTEpXG4gICAgICAgICAgICB0djQgPSBGcC5jbW92KHR2djUsIHR2NCwgZTEpOyAvLyAyNi4gICAgdHY0ID0gQ01PVih0djUsIHR2NCwgZTEpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHR2MyB9O1xuICAgIH07XG4gICAgaWYgKEZwLk9SREVSICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgLy8gc3FydF9yYXRpb18zbW9kNCh1LCB2KVxuICAgICAgICBjb25zdCBjMSA9IChGcC5PUkRFUiAtIF8zbikgLyBfNG47IC8vIDEuIGMxID0gKHEgLSAzKSAvIDQgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgICAgIGNvbnN0IGMyID0gRnAuc3FydChGcC5uZWcoWikpOyAvLyAyLiBjMiA9IHNxcnQoLVopXG4gICAgICAgIHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgICAgICBsZXQgdHYxID0gRnAuc3FyKHYpOyAvLyAxLiB0djEgPSB2XjJcbiAgICAgICAgICAgIGNvbnN0IHR2MiA9IEZwLm11bCh1LCB2KTsgLy8gMi4gdHYyID0gdSAqIHZcbiAgICAgICAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2Mik7IC8vIDMuIHR2MSA9IHR2MSAqIHR2MlxuICAgICAgICAgICAgbGV0IHkxID0gRnAucG93KHR2MSwgYzEpOyAvLyA0LiB5MSA9IHR2MV5jMVxuICAgICAgICAgICAgeTEgPSBGcC5tdWwoeTEsIHR2Mik7IC8vIDUuIHkxID0geTEgKiB0djJcbiAgICAgICAgICAgIGNvbnN0IHkyID0gRnAubXVsKHkxLCBjMik7IC8vIDYuIHkyID0geTEgKiBjMlxuICAgICAgICAgICAgY29uc3QgdHYzID0gRnAubXVsKEZwLnNxcih5MSksIHYpOyAvLyA3LiB0djMgPSB5MV4yOyA4LiB0djMgPSB0djMgKiB2XG4gICAgICAgICAgICBjb25zdCBpc1FSID0gRnAuZXFsKHR2MywgdSk7IC8vIDkuIGlzUVIgPSB0djMgPT0gdVxuICAgICAgICAgICAgbGV0IHkgPSBGcC5jbW92KHkyLCB5MSwgaXNRUik7IC8vIDEwLiB5ID0gQ01PVih5MiwgeTEsIGlzUVIpXG4gICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBpc1FSLCB2YWx1ZTogeSB9OyAvLyAxMS4gcmV0dXJuIChpc1FSLCB5KSBpc1FSID8geSA6IHkqYzJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gTm8gY3VydmVzIHVzZXMgdGhhdFxuICAgIC8vIGlmIChGcC5PUkRFUiAlIF84biA9PT0gXzVuKSAvLyBzcXJ0X3JhdGlvXzVtb2Q4XG4gICAgcmV0dXJuIHNxcnRSYXRpbztcbn1cbi8qKlxuICogU2ltcGxpZmllZCBTaGFsbHVlLXZhbiBkZSBXb2VzdGlqbmUtVWxhcyBNZXRob2RcbiAqIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNi42LjJcbiAqL1xuZnVuY3Rpb24gbWFwVG9DdXJ2ZVNpbXBsZVNXVShGcCwgb3B0cykge1xuICAgIG1vZC52YWxpZGF0ZUZpZWxkKEZwKTtcbiAgICBpZiAoIUZwLmlzVmFsaWQob3B0cy5BKSB8fCAhRnAuaXNWYWxpZChvcHRzLkIpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuWikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZVNpbXBsZVNXVTogaW52YWxpZCBvcHRzJyk7XG4gICAgY29uc3Qgc3FydFJhdGlvID0gU1dVRnBTcXJ0UmF0aW8oRnAsIG9wdHMuWik7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGcC5pc09kZCBpcyBub3QgaW1wbGVtZW50ZWQhJyk7XG4gICAgLy8gSW5wdXQ6IHUsIGFuIGVsZW1lbnQgb2YgRi5cbiAgICAvLyBPdXRwdXQ6ICh4LCB5KSwgYSBwb2ludCBvbiBFLlxuICAgIHJldHVybiAodSkgPT4ge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgbGV0IHR2MSwgdHYyLCB0djMsIHR2NCwgdHY1LCB0djYsIHgsIHk7XG4gICAgICAgIHR2MSA9IEZwLnNxcih1KTsgLy8gMS4gIHR2MSA9IHVeMlxuICAgICAgICB0djEgPSBGcC5tdWwodHYxLCBvcHRzLlopOyAvLyAyLiAgdHYxID0gWiAqIHR2MVxuICAgICAgICB0djIgPSBGcC5zcXIodHYxKTsgLy8gMy4gIHR2MiA9IHR2MV4yXG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2MSk7IC8vIDQuICB0djIgPSB0djIgKyB0djFcbiAgICAgICAgdHYzID0gRnAuYWRkKHR2MiwgRnAuT05FKTsgLy8gNS4gIHR2MyA9IHR2MiArIDFcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgb3B0cy5CKTsgLy8gNi4gIHR2MyA9IEIgKiB0djNcbiAgICAgICAgdHY0ID0gRnAuY21vdihvcHRzLlosIEZwLm5lZyh0djIpLCAhRnAuZXFsKHR2MiwgRnAuWkVSTykpOyAvLyA3LiAgdHY0ID0gQ01PVihaLCAtdHYyLCB0djIgIT0gMClcbiAgICAgICAgdHY0ID0gRnAubXVsKHR2NCwgb3B0cy5BKTsgLy8gOC4gIHR2NCA9IEEgKiB0djRcbiAgICAgICAgdHYyID0gRnAuc3FyKHR2Myk7IC8vIDkuICB0djIgPSB0djNeMlxuICAgICAgICB0djYgPSBGcC5zcXIodHY0KTsgLy8gMTAuIHR2NiA9IHR2NF4yXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djYsIG9wdHMuQSk7IC8vIDExLiB0djUgPSBBICogdHY2XG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2NSk7IC8vIDEyLiB0djIgPSB0djIgKyB0djVcbiAgICAgICAgdHYyID0gRnAubXVsKHR2MiwgdHYzKTsgLy8gMTMuIHR2MiA9IHR2MiAqIHR2M1xuICAgICAgICB0djYgPSBGcC5tdWwodHY2LCB0djQpOyAvLyAxNC4gdHY2ID0gdHY2ICogdHY0XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djYsIG9wdHMuQik7IC8vIDE1LiB0djUgPSBCICogdHY2XG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2NSk7IC8vIDE2LiB0djIgPSB0djIgKyB0djVcbiAgICAgICAgeCA9IEZwLm11bCh0djEsIHR2Myk7IC8vIDE3LiAgIHggPSB0djEgKiB0djNcbiAgICAgICAgY29uc3QgeyBpc1ZhbGlkLCB2YWx1ZSB9ID0gc3FydFJhdGlvKHR2MiwgdHY2KTsgLy8gMTguIChpc19neDFfc3F1YXJlLCB5MSkgPSBzcXJ0X3JhdGlvKHR2MiwgdHY2KVxuICAgICAgICB5ID0gRnAubXVsKHR2MSwgdSk7IC8vIDE5LiAgIHkgPSB0djEgKiB1ICAtPiBaICogdV4zICogeTFcbiAgICAgICAgeSA9IEZwLm11bCh5LCB2YWx1ZSk7IC8vIDIwLiAgIHkgPSB5ICogeTFcbiAgICAgICAgeCA9IEZwLmNtb3YoeCwgdHYzLCBpc1ZhbGlkKTsgLy8gMjEuICAgeCA9IENNT1YoeCwgdHYzLCBpc19neDFfc3F1YXJlKVxuICAgICAgICB5ID0gRnAuY21vdih5LCB2YWx1ZSwgaXNWYWxpZCk7IC8vIDIyLiAgIHkgPSBDTU9WKHksIHkxLCBpc19neDFfc3F1YXJlKVxuICAgICAgICBjb25zdCBlMSA9IEZwLmlzT2RkKHUpID09PSBGcC5pc09kZCh5KTsgLy8gMjMuICBlMSA9IHNnbjAodSkgPT0gc2duMCh5KVxuICAgICAgICB5ID0gRnAuY21vdihGcC5uZWcoeSksIHksIGUxKTsgLy8gMjQuICAgeSA9IENNT1YoLXksIHksIGUxKVxuICAgICAgICB4ID0gRnAuZGl2KHgsIHR2NCk7IC8vIDI1LiAgIHggPSB4IC8gdHY0XG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2VpZXJzdHJhc3MuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/abstract/weierstrass.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/secp256k1.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/secp256k1.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/sha256.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/utils.js\");\nconst _shortw_utils_js_1 = __webpack_require__(/*! ./_shortw_utils.js */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/_shortw_utils.js\");\nconst hash_to_curve_js_1 = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/abstract/hash-to-curve.js\");\nconst modular_js_1 = __webpack_require__(/*! ./abstract/modular.js */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/abstract/modular.js\");\nconst utils_js_1 = __webpack_require__(/*! ./abstract/utils.js */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/abstract/utils.js\");\nconst weierstrass_js_1 = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/abstract/weierstrass.js\");\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = ((0, modular_js_1.pow2)(b3, _3n, P) * b3) % P;\n    const b9 = ((0, modular_js_1.pow2)(b6, _3n, P) * b3) % P;\n    const b11 = ((0, modular_js_1.pow2)(b9, _2n, P) * b2) % P;\n    const b22 = ((0, modular_js_1.pow2)(b11, _11n, P) * b11) % P;\n    const b44 = ((0, modular_js_1.pow2)(b22, _22n, P) * b22) % P;\n    const b88 = ((0, modular_js_1.pow2)(b44, _44n, P) * b44) % P;\n    const b176 = ((0, modular_js_1.pow2)(b88, _88n, P) * b88) % P;\n    const b220 = ((0, modular_js_1.pow2)(b176, _44n, P) * b44) % P;\n    const b223 = ((0, modular_js_1.pow2)(b220, _3n, P) * b3) % P;\n    const t1 = ((0, modular_js_1.pow2)(b223, _23n, P) * b22) % P;\n    const t2 = ((0, modular_js_1.pow2)(t1, _6n, P) * b2) % P;\n    const root = (0, modular_js_1.pow2)(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fp = (0, modular_js_1.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\nexports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({\n    a: BigInt(0), // equation params: a, b\n    b: BigInt(7), // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975\n    Fp, // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n\n    n: secp256k1N, // Curve order, total count of valid points in the field\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1), // Cofactor\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, sha256_1.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => (0, utils_js_1.numberToBytesBE)(n, 32);\nconst modP = (x) => (0, modular_js_1.mod)(x, secp256k1P);\nconst modN = (x) => (0, modular_js_1.mod)(x, secp256k1N);\nconst Point = exports.secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    if (!fe(x))\n        throw new Error('bad x: need 0 < x < p'); // Fail if x ≥ p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN((0, utils_js_1.bytesToNumberBE)(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {\n    const m = (0, utils_js_1.ensureBytes)('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0, utils_js_1.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ (0, utils_js_1.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN((0, utils_js_1.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = (0, utils_js_1.ensureBytes)('signature', signature, 64);\n    const m = (0, utils_js_1.ensureBytes)('message', message);\n    const pub = (0, utils_js_1.ensureBytes)('publicKey', publicKey, 32);\n    try {\n        const P = lift_x((0, utils_js_1.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n        if (!fe(r))\n            return false;\n        const s = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n        if (!ge(s))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n    }\n    catch (error) {\n        return false;\n    }\n}\nexports.schnorr = (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE: utils_js_1.numberToBytesBE,\n        bytesToNumberBE: utils_js_1.bytesToNumberBE,\n        taggedHash,\n        mod: modular_js_1.mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.isogenyMap)(Fp, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n}))();\nconst htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fp.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha256_1.sha256,\n}))();\nexports.hashToCurve = (() => htf.hashToCurve)();\nexports.encodeToCurve = (() => htf.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixHQUFHLG1CQUFtQixHQUFHLGVBQWUsR0FBRyxpQkFBaUI7QUFDakY7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyxrSEFBc0I7QUFDL0MsZ0JBQWdCLG1CQUFPLENBQUMsZ0hBQXFCO0FBQzdDLDJCQUEyQixtQkFBTyxDQUFDLHVIQUFvQjtBQUN2RCwyQkFBMkIsbUJBQU8sQ0FBQyx5SUFBNkI7QUFDaEUscUJBQXFCLG1CQUFPLENBQUMsNkhBQXVCO0FBQ3BELG1CQUFtQixtQkFBTyxDQUFDLHlIQUFxQjtBQUNoRCx5QkFBeUIsbUJBQU8sQ0FBQyxxSUFBMkI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxlQUFlO0FBQ3RGLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVCxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FLHNDQUFzQyxhQUFhO0FBQ25EO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0Esd0NBQXdDO0FBQ3hDLHdCQUF3QjtBQUN4QjtBQUNBLHNCQUFzQjtBQUN0QixvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QixtQ0FBbUM7QUFDdEUsbUVBQW1FO0FBQ25FLDJGQUEyRjtBQUMzRix3REFBd0Q7QUFDeEQsNERBQTREO0FBQzVEO0FBQ0EsbURBQW1EO0FBQ25ELFlBQVksdUJBQXVCLDJCQUEyQjtBQUM5RCxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHdCQUF3QjtBQUN4Rix3RUFBd0UsMkJBQTJCO0FBQ25HO0FBQ0E7QUFDQSx5RUFBeUUsNEJBQTRCO0FBQ3JHO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQsMkNBQTJDO0FBQzNDO0FBQ0EsMEJBQTBCO0FBQzFCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXNpZy11dGlsL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL3NlY3AyNTZrMS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW5jb2RlVG9DdXJ2ZSA9IGV4cG9ydHMuaGFzaFRvQ3VydmUgPSBleHBvcnRzLnNjaG5vcnIgPSBleHBvcnRzLnNlY3AyNTZrMSA9IHZvaWQgMDtcbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmNvbnN0IHNoYTI1Nl8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCIpO1xuY29uc3QgX3Nob3J0d191dGlsc19qc18xID0gcmVxdWlyZShcIi4vX3Nob3J0d191dGlscy5qc1wiKTtcbmNvbnN0IGhhc2hfdG9fY3VydmVfanNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanNcIik7XG5jb25zdCBtb2R1bGFyX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC9tb2R1bGFyLmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0L3V0aWxzLmpzXCIpO1xuY29uc3Qgd2VpZXJzdHJhc3NfanNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzXCIpO1xuY29uc3Qgc2VjcDI1NmsxUCA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmYzJmJyk7XG5jb25zdCBzZWNwMjU2azFOID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDEnKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IGRpdk5lYXJlc3QgPSAoYSwgYikgPT4gKGEgKyBiIC8gXzJuKSAvIGI7XG4vKipcbiAqIOKImm4gPSBuXigocCsxKS80KSBmb3IgZmllbGRzIHAgPSAzIG1vZCA0LiBXZSB1bndyYXAgdGhlIGxvb3AgYW5kIG11bHRpcGx5IGJpdC1ieS1iaXQuXG4gKiAoUCsxbi80bikudG9TdHJpbmcoMikgd291bGQgcHJvZHVjZSBiaXRzIFsyMjN4IDEsIDAsIDIyeCAxLCA0eCAwLCAxMSwgMDBdXG4gKi9cbmZ1bmN0aW9uIHNxcnRNb2QoeSkge1xuICAgIGNvbnN0IFAgPSBzZWNwMjU2azFQO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8zbiA9IEJpZ0ludCgzKSwgXzZuID0gQmlnSW50KDYpLCBfMTFuID0gQmlnSW50KDExKSwgXzIybiA9IEJpZ0ludCgyMik7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzIzbiA9IEJpZ0ludCgyMyksIF80NG4gPSBCaWdJbnQoNDQpLCBfODhuID0gQmlnSW50KDg4KTtcbiAgICBjb25zdCBiMiA9ICh5ICogeSAqIHkpICUgUDsgLy8geF4zLCAxMVxuICAgIGNvbnN0IGIzID0gKGIyICogYjIgKiB5KSAlIFA7IC8vIHheN1xuICAgIGNvbnN0IGI2ID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjMsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGI5ID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjYsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGIxMSA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGI5LCBfMm4sIFApICogYjIpICUgUDtcbiAgICBjb25zdCBiMjIgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiMTEsIF8xMW4sIFApICogYjExKSAlIFA7XG4gICAgY29uc3QgYjQ0ID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjIyLCBfMjJuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IGI4OCA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGI0NCwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMTc2ID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjg4LCBfODhuLCBQKSAqIGI4OCkgJSBQO1xuICAgIGNvbnN0IGIyMjAgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiMTc2LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIyMjMgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiMjIwLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCB0MSA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGIyMjMsIF8yM24sIFApICogYjIyKSAlIFA7XG4gICAgY29uc3QgdDIgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKSh0MSwgXzZuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3Qgcm9vdCA9ICgwLCBtb2R1bGFyX2pzXzEucG93MikodDIsIF8ybiwgUCk7XG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCB5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgIHJldHVybiByb290O1xufVxuY29uc3QgRnAgPSAoMCwgbW9kdWxhcl9qc18xLkZpZWxkKShzZWNwMjU2azFQLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgeyBzcXJ0OiBzcXJ0TW9kIH0pO1xuZXhwb3J0cy5zZWNwMjU2azEgPSAoMCwgX3Nob3J0d191dGlsc19qc18xLmNyZWF0ZUN1cnZlKSh7XG4gICAgYTogQmlnSW50KDApLCAvLyBlcXVhdGlvbiBwYXJhbXM6IGEsIGJcbiAgICBiOiBCaWdJbnQoNyksIC8vIFNlZW0gdG8gYmUgcmlnaWQ6IGJpdGNvaW50YWxrLm9yZy9pbmRleC5waHA/dG9waWM9Mjg5Nzk1Lm1zZzMxODM5NzUjbXNnMzE4Mzk3NVxuICAgIEZwLCAvLyBGaWVsZCdzIHByaW1lOiAybioqMjU2biAtIDJuKiozMm4gLSAybioqOW4gLSAybioqOG4gLSAybioqN24gLSAybioqNm4gLSAybioqNG4gLSAxblxuICAgIG46IHNlY3AyNTZrMU4sIC8vIEN1cnZlIG9yZGVyLCB0b3RhbCBjb3VudCBvZiB2YWxpZCBwb2ludHMgaW4gdGhlIGZpZWxkXG4gICAgLy8gQmFzZSBwb2ludCAoeCwgeSkgYWthIGdlbmVyYXRvciBwb2ludFxuICAgIEd4OiBCaWdJbnQoJzU1MDY2MjYzMDIyMjc3MzQzNjY5NTc4NzE4ODk1MTY4NTM0MzI2MjUwNjAzNDUzNzc3NTk0MTc1NTAwMTg3MzYwMzg5MTE2NzI5MjQwJyksXG4gICAgR3k6IEJpZ0ludCgnMzI2NzA1MTAwMjA3NTg4MTY5NzgwODMwODUxMzA1MDcwNDMxODQ0NzEyNzMzODA2NTkyNDMyNzU5Mzg5MDQzMzU3NTczMzc0ODI0MjQnKSxcbiAgICBoOiBCaWdJbnQoMSksIC8vIENvZmFjdG9yXG4gICAgbG93UzogdHJ1ZSwgLy8gQWxsb3cgb25seSBsb3ctUyBzaWduYXR1cmVzIGJ5IGRlZmF1bHQgaW4gc2lnbigpIGFuZCB2ZXJpZnkoKVxuICAgIC8qKlxuICAgICAqIHNlY3AyNTZrMSBiZWxvbmdzIHRvIEtvYmxpdHogY3VydmVzOiBpdCBoYXMgZWZmaWNpZW50bHkgY29tcHV0YWJsZSBlbmRvbW9ycGhpc20uXG4gICAgICogRW5kb21vcnBoaXNtIHVzZXMgMnggbGVzcyBSQU0sIHNwZWVkcyB1cCBwcmVjb21wdXRhdGlvbiBieSAyeCBhbmQgRUNESCAvIGtleSByZWNvdmVyeSBieSAyMCUuXG4gICAgICogRm9yIHByZWNvbXB1dGVkIHdOQUYgaXQgdHJhZGVzIG9mZiAxLzIgaW5pdCB0aW1lICYgMS8zIHJhbSBmb3IgMjAlIHBlcmYgaGl0LlxuICAgICAqIEV4cGxhbmF0aW9uOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsbWlsbHIvZWI2NzA4MDY3OTNlODRkZjYyOGE3YzQzNGE4NzMwNjZcbiAgICAgKi9cbiAgICBlbmRvOiB7XG4gICAgICAgIGJldGE6IEJpZ0ludCgnMHg3YWU5NmEyYjY1N2MwNzEwNmU2NDQ3OWVhYzM0MzRlOTljZjA0OTc1MTJmNTg5OTVjMTM5NmMyODcxOTUwMWVlJyksXG4gICAgICAgIHNwbGl0U2NhbGFyOiAoaykgPT4ge1xuICAgICAgICAgICAgY29uc3QgbiA9IHNlY3AyNTZrMU47XG4gICAgICAgICAgICBjb25zdCBhMSA9IEJpZ0ludCgnMHgzMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNScpO1xuICAgICAgICAgICAgY29uc3QgYjEgPSAtXzFuICogQmlnSW50KCcweGU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzJyk7XG4gICAgICAgICAgICBjb25zdCBhMiA9IEJpZ0ludCgnMHgxMTRjYTUwZjdhOGUyZjNmNjU3YzExMDhkOWQ0NGNmZDgnKTtcbiAgICAgICAgICAgIGNvbnN0IGIyID0gYTE7XG4gICAgICAgICAgICBjb25zdCBQT1dfMl8xMjggPSBCaWdJbnQoJzB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyk7IC8vICgybioqMTI4bikudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICBjb25zdCBjMSA9IGRpdk5lYXJlc3QoYjIgKiBrLCBuKTtcbiAgICAgICAgICAgIGNvbnN0IGMyID0gZGl2TmVhcmVzdCgtYjEgKiBrLCBuKTtcbiAgICAgICAgICAgIGxldCBrMSA9ICgwLCBtb2R1bGFyX2pzXzEubW9kKShrIC0gYzEgKiBhMSAtIGMyICogYTIsIG4pO1xuICAgICAgICAgICAgbGV0IGsyID0gKDAsIG1vZHVsYXJfanNfMS5tb2QpKC1jMSAqIGIxIC0gYzIgKiBiMiwgbik7XG4gICAgICAgICAgICBjb25zdCBrMW5lZyA9IGsxID4gUE9XXzJfMTI4O1xuICAgICAgICAgICAgY29uc3QgazJuZWcgPSBrMiA+IFBPV18yXzEyODtcbiAgICAgICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgICAgICBrMSA9IG4gLSBrMTtcbiAgICAgICAgICAgIGlmIChrMm5lZylcbiAgICAgICAgICAgICAgICBrMiA9IG4gLSBrMjtcbiAgICAgICAgICAgIGlmIChrMSA+IFBPV18yXzEyOCB8fCBrMiA+IFBPV18yXzEyOCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3BsaXRTY2FsYXI6IEVuZG9tb3JwaGlzbSBmYWlsZWQsIGs9JyArIGspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgazFuZWcsIGsxLCBrMm5lZywgazIgfTtcbiAgICAgICAgfSxcbiAgICB9LFxufSwgc2hhMjU2XzEuc2hhMjU2KTtcbi8vIFNjaG5vcnIgc2lnbmF0dXJlcyBhcmUgc3VwZXJpb3IgdG8gRUNEU0EgZnJvbSBhYm92ZS4gQmVsb3cgaXMgU2Nobm9yci1zcGVjaWZpYyBCSVAwMzQwIGNvZGUuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMzQwLm1lZGlhd2lraVxuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgZmUgPSAoeCkgPT4gdHlwZW9mIHggPT09ICdiaWdpbnQnICYmIF8wbiA8IHggJiYgeCA8IHNlY3AyNTZrMVA7XG5jb25zdCBnZSA9ICh4KSA9PiB0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgeCAmJiB4IDwgc2VjcDI1NmsxTjtcbi8qKiBBbiBvYmplY3QgbWFwcGluZyB0YWdzIHRvIHRoZWlyIHRhZ2dlZCBoYXNoIHByZWZpeCBvZiBbU0hBMjU2KHRhZykgfCBTSEEyNTYodGFnKV0gKi9cbmNvbnN0IFRBR0dFRF9IQVNIX1BSRUZJWEVTID0ge307XG5mdW5jdGlvbiB0YWdnZWRIYXNoKHRhZywgLi4ubWVzc2FnZXMpIHtcbiAgICBsZXQgdGFnUCA9IFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ107XG4gICAgaWYgKHRhZ1AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB0YWdIID0gKDAsIHNoYTI1Nl8xLnNoYTI1NikoVWludDhBcnJheS5mcm9tKHRhZywgKGMpID0+IGMuY2hhckNvZGVBdCgwKSkpO1xuICAgICAgICB0YWdQID0gKDAsIHV0aWxzX2pzXzEuY29uY2F0Qnl0ZXMpKHRhZ0gsIHRhZ0gpO1xuICAgICAgICBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddID0gdGFnUDtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBzaGEyNTZfMS5zaGEyNTYpKCgwLCB1dGlsc19qc18xLmNvbmNhdEJ5dGVzKSh0YWdQLCAuLi5tZXNzYWdlcykpO1xufVxuLy8gRUNEU0EgY29tcGFjdCBwb2ludHMgYXJlIDMzLWJ5dGUuIFNjaG5vcnIgaXMgMzI6IHdlIHN0cmlwIGZpcnN0IGJ5dGUgMHgwMiBvciAweDAzXG5jb25zdCBwb2ludFRvQnl0ZXMgPSAocG9pbnQpID0+IHBvaW50LnRvUmF3Qnl0ZXModHJ1ZSkuc2xpY2UoMSk7XG5jb25zdCBudW1UbzMyYiA9IChuKSA9PiAoMCwgdXRpbHNfanNfMS5udW1iZXJUb0J5dGVzQkUpKG4sIDMyKTtcbmNvbnN0IG1vZFAgPSAoeCkgPT4gKDAsIG1vZHVsYXJfanNfMS5tb2QpKHgsIHNlY3AyNTZrMVApO1xuY29uc3QgbW9kTiA9ICh4KSA9PiAoMCwgbW9kdWxhcl9qc18xLm1vZCkoeCwgc2VjcDI1NmsxTik7XG5jb25zdCBQb2ludCA9IGV4cG9ydHMuc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludDtcbmNvbnN0IEdtdWxBZGQgPSAoUSwgYSwgYikgPT4gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKTtcbi8vIENhbGN1bGF0ZSBwb2ludCwgc2NhbGFyIGFuZCBieXRlc1xuZnVuY3Rpb24gc2Nobm9yckdldEV4dFB1YktleShwcml2KSB7XG4gICAgbGV0IGRfID0gZXhwb3J0cy5zZWNwMjU2azEudXRpbHMubm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2KTsgLy8gc2FtZSBtZXRob2QgZXhlY3V0ZWQgaW4gZnJvbVByaXZhdGVLZXlcbiAgICBsZXQgcCA9IFBvaW50LmZyb21Qcml2YXRlS2V5KGRfKTsgLy8gUCA9IGQn4ouFRzsgMCA8IGQnIDwgbiBjaGVjayBpcyBkb25lIGluc2lkZVxuICAgIGNvbnN0IHNjYWxhciA9IHAuaGFzRXZlblkoKSA/IGRfIDogbW9kTigtZF8pO1xuICAgIHJldHVybiB7IHNjYWxhcjogc2NhbGFyLCBieXRlczogcG9pbnRUb0J5dGVzKHApIH07XG59XG4vKipcbiAqIGxpZnRfeCBmcm9tIEJJUDM0MC4gQ29udmVydCAzMi1ieXRlIHggY29vcmRpbmF0ZSB0byBlbGxpcHRpYyBjdXJ2ZSBwb2ludC5cbiAqIEByZXR1cm5zIHZhbGlkIHBvaW50IGNoZWNrZWQgZm9yIGJlaW5nIG9uLWN1cnZlXG4gKi9cbmZ1bmN0aW9uIGxpZnRfeCh4KSB7XG4gICAgaWYgKCFmZSh4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgeDogbmVlZCAwIDwgeCA8IHAnKTsgLy8gRmFpbCBpZiB4IOKJpSBwLlxuICAgIGNvbnN0IHh4ID0gbW9kUCh4ICogeCk7XG4gICAgY29uc3QgYyA9IG1vZFAoeHggKiB4ICsgQmlnSW50KDcpKTsgLy8gTGV0IGMgPSB4wrMgKyA3IG1vZCBwLlxuICAgIGxldCB5ID0gc3FydE1vZChjKTsgLy8gTGV0IHkgPSBjXihwKzEpLzQgbW9kIHAuXG4gICAgaWYgKHkgJSBfMm4gIT09IF8wbilcbiAgICAgICAgeSA9IG1vZFAoLXkpOyAvLyBSZXR1cm4gdGhlIHVuaXF1ZSBwb2ludCBQIHN1Y2ggdGhhdCB4KFApID0geCBhbmRcbiAgICBjb25zdCBwID0gbmV3IFBvaW50KHgsIHksIF8xbik7IC8vIHkoUCkgPSB5IGlmIHkgbW9kIDIgPSAwIG9yIHkoUCkgPSBwLXkgb3RoZXJ3aXNlLlxuICAgIHAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4gcDtcbn1cbi8qKlxuICogQ3JlYXRlIHRhZ2dlZCBoYXNoLCBjb252ZXJ0IGl0IHRvIGJpZ2ludCwgcmVkdWNlIG1vZHVsby1uLlxuICovXG5mdW5jdGlvbiBjaGFsbGVuZ2UoLi4uYXJncykge1xuICAgIHJldHVybiBtb2ROKCgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJCRSkodGFnZ2VkSGFzaCgnQklQMDM0MC9jaGFsbGVuZ2UnLCAuLi5hcmdzKSkpO1xufVxuLyoqXG4gKiBTY2hub3JyIHB1YmxpYyBrZXkgaXMganVzdCBgeGAgY29vcmRpbmF0ZSBvZiBQb2ludCBhcyBwZXIgQklQMzQwLlxuICovXG5mdW5jdGlvbiBzY2hub3JyR2V0UHVibGljS2V5KHByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gc2Nobm9yckdldEV4dFB1YktleShwcml2YXRlS2V5KS5ieXRlczsgLy8gZCc9aW50KHNrKS4gRmFpbCBpZiBkJz0wIG9yIGQn4omlbi4gUmV0IGJ5dGVzKGQn4ouFRylcbn1cbi8qKlxuICogQ3JlYXRlcyBTY2hub3JyIHNpZ25hdHVyZSBhcyBwZXIgQklQMzQwLiBWZXJpZmllcyBpdHNlbGYgYmVmb3JlIHJldHVybmluZyBhbnl0aGluZy5cbiAqIGF1eFJhbmQgaXMgb3B0aW9uYWwgYW5kIGlzIG5vdCB0aGUgc29sZSBzb3VyY2Ugb2YgayBnZW5lcmF0aW9uOiBiYWQgQ1NQUk5HIHdvbid0IGJlIGRhbmdlcm91cy5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yclNpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSwgYXV4UmFuZCA9ICgwLCB1dGlsc18xLnJhbmRvbUJ5dGVzKSgzMikpIHtcbiAgICBjb25zdCBtID0gKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgeyBieXRlczogcHgsIHNjYWxhcjogZCB9ID0gc2Nobm9yckdldEV4dFB1YktleShwcml2YXRlS2V5KTsgLy8gY2hlY2tzIGZvciBpc1dpdGhpbkN1cnZlT3JkZXJcbiAgICBjb25zdCBhID0gKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdhdXhSYW5kJywgYXV4UmFuZCwgMzIpOyAvLyBBdXhpbGlhcnkgcmFuZG9tIGRhdGEgYTogYSAzMi1ieXRlIGFycmF5XG4gICAgY29uc3QgdCA9IG51bVRvMzJiKGQgXiAoMCwgdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyQkUpKHRhZ2dlZEhhc2goJ0JJUDAzNDAvYXV4JywgYSkpKTsgLy8gTGV0IHQgYmUgdGhlIGJ5dGUtd2lzZSB4b3Igb2YgYnl0ZXMoZCkgYW5kIGhhc2gvYXV4KGEpXG4gICAgY29uc3QgcmFuZCA9IHRhZ2dlZEhhc2goJ0JJUDAzNDAvbm9uY2UnLCB0LCBweCwgbSk7IC8vIExldCByYW5kID0gaGFzaC9ub25jZSh0IHx8IGJ5dGVzKFApIHx8IG0pXG4gICAgY29uc3Qga18gPSBtb2ROKCgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJCRSkocmFuZCkpOyAvLyBMZXQgaycgPSBpbnQocmFuZCkgbW9kIG5cbiAgICBpZiAoa18gPT09IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduIGZhaWxlZDogayBpcyB6ZXJvJyk7IC8vIEZhaWwgaWYgaycgPSAwLlxuICAgIGNvbnN0IHsgYnl0ZXM6IHJ4LCBzY2FsYXI6IGsgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkoa18pOyAvLyBMZXQgUiA9IGsn4ouFRy5cbiAgICBjb25zdCBlID0gY2hhbGxlbmdlKHJ4LCBweCwgbSk7IC8vIExldCBlID0gaW50KGhhc2gvY2hhbGxlbmdlKGJ5dGVzKFIpIHx8IGJ5dGVzKFApIHx8IG0pKSBtb2Qgbi5cbiAgICBjb25zdCBzaWcgPSBuZXcgVWludDhBcnJheSg2NCk7IC8vIExldCBzaWcgPSBieXRlcyhSKSB8fCBieXRlcygoayArIGVkKSBtb2QgbikuXG4gICAgc2lnLnNldChyeCwgMCk7XG4gICAgc2lnLnNldChudW1UbzMyYihtb2ROKGsgKyBlICogZCkpLCAzMik7XG4gICAgLy8gSWYgVmVyaWZ5KGJ5dGVzKFApLCBtLCBzaWcpIChzZWUgYmVsb3cpIHJldHVybnMgZmFpbHVyZSwgYWJvcnRcbiAgICBpZiAoIXNjaG5vcnJWZXJpZnkoc2lnLCBtLCBweCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbjogSW52YWxpZCBzaWduYXR1cmUgcHJvZHVjZWQnKTtcbiAgICByZXR1cm4gc2lnO1xufVxuLyoqXG4gKiBWZXJpZmllcyBTY2hub3JyIHNpZ25hdHVyZS5cbiAqIFdpbGwgc3dhbGxvdyBlcnJvcnMgJiByZXR1cm4gZmFsc2UgZXhjZXB0IGZvciBpbml0aWFsIHR5cGUgdmFsaWRhdGlvbiBvZiBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICBjb25zdCBzaWcgPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ3NpZ25hdHVyZScsIHNpZ25hdHVyZSwgNjQpO1xuICAgIGNvbnN0IG0gPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCBwdWIgPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ3B1YmxpY0tleScsIHB1YmxpY0tleSwgMzIpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFAgPSBsaWZ0X3goKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckJFKShwdWIpKTsgLy8gUCA9IGxpZnRfeChpbnQocGspKTsgZmFpbCBpZiB0aGF0IGZhaWxzXG4gICAgICAgIGNvbnN0IHIgPSAoMCwgdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyQkUpKHNpZy5zdWJhcnJheSgwLCAzMikpOyAvLyBMZXQgciA9IGludChzaWdbMDozMl0pOyBmYWlsIGlmIHIg4omlIHAuXG4gICAgICAgIGlmICghZmUocikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHMgPSAoMCwgdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyQkUpKHNpZy5zdWJhcnJheSgzMiwgNjQpKTsgLy8gTGV0IHMgPSBpbnQoc2lnWzMyOjY0XSk7IGZhaWwgaWYgcyDiiaUgbi5cbiAgICAgICAgaWYgKCFnZShzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgZSA9IGNoYWxsZW5nZShudW1UbzMyYihyKSwgcG9pbnRUb0J5dGVzKFApLCBtKTsgLy8gaW50KGNoYWxsZW5nZShieXRlcyhyKXx8Ynl0ZXMoUCl8fG0pKSVuXG4gICAgICAgIGNvbnN0IFIgPSBHbXVsQWRkKFAsIHMsIG1vZE4oLWUpKTsgLy8gUiA9IHPii4VHIC0gZeKLhVBcbiAgICAgICAgaWYgKCFSIHx8ICFSLmhhc0V2ZW5ZKCkgfHwgUi50b0FmZmluZSgpLnggIT09IHIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIC1lUCA9PSAobi1lKVBcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEZhaWwgaWYgaXNfaW5maW5pdGUoUikgLyBub3QgaGFzX2V2ZW5feShSKSAvIHgoUikg4omgIHIuXG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5zY2hub3JyID0gKCgpID0+ICh7XG4gICAgZ2V0UHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5LFxuICAgIHNpZ246IHNjaG5vcnJTaWduLFxuICAgIHZlcmlmeTogc2Nobm9yclZlcmlmeSxcbiAgICB1dGlsczoge1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiBleHBvcnRzLnNlY3AyNTZrMS51dGlscy5yYW5kb21Qcml2YXRlS2V5LFxuICAgICAgICBsaWZ0X3gsXG4gICAgICAgIHBvaW50VG9CeXRlcyxcbiAgICAgICAgbnVtYmVyVG9CeXRlc0JFOiB1dGlsc19qc18xLm51bWJlclRvQnl0ZXNCRSxcbiAgICAgICAgYnl0ZXNUb051bWJlckJFOiB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJCRSxcbiAgICAgICAgdGFnZ2VkSGFzaCxcbiAgICAgICAgbW9kOiBtb2R1bGFyX2pzXzEubW9kLFxuICAgIH0sXG59KSkoKTtcbmNvbnN0IGlzb01hcCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gKDAsIGhhc2hfdG9fY3VydmVfanNfMS5pc29nZW55TWFwKShGcCwgW1xuICAgIC8vIHhOdW1cbiAgICBbXG4gICAgICAgICcweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4YzcnLFxuICAgICAgICAnMHg3ZDNkNGM4MGJjMzIxZDViOWYzMTVjZWE3ZmQ0NGM1ZDU5NWQyZmMwYmY2M2I5MmRmZmYxMDQ0ZjE3YzY1ODEnLFxuICAgICAgICAnMHg1MzRjMzI4ZDIzZjIzNGU2ZTJhNDEzZGVjYTI1Y2FlY2U0NTA2MTQ0MDM3YzQwMzE0ZWNiZDBiNTNkOWRkMjYyJyxcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYTg4YycsXG4gICAgXSxcbiAgICAvLyB4RGVuXG4gICAgW1xuICAgICAgICAnMHhkMzU3NzExOTNkOTQ5MThhOWNhMzRjY2JiN2I2NDBkZDg2Y2Q0MDk1NDJmODQ4N2Q5ZmU2Yjc0NTc4MWViNDliJyxcbiAgICAgICAgJzB4ZWRhZGM2ZjY0MzgzZGMxZGY3YzRiMmQ1MWI1NDIyNTQwNmQzNmI2NDFmNWU0MWJiYzUyYTU2NjEyYThjNmQxNCcsXG4gICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcbiAgICBdLFxuICAgIC8vIHlOdW1cbiAgICBbXG4gICAgICAgICcweDRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiOGUzOGUyM2MnLFxuICAgICAgICAnMHhjNzVlMGMzMmQ1Y2I3YzBmYTlkMGE1NGIxMmEwYTZkNTY0N2FiMDQ2ZDY4NmRhNmZkZmZjOTBmYzIwMWQ3MWEzJyxcbiAgICAgICAgJzB4MjlhNjE5NDY5MWY5MWE3MzcxNTIwOWVmNjUxMmU1NzY3MjI4MzBhMjAxYmUyMDE4YTc2NWU4NWE5ZWNlZTkzMScsXG4gICAgICAgICcweDJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmMzhlMzhkODQnLFxuICAgIF0sXG4gICAgLy8geURlblxuICAgIFtcbiAgICAgICAgJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZjkzYicsXG4gICAgICAgICcweDdhMDY1MzRiYjhiZGI0OWZkNWU5ZTY2MzI3MjJjMjk4OTQ2N2MxYmZjOGU4ZDk3OGRmYjQyNWQyNjg1YzI1NzMnLFxuICAgICAgICAnMHg2NDg0YWE3MTY1NDVjYTJjZjNhNzBjM2ZhOGZlMzM3ZTBhM2QyMTE2MmYwZDYyOTlhN2JmODE5MmJmZDJhNzZmJyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG5dLm1hcCgoaSkgPT4gaS5tYXAoKGopID0+IEJpZ0ludChqKSkpKSkoKTtcbmNvbnN0IG1hcFNXVSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gKDAsIHdlaWVyc3RyYXNzX2pzXzEubWFwVG9DdXJ2ZVNpbXBsZVNXVSkoRnAsIHtcbiAgICBBOiBCaWdJbnQoJzB4M2Y4NzMxYWJkZDY2MWFkY2EwOGE1NTU4ZjBmNWQyNzJlOTUzZDM2M2NiNmYwZTVkNDA1NDQ3YzAxYTQ0NDUzMycpLFxuICAgIEI6IEJpZ0ludCgnMTc3MScpLFxuICAgIFo6IEZwLmNyZWF0ZShCaWdJbnQoJy0xMScpKSxcbn0pKSgpO1xuY29uc3QgaHRmID0gLyogQF9fUFVSRV9fICovICgoKSA9PiAoMCwgaGFzaF90b19jdXJ2ZV9qc18xLmNyZWF0ZUhhc2hlcikoZXhwb3J0cy5zZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LCAoc2NhbGFycykgPT4ge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gbWFwU1dVKEZwLmNyZWF0ZShzY2FsYXJzWzBdKSk7XG4gICAgcmV0dXJuIGlzb01hcCh4LCB5KTtcbn0sIHtcbiAgICBEU1Q6ICdzZWNwMjU2azFfWE1EOlNIQS0yNTZfU1NXVV9ST18nLFxuICAgIGVuY29kZURTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX05VXycsXG4gICAgcDogRnAuT1JERVIsXG4gICAgbTogMSxcbiAgICBrOiAxMjgsXG4gICAgZXhwYW5kOiAneG1kJyxcbiAgICBoYXNoOiBzaGEyNTZfMS5zaGEyNTYsXG59KSkoKTtcbmV4cG9ydHMuaGFzaFRvQ3VydmUgPSAoKCkgPT4gaHRmLmhhc2hUb0N1cnZlKSgpO1xuZXhwb3J0cy5lbmNvZGVUb0N1cnZlID0gKCgpID0+IGh0Zi5lbmNvZGVUb0N1cnZlKSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VjcDI1NmsxLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/secp256k1.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/_assert.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/_assert.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = exports.isBytes = void 0;\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`positive integer expected, not ${n}`);\n}\nexports.number = number;\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\nexports.bool = bool;\n// copied from utils\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nexports.isBytes = isBytes;\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nexports.bytes = bytes;\nfunction hash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(h.outputLen);\n    number(h.blockLen);\n}\nexports.hash = hash;\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nexports.exists = exists;\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexports.output = output;\nconst assert = { number, bool, bytes, hash, exists, output };\nexports[\"default\"] = assert;\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX2Fzc2VydC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsY0FBYyxHQUFHLFlBQVksR0FBRyxhQUFhLEdBQUcsWUFBWSxHQUFHLGNBQWMsR0FBRyxlQUFlO0FBQ2hIO0FBQ0E7QUFDQSwwREFBMEQsRUFBRTtBQUM1RDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQ7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxRQUFRLGtCQUFrQixTQUFTO0FBQzVGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsSUFBSTtBQUNyRjtBQUNBO0FBQ0EsY0FBYztBQUNkLGlCQUFpQjtBQUNqQixrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXNpZy11dGlsL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL19hc3NlcnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm91dHB1dCA9IGV4cG9ydHMuZXhpc3RzID0gZXhwb3J0cy5oYXNoID0gZXhwb3J0cy5ieXRlcyA9IGV4cG9ydHMuYm9vbCA9IGV4cG9ydHMubnVtYmVyID0gZXhwb3J0cy5pc0J5dGVzID0gdm9pZCAwO1xuZnVuY3Rpb24gbnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBvc2l0aXZlIGludGVnZXIgZXhwZWN0ZWQsIG5vdCAke259YCk7XG59XG5leHBvcnRzLm51bWJlciA9IG51bWJlcjtcbmZ1bmN0aW9uIGJvb2woYikge1xuICAgIGlmICh0eXBlb2YgYiAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJvb2xlYW4gZXhwZWN0ZWQsIG5vdCAke2J9YCk7XG59XG5leHBvcnRzLmJvb2wgPSBib29sO1xuLy8gY29waWVkIGZyb20gdXRpbHNcbmZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbmV4cG9ydHMuaXNCeXRlcyA9IGlzQnl0ZXM7XG5mdW5jdGlvbiBieXRlcyhiLCAuLi5sZW5ndGhzKSB7XG4gICAgaWYgKCFpc0J5dGVzKGIpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVaW50OEFycmF5IGV4cGVjdGVkIG9mIGxlbmd0aCAke2xlbmd0aHN9LCBub3Qgb2YgbGVuZ3RoPSR7Yi5sZW5ndGh9YCk7XG59XG5leHBvcnRzLmJ5dGVzID0gYnl0ZXM7XG5mdW5jdGlvbiBoYXNoKGgpIHtcbiAgICBpZiAodHlwZW9mIGggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGguY3JlYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMud3JhcENvbnN0cnVjdG9yJyk7XG4gICAgbnVtYmVyKGgub3V0cHV0TGVuKTtcbiAgICBudW1iZXIoaC5ibG9ja0xlbik7XG59XG5leHBvcnRzLmhhc2ggPSBoYXNoO1xuZnVuY3Rpb24gZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG5leHBvcnRzLmV4aXN0cyA9IGV4aXN0cztcbmZ1bmN0aW9uIG91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gICAgYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke21pbn1gKTtcbiAgICB9XG59XG5leHBvcnRzLm91dHB1dCA9IG91dHB1dDtcbmNvbnN0IGFzc2VydCA9IHsgbnVtYmVyLCBib29sLCBieXRlcywgaGFzaCwgZXhpc3RzLCBvdXRwdXQgfTtcbmV4cG9ydHMuZGVmYXVsdCA9IGFzc2VydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9hc3NlcnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/_assert.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/_md.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/_md.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HashMD = exports.Maj = exports.Chi = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/_assert.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/utils.js\");\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\nexports.Chi = Chi;\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\nexports.Maj = Maj;\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nclass HashMD extends utils_js_1.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, utils_js_1.createView)(this.buffer);\n    }\n    update(data) {\n        (0, _assert_js_1.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0, utils_js_1.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, utils_js_1.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0, _assert_js_1.exists)(this);\n        (0, _assert_js_1.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, utils_js_1.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\nexports.HashMD = HashMD;\n//# sourceMappingURL=_md.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX21kLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxXQUFXLEdBQUcsV0FBVztBQUMxQyxxQkFBcUIsbUJBQU8sQ0FBQywyR0FBYztBQUMzQyxtQkFBbUIsbUJBQU8sQ0FBQyx1R0FBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQyxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQXFEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fbWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkhhc2hNRCA9IGV4cG9ydHMuTWFqID0gZXhwb3J0cy5DaGkgPSB2b2lkIDA7XG5jb25zdCBfYXNzZXJ0X2pzXzEgPSByZXF1aXJlKFwiLi9fYXNzZXJ0LmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gUG9seWZpbGwgZm9yIFNhZmFyaSAxNFxuZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8vIENob2ljZTogYSA/IGIgOiBjXG5jb25zdCBDaGkgPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeICh+YSAmIGMpO1xuZXhwb3J0cy5DaGkgPSBDaGk7XG4vLyBNYWpvcml0eSBmdW5jdGlvbiwgdHJ1ZSBpZiBhbnkgdHdvIGlucHVzdCBpcyB0cnVlXG5jb25zdCBNYWogPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xuZXhwb3J0cy5NYWogPSBNYWo7XG4vKipcbiAqIE1lcmtsZS1EYW1nYXJkIGhhc2ggY29uc3RydWN0aW9uIGJhc2UgY2xhc3MuXG4gKiBDb3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBNRDUsIFJJUEVNRCwgU0hBMSwgU0hBMi5cbiAqL1xuY2xhc3MgSGFzaE1EIGV4dGVuZHMgdXRpbHNfanNfMS5IYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XG4gICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLnZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KSh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuZXhpc3RzKSh0aGlzKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXQsIGNhc3QgaXQgdG8gdmlldyBhbmQgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KShkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmV4aXN0cykodGhpcyk7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEub3V0cHV0KShvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgIHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykuZmlsbCgwKTtcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpblxuICAgICAgICAvLyBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICAvLyBOb3RlOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cbiAgICAgICAgc2V0QmlnVWludDY0KHZpZXcsIGJsb2NrTGVuIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGlzTEUpO1xuICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgIGNvbnN0IG92aWV3ID0gKDAsIHV0aWxzX2pzXzEuY3JlYXRlVmlldykob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG5leHBvcnRzLkhhc2hNRCA9IEhhc2hNRDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9tZC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/_md.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/_u64.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/_u64.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nexports.fromBig = fromBig;\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nexports.split = split;\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\nexports.toBig = toBig;\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nexports.shrSH = shrSH;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\nexports.shrSL = shrSL;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nexports.rotrSH = rotrSH;\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\nexports.rotrSL = rotrSL;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nexports.rotrBH = rotrBH;\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\nexports.rotrBL = rotrBL;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nexports.rotr32H = rotr32H;\nconst rotr32L = (h, _l) => h;\nexports.rotr32L = rotr32L;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nexports.rotlSH = rotlSH;\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\nexports.rotlSL = rotlSL;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nexports.rotlBH = rotlBH;\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\nexports.rotlBL = rotlBL;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\nexports.add = add;\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nexports.add3L = add3L;\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nexports.add3H = add3H;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nexports.add4L = add4L;\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nexports.add4H = add4H;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nexports.add5L = add5L;\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\nexports.add5H = add5H;\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexports[\"default\"] = u64;\n//# sourceMappingURL=_u64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX3U2NC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRyxXQUFXLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGVBQWUsR0FBRyxlQUFlLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRyxlQUFlO0FBQ3pXO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEMsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXNpZy11dGlsL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL191NjQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFkZDVMID0gZXhwb3J0cy5hZGQ1SCA9IGV4cG9ydHMuYWRkNEggPSBleHBvcnRzLmFkZDRMID0gZXhwb3J0cy5hZGQzSCA9IGV4cG9ydHMuYWRkM0wgPSBleHBvcnRzLmFkZCA9IGV4cG9ydHMucm90bEJMID0gZXhwb3J0cy5yb3RsQkggPSBleHBvcnRzLnJvdGxTTCA9IGV4cG9ydHMucm90bFNIID0gZXhwb3J0cy5yb3RyMzJMID0gZXhwb3J0cy5yb3RyMzJIID0gZXhwb3J0cy5yb3RyQkwgPSBleHBvcnRzLnJvdHJCSCA9IGV4cG9ydHMucm90clNMID0gZXhwb3J0cy5yb3RyU0ggPSBleHBvcnRzLnNoclNMID0gZXhwb3J0cy5zaHJTSCA9IGV4cG9ydHMudG9CaWcgPSBleHBvcnRzLnNwbGl0ID0gZXhwb3J0cy5mcm9tQmlnID0gdm9pZCAwO1xuY29uc3QgVTMyX01BU0s2NCA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMiAqKiAzMiAtIDEpO1xuY29uc3QgXzMybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMzIpO1xuLy8gV2UgYXJlIG5vdCB1c2luZyBCaWdVaW50NjRBcnJheSwgYmVjYXVzZSB0aGV5IGFyZSBleHRyZW1lbHkgc2xvdyBhcyBwZXIgMjAyMlxuZnVuY3Rpb24gZnJvbUJpZyhuLCBsZSA9IGZhbHNlKSB7XG4gICAgaWYgKGxlKVxuICAgICAgICByZXR1cm4geyBoOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpLCBsOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB9O1xuICAgIHJldHVybiB7IGg6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIHwgMCwgbDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSB8IDAgfTtcbn1cbmV4cG9ydHMuZnJvbUJpZyA9IGZyb21CaWc7XG5mdW5jdGlvbiBzcGxpdChsc3QsIGxlID0gZmFsc2UpIHtcbiAgICBsZXQgQWggPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XG4gICAgbGV0IEFsID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbHN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgaCwgbCB9ID0gZnJvbUJpZyhsc3RbaV0sIGxlKTtcbiAgICAgICAgW0FoW2ldLCBBbFtpXV0gPSBbaCwgbF07XG4gICAgfVxuICAgIHJldHVybiBbQWgsIEFsXTtcbn1cbmV4cG9ydHMuc3BsaXQgPSBzcGxpdDtcbmNvbnN0IHRvQmlnID0gKGgsIGwpID0+IChCaWdJbnQoaCA+Pj4gMCkgPDwgXzMybikgfCBCaWdJbnQobCA+Pj4gMCk7XG5leHBvcnRzLnRvQmlnID0gdG9CaWc7XG4vLyBmb3IgU2hpZnQgaW4gWzAsIDMyKVxuY29uc3Qgc2hyU0ggPSAoaCwgX2wsIHMpID0+IGggPj4+IHM7XG5leHBvcnRzLnNoclNIID0gc2hyU0g7XG5jb25zdCBzaHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG5leHBvcnRzLnNoclNMID0gc2hyU0w7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdHJTSCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gcykgfCAobCA8PCAoMzIgLSBzKSk7XG5leHBvcnRzLnJvdHJTSCA9IHJvdHJTSDtcbmNvbnN0IHJvdHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG5leHBvcnRzLnJvdHJTTCA9IHJvdHJTTDtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xuZXhwb3J0cy5yb3RyQkggPSByb3RyQkg7XG5jb25zdCByb3RyQkwgPSAoaCwgbCwgcykgPT4gKGggPj4+IChzIC0gMzIpKSB8IChsIDw8ICg2NCAtIHMpKTtcbmV4cG9ydHMucm90ckJMID0gcm90ckJMO1xuLy8gUmlnaHQgcm90YXRlIGZvciBzaGlmdD09PTMyIChqdXN0IHN3YXBzIGwmaClcbmNvbnN0IHJvdHIzMkggPSAoX2gsIGwpID0+IGw7XG5leHBvcnRzLnJvdHIzMkggPSByb3RyMzJIO1xuY29uc3Qgcm90cjMyTCA9IChoLCBfbCkgPT4gaDtcbmV4cG9ydHMucm90cjMyTCA9IHJvdHIzMkw7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90bFNIID0gKGgsIGwsIHMpID0+IChoIDw8IHMpIHwgKGwgPj4+ICgzMiAtIHMpKTtcbmV4cG9ydHMucm90bFNIID0gcm90bFNIO1xuY29uc3Qgcm90bFNMID0gKGgsIGwsIHMpID0+IChsIDw8IHMpIHwgKGggPj4+ICgzMiAtIHMpKTtcbmV4cG9ydHMucm90bFNMID0gcm90bFNMO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RsQkggPSAoaCwgbCwgcykgPT4gKGwgPDwgKHMgLSAzMikpIHwgKGggPj4+ICg2NCAtIHMpKTtcbmV4cG9ydHMucm90bEJIID0gcm90bEJIO1xuY29uc3Qgcm90bEJMID0gKGgsIGwsIHMpID0+IChoIDw8IChzIC0gMzIpKSB8IChsID4+PiAoNjQgLSBzKSk7XG5leHBvcnRzLnJvdGxCTCA9IHJvdGxCTDtcbi8vIEpTIHVzZXMgMzItYml0IHNpZ25lZCBpbnRlZ2VycyBmb3IgYml0d2lzZSBvcGVyYXRpb25zIHdoaWNoIG1lYW5zIHdlIGNhbm5vdFxuLy8gc2ltcGxlIHRha2UgY2Fycnkgb3V0IG9mIGxvdyBiaXQgc3VtIGJ5IHNoaWZ0LCB3ZSBuZWVkIHRvIHVzZSBkaXZpc2lvbi5cbmZ1bmN0aW9uIGFkZChBaCwgQWwsIEJoLCBCbCkge1xuICAgIGNvbnN0IGwgPSAoQWwgPj4+IDApICsgKEJsID4+PiAwKTtcbiAgICByZXR1cm4geyBoOiAoQWggKyBCaCArICgobCAvIDIgKiogMzIpIHwgMCkpIHwgMCwgbDogbCB8IDAgfTtcbn1cbmV4cG9ydHMuYWRkID0gYWRkO1xuLy8gQWRkaXRpb24gd2l0aCBtb3JlIHRoYW4gMiBlbGVtZW50c1xuY29uc3QgYWRkM0wgPSAoQWwsIEJsLCBDbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApO1xuZXhwb3J0cy5hZGQzTCA9IGFkZDNMO1xuY29uc3QgYWRkM0ggPSAobG93LCBBaCwgQmgsIENoKSA9PiAoQWggKyBCaCArIENoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5leHBvcnRzLmFkZDNIID0gYWRkM0g7XG5jb25zdCBhZGQ0TCA9IChBbCwgQmwsIENsLCBEbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKTtcbmV4cG9ydHMuYWRkNEwgPSBhZGQ0TDtcbmNvbnN0IGFkZDRIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuZXhwb3J0cy5hZGQ0SCA9IGFkZDRIO1xuY29uc3QgYWRkNUwgPSAoQWwsIEJsLCBDbCwgRGwsIEVsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApICsgKEVsID4+PiAwKTtcbmV4cG9ydHMuYWRkNUwgPSBhZGQ1TDtcbmNvbnN0IGFkZDVIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgsIEVoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyBFaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuZXhwb3J0cy5hZGQ1SCA9IGFkZDVIO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB1NjQgPSB7XG4gICAgZnJvbUJpZywgc3BsaXQsIHRvQmlnLFxuICAgIHNoclNILCBzaHJTTCxcbiAgICByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsXG4gICAgcm90cjMySCwgcm90cjMyTCxcbiAgICByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsXG4gICAgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHU2NDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV91NjQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/_u64.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/cryptoNode.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/cryptoNode.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.crypto = void 0;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\n// The file will throw on node.js 14 and earlier.\n// @ts-ignore\nconst nc = __webpack_require__(/*! node:crypto */ \"node:crypto\");\nexports.crypto = nc && typeof nc === 'object' && 'webcrypto' in nc ? nc.webcrypto : undefined;\n//# sourceMappingURL=cryptoNode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvY3J5cHRvTm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFPLENBQUMsZ0NBQWE7QUFDaEMsY0FBYztBQUNkIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXNpZy11dGlsL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2NyeXB0b05vZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyeXB0byA9IHZvaWQgMDtcbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gU2VlIHV0aWxzLnRzIGZvciBkZXRhaWxzLlxuLy8gVGhlIGZpbGUgd2lsbCB0aHJvdyBvbiBub2RlLmpzIDE0IGFuZCBlYXJsaWVyLlxuLy8gQHRzLWlnbm9yZVxuY29uc3QgbmMgPSByZXF1aXJlKFwibm9kZTpjcnlwdG9cIik7XG5leHBvcnRzLmNyeXB0byA9IG5jICYmIHR5cGVvZiBuYyA9PT0gJ29iamVjdCcgJiYgJ3dlYmNyeXB0bycgaW4gbmMgPyBuYy53ZWJjcnlwdG8gOiB1bmRlZmluZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG9Ob2RlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/cryptoNode.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/hmac.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/hmac.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hmac = exports.HMAC = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/_assert.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/utils.js\");\n// HMAC (RFC 2104)\nclass HMAC extends utils_js_1.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0, _assert_js_1.hash)(hash);\n        const key = (0, utils_js_1.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0, _assert_js_1.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0, _assert_js_1.exists)(this);\n        (0, _assert_js_1.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\nexports.HMAC = HMAC;\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nexports.hmac = hmac;\nexports.hmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvaG1hYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZLEdBQUcsWUFBWTtBQUMzQixxQkFBcUIsbUJBQU8sQ0FBQywyR0FBYztBQUMzQyxtQkFBbUIsbUJBQU8sQ0FBQyx1R0FBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxnQkFBZ0IseURBQXlEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvaG1hYy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaG1hYyA9IGV4cG9ydHMuSE1BQyA9IHZvaWQgMDtcbmNvbnN0IF9hc3NlcnRfanNfMSA9IHJlcXVpcmUoXCIuL19hc3NlcnQuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vLyBITUFDIChSRkMgMjEwNClcbmNsYXNzIEhNQUMgZXh0ZW5kcyB1dGlsc19qc18xLkhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGhhc2gsIF9rZXkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmhhc2gpKGhhc2gpO1xuICAgICAgICBjb25zdCBrZXkgPSAoMCwgdXRpbHNfanNfMS50b0J5dGVzKShfa2V5KTtcbiAgICAgICAgdGhpcy5pSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5pSGFzaC51cGRhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaCcpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICAgICAgY29uc3QgYmxvY2tMZW4gPSB0aGlzLmJsb2NrTGVuO1xuICAgICAgICBjb25zdCBwYWQgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIC8vIGJsb2NrTGVuIGNhbiBiZSBiaWdnZXIgdGhhbiBvdXRwdXRMZW5cbiAgICAgICAgcGFkLnNldChrZXkubGVuZ3RoID4gYmxvY2tMZW4gPyBoYXNoLmNyZWF0ZSgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpIDoga2V5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNjtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgLy8gQnkgZG9pbmcgdXBkYXRlIChwcm9jZXNzaW5nIG9mIGZpcnN0IGJsb2NrKSBvZiBvdXRlciBoYXNoIGhlcmUgd2UgY2FuIHJlLXVzZSBpdCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzIHZpYSBjbG9uZVxuICAgICAgICB0aGlzLm9IYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgLy8gVW5kbyBpbnRlcm5hbCBYT1IgJiYgYXBwbHkgb3V0ZXIgWE9SXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzYgXiAweDVjO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICBwYWQuZmlsbCgwKTtcbiAgICB9XG4gICAgdXBkYXRlKGJ1Zikge1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmV4aXN0cykodGhpcyk7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmV4aXN0cykodGhpcyk7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKG91dCwgdGhpcy5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2Ugd2l0aG91dCBjYWxsaW5nIGNvbnN0cnVjdG9yIHNpbmNlIGtleSBhbHJlYWR5IGluIHN0YXRlIGFuZCB3ZSBkb24ndCBrbm93IGl0LlxuICAgICAgICB0byB8fCAodG8gPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICAgICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRvID0gdG87XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5vSGFzaCA9IG9IYXNoLl9jbG9uZUludG8odG8ub0hhc2gpO1xuICAgICAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vSGFzaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICAgIH1cbn1cbmV4cG9ydHMuSE1BQyA9IEhNQUM7XG4vKipcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICogQHBhcmFtIGhhc2ggLSBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBrZXkgLSBtZXNzYWdlIGtleVxuICogQHBhcmFtIG1lc3NhZ2UgLSBtZXNzYWdlIGRhdGFcbiAqL1xuY29uc3QgaG1hYyA9IChoYXNoLCBrZXksIG1lc3NhZ2UpID0+IG5ldyBITUFDKGhhc2gsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xuZXhwb3J0cy5obWFjID0gaG1hYztcbmV4cG9ydHMuaG1hYy5jcmVhdGUgPSAoaGFzaCwga2V5KSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG1hYy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/hmac.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/sha256.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/sha256.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sha224 = exports.sha256 = void 0;\nconst _md_js_1 = __webpack_require__(/*! ./_md.js */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/_md.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/utils.js\");\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_js_1.HashMD {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);\n            const T1 = (H + sigma1 + (0, _md_js_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);\n            const T2 = (sigma0 + (0, _md_js_1.Maj)(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());\nexports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc2hhMjU2LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxjQUFjO0FBQy9CLGlCQUFpQixtQkFBTyxDQUFDLG1HQUFVO0FBQ25DLG1CQUFtQixtQkFBTyxDQUFDLHVHQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUJBQXlCO0FBQ3ZDLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxjQUFjO0FBQ2QiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc2hhMjU2LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaGEyMjQgPSBleHBvcnRzLnNoYTI1NiA9IHZvaWQgMDtcbmNvbnN0IF9tZF9qc18xID0gcmVxdWlyZShcIi4vX21kLmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gU0hBMi0yNTYgbmVlZCB0byB0cnkgMl4xMjggaGFzaGVzIHRvIGV4ZWN1dGUgYmlydGhkYXkgYXR0YWNrLlxuLy8gQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl42NyBoYXNoZXMvc2VjIGFzIHBlciBlYXJseSAyMDIzLlxuLy8gUm91bmQgY29uc3RhbnRzOlxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl0pO1xuLy8gSW5pdGlhbCBzdGF0ZTpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0lWID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXSk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxuY29uc3QgU0hBMjU2X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmNsYXNzIFNIQTI1NiBleHRlbmRzIF9tZF9qc18xLkhhc2hNRCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAzMiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gU0hBMjU2X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gU0hBMjU2X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gU0hBMjU2X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gU0hBMjU2X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gU0hBMjU2X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gU0hBMjU2X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gU0hBMjU2X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gU0hBMjU2X0lWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9ICgwLCB1dGlsc19qc18xLnJvdHIpKFcxNSwgNykgXiAoMCwgdXRpbHNfanNfMS5yb3RyKShXMTUsIDE4KSBeIChXMTUgPj4+IDMpO1xuICAgICAgICAgICAgY29uc3QgczEgPSAoMCwgdXRpbHNfanNfMS5yb3RyKShXMiwgMTcpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoVzIsIDE5KSBeIChXMiA+Pj4gMTApO1xuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSAoczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0pIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMSA9ICgwLCB1dGlsc19qc18xLnJvdHIpKEUsIDYpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoRSwgMTEpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoRSwgMjUpO1xuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArICgwLCBfbWRfanNfMS5DaGkpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gKDAsIHV0aWxzX2pzXzEucm90cikoQSwgMikgXiAoMCwgdXRpbHNfanNfMS5yb3RyKShBLCAxMykgXiAoMCwgdXRpbHNfanNfMS5yb3RyKShBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyAoMCwgX21kX2pzXzEuTWFqKShBLCBCLCBDKSkgfCAwO1xuICAgICAgICAgICAgSCA9IEc7XG4gICAgICAgICAgICBHID0gRjtcbiAgICAgICAgICAgIEYgPSBFO1xuICAgICAgICAgICAgRSA9IChEICsgVDEpIHwgMDtcbiAgICAgICAgICAgIEQgPSBDO1xuICAgICAgICAgICAgQyA9IEI7XG4gICAgICAgICAgICBCID0gQTtcbiAgICAgICAgICAgIEEgPSAoVDEgKyBUMikgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgICAgICBFID0gKEUgKyB0aGlzLkUpIHwgMDtcbiAgICAgICAgRiA9IChGICsgdGhpcy5GKSB8IDA7XG4gICAgICAgIEcgPSAoRyArIHRoaXMuRykgfCAwO1xuICAgICAgICBIID0gKEggKyB0aGlzLkgpIHwgMDtcbiAgICAgICAgdGhpcy5zZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIFNIQTI1Nl9XLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgIH1cbn1cbi8vIENvbnN0YW50cyBmcm9tIGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODAtNC5wZGZcbmNsYXNzIFNIQTIyNCBleHRlbmRzIFNIQTI1NiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuQSA9IDB4YzEwNTllZDggfCAwO1xuICAgICAgICB0aGlzLkIgPSAweDM2N2NkNTA3IHwgMDtcbiAgICAgICAgdGhpcy5DID0gMHgzMDcwZGQxNyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IDB4ZjcwZTU5MzkgfCAwO1xuICAgICAgICB0aGlzLkUgPSAweGZmYzAwYjMxIHwgMDtcbiAgICAgICAgdGhpcy5GID0gMHg2ODU4MTUxMSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IDB4NjRmOThmYTcgfCAwO1xuICAgICAgICB0aGlzLkggPSAweGJlZmE0ZmE0IHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAyODtcbiAgICB9XG59XG4vKipcbiAqIFNIQTItMjU2IGhhc2ggZnVuY3Rpb25cbiAqIEBwYXJhbSBtZXNzYWdlIC0gZGF0YSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnRzLnNoYTI1NiA9ICgwLCB1dGlsc19qc18xLndyYXBDb25zdHJ1Y3RvcikoKCkgPT4gbmV3IFNIQTI1NigpKTtcbmV4cG9ydHMuc2hhMjI0ID0gKDAsIHV0aWxzX2pzXzEud3JhcENvbnN0cnVjdG9yKSgoKSA9PiBuZXcgU0hBMjI0KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMjU2LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/sha256.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/sha3.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/sha3.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/_assert.js\");\nconst _u64_js_1 = __webpack_require__(/*! ./_u64.js */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/_u64.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/utils.js\");\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n// Various per round constants calculations\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0, _u64_js_1.split)(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s));\n// Same as keccakf1600, but allows to skip some rounds\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta θ\n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (ρ) and Pi (π)\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (χ)\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (ι)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nexports.keccakP = keccakP;\nclass Keccak extends utils_js_1.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        (0, _assert_js_1.number)(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200)\n            throw new Error('Sha3 supports only keccak-f1600 function');\n        this.state = new Uint8Array(200);\n        this.state32 = (0, utils_js_1.u32)(this.state);\n    }\n    keccak() {\n        if (!utils_js_1.isLE)\n            (0, utils_js_1.byteSwap32)(this.state32);\n        keccakP(this.state32, this.rounds);\n        if (!utils_js_1.isLE)\n            (0, utils_js_1.byteSwap32)(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        (0, _assert_js_1.exists)(this);\n        const { blockLen, state } = this;\n        data = (0, utils_js_1.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        (0, _assert_js_1.exists)(this, false);\n        (0, _assert_js_1.bytes)(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0, _assert_js_1.number)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        (0, _assert_js_1.output)(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nexports.Keccak = Keccak;\nconst gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));\nexports.sha3_224 = gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nexports.sha3_256 = gen(0x06, 136, 256 / 8);\nexports.sha3_384 = gen(0x06, 104, 384 / 8);\nexports.sha3_512 = gen(0x06, 72, 512 / 8);\nexports.keccak_224 = gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nexports.keccak_256 = gen(0x01, 136, 256 / 8);\nexports.keccak_384 = gen(0x01, 104, 384 / 8);\nexports.keccak_512 = gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nexports.shake128 = genShake(0x1f, 168, 128 / 8);\nexports.shake256 = genShake(0x1f, 136, 256 / 8);\n//# sourceMappingURL=sha3.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc2hhMy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxrQkFBa0IsR0FBRyxrQkFBa0IsR0FBRyxrQkFBa0IsR0FBRyxrQkFBa0IsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxjQUFjLEdBQUcsZUFBZTtBQUN0TyxxQkFBcUIsbUJBQU8sQ0FBQywyR0FBYztBQUMzQyxrQkFBa0IsbUJBQU8sQ0FBQyxxR0FBVztBQUNyQyxtQkFBbUIsbUJBQU8sQ0FBQyx1R0FBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsWUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0IsNENBQTRDLFVBQVU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpREFBaUQ7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLHVHQUF1RztBQUN2RyxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXNpZy11dGlsL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NoYTMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNoYWtlMjU2ID0gZXhwb3J0cy5zaGFrZTEyOCA9IGV4cG9ydHMua2VjY2FrXzUxMiA9IGV4cG9ydHMua2VjY2FrXzM4NCA9IGV4cG9ydHMua2VjY2FrXzI1NiA9IGV4cG9ydHMua2VjY2FrXzIyNCA9IGV4cG9ydHMuc2hhM181MTIgPSBleHBvcnRzLnNoYTNfMzg0ID0gZXhwb3J0cy5zaGEzXzI1NiA9IGV4cG9ydHMuc2hhM18yMjQgPSBleHBvcnRzLktlY2NhayA9IGV4cG9ydHMua2VjY2FrUCA9IHZvaWQgMDtcbmNvbnN0IF9hc3NlcnRfanNfMSA9IHJlcXVpcmUoXCIuL19hc3NlcnQuanNcIik7XG5jb25zdCBfdTY0X2pzXzEgPSByZXF1aXJlKFwiLi9fdTY0LmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gU0hBMyAoa2VjY2FrKSBpcyBiYXNlZCBvbiBhIG5ldyBkZXNpZ246IGJhc2ljYWxseSwgdGhlIGludGVybmFsIHN0YXRlIGlzIGJpZ2dlciB0aGFuIG91dHB1dCBzaXplLlxuLy8gSXQncyBjYWxsZWQgYSBzcG9uZ2UgZnVuY3Rpb24uXG4vLyBWYXJpb3VzIHBlciByb3VuZCBjb25zdGFudHMgY2FsY3VsYXRpb25zXG5jb25zdCBTSEEzX1BJID0gW107XG5jb25zdCBTSEEzX1JPVEwgPSBbXTtcbmNvbnN0IF9TSEEzX0lPVEEgPSBbXTtcbmNvbnN0IF8wbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyKTtcbmNvbnN0IF83biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoNyk7XG5jb25zdCBfMjU2biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMjU2KTtcbmNvbnN0IF8weDcxbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMHg3MSk7XG5mb3IgKGxldCByb3VuZCA9IDAsIFIgPSBfMW4sIHggPSAxLCB5ID0gMDsgcm91bmQgPCAyNDsgcm91bmQrKykge1xuICAgIC8vIFBpXG4gICAgW3gsIHldID0gW3ksICgyICogeCArIDMgKiB5KSAlIDVdO1xuICAgIFNIQTNfUEkucHVzaCgyICogKDUgKiB5ICsgeCkpO1xuICAgIC8vIFJvdGF0aW9uYWxcbiAgICBTSEEzX1JPVEwucHVzaCgoKChyb3VuZCArIDEpICogKHJvdW5kICsgMikpIC8gMikgJSA2NCk7XG4gICAgLy8gSW90YVxuICAgIGxldCB0ID0gXzBuO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgNzsgaisrKSB7XG4gICAgICAgIFIgPSAoKFIgPDwgXzFuKSBeICgoUiA+PiBfN24pICogXzB4NzFuKSkgJSBfMjU2bjtcbiAgICAgICAgaWYgKFIgJiBfMm4pXG4gICAgICAgICAgICB0IF49IF8xbiA8PCAoKF8xbiA8PCAvKiBAX19QVVJFX18gKi8gQmlnSW50KGopKSAtIF8xbik7XG4gICAgfVxuICAgIF9TSEEzX0lPVEEucHVzaCh0KTtcbn1cbmNvbnN0IFtTSEEzX0lPVEFfSCwgU0hBM19JT1RBX0xdID0gLyogQF9fUFVSRV9fICovICgwLCBfdTY0X2pzXzEuc3BsaXQpKF9TSEEzX0lPVEEsIHRydWUpO1xuLy8gTGVmdCByb3RhdGlvbiAod2l0aG91dCAwLCAzMiwgNjQpXG5jb25zdCByb3RsSCA9IChoLCBsLCBzKSA9PiAocyA+IDMyID8gKDAsIF91NjRfanNfMS5yb3RsQkgpKGgsIGwsIHMpIDogKDAsIF91NjRfanNfMS5yb3RsU0gpKGgsIGwsIHMpKTtcbmNvbnN0IHJvdGxMID0gKGgsIGwsIHMpID0+IChzID4gMzIgPyAoMCwgX3U2NF9qc18xLnJvdGxCTCkoaCwgbCwgcykgOiAoMCwgX3U2NF9qc18xLnJvdGxTTCkoaCwgbCwgcykpO1xuLy8gU2FtZSBhcyBrZWNjYWtmMTYwMCwgYnV0IGFsbG93cyB0byBza2lwIHNvbWUgcm91bmRzXG5mdW5jdGlvbiBrZWNjYWtQKHMsIHJvdW5kcyA9IDI0KSB7XG4gICAgY29uc3QgQiA9IG5ldyBVaW50MzJBcnJheSg1ICogMik7XG4gICAgLy8gTk9URTogYWxsIGluZGljZXMgYXJlIHgyIHNpbmNlIHdlIHN0b3JlIHN0YXRlIGFzIHUzMiBpbnN0ZWFkIG9mIHU2NCAoYmlnaW50cyB0byBzbG93IGluIGpzKVxuICAgIGZvciAobGV0IHJvdW5kID0gMjQgLSByb3VuZHM7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAgICAgLy8gVGhldGEgzrhcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgQlt4XSA9IHNbeF0gXiBzW3ggKyAxMF0gXiBzW3ggKyAyMF0gXiBzW3ggKyAzMF0gXiBzW3ggKyA0MF07XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHggKz0gMikge1xuICAgICAgICAgICAgY29uc3QgaWR4MSA9ICh4ICsgOCkgJSAxMDtcbiAgICAgICAgICAgIGNvbnN0IGlkeDAgPSAoeCArIDIpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBCMCA9IEJbaWR4MF07XG4gICAgICAgICAgICBjb25zdCBCMSA9IEJbaWR4MCArIDFdO1xuICAgICAgICAgICAgY29uc3QgVGggPSByb3RsSChCMCwgQjEsIDEpIF4gQltpZHgxXTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoQjAsIEIxLCAxKSBeIEJbaWR4MSArIDFdO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xuICAgICAgICAgICAgICAgIHNbeCArIHldIF49IFRoO1xuICAgICAgICAgICAgICAgIHNbeCArIHkgKyAxXSBePSBUbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSaG8gKM+BKSBhbmQgUGkgKM+AKVxuICAgICAgICBsZXQgY3VySCA9IHNbMl07XG4gICAgICAgIGxldCBjdXJMID0gc1szXTtcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCAyNDsgdCsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaGlmdCA9IFNIQTNfUk9UTFt0XTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgVGwgPSByb3RsTChjdXJILCBjdXJMLCBzaGlmdCk7XG4gICAgICAgICAgICBjb25zdCBQSSA9IFNIQTNfUElbdF07XG4gICAgICAgICAgICBjdXJIID0gc1tQSV07XG4gICAgICAgICAgICBjdXJMID0gc1tQSSArIDFdO1xuICAgICAgICAgICAgc1tQSV0gPSBUaDtcbiAgICAgICAgICAgIHNbUEkgKyAxXSA9IFRsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoaSAoz4cpXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgICAgICBCW3hdID0gc1t5ICsgeF07XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgc1t5ICsgeF0gXj0gfkJbKHggKyAyKSAlIDEwXSAmIEJbKHggKyA0KSAlIDEwXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJb3RhICjOuSlcbiAgICAgICAgc1swXSBePSBTSEEzX0lPVEFfSFtyb3VuZF07XG4gICAgICAgIHNbMV0gXj0gU0hBM19JT1RBX0xbcm91bmRdO1xuICAgIH1cbiAgICBCLmZpbGwoMCk7XG59XG5leHBvcnRzLmtlY2Nha1AgPSBrZWNjYWtQO1xuY2xhc3MgS2VjY2FrIGV4dGVuZHMgdXRpbHNfanNfMS5IYXNoIHtcbiAgICAvLyBOT1RFOiB3ZSBhY2NlcHQgYXJndW1lbnRzIGluIGJ5dGVzIGluc3RlYWQgb2YgYml0cyBoZXJlLlxuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgZW5hYmxlWE9GID0gZmFsc2UsIHJvdW5kcyA9IDI0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcbiAgICAgICAgdGhpcy5yb3VuZHMgPSByb3VuZHM7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5wb3NPdXQgPSAwO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIC8vIENhbiBiZSBwYXNzZWQgZnJvbSB1c2VyIGFzIGRrTGVuXG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEubnVtYmVyKShvdXRwdXRMZW4pO1xuICAgICAgICAvLyAxNjAwID0gNXg1IG1hdHJpeCBvZiA2NGJpdC4gIDE2MDAgYml0cyA9PT0gMjAwIGJ5dGVzXG4gICAgICAgIGlmICgwID49IHRoaXMuYmxvY2tMZW4gfHwgdGhpcy5ibG9ja0xlbiA+PSAyMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYTMgc3VwcG9ydHMgb25seSBrZWNjYWstZjE2MDAgZnVuY3Rpb24nKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG5ldyBVaW50OEFycmF5KDIwMCk7XG4gICAgICAgIHRoaXMuc3RhdGUzMiA9ICgwLCB1dGlsc19qc18xLnUzMikodGhpcy5zdGF0ZSk7XG4gICAgfVxuICAgIGtlY2NhaygpIHtcbiAgICAgICAgaWYgKCF1dGlsc19qc18xLmlzTEUpXG4gICAgICAgICAgICAoMCwgdXRpbHNfanNfMS5ieXRlU3dhcDMyKSh0aGlzLnN0YXRlMzIpO1xuICAgICAgICBrZWNjYWtQKHRoaXMuc3RhdGUzMiwgdGhpcy5yb3VuZHMpO1xuICAgICAgICBpZiAoIXV0aWxzX2pzXzEuaXNMRSlcbiAgICAgICAgICAgICgwLCB1dGlsc19qc18xLmJ5dGVTd2FwMzIpKHRoaXMuc3RhdGUzMik7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmV4aXN0cykodGhpcyk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFrZTsgaSsrKVxuICAgICAgICAgICAgICAgIHN0YXRlW3RoaXMucG9zKytdIF49IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBzdGF0ZSwgc3VmZml4LCBwb3MsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICAvLyBEbyB0aGUgcGFkZGluZ1xuICAgICAgICBzdGF0ZVtwb3NdIF49IHN1ZmZpeDtcbiAgICAgICAgaWYgKChzdWZmaXggJiAweDgwKSAhPT0gMCAmJiBwb3MgPT09IGJsb2NrTGVuIC0gMSlcbiAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgIHN0YXRlW2Jsb2NrTGVuIC0gMV0gXj0gMHg4MDtcbiAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICB9XG4gICAgd3JpdGVJbnRvKG91dCkge1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmV4aXN0cykodGhpcywgZmFsc2UpO1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShvdXQpO1xuICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICBjb25zdCBidWZmZXJPdXQgPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBsZW4gPSBvdXQubGVuZ3RoOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3NPdXQgPj0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zT3V0LCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgb3V0LnNldChidWZmZXJPdXQuc3ViYXJyYXkodGhpcy5wb3NPdXQsIHRoaXMucG9zT3V0ICsgdGFrZSksIHBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvc091dCArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgeG9mSW50byhvdXQpIHtcbiAgICAgICAgLy8gU2hhMy9LZWNjYWsgdXNhZ2Ugd2l0aCBYT0YgaXMgcHJvYmFibHkgbWlzdGFrZSwgb25seSBTSEFLRSBpbnN0YW5jZXMgY2FuIGRvIFhPRlxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlWE9GKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdYT0YgaXMgbm90IHBvc3NpYmxlIGZvciB0aGlzIGluc3RhbmNlJyk7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlSW50byhvdXQpO1xuICAgIH1cbiAgICB4b2YoYnl0ZXMpIHtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5udW1iZXIpKGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMueG9mSW50byhuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLm91dHB1dCkob3V0LCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCgpIHdhcyBhbHJlYWR5IGNhbGxlZCcpO1xuICAgICAgICB0aGlzLndyaXRlSW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaWdlc3RJbnRvKG5ldyBVaW50OEFycmF5KHRoaXMub3V0cHV0TGVuKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdGF0ZS5maWxsKDApO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCByb3VuZHMsIGVuYWJsZVhPRiB9ID0gdGhpcztcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiwgcm91bmRzKSk7XG4gICAgICAgIHRvLnN0YXRlMzIuc2V0KHRoaXMuc3RhdGUzMik7XG4gICAgICAgIHRvLnBvcyA9IHRoaXMucG9zO1xuICAgICAgICB0by5wb3NPdXQgPSB0aGlzLnBvc091dDtcbiAgICAgICAgdG8uZmluaXNoZWQgPSB0aGlzLmZpbmlzaGVkO1xuICAgICAgICB0by5yb3VuZHMgPSByb3VuZHM7XG4gICAgICAgIC8vIFN1ZmZpeCBjYW4gY2hhbmdlIGluIGNTSEFLRVxuICAgICAgICB0by5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8uZW5hYmxlWE9GID0gZW5hYmxlWE9GO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSB0aGlzLmRlc3Ryb3llZDtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbmV4cG9ydHMuS2VjY2FrID0gS2VjY2FrO1xuY29uc3QgZ2VuID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gKDAsIHV0aWxzX2pzXzEud3JhcENvbnN0cnVjdG9yKSgoKSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbikpO1xuZXhwb3J0cy5zaGEzXzIyNCA9IGdlbigweDA2LCAxNDQsIDIyNCAvIDgpO1xuLyoqXG4gKiBTSEEzLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydHMuc2hhM18yNTYgPSBnZW4oMHgwNiwgMTM2LCAyNTYgLyA4KTtcbmV4cG9ydHMuc2hhM18zODQgPSBnZW4oMHgwNiwgMTA0LCAzODQgLyA4KTtcbmV4cG9ydHMuc2hhM181MTIgPSBnZW4oMHgwNiwgNzIsIDUxMiAvIDgpO1xuZXhwb3J0cy5rZWNjYWtfMjI0ID0gZ2VuKDB4MDEsIDE0NCwgMjI0IC8gOCk7XG4vKipcbiAqIGtlY2Nhay0yNTYgaGFzaCBmdW5jdGlvbi4gRGlmZmVyZW50IGZyb20gU0hBMy0yNTYuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydHMua2VjY2FrXzI1NiA9IGdlbigweDAxLCAxMzYsIDI1NiAvIDgpO1xuZXhwb3J0cy5rZWNjYWtfMzg0ID0gZ2VuKDB4MDEsIDEwNCwgMzg0IC8gOCk7XG5leHBvcnRzLmtlY2Nha181MTIgPSBnZW4oMHgwMSwgNzIsIDUxMiAvIDgpO1xuY29uc3QgZ2VuU2hha2UgPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiAoMCwgdXRpbHNfanNfMS53cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cykoKG9wdHMgPSB7fSkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvcHRzLmRrTGVuID09PSB1bmRlZmluZWQgPyBvdXRwdXRMZW4gOiBvcHRzLmRrTGVuLCB0cnVlKSk7XG5leHBvcnRzLnNoYWtlMTI4ID0gZ2VuU2hha2UoMHgxZiwgMTY4LCAxMjggLyA4KTtcbmV4cG9ydHMuc2hha2UyNTYgPSBnZW5TaGFrZSgweDFmLCAxMzYsIDI1NiAvIDgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/sha3.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/utils.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/utils.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.byteSwap32 = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = exports.isBytes = void 0;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nconst crypto_1 = __webpack_require__(/*! @noble/hashes/crypto */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/cryptoNode.js\");\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/_assert.js\");\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nexports.isBytes = isBytes;\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.u8 = u8;\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nexports.u32 = u32;\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.createView = createView;\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\nexports.rotr = rotr;\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\nexports.rotl = rotl;\nexports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nconst byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\nexports.byteSwap = byteSwap;\n// Conditionally byte swap if on a big-endian platform\nexports.byteSwapIfBE = exports.isLE ? (n) => n : (n) => (0, exports.byteSwap)(n);\n// In place byte swap for Uint32Array\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = (0, exports.byteSwap)(arr[i]);\n    }\n}\nexports.byteSwap32 = byteSwap32;\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    (0, _assert_js_1.bytes)(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexports.bytesToHex = bytesToHex;\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\nexports.hexToBytes = hexToBytes;\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\nexports.nextTick = nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\nexports.asyncLoop = asyncLoop;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nexports.utf8ToBytes = utf8ToBytes;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    (0, _assert_js_1.bytes)(data);\n    return data;\n}\nexports.toBytes = toBytes;\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        (0, _assert_js_1.bytes)(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nexports.concatBytes = concatBytes;\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.Hash = Hash;\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexports.checkOpts = checkOpts;\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexports.wrapConstructor = wrapConstructor;\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapConstructorWithOpts = wrapConstructorWithOpts;\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {\n        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\nexports.randomBytes = randomBytes;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyxrQ0FBa0MsR0FBRywrQkFBK0IsR0FBRyx1QkFBdUIsR0FBRyxpQkFBaUIsR0FBRyxZQUFZLEdBQUcsbUJBQW1CLEdBQUcsZUFBZSxHQUFHLG1CQUFtQixHQUFHLGlCQUFpQixHQUFHLGdCQUFnQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLG9CQUFvQixHQUFHLGdCQUFnQixHQUFHLFlBQVksR0FBRyxZQUFZLEdBQUcsWUFBWSxHQUFHLGtCQUFrQixHQUFHLFdBQVcsR0FBRyxVQUFVLEdBQUcsZUFBZTtBQUNwZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyxzSEFBc0I7QUFDL0MscUJBQXFCLG1CQUFPLENBQUMsMkdBQWM7QUFDM0MsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsMERBQTBEO0FBQzFEO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBleHBvcnRzLndyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzID0gZXhwb3J0cy53cmFwQ29uc3RydWN0b3JXaXRoT3B0cyA9IGV4cG9ydHMud3JhcENvbnN0cnVjdG9yID0gZXhwb3J0cy5jaGVja09wdHMgPSBleHBvcnRzLkhhc2ggPSBleHBvcnRzLmNvbmNhdEJ5dGVzID0gZXhwb3J0cy50b0J5dGVzID0gZXhwb3J0cy51dGY4VG9CeXRlcyA9IGV4cG9ydHMuYXN5bmNMb29wID0gZXhwb3J0cy5uZXh0VGljayA9IGV4cG9ydHMuaGV4VG9CeXRlcyA9IGV4cG9ydHMuYnl0ZXNUb0hleCA9IGV4cG9ydHMuYnl0ZVN3YXAzMiA9IGV4cG9ydHMuYnl0ZVN3YXBJZkJFID0gZXhwb3J0cy5ieXRlU3dhcCA9IGV4cG9ydHMuaXNMRSA9IGV4cG9ydHMucm90bCA9IGV4cG9ydHMucm90ciA9IGV4cG9ydHMuY3JlYXRlVmlldyA9IGV4cG9ydHMudTMyID0gZXhwb3J0cy51OCA9IGV4cG9ydHMuaXNCeXRlcyA9IHZvaWQgMDtcbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxuLy8gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCAoMjAyNS0wNC0zMCksIHdlIGNhbiBqdXN0IGRyb3AgdGhlIGltcG9ydC5cbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvY3J5cHRvXCIpO1xuY29uc3QgX2Fzc2VydF9qc18xID0gcmVxdWlyZShcIi4vX2Fzc2VydC5qc1wiKTtcbi8vIGV4cG9ydCB7IGlzQnl0ZXMgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuLy8gV2UgY2FuJ3QgcmV1c2UgaXNCeXRlcyBmcm9tIF9hc3NlcnQsIGJlY2F1c2Ugc29tZWhvdyB0aGlzIGNhdXNlcyBodWdlIHBlcmYgaXNzdWVzXG5mdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG5leHBvcnRzLmlzQnl0ZXMgPSBpc0J5dGVzO1xuLy8gQ2FzdCBhcnJheSB0byBkaWZmZXJlbnQgdHlwZVxuY29uc3QgdTggPSAoYXJyKSA9PiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0cy51OCA9IHU4O1xuY29uc3QgdTMyID0gKGFycikgPT4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xuZXhwb3J0cy51MzIgPSB1MzI7XG4vLyBDYXN0IGFycmF5IHRvIHZpZXdcbmNvbnN0IGNyZWF0ZVZpZXcgPSAoYXJyKSA9PiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydHMuY3JlYXRlVmlldyA9IGNyZWF0ZVZpZXc7XG4vLyBUaGUgcm90YXRlIHJpZ2h0IChjaXJjdWxhciByaWdodCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmNvbnN0IHJvdHIgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8ICgzMiAtIHNoaWZ0KSkgfCAod29yZCA+Pj4gc2hpZnQpO1xuZXhwb3J0cy5yb3RyID0gcm90cjtcbi8vIFRoZSByb3RhdGUgbGVmdCAoY2lyY3VsYXIgbGVmdCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmNvbnN0IHJvdGwgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8IHNoaWZ0KSB8ICgod29yZCA+Pj4gKDMyIC0gc2hpZnQpKSA+Pj4gMCk7XG5leHBvcnRzLnJvdGwgPSByb3RsO1xuZXhwb3J0cy5pc0xFID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NDtcbi8vIFRoZSBieXRlIHN3YXAgb3BlcmF0aW9uIGZvciB1aW50MzJcbmNvbnN0IGJ5dGVTd2FwID0gKHdvcmQpID0+ICgod29yZCA8PCAyNCkgJiAweGZmMDAwMDAwKSB8XG4gICAgKCh3b3JkIDw8IDgpICYgMHhmZjAwMDApIHxcbiAgICAoKHdvcmQgPj4+IDgpICYgMHhmZjAwKSB8XG4gICAgKCh3b3JkID4+PiAyNCkgJiAweGZmKTtcbmV4cG9ydHMuYnl0ZVN3YXAgPSBieXRlU3dhcDtcbi8vIENvbmRpdGlvbmFsbHkgYnl0ZSBzd2FwIGlmIG9uIGEgYmlnLWVuZGlhbiBwbGF0Zm9ybVxuZXhwb3J0cy5ieXRlU3dhcElmQkUgPSBleHBvcnRzLmlzTEUgPyAobikgPT4gbiA6IChuKSA9PiAoMCwgZXhwb3J0cy5ieXRlU3dhcCkobik7XG4vLyBJbiBwbGFjZSBieXRlIHN3YXAgZm9yIFVpbnQzMkFycmF5XG5mdW5jdGlvbiBieXRlU3dhcDMyKGFycikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9ICgwLCBleHBvcnRzLmJ5dGVTd2FwKShhcnJbaV0pO1xuICAgIH1cbn1cbmV4cG9ydHMuYnl0ZVN3YXAzMiA9IGJ5dGVTd2FwMzI7XG4vLyBBcnJheSB3aGVyZSBpbmRleCAweGYwICgyNDApIGlzIG1hcHBlZCB0byBzdHJpbmcgJ2YwJ1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5mdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgKDAsIF9hc3NlcnRfanNfMS5ieXRlcykoYnl0ZXMpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5leHBvcnRzLmJ5dGVzVG9IZXggPSBieXRlc1RvSGV4O1xuLy8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbmNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIF9BOiA2NSwgX0Y6IDcwLCBfYTogOTcsIF9mOiAxMDIgfTtcbmZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2hhcikge1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fMCAmJiBjaGFyIDw9IGFzY2lpcy5fOSlcbiAgICAgICAgcmV0dXJuIGNoYXIgLSBhc2NpaXMuXzA7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9BICYmIGNoYXIgPD0gYXNjaWlzLl9GKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX0EgLSAxMCk7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9hICYmIGNoYXIgPD0gYXNjaWlzLl9mKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX2EgLSAxMCk7XG4gICAgcmV0dXJuO1xufVxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBobCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhbCk7XG4gICAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcbiAgICAgICAgY29uc3QgbjEgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpKSk7XG4gICAgICAgIGNvbnN0IG4yID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSArIDEpKTtcbiAgICAgICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGhleFtoaV0gKyBoZXhbaGkgKyAxXTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheVthaV0gPSBuMSAqIDE2ICsgbjI7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbmV4cG9ydHMuaGV4VG9CeXRlcyA9IGhleFRvQnl0ZXM7XG4vLyBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LlxuLy8gY2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXG4vLyBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5jb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbmV4cG9ydHMubmV4dFRpY2sgPSBuZXh0VGljaztcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgICAgICBjYihpKTtcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhd2FpdCAoMCwgZXhwb3J0cy5uZXh0VGljaykoKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG5leHBvcnRzLmFzeW5jTG9vcCA9IGFzeW5jTG9vcDtcbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG5leHBvcnRzLnV0ZjhUb0J5dGVzID0gdXRmOFRvQnl0ZXM7XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKGRhdGEpO1xuICAgIHJldHVybiBkYXRhO1xufVxuZXhwb3J0cy50b0J5dGVzID0gdG9CeXRlcztcbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKGEpO1xuICAgICAgICBzdW0gKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHN1bSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5leHBvcnRzLmNvbmNhdEJ5dGVzID0gY29uY2F0Qnl0ZXM7XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuY2xhc3MgSGFzaCB7XG4gICAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG5leHBvcnRzLkhhc2ggPSBIYXNoO1xuY29uc3QgdG9TdHIgPSB7fS50b1N0cmluZztcbmZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYgdG9TdHIuY2FsbChvcHRzKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZCcpO1xuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuICAgIHJldHVybiBtZXJnZWQ7XG59XG5leHBvcnRzLmNoZWNrT3B0cyA9IGNoZWNrT3B0cztcbmZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnRzLndyYXBDb25zdHJ1Y3RvciA9IHdyYXBDb25zdHJ1Y3RvcjtcbmZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0cy53cmFwQ29uc3RydWN0b3JXaXRoT3B0cyA9IHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzO1xuZnVuY3Rpb24gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnRzLndyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzID0gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHM7XG4vKipcbiAqIFNlY3VyZSBQUk5HLiBVc2VzIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYCwgd2hpY2ggZGVmZXJzIHRvIE9TLlxuICovXG5mdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgaWYgKGNyeXB0b18xLmNyeXB0byAmJiB0eXBlb2YgY3J5cHRvXzEuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvXzEuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG59XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gcmFuZG9tQnl0ZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/utils.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@scure/base/lib/index.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/@scure/base/lib/index.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.createBase58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64urlnopad = exports.base64url = exports.base64nopad = exports.base64 = exports.base32crockford = exports.base32hexnopad = exports.base32hex = exports.base32nopad = exports.base32 = exports.base16 = exports.utils = void 0;\nexports.assertNumber = assertNumber;\n// Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain(...args) {\n    const id = (a) => a;\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b) => (c) => a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.map((x) => x.decode).reduce(wrap, id);\n    return { encode, decode };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            const rounded = Math.floor(digitBase / to);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!rounded)\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = /* @__NO_SIDE_EFFECTS__ */ (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of numbers');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of numbers');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\n// prettier-ignore\nexports.utils = {\n    alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\nexports.base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nexports.base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nexports.base32nopad = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), join(''));\nexports.base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nexports.base32hexnopad = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), join(''));\nexports.base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nexports.base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nexports.base64nopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), join(''));\nexports.base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nexports.base64urlnopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nexports.base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nexports.base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nexports.base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nexports.base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = exports.base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nconst createBase58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), exports.base58);\nexports.createBase58check = createBase58check;\n// legacy export, bad name\nexports.base58check = exports.createBase58check;\nconst BECH_ALPHABET = /* @__PURE__ */ chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (words instanceof Uint8Array)\n            words = Array.from(words);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        if (prefix.length === 0)\n            throw new TypeError(`Invalid prefix length ${prefix.length}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        const sepIndex = lowered.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = lowered.slice(0, sepIndex);\n        const data = lowered.slice(sepIndex + 1);\n        if (data.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(data).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!data.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    function encodeFromBytes(prefix, bytes) {\n        return encode(prefix, toWords(bytes));\n    }\n    return {\n        encode,\n        decode,\n        encodeFromBytes,\n        decodeToBytes,\n        decodeUnsafe,\n        fromWords,\n        fromWordsUnsafe,\n        toWords,\n    };\n}\nexports.bech32 = genBech32('bech32');\nexports.bech32m = genBech32('bech32m');\nexports.utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nexports.hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8: exports.utf8, hex: exports.hex, base16: exports.base16, base32: exports.base32, base64: exports.base64, base64url: exports.base64url, base58: exports.base58, base58xmr: exports.base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\nconst bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!isBytes(bytes))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nexports.bytesToString = bytesToString;\nexports.str = exports.bytesToString; // as in python, but for bytes only\nconst stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nexports.stringToBytes = stringToBytes;\nexports.bytes = exports.stringToBytes;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0BzY3VyZS9iYXNlL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsR0FBRyxxQkFBcUIsR0FBRyxXQUFXLEdBQUcscUJBQXFCLEdBQUcsV0FBVyxHQUFHLFlBQVksR0FBRyxlQUFlLEdBQUcsY0FBYyxHQUFHLG1CQUFtQixHQUFHLHlCQUF5QixHQUFHLGlCQUFpQixHQUFHLGlCQUFpQixHQUFHLG9CQUFvQixHQUFHLGNBQWMsR0FBRyxzQkFBc0IsR0FBRyxpQkFBaUIsR0FBRyxtQkFBbUIsR0FBRyxjQUFjLEdBQUcsdUJBQXVCLEdBQUcsc0JBQXNCLEdBQUcsaUJBQWlCLEdBQUcsbUJBQW1CLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxhQUFhO0FBQ2hmLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsRUFBRTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxHQUFHLGFBQWEsZ0JBQWdCO0FBQ3JHO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLE9BQU87QUFDbEY7QUFDQTtBQUNBLHdEQUF3RCxPQUFPLGNBQWMsU0FBUztBQUN0RjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxFQUFFO0FBQ3ZFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLEVBQUU7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsRUFBRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUNBQW1DO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxLQUFLO0FBQ3pEO0FBQ0Esa0RBQWtELEdBQUc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsRUFBRTtBQUNoRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNDQUFzQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxLQUFLO0FBQzFEO0FBQ0EsbURBQW1ELEdBQUc7QUFDdEQ7QUFDQSw4REFBOEQsTUFBTSxLQUFLLElBQUksWUFBWSxzQkFBc0I7QUFDL0c7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLEdBQUcsT0FBTyxLQUFLO0FBQy9FO0FBQ0E7QUFDQSxpRUFBaUUsS0FBSyxPQUFPLEtBQUs7QUFDbEY7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxNQUFNO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsY0FBYztBQUNkLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakIsc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2QixjQUFjO0FBQ2QsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLG9CQUFvQjtBQUNwQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZCQUE2QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxjQUFjO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixhQUFhO0FBQ2hHO0FBQ0EseURBQXlELGNBQWM7QUFDdkU7QUFDQTtBQUNBLDBDQUEwQyxjQUFjLGdCQUFnQixNQUFNO0FBQzlFO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUSxHQUFHLDRCQUE0QixFQUFFLElBQUk7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLFdBQVc7QUFDcEY7QUFDQSx3REFBd0QsWUFBWSxHQUFHLElBQUksa0JBQWtCLE1BQU07QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxJQUFJLGNBQWMsSUFBSTtBQUN6RSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGVBQWU7QUFDZixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsZ0VBQWdFLFVBQVUsY0FBYyxTQUFTO0FBQ2pHO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixXQUFXLDBCQUEwQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0BzY3VyZS9iYXNlL2xpYi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qISBzY3VyZS1iYXNlIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJ5dGVzID0gZXhwb3J0cy5zdHJpbmdUb0J5dGVzID0gZXhwb3J0cy5zdHIgPSBleHBvcnRzLmJ5dGVzVG9TdHJpbmcgPSBleHBvcnRzLmhleCA9IGV4cG9ydHMudXRmOCA9IGV4cG9ydHMuYmVjaDMybSA9IGV4cG9ydHMuYmVjaDMyID0gZXhwb3J0cy5iYXNlNThjaGVjayA9IGV4cG9ydHMuY3JlYXRlQmFzZTU4Y2hlY2sgPSBleHBvcnRzLmJhc2U1OHhtciA9IGV4cG9ydHMuYmFzZTU4eHJwID0gZXhwb3J0cy5iYXNlNThmbGlja3IgPSBleHBvcnRzLmJhc2U1OCA9IGV4cG9ydHMuYmFzZTY0dXJsbm9wYWQgPSBleHBvcnRzLmJhc2U2NHVybCA9IGV4cG9ydHMuYmFzZTY0bm9wYWQgPSBleHBvcnRzLmJhc2U2NCA9IGV4cG9ydHMuYmFzZTMyY3JvY2tmb3JkID0gZXhwb3J0cy5iYXNlMzJoZXhub3BhZCA9IGV4cG9ydHMuYmFzZTMyaGV4ID0gZXhwb3J0cy5iYXNlMzJub3BhZCA9IGV4cG9ydHMuYmFzZTMyID0gZXhwb3J0cy5iYXNlMTYgPSBleHBvcnRzLnV0aWxzID0gdm9pZCAwO1xuZXhwb3J0cy5hc3NlcnROdW1iZXIgPSBhc3NlcnROdW1iZXI7XG4vLyBVdGlsaXRpZXNcbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0TnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIGludGVnZXI6ICR7bn1gKTtcbn1cbmZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gY2hhaW4oLi4uYXJncykge1xuICAgIGNvbnN0IGlkID0gKGEpID0+IGE7XG4gICAgLy8gV3JhcCBjYWxsIGluIGNsb3N1cmUgc28gSklUIGNhbiBpbmxpbmUgY2FsbHNcbiAgICBjb25zdCB3cmFwID0gKGEsIGIpID0+IChjKSA9PiBhKGIoYykpO1xuICAgIC8vIENvbnN0cnVjdCBjaGFpbiBvZiBhcmdzWy0xXS5lbmNvZGUoYXJnc1stMl0uZW5jb2RlKFsuLi5dKSlcbiAgICBjb25zdCBlbmNvZGUgPSBhcmdzLm1hcCgoeCkgPT4geC5lbmNvZGUpLnJlZHVjZVJpZ2h0KHdyYXAsIGlkKTtcbiAgICAvLyBDb25zdHJ1Y3QgY2hhaW4gb2YgYXJnc1swXS5kZWNvZGUoYXJnc1sxXS5kZWNvZGUoLi4uKSlcbiAgICBjb25zdCBkZWNvZGUgPSBhcmdzLm1hcCgoeCkgPT4geC5kZWNvZGUpLnJlZHVjZSh3cmFwLCBpZCk7XG4gICAgcmV0dXJuIHsgZW5jb2RlLCBkZWNvZGUgfTtcbn1cbi8qKlxuICogRW5jb2RlcyBpbnRlZ2VyIHJhZGl4IHJlcHJlc2VudGF0aW9uIHRvIGFycmF5IG9mIHN0cmluZ3MgdXNpbmcgYWxwaGFiZXQgYW5kIGJhY2tcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGFscGhhYmV0KGFscGhhYmV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbHBoYWJldC5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFuIGFycmF5IG9mIG51bWJlcnMnKTtcbiAgICAgICAgICAgIHJldHVybiBkaWdpdHMubWFwKChpKSA9PiB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0TnVtYmVyKGkpO1xuICAgICAgICAgICAgICAgIGlmIChpIDwgMCB8fCBpID49IGFscGhhYmV0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaWdpdCBpbmRleCBvdXRzaWRlIGFscGhhYmV0OiAke2l9IChhbHBoYWJldDogJHthbHBoYWJldC5sZW5ndGh9KWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBhbHBoYWJldFtpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSB8fCAoaW5wdXQubGVuZ3RoICYmIHR5cGVvZiBpbnB1dFswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWxwaGFiZXQuZGVjb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQubWFwKChsZXR0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxldHRlciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYWxwaGFiZXQuZGVjb2RlOiBub3Qgc3RyaW5nIGVsZW1lbnQ9JHtsZXR0ZXJ9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBhbHBoYWJldC5pbmRleE9mKGxldHRlcik7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGxldHRlcjogXCIke2xldHRlcn1cIi4gQWxsb3dlZDogJHthbHBoYWJldH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBqb2luKHNlcGFyYXRvciA9ICcnKSB7XG4gICAgaWYgKHR5cGVvZiBzZXBhcmF0b3IgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2pvaW4gc2VwYXJhdG9yIHNob3VsZCBiZSBzdHJpbmcnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChmcm9tKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZnJvbSkgfHwgKGZyb20ubGVuZ3RoICYmIHR5cGVvZiBmcm9tWzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqb2luLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBmcm9tKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgam9pbi5lbmNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtpfWApO1xuICAgICAgICAgICAgcmV0dXJuIGZyb20uam9pbihzZXBhcmF0b3IpO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6ICh0bykgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0byAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqb2luLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgc3RyaW5nJyk7XG4gICAgICAgICAgICByZXR1cm4gdG8uc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBQYWQgc3RyaW5ncyBhcnJheSBzbyBpdCBoYXMgaW50ZWdlciBudW1iZXIgb2YgYml0c1xuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gcGFkZGluZyhiaXRzLCBjaHIgPSAnPScpIHtcbiAgICBhc3NlcnROdW1iZXIoYml0cyk7XG4gICAgaWYgKHR5cGVvZiBjaHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmcgY2hyIHNob3VsZCBiZSBzdHJpbmcnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpIHx8IChkYXRhLmxlbmd0aCAmJiB0eXBlb2YgZGF0YVswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZy5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgb2YgZGF0YSlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZGRpbmcuZW5jb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgICAgICAgIHdoaWxlICgoZGF0YS5sZW5ndGggKiBiaXRzKSAlIDgpXG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKGNocik7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlKGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpIHx8IChpbnB1dC5sZW5ndGggJiYgdHlwZW9mIGlucHV0WzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBpbnB1dClcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZGRpbmcuZGVjb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgICAgICAgIGxldCBlbmQgPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoKGVuZCAqIGJpdHMpICUgOClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFkZGluZzogc3RyaW5nIHNob3VsZCBoYXZlIHdob2xlIG51bWJlciBvZiBieXRlcycpO1xuICAgICAgICAgICAgZm9yICg7IGVuZCA+IDAgJiYgaW5wdXRbZW5kIC0gMV0gPT09IGNocjsgZW5kLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoISgoKGVuZCAtIDEpICogYml0cykgJSA4KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhZGRpbmc6IHN0cmluZyBoYXMgdG9vIG11Y2ggcGFkZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnNsaWNlKDAsIGVuZCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3JtYWxpemUgZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIHsgZW5jb2RlOiAoZnJvbSkgPT4gZnJvbSwgZGVjb2RlOiAodG8pID0+IGZuKHRvKSB9O1xufVxuLyoqXG4gKiBTbG93OiBPKG5eMikgdGltZSBjb21wbGV4aXR5XG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBjb252ZXJ0UmFkaXgoZGF0YSwgZnJvbSwgdG8pIHtcbiAgICAvLyBiYXNlIDEgaXMgaW1wb3NzaWJsZVxuICAgIGlmIChmcm9tIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXg6IHdyb25nIGZyb209JHtmcm9tfSwgYmFzZSBjYW5ub3QgYmUgbGVzcyB0aGFuIDJgKTtcbiAgICBpZiAodG8gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDogd3JvbmcgdG89JHt0b30sIGJhc2UgY2Fubm90IGJlIGxlc3MgdGhhbiAyYCk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogZGF0YSBzaG91bGQgYmUgYXJyYXknKTtcbiAgICBpZiAoIWRhdGEubGVuZ3RoKVxuICAgICAgICByZXR1cm4gW107XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgY29uc3QgZGlnaXRzID0gQXJyYXkuZnJvbShkYXRhKTtcbiAgICBkaWdpdHMuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgICBhc3NlcnROdW1iZXIoZCk7XG4gICAgICAgIGlmIChkIDwgMCB8fCBkID49IGZyb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIGludGVnZXI6ICR7ZH1gKTtcbiAgICB9KTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgY2FycnkgPSAwO1xuICAgICAgICBsZXQgZG9uZSA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBkaWdpdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZ2l0ID0gZGlnaXRzW2ldO1xuICAgICAgICAgICAgY29uc3QgZGlnaXRCYXNlID0gZnJvbSAqIGNhcnJ5ICsgZGlnaXQ7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGRpZ2l0QmFzZSkgfHxcbiAgICAgICAgICAgICAgICAoZnJvbSAqIGNhcnJ5KSAvIGZyb20gIT09IGNhcnJ5IHx8XG4gICAgICAgICAgICAgICAgZGlnaXRCYXNlIC0gZGlnaXQgIT09IGZyb20gKiBjYXJyeSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBjYXJyeSBvdmVyZmxvdycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FycnkgPSBkaWdpdEJhc2UgJSB0bztcbiAgICAgICAgICAgIGNvbnN0IHJvdW5kZWQgPSBNYXRoLmZsb29yKGRpZ2l0QmFzZSAvIHRvKTtcbiAgICAgICAgICAgIGRpZ2l0c1tpXSA9IHJvdW5kZWQ7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHJvdW5kZWQpIHx8IHJvdW5kZWQgKiB0byArIGNhcnJ5ICE9PSBkaWdpdEJhc2UpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgICAgICAgICBpZiAoIWRvbmUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBlbHNlIGlmICghcm91bmRlZClcbiAgICAgICAgICAgICAgICBwb3MgPSBpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChjYXJyeSk7XG4gICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggLSAxICYmIGRhdGFbaV0gPT09IDA7IGkrKylcbiAgICAgICAgcmVzLnB1c2goMCk7XG4gICAgcmV0dXJuIHJlcy5yZXZlcnNlKCk7XG59XG5jb25zdCBnY2QgPSAvKiBAX19OT19TSURFX0VGRkVDVFNfXyAqLyAoYSwgYikgPT4gKCFiID8gYSA6IGdjZChiLCBhICUgYikpO1xuY29uc3QgcmFkaXgyY2FycnkgPSAvKkBfX05PX1NJREVfRUZGRUNUU19fICovIChmcm9tLCB0bykgPT4gZnJvbSArICh0byAtIGdjZChmcm9tLCB0bykpO1xuLyoqXG4gKiBJbXBsZW1lbnRlZCB3aXRoIG51bWJlcnMsIGJlY2F1c2UgQmlnSW50IGlzIDV4IHNsb3dlclxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gY29udmVydFJhZGl4MihkYXRhLCBmcm9tLCB0bywgcGFkZGluZykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXgyOiBkYXRhIHNob3VsZCBiZSBhcnJheScpO1xuICAgIGlmIChmcm9tIDw9IDAgfHwgZnJvbSA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IHdyb25nIGZyb209JHtmcm9tfWApO1xuICAgIGlmICh0byA8PSAwIHx8IHRvID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4Mjogd3JvbmcgdG89JHt0b31gKTtcbiAgICBpZiAocmFkaXgyY2FycnkoZnJvbSwgdG8pID4gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBjYXJyeSBvdmVyZmxvdyBmcm9tPSR7ZnJvbX0gdG89JHt0b30gY2FycnlCaXRzPSR7cmFkaXgyY2FycnkoZnJvbSwgdG8pfWApO1xuICAgIH1cbiAgICBsZXQgY2FycnkgPSAwO1xuICAgIGxldCBwb3MgPSAwOyAvLyBiaXR3aXNlIHBvc2l0aW9uIGluIGN1cnJlbnQgZWxlbWVudFxuICAgIGNvbnN0IG1hc2sgPSAyICoqIHRvIC0gMTtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgZGF0YSkge1xuICAgICAgICBhc3NlcnROdW1iZXIobik7XG4gICAgICAgIGlmIChuID49IDIgKiogZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogaW52YWxpZCBkYXRhIHdvcmQ9JHtufSBmcm9tPSR7ZnJvbX1gKTtcbiAgICAgICAgY2FycnkgPSAoY2FycnkgPDwgZnJvbSkgfCBuO1xuICAgICAgICBpZiAocG9zICsgZnJvbSA+IDMyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBjYXJyeSBvdmVyZmxvdyBwb3M9JHtwb3N9IGZyb209JHtmcm9tfWApO1xuICAgICAgICBwb3MgKz0gZnJvbTtcbiAgICAgICAgZm9yICg7IHBvcyA+PSB0bzsgcG9zIC09IHRvKVxuICAgICAgICAgICAgcmVzLnB1c2goKChjYXJyeSA+PiAocG9zIC0gdG8pKSAmIG1hc2spID4+PiAwKTtcbiAgICAgICAgY2FycnkgJj0gMiAqKiBwb3MgLSAxOyAvLyBjbGVhbiBjYXJyeSwgb3RoZXJ3aXNlIGl0IHdpbGwgY2F1c2Ugb3ZlcmZsb3dcbiAgICB9XG4gICAgY2FycnkgPSAoY2FycnkgPDwgKHRvIC0gcG9zKSkgJiBtYXNrO1xuICAgIGlmICghcGFkZGluZyAmJiBwb3MgPj0gZnJvbSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeGNlc3MgcGFkZGluZycpO1xuICAgIGlmICghcGFkZGluZyAmJiBjYXJyeSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb24temVybyBwYWRkaW5nOiAke2NhcnJ5fWApO1xuICAgIGlmIChwYWRkaW5nICYmIHBvcyA+IDApXG4gICAgICAgIHJlcy5wdXNoKGNhcnJ5ID4+PiAwKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiByYWRpeChudW0pIHtcbiAgICBhc3NlcnROdW1iZXIobnVtKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc0J5dGVzKGJ5dGVzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4LmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRSYWRpeChBcnJheS5mcm9tKGJ5dGVzKSwgMiAqKiA4LCBudW0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkaWdpdHMpIHx8IChkaWdpdHMubGVuZ3RoICYmIHR5cGVvZiBkaWdpdHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4LmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2YgbnVtYmVycycpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjb252ZXJ0UmFkaXgoZGlnaXRzLCBudW0sIDIgKiogOCkpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIElmIGJvdGggYmFzZXMgYXJlIHBvd2VyIG9mIHNhbWUgbnVtYmVyIChsaWtlIGAyKio4IDwtPiAyKio2NGApLFxuICogdGhlcmUgaXMgYSBsaW5lYXIgYWxnb3JpdGhtLiBGb3Igbm93IHdlIGhhdmUgaW1wbGVtZW50YXRpb24gZm9yIHBvd2VyLW9mLXR3byBiYXNlcyBvbmx5LlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gcmFkaXgyKGJpdHMsIHJldlBhZGRpbmcgPSBmYWxzZSkge1xuICAgIGFzc2VydE51bWJlcihiaXRzKTtcbiAgICBpZiAoYml0cyA8PSAwIHx8IGJpdHMgPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDI6IGJpdHMgc2hvdWxkIGJlIGluICgwLi4zMl0nKTtcbiAgICBpZiAocmFkaXgyY2FycnkoOCwgYml0cykgPiAzMiB8fCByYWRpeDJjYXJyeShiaXRzLCA4KSA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4MjogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc0J5dGVzKGJ5dGVzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4Mi5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0UmFkaXgyKEFycmF5LmZyb20oYnl0ZXMpLCA4LCBiaXRzLCAhcmV2UGFkZGluZyk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRpZ2l0cykgfHwgKGRpZ2l0cy5sZW5ndGggJiYgdHlwZW9mIGRpZ2l0c1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2YgbnVtYmVycycpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjb252ZXJ0UmFkaXgyKGRpZ2l0cywgYml0cywgOCwgcmV2UGFkZGluZykpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIHVuc2FmZVdyYXBwZXIoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc2FmZVdyYXBwZXIgZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgIH07XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGNoZWNrc3VtKGxlbiwgZm4pIHtcbiAgICBhc3NlcnROdW1iZXIobGVuKTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtIGZuIHNob3VsZCBiZSBmdW5jdGlvbicpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIWlzQnl0ZXMoZGF0YSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bS5lbmNvZGU6IGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICBjb25zdCBjaGVja3N1bSA9IGZuKGRhdGEpLnNsaWNlKDAsIGxlbik7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCArIGxlbik7XG4gICAgICAgICAgICByZXMuc2V0KGRhdGEpO1xuICAgICAgICAgICAgcmVzLnNldChjaGVja3N1bSwgZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghaXNCeXRlcyhkYXRhKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtLmRlY29kZTogaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBkYXRhLnNsaWNlKDAsIC1sZW4pO1xuICAgICAgICAgICAgY29uc3QgbmV3Q2hlY2tzdW0gPSBmbihwYXlsb2FkKS5zbGljZSgwLCBsZW4pO1xuICAgICAgICAgICAgY29uc3Qgb2xkQ2hlY2tzdW0gPSBkYXRhLnNsaWNlKC1sZW4pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICAgICAgICBpZiAobmV3Q2hlY2tzdW1baV0gIT09IG9sZENoZWNrc3VtW2ldKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2hlY2tzdW0nKTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydHMudXRpbHMgPSB7XG4gICAgYWxwaGFiZXQsIGNoYWluLCBjaGVja3N1bSwgY29udmVydFJhZGl4LCBjb252ZXJ0UmFkaXgyLCByYWRpeCwgcmFkaXgyLCBqb2luLCBwYWRkaW5nLFxufTtcbi8vIFJGQyA0NjQ4IGFrYSBSRkMgMzU0OFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5leHBvcnRzLmJhc2UxNiA9IGNoYWluKHJhZGl4Mig0KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUYnKSwgam9pbignJykpO1xuZXhwb3J0cy5iYXNlMzIgPSBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2NycpLCBwYWRkaW5nKDUpLCBqb2luKCcnKSk7XG5leHBvcnRzLmJhc2UzMm5vcGFkID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjcnKSwgam9pbignJykpO1xuZXhwb3J0cy5iYXNlMzJoZXggPSBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVicpLCBwYWRkaW5nKDUpLCBqb2luKCcnKSk7XG5leHBvcnRzLmJhc2UzMmhleG5vcGFkID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVYnKSwgam9pbignJykpO1xuZXhwb3J0cy5iYXNlMzJjcm9ja2ZvcmQgPSBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGR0hKS01OUFFSU1RWV1hZWicpLCBqb2luKCcnKSwgbm9ybWFsaXplKChzKSA9PiBzLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvTy9nLCAnMCcpLnJlcGxhY2UoL1tJTF0vZywgJzEnKSkpO1xuZXhwb3J0cy5iYXNlNjQgPSBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyksIHBhZGRpbmcoNiksIGpvaW4oJycpKTtcbmV4cG9ydHMuYmFzZTY0bm9wYWQgPSBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyksIGpvaW4oJycpKTtcbmV4cG9ydHMuYmFzZTY0dXJsID0gY2hhaW4ocmFkaXgyKDYpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXycpLCBwYWRkaW5nKDYpLCBqb2luKCcnKSk7XG5leHBvcnRzLmJhc2U2NHVybG5vcGFkID0gY2hhaW4ocmFkaXgyKDYpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXycpLCBqb2luKCcnKSk7XG4vLyBiYXNlNTggY29kZVxuLy8gLS0tLS0tLS0tLS1cbmNvbnN0IGdlbkJhc2U1OCA9IChhYmMpID0+IGNoYWluKHJhZGl4KDU4KSwgYWxwaGFiZXQoYWJjKSwgam9pbignJykpO1xuZXhwb3J0cy5iYXNlNTggPSBnZW5CYXNlNTgoJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonKTtcbmV4cG9ydHMuYmFzZTU4ZmxpY2tyID0gZ2VuQmFzZTU4KCcxMjM0NTY3ODlhYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaJyk7XG5leHBvcnRzLmJhc2U1OHhycCA9IGdlbkJhc2U1OCgncnBzaG5hZjM5d0JVRE5FR0hKS0xNNFBRUlNUN1ZXWFlaMmJjZGVDZzY1amttOG9GcWkxdHV2QXh5eicpO1xuLy8geG1yIHZlciBpcyBkb25lIGluIDgtYnl0ZSBibG9ja3MgKHdoaWNoIGVxdWFscyAxMSBjaGFycyBpbiBkZWNvZGluZykuIExhc3QgKG5vbi1mdWxsKSBibG9jayBwYWRkZWQgd2l0aCAnMScgdG8gc2l6ZSBpbiBYTVJfQkxPQ0tfTEVOLlxuLy8gQmxvY2sgZW5jb2Rpbmcgc2lnbmlmaWNhbnRseSByZWR1Y2VzIHF1YWRyYXRpYyBjb21wbGV4aXR5IG9mIGJhc2U1OC5cbi8vIERhdGEgbGVuIChpbmRleCkgLT4gZW5jb2RlZCBibG9jayBsZW5cbmNvbnN0IFhNUl9CTE9DS19MRU4gPSBbMCwgMiwgMywgNSwgNiwgNywgOSwgMTAsIDExXTtcbmV4cG9ydHMuYmFzZTU4eG1yID0ge1xuICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgIGxldCByZXMgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA4KSB7XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IGRhdGEuc3ViYXJyYXkoaSwgaSArIDgpO1xuICAgICAgICAgICAgcmVzICs9IGV4cG9ydHMuYmFzZTU4LmVuY29kZShibG9jaykucGFkU3RhcnQoWE1SX0JMT0NLX0xFTltibG9jay5sZW5ndGhdLCAnMScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBkZWNvZGUoc3RyKSB7XG4gICAgICAgIGxldCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDExKSB7XG4gICAgICAgICAgICBjb25zdCBzbGljZSA9IHN0ci5zbGljZShpLCBpICsgMTEpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2tMZW4gPSBYTVJfQkxPQ0tfTEVOLmluZGV4T2Yoc2xpY2UubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gZXhwb3J0cy5iYXNlNTguZGVjb2RlKHNsaWNlKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmxvY2subGVuZ3RoIC0gYmxvY2tMZW47IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChibG9ja1tqXSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYXNlNTh4bXI6IHdyb25nIHBhZGRpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoQXJyYXkuZnJvbShibG9jay5zbGljZShibG9jay5sZW5ndGggLSBibG9ja0xlbikpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKHJlcyk7XG4gICAgfSxcbn07XG5jb25zdCBjcmVhdGVCYXNlNThjaGVjayA9IChzaGEyNTYpID0+IGNoYWluKGNoZWNrc3VtKDQsIChkYXRhKSA9PiBzaGEyNTYoc2hhMjU2KGRhdGEpKSksIGV4cG9ydHMuYmFzZTU4KTtcbmV4cG9ydHMuY3JlYXRlQmFzZTU4Y2hlY2sgPSBjcmVhdGVCYXNlNThjaGVjaztcbi8vIGxlZ2FjeSBleHBvcnQsIGJhZCBuYW1lXG5leHBvcnRzLmJhc2U1OGNoZWNrID0gZXhwb3J0cy5jcmVhdGVCYXNlNThjaGVjaztcbmNvbnN0IEJFQ0hfQUxQSEFCRVQgPSAvKiBAX19QVVJFX18gKi8gY2hhaW4oYWxwaGFiZXQoJ3FwenJ5OXg4Z2YydHZkdzBzM2puNTRraGNlNm11YTdsJyksIGpvaW4oJycpKTtcbmNvbnN0IFBPTFlNT0RfR0VORVJBVE9SUyA9IFsweDNiNmE1N2IyLCAweDI2NTA4ZTZkLCAweDFlYTExOWZhLCAweDNkNDIzM2RkLCAweDJhMTQ2MmIzXTtcbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gYmVjaDMyUG9seW1vZChwcmUpIHtcbiAgICBjb25zdCBiID0gcHJlID4+IDI1O1xuICAgIGxldCBjaGsgPSAocHJlICYgMHgxZmZmZmZmKSA8PCA1O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgUE9MWU1PRF9HRU5FUkFUT1JTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgoKGIgPj4gaSkgJiAxKSA9PT0gMSlcbiAgICAgICAgICAgIGNoayBePSBQT0xZTU9EX0dFTkVSQVRPUlNbaV07XG4gICAgfVxuICAgIHJldHVybiBjaGs7XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGJlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBlbmNvZGluZ0NvbnN0ID0gMSkge1xuICAgIGNvbnN0IGxlbiA9IHByZWZpeC5sZW5ndGg7XG4gICAgbGV0IGNoayA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBjID0gcHJlZml4LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMzMgfHwgYyA+IDEyNilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwcmVmaXggKCR7cHJlZml4fSlgKTtcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspIF4gKGMgPj4gNSk7XG4gICAgfVxuICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiAocHJlZml4LmNoYXJDb2RlQXQoaSkgJiAweDFmKTtcbiAgICBmb3IgKGxldCB2IG9mIHdvcmRzKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiB2O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoayk7XG4gICAgY2hrIF49IGVuY29kaW5nQ29uc3Q7XG4gICAgcmV0dXJuIEJFQ0hfQUxQSEFCRVQuZW5jb2RlKGNvbnZlcnRSYWRpeDIoW2NoayAlIDIgKiogMzBdLCAzMCwgNSwgZmFsc2UpKTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gZ2VuQmVjaDMyKGVuY29kaW5nKSB7XG4gICAgY29uc3QgRU5DT0RJTkdfQ09OU1QgPSBlbmNvZGluZyA9PT0gJ2JlY2gzMicgPyAxIDogMHgyYmM4MzBhMztcbiAgICBjb25zdCBfd29yZHMgPSByYWRpeDIoNSk7XG4gICAgY29uc3QgZnJvbVdvcmRzID0gX3dvcmRzLmRlY29kZTtcbiAgICBjb25zdCB0b1dvcmRzID0gX3dvcmRzLmVuY29kZTtcbiAgICBjb25zdCBmcm9tV29yZHNVbnNhZmUgPSB1bnNhZmVXcmFwcGVyKGZyb21Xb3Jkcyk7XG4gICAgZnVuY3Rpb24gZW5jb2RlKHByZWZpeCwgd29yZHMsIGxpbWl0ID0gOTApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcmVmaXggIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiZWNoMzIuZW5jb2RlIHByZWZpeCBzaG91bGQgYmUgc3RyaW5nLCBub3QgJHt0eXBlb2YgcHJlZml4fWApO1xuICAgICAgICBpZiAod29yZHMgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICAgICAgd29yZHMgPSBBcnJheS5mcm9tKHdvcmRzKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHdvcmRzKSB8fCAod29yZHMubGVuZ3RoICYmIHR5cGVvZiB3b3Jkc1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiZWNoMzIuZW5jb2RlIHdvcmRzIHNob3VsZCBiZSBhcnJheSBvZiBudW1iZXJzLCBub3QgJHt0eXBlb2Ygd29yZHN9YCk7XG4gICAgICAgIGlmIChwcmVmaXgubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBwcmVmaXggbGVuZ3RoICR7cHJlZml4Lmxlbmd0aH1gKTtcbiAgICAgICAgY29uc3QgYWN0dWFsTGVuZ3RoID0gcHJlZml4Lmxlbmd0aCArIDcgKyB3b3Jkcy5sZW5ndGg7XG4gICAgICAgIGlmIChsaW1pdCAhPT0gZmFsc2UgJiYgYWN0dWFsTGVuZ3RoID4gbGltaXQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBMZW5ndGggJHthY3R1YWxMZW5ndGh9IGV4Y2VlZHMgbGltaXQgJHtsaW1pdH1gKTtcbiAgICAgICAgY29uc3QgbG93ZXJlZCA9IHByZWZpeC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBzdW0gPSBiZWNoQ2hlY2tzdW0obG93ZXJlZCwgd29yZHMsIEVOQ09ESU5HX0NPTlNUKTtcbiAgICAgICAgcmV0dXJuIGAke2xvd2VyZWR9MSR7QkVDSF9BTFBIQUJFVC5lbmNvZGUod29yZHMpfSR7c3VtfWA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZShzdHIsIGxpbWl0ID0gOTApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiZWNoMzIuZGVjb2RlIGlucHV0IHNob3VsZCBiZSBzdHJpbmcsIG5vdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgICAgIGlmIChzdHIubGVuZ3RoIDwgOCB8fCAobGltaXQgIT09IGZhbHNlICYmIHN0ci5sZW5ndGggPiBsaW1pdCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBXcm9uZyBzdHJpbmcgbGVuZ3RoOiAke3N0ci5sZW5ndGh9ICgke3N0cn0pLiBFeHBlY3RlZCAoOC4uJHtsaW1pdH0pYCk7XG4gICAgICAgIC8vIGRvbid0IGFsbG93IG1peGVkIGNhc2VcbiAgICAgICAgY29uc3QgbG93ZXJlZCA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoc3RyICE9PSBsb3dlcmVkICYmIHN0ciAhPT0gc3RyLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0cmluZyBtdXN0IGJlIGxvd2VyY2FzZSBvciB1cHBlcmNhc2VgKTtcbiAgICAgICAgY29uc3Qgc2VwSW5kZXggPSBsb3dlcmVkLmxhc3RJbmRleE9mKCcxJyk7XG4gICAgICAgIGlmIChzZXBJbmRleCA9PT0gMCB8fCBzZXBJbmRleCA9PT0gLTEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExldHRlciBcIjFcIiBtdXN0IGJlIHByZXNlbnQgYmV0d2VlbiBwcmVmaXggYW5kIGRhdGEgb25seWApO1xuICAgICAgICBjb25zdCBwcmVmaXggPSBsb3dlcmVkLnNsaWNlKDAsIHNlcEluZGV4KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGxvd2VyZWQuc2xpY2Uoc2VwSW5kZXggKyAxKTtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgNilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBtdXN0IGJlIGF0IGxlYXN0IDYgY2hhcmFjdGVycyBsb25nJyk7XG4gICAgICAgIGNvbnN0IHdvcmRzID0gQkVDSF9BTFBIQUJFVC5kZWNvZGUoZGF0YSkuc2xpY2UoMCwgLTYpO1xuICAgICAgICBjb25zdCBzdW0gPSBiZWNoQ2hlY2tzdW0ocHJlZml4LCB3b3JkcywgRU5DT0RJTkdfQ09OU1QpO1xuICAgICAgICBpZiAoIWRhdGEuZW5kc1dpdGgoc3VtKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjaGVja3N1bSBpbiAke3N0cn06IGV4cGVjdGVkIFwiJHtzdW19XCJgKTtcbiAgICAgICAgcmV0dXJuIHsgcHJlZml4LCB3b3JkcyB9O1xuICAgIH1cbiAgICBjb25zdCBkZWNvZGVVbnNhZmUgPSB1bnNhZmVXcmFwcGVyKGRlY29kZSk7XG4gICAgZnVuY3Rpb24gZGVjb2RlVG9CeXRlcyhzdHIpIHtcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIHdvcmRzIH0gPSBkZWNvZGUoc3RyLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgd29yZHMsIGJ5dGVzOiBmcm9tV29yZHMod29yZHMpIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY29kZUZyb21CeXRlcyhwcmVmaXgsIGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGUocHJlZml4LCB0b1dvcmRzKGJ5dGVzKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZSxcbiAgICAgICAgZGVjb2RlLFxuICAgICAgICBlbmNvZGVGcm9tQnl0ZXMsXG4gICAgICAgIGRlY29kZVRvQnl0ZXMsXG4gICAgICAgIGRlY29kZVVuc2FmZSxcbiAgICAgICAgZnJvbVdvcmRzLFxuICAgICAgICBmcm9tV29yZHNVbnNhZmUsXG4gICAgICAgIHRvV29yZHMsXG4gICAgfTtcbn1cbmV4cG9ydHMuYmVjaDMyID0gZ2VuQmVjaDMyKCdiZWNoMzInKTtcbmV4cG9ydHMuYmVjaDMybSA9IGdlbkJlY2gzMignYmVjaDMybScpO1xuZXhwb3J0cy51dGY4ID0ge1xuICAgIGVuY29kZTogKGRhdGEpID0+IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShkYXRhKSxcbiAgICBkZWNvZGU6IChzdHIpID0+IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpLFxufTtcbmV4cG9ydHMuaGV4ID0gY2hhaW4ocmFkaXgyKDQpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OWFiY2RlZicpLCBqb2luKCcnKSwgbm9ybWFsaXplKChzKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzICE9PSAnc3RyaW5nJyB8fCBzLmxlbmd0aCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGhleC5kZWNvZGU6IGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN9IHdpdGggbGVuZ3RoICR7cy5sZW5ndGh9YCk7XG4gICAgcmV0dXJuIHMudG9Mb3dlckNhc2UoKTtcbn0pKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgQ09ERVJTID0ge1xuICAgIHV0Zjg6IGV4cG9ydHMudXRmOCwgaGV4OiBleHBvcnRzLmhleCwgYmFzZTE2OiBleHBvcnRzLmJhc2UxNiwgYmFzZTMyOiBleHBvcnRzLmJhc2UzMiwgYmFzZTY0OiBleHBvcnRzLmJhc2U2NCwgYmFzZTY0dXJsOiBleHBvcnRzLmJhc2U2NHVybCwgYmFzZTU4OiBleHBvcnRzLmJhc2U1OCwgYmFzZTU4eG1yOiBleHBvcnRzLmJhc2U1OHhtclxufTtcbmNvbnN0IGNvZGVyVHlwZUVycm9yID0gJ0ludmFsaWQgZW5jb2RpbmcgdHlwZS4gQXZhaWxhYmxlIHR5cGVzOiB1dGY4LCBoZXgsIGJhc2UxNiwgYmFzZTMyLCBiYXNlNjQsIGJhc2U2NHVybCwgYmFzZTU4LCBiYXNlNTh4bXInO1xuY29uc3QgYnl0ZXNUb1N0cmluZyA9ICh0eXBlLCBieXRlcykgPT4ge1xuICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycgfHwgIUNPREVSUy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjb2RlclR5cGVFcnJvcik7XG4gICAgaWYgKCFpc0J5dGVzKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYnl0ZXNUb1N0cmluZygpIGV4cGVjdHMgVWludDhBcnJheScpO1xuICAgIHJldHVybiBDT0RFUlNbdHlwZV0uZW5jb2RlKGJ5dGVzKTtcbn07XG5leHBvcnRzLmJ5dGVzVG9TdHJpbmcgPSBieXRlc1RvU3RyaW5nO1xuZXhwb3J0cy5zdHIgPSBleHBvcnRzLmJ5dGVzVG9TdHJpbmc7IC8vIGFzIGluIHB5dGhvbiwgYnV0IGZvciBieXRlcyBvbmx5XG5jb25zdCBzdHJpbmdUb0J5dGVzID0gKHR5cGUsIHN0cikgPT4ge1xuICAgIGlmICghQ09ERVJTLmhhc093blByb3BlcnR5KHR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvZGVyVHlwZUVycm9yKTtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ1RvQnl0ZXMoKSBleHBlY3RzIHN0cmluZycpO1xuICAgIHJldHVybiBDT0RFUlNbdHlwZV0uZGVjb2RlKHN0cik7XG59O1xuZXhwb3J0cy5zdHJpbmdUb0J5dGVzID0gc3RyaW5nVG9CeXRlcztcbmV4cG9ydHMuYnl0ZXMgPSBleHBvcnRzLnN0cmluZ1RvQnl0ZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@scure/base/lib/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/ethereum-cryptography/keccak.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/ethereum-cryptography/keccak.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.keccak512 = exports.keccak384 = exports.keccak256 = exports.keccak224 = void 0;\nconst sha3_1 = __webpack_require__(/*! @noble/hashes/sha3 */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/sha3.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/ethereum-cryptography/utils.js\");\nexports.keccak224 = (0, utils_js_1.wrapHash)(sha3_1.keccak_224);\nexports.keccak256 = (() => {\n    const k = (0, utils_js_1.wrapHash)(sha3_1.keccak_256);\n    k.create = sha3_1.keccak_256.create;\n    return k;\n})();\nexports.keccak384 = (0, utils_js_1.wrapHash)(sha3_1.keccak_384);\nexports.keccak512 = (0, utils_js_1.wrapHash)(sha3_1.keccak_512);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9rZWNjYWsuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCO0FBQzdFLGVBQWUsbUJBQU8sQ0FBQyw4R0FBb0I7QUFDM0MsbUJBQW1CLG1CQUFPLENBQUMsK0dBQVk7QUFDdkMsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUJBQWlCO0FBQ2pCLGlCQUFpQiIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2Nhay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMua2VjY2FrNTEyID0gZXhwb3J0cy5rZWNjYWszODQgPSBleHBvcnRzLmtlY2NhazI1NiA9IGV4cG9ydHMua2VjY2FrMjI0ID0gdm9pZCAwO1xuY29uc3Qgc2hhM18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhM1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbmV4cG9ydHMua2VjY2FrMjI0ID0gKDAsIHV0aWxzX2pzXzEud3JhcEhhc2gpKHNoYTNfMS5rZWNjYWtfMjI0KTtcbmV4cG9ydHMua2VjY2FrMjU2ID0gKCgpID0+IHtcbiAgICBjb25zdCBrID0gKDAsIHV0aWxzX2pzXzEud3JhcEhhc2gpKHNoYTNfMS5rZWNjYWtfMjU2KTtcbiAgICBrLmNyZWF0ZSA9IHNoYTNfMS5rZWNjYWtfMjU2LmNyZWF0ZTtcbiAgICByZXR1cm4gaztcbn0pKCk7XG5leHBvcnRzLmtlY2NhazM4NCA9ICgwLCB1dGlsc19qc18xLndyYXBIYXNoKShzaGEzXzEua2VjY2FrXzM4NCk7XG5leHBvcnRzLmtlY2NhazUxMiA9ICgwLCB1dGlsc19qc18xLndyYXBIYXNoKShzaGEzXzEua2VjY2FrXzUxMik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/ethereum-cryptography/keccak.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/ethereum-cryptography/secp256k1.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/ethereum-cryptography/secp256k1.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.secp256k1 = void 0;\nvar secp256k1_1 = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/curves/secp256k1.js\");\nObject.defineProperty(exports, \"secp256k1\", ({ enumerable: true, get: function () { return secp256k1_1.secp256k1; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9zZWNwMjU2azEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLGtCQUFrQixtQkFBTyxDQUFDLHdIQUF5QjtBQUNuRCw2Q0FBNEMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUMiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9zZWNwMjU2azEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNlY3AyNTZrMSA9IHZvaWQgMDtcbnZhciBzZWNwMjU2azFfMSA9IHJlcXVpcmUoXCJAbm9ibGUvY3VydmVzL3NlY3AyNTZrMVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNlY3AyNTZrMVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VjcDI1NmsxXzEuc2VjcDI1NmsxOyB9IH0pO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/ethereum-cryptography/secp256k1.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/ethereum-cryptography/utils.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/ethereum-cryptography/utils.js ***!
  \*********************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.crypto = exports.utf8ToBytes = exports.createView = exports.concatBytes = exports.toHex = exports.bytesToHex = exports.assertBytes = exports.assertBool = void 0;\nexports.bytesToUtf8 = bytesToUtf8;\nexports.hexToBytes = hexToBytes;\nexports.equalsBytes = equalsBytes;\nexports.wrapHash = wrapHash;\nconst _assert_1 = __importDefault(__webpack_require__(/*! @noble/hashes/_assert */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/_assert.js\"));\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/utils.js\");\nconst assertBool = _assert_1.default.bool;\nexports.assertBool = assertBool;\nconst assertBytes = _assert_1.default.bytes;\nexports.assertBytes = assertBytes;\nvar utils_2 = __webpack_require__(/*! @noble/hashes/utils */ \"(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/@noble/hashes/utils.js\");\nObject.defineProperty(exports, \"bytesToHex\", ({ enumerable: true, get: function () { return utils_2.bytesToHex; } }));\nObject.defineProperty(exports, \"toHex\", ({ enumerable: true, get: function () { return utils_2.bytesToHex; } }));\nObject.defineProperty(exports, \"concatBytes\", ({ enumerable: true, get: function () { return utils_2.concatBytes; } }));\nObject.defineProperty(exports, \"createView\", ({ enumerable: true, get: function () { return utils_2.createView; } }));\nObject.defineProperty(exports, \"utf8ToBytes\", ({ enumerable: true, get: function () { return utils_2.utf8ToBytes; } }));\n// buf.toString('utf8') -> bytesToUtf8(buf)\nfunction bytesToUtf8(data) {\n    if (!(data instanceof Uint8Array)) {\n        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);\n    }\n    return new TextDecoder().decode(data);\n}\nfunction hexToBytes(data) {\n    const sliced = data.startsWith(\"0x\") ? data.substring(2) : data;\n    return (0, utils_1.hexToBytes)(sliced);\n}\n// buf.equals(buf2) -> equalsBytes(buf, buf2)\nfunction equalsBytes(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n// Internal utils\nfunction wrapHash(hash) {\n    return (msg) => {\n        _assert_1.default.bytes(msg);\n        return hash(msg);\n    };\n}\n// TODO(v3): switch away from node crypto, remove this unnecessary variable.\nexports.crypto = (() => {\n    const webCrypto = typeof globalThis === \"object\" && \"crypto\" in globalThis ? globalThis.crypto : undefined;\n    const nodeRequire =  true &&\n        typeof module.require === \"function\" &&\n        module.require.bind(module);\n    return {\n        node: nodeRequire && !webCrypto ? nodeRequire(\"crypto\") : undefined,\n        web: webCrypto\n    };\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL2V0aGVyZXVtLWNyeXB0b2dyYXBoeS91dGlscy5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsbUJBQW1CLEdBQUcsa0JBQWtCLEdBQUcsbUJBQW1CLEdBQUcsYUFBYSxHQUFHLGtCQUFrQixHQUFHLG1CQUFtQixHQUFHLGtCQUFrQjtBQUMvSixtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixnQkFBZ0I7QUFDaEIsa0NBQWtDLG1CQUFPLENBQUMsb0hBQXVCO0FBQ2pFLGdCQUFnQixtQkFBTyxDQUFDLGdIQUFxQjtBQUM3QztBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLG1CQUFtQjtBQUNuQixjQUFjLG1CQUFPLENBQUMsZ0hBQXFCO0FBQzNDLDhDQUE2QyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNuSCx5Q0FBd0MsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDOUcsK0NBQThDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQ3JILDhDQUE2QyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNuSCwrQ0FBOEMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDckg7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFlBQVk7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLHdCQUF3QixLQUE2QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXNpZy11dGlsL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1jcnlwdG9ncmFwaHkvdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyeXB0byA9IGV4cG9ydHMudXRmOFRvQnl0ZXMgPSBleHBvcnRzLmNyZWF0ZVZpZXcgPSBleHBvcnRzLmNvbmNhdEJ5dGVzID0gZXhwb3J0cy50b0hleCA9IGV4cG9ydHMuYnl0ZXNUb0hleCA9IGV4cG9ydHMuYXNzZXJ0Qnl0ZXMgPSBleHBvcnRzLmFzc2VydEJvb2wgPSB2b2lkIDA7XG5leHBvcnRzLmJ5dGVzVG9VdGY4ID0gYnl0ZXNUb1V0Zjg7XG5leHBvcnRzLmhleFRvQnl0ZXMgPSBoZXhUb0J5dGVzO1xuZXhwb3J0cy5lcXVhbHNCeXRlcyA9IGVxdWFsc0J5dGVzO1xuZXhwb3J0cy53cmFwSGFzaCA9IHdyYXBIYXNoO1xuY29uc3QgX2Fzc2VydF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL19hc3NlcnRcIikpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCIpO1xuY29uc3QgYXNzZXJ0Qm9vbCA9IF9hc3NlcnRfMS5kZWZhdWx0LmJvb2w7XG5leHBvcnRzLmFzc2VydEJvb2wgPSBhc3NlcnRCb29sO1xuY29uc3QgYXNzZXJ0Qnl0ZXMgPSBfYXNzZXJ0XzEuZGVmYXVsdC5ieXRlcztcbmV4cG9ydHMuYXNzZXJ0Qnl0ZXMgPSBhc3NlcnRCeXRlcztcbnZhciB1dGlsc18yID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvdXRpbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJieXRlc1RvSGV4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18yLmJ5dGVzVG9IZXg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b0hleFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMi5ieXRlc1RvSGV4OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29uY2F0Qnl0ZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzIuY29uY2F0Qnl0ZXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVWaWV3XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18yLmNyZWF0ZVZpZXc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1dGY4VG9CeXRlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMi51dGY4VG9CeXRlczsgfSB9KTtcbi8vIGJ1Zi50b1N0cmluZygndXRmOCcpIC0+IGJ5dGVzVG9VdGY4KGJ1ZilcbmZ1bmN0aW9uIGJ5dGVzVG9VdGY4KGRhdGEpIHtcbiAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgYnl0ZXNUb1V0ZjggZXhwZWN0ZWQgVWludDhBcnJheSwgZ290ICR7dHlwZW9mIGRhdGF9YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZGF0YSk7XG59XG5mdW5jdGlvbiBoZXhUb0J5dGVzKGRhdGEpIHtcbiAgICBjb25zdCBzbGljZWQgPSBkYXRhLnN0YXJ0c1dpdGgoXCIweFwiKSA/IGRhdGEuc3Vic3RyaW5nKDIpIDogZGF0YTtcbiAgICByZXR1cm4gKDAsIHV0aWxzXzEuaGV4VG9CeXRlcykoc2xpY2VkKTtcbn1cbi8vIGJ1Zi5lcXVhbHMoYnVmMikgLT4gZXF1YWxzQnl0ZXMoYnVmLCBidWYyKVxuZnVuY3Rpb24gZXF1YWxzQnl0ZXMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIEludGVybmFsIHV0aWxzXG5mdW5jdGlvbiB3cmFwSGFzaChoYXNoKSB7XG4gICAgcmV0dXJuIChtc2cpID0+IHtcbiAgICAgICAgX2Fzc2VydF8xLmRlZmF1bHQuYnl0ZXMobXNnKTtcbiAgICAgICAgcmV0dXJuIGhhc2gobXNnKTtcbiAgICB9O1xufVxuLy8gVE9ETyh2Myk6IHN3aXRjaCBhd2F5IGZyb20gbm9kZSBjcnlwdG8sIHJlbW92ZSB0aGlzIHVubmVjZXNzYXJ5IHZhcmlhYmxlLlxuZXhwb3J0cy5jcnlwdG8gPSAoKCkgPT4ge1xuICAgIGNvbnN0IHdlYkNyeXB0byA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiICYmIFwiY3J5cHRvXCIgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuY3J5cHRvIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG5vZGVSZXF1aXJlID0gdHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0eXBlb2YgbW9kdWxlLnJlcXVpcmUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICBtb2R1bGUucmVxdWlyZS5iaW5kKG1vZHVsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZTogbm9kZVJlcXVpcmUgJiYgIXdlYkNyeXB0byA/IG5vZGVSZXF1aXJlKFwiY3J5cHRvXCIpIDogdW5kZWZpbmVkLFxuICAgICAgICB3ZWI6IHdlYkNyeXB0b1xuICAgIH07XG59KSgpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/ethereum-cryptography/utils.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/tweetnacl/nacl-fast.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/@metamask/eth-sig-util/node_modules/tweetnacl/nacl-fast.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("(function(nacl) {\n'use strict';\n\n// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.\n// Public domain.\n//\n// Implementation derived from TweetNaCl version 20140427.\n// See for details: http://tweetnacl.cr.yp.to/\n\nvar gf = function(init) {\n  var i, r = new Float64Array(16);\n  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];\n  return r;\n};\n\n//  Pluggable, initialized in high-level API below.\nvar randombytes = function(/* x, n */) { throw new Error('no PRNG'); };\n\nvar _0 = new Uint8Array(16);\nvar _9 = new Uint8Array(32); _9[0] = 9;\n\nvar gf0 = gf(),\n    gf1 = gf([1]),\n    _121665 = gf([0xdb41, 1]),\n    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),\n    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),\n    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),\n    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),\n    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);\n\nfunction ts64(x, i, h, l) {\n  x[i]   = (h >> 24) & 0xff;\n  x[i+1] = (h >> 16) & 0xff;\n  x[i+2] = (h >>  8) & 0xff;\n  x[i+3] = h & 0xff;\n  x[i+4] = (l >> 24)  & 0xff;\n  x[i+5] = (l >> 16)  & 0xff;\n  x[i+6] = (l >>  8)  & 0xff;\n  x[i+7] = l & 0xff;\n}\n\nfunction vn(x, xi, y, yi, n) {\n  var i,d = 0;\n  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];\n  return (1 & ((d - 1) >>> 8)) - 1;\n}\n\nfunction crypto_verify_16(x, xi, y, yi) {\n  return vn(x,xi,y,yi,16);\n}\n\nfunction crypto_verify_32(x, xi, y, yi) {\n  return vn(x,xi,y,yi,32);\n}\n\nfunction core_salsa20(o, p, k, c) {\n  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,\n      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,\n      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,\n      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,\n      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,\n      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,\n      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,\n      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,\n      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,\n      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,\n      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,\n      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,\n      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,\n      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,\n      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,\n      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;\n\n  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,\n      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,\n      x15 = j15, u;\n\n  for (var i = 0; i < 20; i += 2) {\n    u = x0 + x12 | 0;\n    x4 ^= u<<7 | u>>>(32-7);\n    u = x4 + x0 | 0;\n    x8 ^= u<<9 | u>>>(32-9);\n    u = x8 + x4 | 0;\n    x12 ^= u<<13 | u>>>(32-13);\n    u = x12 + x8 | 0;\n    x0 ^= u<<18 | u>>>(32-18);\n\n    u = x5 + x1 | 0;\n    x9 ^= u<<7 | u>>>(32-7);\n    u = x9 + x5 | 0;\n    x13 ^= u<<9 | u>>>(32-9);\n    u = x13 + x9 | 0;\n    x1 ^= u<<13 | u>>>(32-13);\n    u = x1 + x13 | 0;\n    x5 ^= u<<18 | u>>>(32-18);\n\n    u = x10 + x6 | 0;\n    x14 ^= u<<7 | u>>>(32-7);\n    u = x14 + x10 | 0;\n    x2 ^= u<<9 | u>>>(32-9);\n    u = x2 + x14 | 0;\n    x6 ^= u<<13 | u>>>(32-13);\n    u = x6 + x2 | 0;\n    x10 ^= u<<18 | u>>>(32-18);\n\n    u = x15 + x11 | 0;\n    x3 ^= u<<7 | u>>>(32-7);\n    u = x3 + x15 | 0;\n    x7 ^= u<<9 | u>>>(32-9);\n    u = x7 + x3 | 0;\n    x11 ^= u<<13 | u>>>(32-13);\n    u = x11 + x7 | 0;\n    x15 ^= u<<18 | u>>>(32-18);\n\n    u = x0 + x3 | 0;\n    x1 ^= u<<7 | u>>>(32-7);\n    u = x1 + x0 | 0;\n    x2 ^= u<<9 | u>>>(32-9);\n    u = x2 + x1 | 0;\n    x3 ^= u<<13 | u>>>(32-13);\n    u = x3 + x2 | 0;\n    x0 ^= u<<18 | u>>>(32-18);\n\n    u = x5 + x4 | 0;\n    x6 ^= u<<7 | u>>>(32-7);\n    u = x6 + x5 | 0;\n    x7 ^= u<<9 | u>>>(32-9);\n    u = x7 + x6 | 0;\n    x4 ^= u<<13 | u>>>(32-13);\n    u = x4 + x7 | 0;\n    x5 ^= u<<18 | u>>>(32-18);\n\n    u = x10 + x9 | 0;\n    x11 ^= u<<7 | u>>>(32-7);\n    u = x11 + x10 | 0;\n    x8 ^= u<<9 | u>>>(32-9);\n    u = x8 + x11 | 0;\n    x9 ^= u<<13 | u>>>(32-13);\n    u = x9 + x8 | 0;\n    x10 ^= u<<18 | u>>>(32-18);\n\n    u = x15 + x14 | 0;\n    x12 ^= u<<7 | u>>>(32-7);\n    u = x12 + x15 | 0;\n    x13 ^= u<<9 | u>>>(32-9);\n    u = x13 + x12 | 0;\n    x14 ^= u<<13 | u>>>(32-13);\n    u = x14 + x13 | 0;\n    x15 ^= u<<18 | u>>>(32-18);\n  }\n   x0 =  x0 +  j0 | 0;\n   x1 =  x1 +  j1 | 0;\n   x2 =  x2 +  j2 | 0;\n   x3 =  x3 +  j3 | 0;\n   x4 =  x4 +  j4 | 0;\n   x5 =  x5 +  j5 | 0;\n   x6 =  x6 +  j6 | 0;\n   x7 =  x7 +  j7 | 0;\n   x8 =  x8 +  j8 | 0;\n   x9 =  x9 +  j9 | 0;\n  x10 = x10 + j10 | 0;\n  x11 = x11 + j11 | 0;\n  x12 = x12 + j12 | 0;\n  x13 = x13 + j13 | 0;\n  x14 = x14 + j14 | 0;\n  x15 = x15 + j15 | 0;\n\n  o[ 0] = x0 >>>  0 & 0xff;\n  o[ 1] = x0 >>>  8 & 0xff;\n  o[ 2] = x0 >>> 16 & 0xff;\n  o[ 3] = x0 >>> 24 & 0xff;\n\n  o[ 4] = x1 >>>  0 & 0xff;\n  o[ 5] = x1 >>>  8 & 0xff;\n  o[ 6] = x1 >>> 16 & 0xff;\n  o[ 7] = x1 >>> 24 & 0xff;\n\n  o[ 8] = x2 >>>  0 & 0xff;\n  o[ 9] = x2 >>>  8 & 0xff;\n  o[10] = x2 >>> 16 & 0xff;\n  o[11] = x2 >>> 24 & 0xff;\n\n  o[12] = x3 >>>  0 & 0xff;\n  o[13] = x3 >>>  8 & 0xff;\n  o[14] = x3 >>> 16 & 0xff;\n  o[15] = x3 >>> 24 & 0xff;\n\n  o[16] = x4 >>>  0 & 0xff;\n  o[17] = x4 >>>  8 & 0xff;\n  o[18] = x4 >>> 16 & 0xff;\n  o[19] = x4 >>> 24 & 0xff;\n\n  o[20] = x5 >>>  0 & 0xff;\n  o[21] = x5 >>>  8 & 0xff;\n  o[22] = x5 >>> 16 & 0xff;\n  o[23] = x5 >>> 24 & 0xff;\n\n  o[24] = x6 >>>  0 & 0xff;\n  o[25] = x6 >>>  8 & 0xff;\n  o[26] = x6 >>> 16 & 0xff;\n  o[27] = x6 >>> 24 & 0xff;\n\n  o[28] = x7 >>>  0 & 0xff;\n  o[29] = x7 >>>  8 & 0xff;\n  o[30] = x7 >>> 16 & 0xff;\n  o[31] = x7 >>> 24 & 0xff;\n\n  o[32] = x8 >>>  0 & 0xff;\n  o[33] = x8 >>>  8 & 0xff;\n  o[34] = x8 >>> 16 & 0xff;\n  o[35] = x8 >>> 24 & 0xff;\n\n  o[36] = x9 >>>  0 & 0xff;\n  o[37] = x9 >>>  8 & 0xff;\n  o[38] = x9 >>> 16 & 0xff;\n  o[39] = x9 >>> 24 & 0xff;\n\n  o[40] = x10 >>>  0 & 0xff;\n  o[41] = x10 >>>  8 & 0xff;\n  o[42] = x10 >>> 16 & 0xff;\n  o[43] = x10 >>> 24 & 0xff;\n\n  o[44] = x11 >>>  0 & 0xff;\n  o[45] = x11 >>>  8 & 0xff;\n  o[46] = x11 >>> 16 & 0xff;\n  o[47] = x11 >>> 24 & 0xff;\n\n  o[48] = x12 >>>  0 & 0xff;\n  o[49] = x12 >>>  8 & 0xff;\n  o[50] = x12 >>> 16 & 0xff;\n  o[51] = x12 >>> 24 & 0xff;\n\n  o[52] = x13 >>>  0 & 0xff;\n  o[53] = x13 >>>  8 & 0xff;\n  o[54] = x13 >>> 16 & 0xff;\n  o[55] = x13 >>> 24 & 0xff;\n\n  o[56] = x14 >>>  0 & 0xff;\n  o[57] = x14 >>>  8 & 0xff;\n  o[58] = x14 >>> 16 & 0xff;\n  o[59] = x14 >>> 24 & 0xff;\n\n  o[60] = x15 >>>  0 & 0xff;\n  o[61] = x15 >>>  8 & 0xff;\n  o[62] = x15 >>> 16 & 0xff;\n  o[63] = x15 >>> 24 & 0xff;\n}\n\nfunction core_hsalsa20(o,p,k,c) {\n  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,\n      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,\n      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,\n      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,\n      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,\n      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,\n      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,\n      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,\n      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,\n      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,\n      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,\n      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,\n      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,\n      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,\n      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,\n      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;\n\n  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,\n      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,\n      x15 = j15, u;\n\n  for (var i = 0; i < 20; i += 2) {\n    u = x0 + x12 | 0;\n    x4 ^= u<<7 | u>>>(32-7);\n    u = x4 + x0 | 0;\n    x8 ^= u<<9 | u>>>(32-9);\n    u = x8 + x4 | 0;\n    x12 ^= u<<13 | u>>>(32-13);\n    u = x12 + x8 | 0;\n    x0 ^= u<<18 | u>>>(32-18);\n\n    u = x5 + x1 | 0;\n    x9 ^= u<<7 | u>>>(32-7);\n    u = x9 + x5 | 0;\n    x13 ^= u<<9 | u>>>(32-9);\n    u = x13 + x9 | 0;\n    x1 ^= u<<13 | u>>>(32-13);\n    u = x1 + x13 | 0;\n    x5 ^= u<<18 | u>>>(32-18);\n\n    u = x10 + x6 | 0;\n    x14 ^= u<<7 | u>>>(32-7);\n    u = x14 + x10 | 0;\n    x2 ^= u<<9 | u>>>(32-9);\n    u = x2 + x14 | 0;\n    x6 ^= u<<13 | u>>>(32-13);\n    u = x6 + x2 | 0;\n    x10 ^= u<<18 | u>>>(32-18);\n\n    u = x15 + x11 | 0;\n    x3 ^= u<<7 | u>>>(32-7);\n    u = x3 + x15 | 0;\n    x7 ^= u<<9 | u>>>(32-9);\n    u = x7 + x3 | 0;\n    x11 ^= u<<13 | u>>>(32-13);\n    u = x11 + x7 | 0;\n    x15 ^= u<<18 | u>>>(32-18);\n\n    u = x0 + x3 | 0;\n    x1 ^= u<<7 | u>>>(32-7);\n    u = x1 + x0 | 0;\n    x2 ^= u<<9 | u>>>(32-9);\n    u = x2 + x1 | 0;\n    x3 ^= u<<13 | u>>>(32-13);\n    u = x3 + x2 | 0;\n    x0 ^= u<<18 | u>>>(32-18);\n\n    u = x5 + x4 | 0;\n    x6 ^= u<<7 | u>>>(32-7);\n    u = x6 + x5 | 0;\n    x7 ^= u<<9 | u>>>(32-9);\n    u = x7 + x6 | 0;\n    x4 ^= u<<13 | u>>>(32-13);\n    u = x4 + x7 | 0;\n    x5 ^= u<<18 | u>>>(32-18);\n\n    u = x10 + x9 | 0;\n    x11 ^= u<<7 | u>>>(32-7);\n    u = x11 + x10 | 0;\n    x8 ^= u<<9 | u>>>(32-9);\n    u = x8 + x11 | 0;\n    x9 ^= u<<13 | u>>>(32-13);\n    u = x9 + x8 | 0;\n    x10 ^= u<<18 | u>>>(32-18);\n\n    u = x15 + x14 | 0;\n    x12 ^= u<<7 | u>>>(32-7);\n    u = x12 + x15 | 0;\n    x13 ^= u<<9 | u>>>(32-9);\n    u = x13 + x12 | 0;\n    x14 ^= u<<13 | u>>>(32-13);\n    u = x14 + x13 | 0;\n    x15 ^= u<<18 | u>>>(32-18);\n  }\n\n  o[ 0] = x0 >>>  0 & 0xff;\n  o[ 1] = x0 >>>  8 & 0xff;\n  o[ 2] = x0 >>> 16 & 0xff;\n  o[ 3] = x0 >>> 24 & 0xff;\n\n  o[ 4] = x5 >>>  0 & 0xff;\n  o[ 5] = x5 >>>  8 & 0xff;\n  o[ 6] = x5 >>> 16 & 0xff;\n  o[ 7] = x5 >>> 24 & 0xff;\n\n  o[ 8] = x10 >>>  0 & 0xff;\n  o[ 9] = x10 >>>  8 & 0xff;\n  o[10] = x10 >>> 16 & 0xff;\n  o[11] = x10 >>> 24 & 0xff;\n\n  o[12] = x15 >>>  0 & 0xff;\n  o[13] = x15 >>>  8 & 0xff;\n  o[14] = x15 >>> 16 & 0xff;\n  o[15] = x15 >>> 24 & 0xff;\n\n  o[16] = x6 >>>  0 & 0xff;\n  o[17] = x6 >>>  8 & 0xff;\n  o[18] = x6 >>> 16 & 0xff;\n  o[19] = x6 >>> 24 & 0xff;\n\n  o[20] = x7 >>>  0 & 0xff;\n  o[21] = x7 >>>  8 & 0xff;\n  o[22] = x7 >>> 16 & 0xff;\n  o[23] = x7 >>> 24 & 0xff;\n\n  o[24] = x8 >>>  0 & 0xff;\n  o[25] = x8 >>>  8 & 0xff;\n  o[26] = x8 >>> 16 & 0xff;\n  o[27] = x8 >>> 24 & 0xff;\n\n  o[28] = x9 >>>  0 & 0xff;\n  o[29] = x9 >>>  8 & 0xff;\n  o[30] = x9 >>> 16 & 0xff;\n  o[31] = x9 >>> 24 & 0xff;\n}\n\nfunction crypto_core_salsa20(out,inp,k,c) {\n  core_salsa20(out,inp,k,c);\n}\n\nfunction crypto_core_hsalsa20(out,inp,k,c) {\n  core_hsalsa20(out,inp,k,c);\n}\n\nvar sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);\n            // \"expand 32-byte k\"\n\nfunction crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {\n  var z = new Uint8Array(16), x = new Uint8Array(64);\n  var u, i;\n  for (i = 0; i < 16; i++) z[i] = 0;\n  for (i = 0; i < 8; i++) z[i] = n[i];\n  while (b >= 64) {\n    crypto_core_salsa20(x,z,k,sigma);\n    for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];\n    u = 1;\n    for (i = 8; i < 16; i++) {\n      u = u + (z[i] & 0xff) | 0;\n      z[i] = u & 0xff;\n      u >>>= 8;\n    }\n    b -= 64;\n    cpos += 64;\n    mpos += 64;\n  }\n  if (b > 0) {\n    crypto_core_salsa20(x,z,k,sigma);\n    for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];\n  }\n  return 0;\n}\n\nfunction crypto_stream_salsa20(c,cpos,b,n,k) {\n  var z = new Uint8Array(16), x = new Uint8Array(64);\n  var u, i;\n  for (i = 0; i < 16; i++) z[i] = 0;\n  for (i = 0; i < 8; i++) z[i] = n[i];\n  while (b >= 64) {\n    crypto_core_salsa20(x,z,k,sigma);\n    for (i = 0; i < 64; i++) c[cpos+i] = x[i];\n    u = 1;\n    for (i = 8; i < 16; i++) {\n      u = u + (z[i] & 0xff) | 0;\n      z[i] = u & 0xff;\n      u >>>= 8;\n    }\n    b -= 64;\n    cpos += 64;\n  }\n  if (b > 0) {\n    crypto_core_salsa20(x,z,k,sigma);\n    for (i = 0; i < b; i++) c[cpos+i] = x[i];\n  }\n  return 0;\n}\n\nfunction crypto_stream(c,cpos,d,n,k) {\n  var s = new Uint8Array(32);\n  crypto_core_hsalsa20(s,n,k,sigma);\n  var sn = new Uint8Array(8);\n  for (var i = 0; i < 8; i++) sn[i] = n[i+16];\n  return crypto_stream_salsa20(c,cpos,d,sn,s);\n}\n\nfunction crypto_stream_xor(c,cpos,m,mpos,d,n,k) {\n  var s = new Uint8Array(32);\n  crypto_core_hsalsa20(s,n,k,sigma);\n  var sn = new Uint8Array(8);\n  for (var i = 0; i < 8; i++) sn[i] = n[i+16];\n  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);\n}\n\n/*\n* Port of Andrew Moon's Poly1305-donna-16. Public domain.\n* https://github.com/floodyberry/poly1305-donna\n*/\n\nvar poly1305 = function(key) {\n  this.buffer = new Uint8Array(16);\n  this.r = new Uint16Array(10);\n  this.h = new Uint16Array(10);\n  this.pad = new Uint16Array(8);\n  this.leftover = 0;\n  this.fin = 0;\n\n  var t0, t1, t2, t3, t4, t5, t6, t7;\n\n  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;\n  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;\n  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;\n  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;\n  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;\n  this.r[5] = ((t4 >>>  1)) & 0x1ffe;\n  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;\n  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;\n  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;\n  this.r[9] = ((t7 >>>  5)) & 0x007f;\n\n  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;\n  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;\n  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;\n  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;\n  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;\n  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;\n  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;\n  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;\n};\n\npoly1305.prototype.blocks = function(m, mpos, bytes) {\n  var hibit = this.fin ? 0 : (1 << 11);\n  var t0, t1, t2, t3, t4, t5, t6, t7, c;\n  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;\n\n  var h0 = this.h[0],\n      h1 = this.h[1],\n      h2 = this.h[2],\n      h3 = this.h[3],\n      h4 = this.h[4],\n      h5 = this.h[5],\n      h6 = this.h[6],\n      h7 = this.h[7],\n      h8 = this.h[8],\n      h9 = this.h[9];\n\n  var r0 = this.r[0],\n      r1 = this.r[1],\n      r2 = this.r[2],\n      r3 = this.r[3],\n      r4 = this.r[4],\n      r5 = this.r[5],\n      r6 = this.r[6],\n      r7 = this.r[7],\n      r8 = this.r[8],\n      r9 = this.r[9];\n\n  while (bytes >= 16) {\n    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;\n    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;\n    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;\n    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;\n    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;\n    h5 += ((t4 >>>  1)) & 0x1fff;\n    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;\n    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;\n    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;\n    h9 += ((t7 >>> 5)) | hibit;\n\n    c = 0;\n\n    d0 = c;\n    d0 += h0 * r0;\n    d0 += h1 * (5 * r9);\n    d0 += h2 * (5 * r8);\n    d0 += h3 * (5 * r7);\n    d0 += h4 * (5 * r6);\n    c = (d0 >>> 13); d0 &= 0x1fff;\n    d0 += h5 * (5 * r5);\n    d0 += h6 * (5 * r4);\n    d0 += h7 * (5 * r3);\n    d0 += h8 * (5 * r2);\n    d0 += h9 * (5 * r1);\n    c += (d0 >>> 13); d0 &= 0x1fff;\n\n    d1 = c;\n    d1 += h0 * r1;\n    d1 += h1 * r0;\n    d1 += h2 * (5 * r9);\n    d1 += h3 * (5 * r8);\n    d1 += h4 * (5 * r7);\n    c = (d1 >>> 13); d1 &= 0x1fff;\n    d1 += h5 * (5 * r6);\n    d1 += h6 * (5 * r5);\n    d1 += h7 * (5 * r4);\n    d1 += h8 * (5 * r3);\n    d1 += h9 * (5 * r2);\n    c += (d1 >>> 13); d1 &= 0x1fff;\n\n    d2 = c;\n    d2 += h0 * r2;\n    d2 += h1 * r1;\n    d2 += h2 * r0;\n    d2 += h3 * (5 * r9);\n    d2 += h4 * (5 * r8);\n    c = (d2 >>> 13); d2 &= 0x1fff;\n    d2 += h5 * (5 * r7);\n    d2 += h6 * (5 * r6);\n    d2 += h7 * (5 * r5);\n    d2 += h8 * (5 * r4);\n    d2 += h9 * (5 * r3);\n    c += (d2 >>> 13); d2 &= 0x1fff;\n\n    d3 = c;\n    d3 += h0 * r3;\n    d3 += h1 * r2;\n    d3 += h2 * r1;\n    d3 += h3 * r0;\n    d3 += h4 * (5 * r9);\n    c = (d3 >>> 13); d3 &= 0x1fff;\n    d3 += h5 * (5 * r8);\n    d3 += h6 * (5 * r7);\n    d3 += h7 * (5 * r6);\n    d3 += h8 * (5 * r5);\n    d3 += h9 * (5 * r4);\n    c += (d3 >>> 13); d3 &= 0x1fff;\n\n    d4 = c;\n    d4 += h0 * r4;\n    d4 += h1 * r3;\n    d4 += h2 * r2;\n    d4 += h3 * r1;\n    d4 += h4 * r0;\n    c = (d4 >>> 13); d4 &= 0x1fff;\n    d4 += h5 * (5 * r9);\n    d4 += h6 * (5 * r8);\n    d4 += h7 * (5 * r7);\n    d4 += h8 * (5 * r6);\n    d4 += h9 * (5 * r5);\n    c += (d4 >>> 13); d4 &= 0x1fff;\n\n    d5 = c;\n    d5 += h0 * r5;\n    d5 += h1 * r4;\n    d5 += h2 * r3;\n    d5 += h3 * r2;\n    d5 += h4 * r1;\n    c = (d5 >>> 13); d5 &= 0x1fff;\n    d5 += h5 * r0;\n    d5 += h6 * (5 * r9);\n    d5 += h7 * (5 * r8);\n    d5 += h8 * (5 * r7);\n    d5 += h9 * (5 * r6);\n    c += (d5 >>> 13); d5 &= 0x1fff;\n\n    d6 = c;\n    d6 += h0 * r6;\n    d6 += h1 * r5;\n    d6 += h2 * r4;\n    d6 += h3 * r3;\n    d6 += h4 * r2;\n    c = (d6 >>> 13); d6 &= 0x1fff;\n    d6 += h5 * r1;\n    d6 += h6 * r0;\n    d6 += h7 * (5 * r9);\n    d6 += h8 * (5 * r8);\n    d6 += h9 * (5 * r7);\n    c += (d6 >>> 13); d6 &= 0x1fff;\n\n    d7 = c;\n    d7 += h0 * r7;\n    d7 += h1 * r6;\n    d7 += h2 * r5;\n    d7 += h3 * r4;\n    d7 += h4 * r3;\n    c = (d7 >>> 13); d7 &= 0x1fff;\n    d7 += h5 * r2;\n    d7 += h6 * r1;\n    d7 += h7 * r0;\n    d7 += h8 * (5 * r9);\n    d7 += h9 * (5 * r8);\n    c += (d7 >>> 13); d7 &= 0x1fff;\n\n    d8 = c;\n    d8 += h0 * r8;\n    d8 += h1 * r7;\n    d8 += h2 * r6;\n    d8 += h3 * r5;\n    d8 += h4 * r4;\n    c = (d8 >>> 13); d8 &= 0x1fff;\n    d8 += h5 * r3;\n    d8 += h6 * r2;\n    d8 += h7 * r1;\n    d8 += h8 * r0;\n    d8 += h9 * (5 * r9);\n    c += (d8 >>> 13); d8 &= 0x1fff;\n\n    d9 = c;\n    d9 += h0 * r9;\n    d9 += h1 * r8;\n    d9 += h2 * r7;\n    d9 += h3 * r6;\n    d9 += h4 * r5;\n    c = (d9 >>> 13); d9 &= 0x1fff;\n    d9 += h5 * r4;\n    d9 += h6 * r3;\n    d9 += h7 * r2;\n    d9 += h8 * r1;\n    d9 += h9 * r0;\n    c += (d9 >>> 13); d9 &= 0x1fff;\n\n    c = (((c << 2) + c)) | 0;\n    c = (c + d0) | 0;\n    d0 = c & 0x1fff;\n    c = (c >>> 13);\n    d1 += c;\n\n    h0 = d0;\n    h1 = d1;\n    h2 = d2;\n    h3 = d3;\n    h4 = d4;\n    h5 = d5;\n    h6 = d6;\n    h7 = d7;\n    h8 = d8;\n    h9 = d9;\n\n    mpos += 16;\n    bytes -= 16;\n  }\n  this.h[0] = h0;\n  this.h[1] = h1;\n  this.h[2] = h2;\n  this.h[3] = h3;\n  this.h[4] = h4;\n  this.h[5] = h5;\n  this.h[6] = h6;\n  this.h[7] = h7;\n  this.h[8] = h8;\n  this.h[9] = h9;\n};\n\npoly1305.prototype.finish = function(mac, macpos) {\n  var g = new Uint16Array(10);\n  var c, mask, f, i;\n\n  if (this.leftover) {\n    i = this.leftover;\n    this.buffer[i++] = 1;\n    for (; i < 16; i++) this.buffer[i] = 0;\n    this.fin = 1;\n    this.blocks(this.buffer, 0, 16);\n  }\n\n  c = this.h[1] >>> 13;\n  this.h[1] &= 0x1fff;\n  for (i = 2; i < 10; i++) {\n    this.h[i] += c;\n    c = this.h[i] >>> 13;\n    this.h[i] &= 0x1fff;\n  }\n  this.h[0] += (c * 5);\n  c = this.h[0] >>> 13;\n  this.h[0] &= 0x1fff;\n  this.h[1] += c;\n  c = this.h[1] >>> 13;\n  this.h[1] &= 0x1fff;\n  this.h[2] += c;\n\n  g[0] = this.h[0] + 5;\n  c = g[0] >>> 13;\n  g[0] &= 0x1fff;\n  for (i = 1; i < 10; i++) {\n    g[i] = this.h[i] + c;\n    c = g[i] >>> 13;\n    g[i] &= 0x1fff;\n  }\n  g[9] -= (1 << 13);\n\n  mask = (c ^ 1) - 1;\n  for (i = 0; i < 10; i++) g[i] &= mask;\n  mask = ~mask;\n  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];\n\n  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;\n  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;\n  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;\n  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;\n  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;\n  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;\n  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;\n  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;\n\n  f = this.h[0] + this.pad[0];\n  this.h[0] = f & 0xffff;\n  for (i = 1; i < 8; i++) {\n    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;\n    this.h[i] = f & 0xffff;\n  }\n\n  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;\n  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;\n  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;\n  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;\n  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;\n  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;\n  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;\n  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;\n  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;\n  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;\n  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;\n  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;\n  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;\n  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;\n  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;\n  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;\n};\n\npoly1305.prototype.update = function(m, mpos, bytes) {\n  var i, want;\n\n  if (this.leftover) {\n    want = (16 - this.leftover);\n    if (want > bytes)\n      want = bytes;\n    for (i = 0; i < want; i++)\n      this.buffer[this.leftover + i] = m[mpos+i];\n    bytes -= want;\n    mpos += want;\n    this.leftover += want;\n    if (this.leftover < 16)\n      return;\n    this.blocks(this.buffer, 0, 16);\n    this.leftover = 0;\n  }\n\n  if (bytes >= 16) {\n    want = bytes - (bytes % 16);\n    this.blocks(m, mpos, want);\n    mpos += want;\n    bytes -= want;\n  }\n\n  if (bytes) {\n    for (i = 0; i < bytes; i++)\n      this.buffer[this.leftover + i] = m[mpos+i];\n    this.leftover += bytes;\n  }\n};\n\nfunction crypto_onetimeauth(out, outpos, m, mpos, n, k) {\n  var s = new poly1305(k);\n  s.update(m, mpos, n);\n  s.finish(out, outpos);\n  return 0;\n}\n\nfunction crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {\n  var x = new Uint8Array(16);\n  crypto_onetimeauth(x,0,m,mpos,n,k);\n  return crypto_verify_16(h,hpos,x,0);\n}\n\nfunction crypto_secretbox(c,m,d,n,k) {\n  var i;\n  if (d < 32) return -1;\n  crypto_stream_xor(c,0,m,0,d,n,k);\n  crypto_onetimeauth(c, 16, c, 32, d - 32, c);\n  for (i = 0; i < 16; i++) c[i] = 0;\n  return 0;\n}\n\nfunction crypto_secretbox_open(m,c,d,n,k) {\n  var i;\n  var x = new Uint8Array(32);\n  if (d < 32) return -1;\n  crypto_stream(x,0,32,n,k);\n  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;\n  crypto_stream_xor(m,0,c,0,d,n,k);\n  for (i = 0; i < 32; i++) m[i] = 0;\n  return 0;\n}\n\nfunction set25519(r, a) {\n  var i;\n  for (i = 0; i < 16; i++) r[i] = a[i]|0;\n}\n\nfunction car25519(o) {\n  var i, v, c = 1;\n  for (i = 0; i < 16; i++) {\n    v = o[i] + c + 65535;\n    c = Math.floor(v / 65536);\n    o[i] = v - c * 65536;\n  }\n  o[0] += c-1 + 37 * (c-1);\n}\n\nfunction sel25519(p, q, b) {\n  var t, c = ~(b-1);\n  for (var i = 0; i < 16; i++) {\n    t = c & (p[i] ^ q[i]);\n    p[i] ^= t;\n    q[i] ^= t;\n  }\n}\n\nfunction pack25519(o, n) {\n  var i, j, b;\n  var m = gf(), t = gf();\n  for (i = 0; i < 16; i++) t[i] = n[i];\n  car25519(t);\n  car25519(t);\n  car25519(t);\n  for (j = 0; j < 2; j++) {\n    m[0] = t[0] - 0xffed;\n    for (i = 1; i < 15; i++) {\n      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);\n      m[i-1] &= 0xffff;\n    }\n    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);\n    b = (m[15]>>16) & 1;\n    m[14] &= 0xffff;\n    sel25519(t, m, 1-b);\n  }\n  for (i = 0; i < 16; i++) {\n    o[2*i] = t[i] & 0xff;\n    o[2*i+1] = t[i]>>8;\n  }\n}\n\nfunction neq25519(a, b) {\n  var c = new Uint8Array(32), d = new Uint8Array(32);\n  pack25519(c, a);\n  pack25519(d, b);\n  return crypto_verify_32(c, 0, d, 0);\n}\n\nfunction par25519(a) {\n  var d = new Uint8Array(32);\n  pack25519(d, a);\n  return d[0] & 1;\n}\n\nfunction unpack25519(o, n) {\n  var i;\n  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);\n  o[15] &= 0x7fff;\n}\n\nfunction A(o, a, b) {\n  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];\n}\n\nfunction Z(o, a, b) {\n  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];\n}\n\nfunction M(o, a, b) {\n  var v, c,\n     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,\n     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,\n    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,\n    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,\n    b0 = b[0],\n    b1 = b[1],\n    b2 = b[2],\n    b3 = b[3],\n    b4 = b[4],\n    b5 = b[5],\n    b6 = b[6],\n    b7 = b[7],\n    b8 = b[8],\n    b9 = b[9],\n    b10 = b[10],\n    b11 = b[11],\n    b12 = b[12],\n    b13 = b[13],\n    b14 = b[14],\n    b15 = b[15];\n\n  v = a[0];\n  t0 += v * b0;\n  t1 += v * b1;\n  t2 += v * b2;\n  t3 += v * b3;\n  t4 += v * b4;\n  t5 += v * b5;\n  t6 += v * b6;\n  t7 += v * b7;\n  t8 += v * b8;\n  t9 += v * b9;\n  t10 += v * b10;\n  t11 += v * b11;\n  t12 += v * b12;\n  t13 += v * b13;\n  t14 += v * b14;\n  t15 += v * b15;\n  v = a[1];\n  t1 += v * b0;\n  t2 += v * b1;\n  t3 += v * b2;\n  t4 += v * b3;\n  t5 += v * b4;\n  t6 += v * b5;\n  t7 += v * b6;\n  t8 += v * b7;\n  t9 += v * b8;\n  t10 += v * b9;\n  t11 += v * b10;\n  t12 += v * b11;\n  t13 += v * b12;\n  t14 += v * b13;\n  t15 += v * b14;\n  t16 += v * b15;\n  v = a[2];\n  t2 += v * b0;\n  t3 += v * b1;\n  t4 += v * b2;\n  t5 += v * b3;\n  t6 += v * b4;\n  t7 += v * b5;\n  t8 += v * b6;\n  t9 += v * b7;\n  t10 += v * b8;\n  t11 += v * b9;\n  t12 += v * b10;\n  t13 += v * b11;\n  t14 += v * b12;\n  t15 += v * b13;\n  t16 += v * b14;\n  t17 += v * b15;\n  v = a[3];\n  t3 += v * b0;\n  t4 += v * b1;\n  t5 += v * b2;\n  t6 += v * b3;\n  t7 += v * b4;\n  t8 += v * b5;\n  t9 += v * b6;\n  t10 += v * b7;\n  t11 += v * b8;\n  t12 += v * b9;\n  t13 += v * b10;\n  t14 += v * b11;\n  t15 += v * b12;\n  t16 += v * b13;\n  t17 += v * b14;\n  t18 += v * b15;\n  v = a[4];\n  t4 += v * b0;\n  t5 += v * b1;\n  t6 += v * b2;\n  t7 += v * b3;\n  t8 += v * b4;\n  t9 += v * b5;\n  t10 += v * b6;\n  t11 += v * b7;\n  t12 += v * b8;\n  t13 += v * b9;\n  t14 += v * b10;\n  t15 += v * b11;\n  t16 += v * b12;\n  t17 += v * b13;\n  t18 += v * b14;\n  t19 += v * b15;\n  v = a[5];\n  t5 += v * b0;\n  t6 += v * b1;\n  t7 += v * b2;\n  t8 += v * b3;\n  t9 += v * b4;\n  t10 += v * b5;\n  t11 += v * b6;\n  t12 += v * b7;\n  t13 += v * b8;\n  t14 += v * b9;\n  t15 += v * b10;\n  t16 += v * b11;\n  t17 += v * b12;\n  t18 += v * b13;\n  t19 += v * b14;\n  t20 += v * b15;\n  v = a[6];\n  t6 += v * b0;\n  t7 += v * b1;\n  t8 += v * b2;\n  t9 += v * b3;\n  t10 += v * b4;\n  t11 += v * b5;\n  t12 += v * b6;\n  t13 += v * b7;\n  t14 += v * b8;\n  t15 += v * b9;\n  t16 += v * b10;\n  t17 += v * b11;\n  t18 += v * b12;\n  t19 += v * b13;\n  t20 += v * b14;\n  t21 += v * b15;\n  v = a[7];\n  t7 += v * b0;\n  t8 += v * b1;\n  t9 += v * b2;\n  t10 += v * b3;\n  t11 += v * b4;\n  t12 += v * b5;\n  t13 += v * b6;\n  t14 += v * b7;\n  t15 += v * b8;\n  t16 += v * b9;\n  t17 += v * b10;\n  t18 += v * b11;\n  t19 += v * b12;\n  t20 += v * b13;\n  t21 += v * b14;\n  t22 += v * b15;\n  v = a[8];\n  t8 += v * b0;\n  t9 += v * b1;\n  t10 += v * b2;\n  t11 += v * b3;\n  t12 += v * b4;\n  t13 += v * b5;\n  t14 += v * b6;\n  t15 += v * b7;\n  t16 += v * b8;\n  t17 += v * b9;\n  t18 += v * b10;\n  t19 += v * b11;\n  t20 += v * b12;\n  t21 += v * b13;\n  t22 += v * b14;\n  t23 += v * b15;\n  v = a[9];\n  t9 += v * b0;\n  t10 += v * b1;\n  t11 += v * b2;\n  t12 += v * b3;\n  t13 += v * b4;\n  t14 += v * b5;\n  t15 += v * b6;\n  t16 += v * b7;\n  t17 += v * b8;\n  t18 += v * b9;\n  t19 += v * b10;\n  t20 += v * b11;\n  t21 += v * b12;\n  t22 += v * b13;\n  t23 += v * b14;\n  t24 += v * b15;\n  v = a[10];\n  t10 += v * b0;\n  t11 += v * b1;\n  t12 += v * b2;\n  t13 += v * b3;\n  t14 += v * b4;\n  t15 += v * b5;\n  t16 += v * b6;\n  t17 += v * b7;\n  t18 += v * b8;\n  t19 += v * b9;\n  t20 += v * b10;\n  t21 += v * b11;\n  t22 += v * b12;\n  t23 += v * b13;\n  t24 += v * b14;\n  t25 += v * b15;\n  v = a[11];\n  t11 += v * b0;\n  t12 += v * b1;\n  t13 += v * b2;\n  t14 += v * b3;\n  t15 += v * b4;\n  t16 += v * b5;\n  t17 += v * b6;\n  t18 += v * b7;\n  t19 += v * b8;\n  t20 += v * b9;\n  t21 += v * b10;\n  t22 += v * b11;\n  t23 += v * b12;\n  t24 += v * b13;\n  t25 += v * b14;\n  t26 += v * b15;\n  v = a[12];\n  t12 += v * b0;\n  t13 += v * b1;\n  t14 += v * b2;\n  t15 += v * b3;\n  t16 += v * b4;\n  t17 += v * b5;\n  t18 += v * b6;\n  t19 += v * b7;\n  t20 += v * b8;\n  t21 += v * b9;\n  t22 += v * b10;\n  t23 += v * b11;\n  t24 += v * b12;\n  t25 += v * b13;\n  t26 += v * b14;\n  t27 += v * b15;\n  v = a[13];\n  t13 += v * b0;\n  t14 += v * b1;\n  t15 += v * b2;\n  t16 += v * b3;\n  t17 += v * b4;\n  t18 += v * b5;\n  t19 += v * b6;\n  t20 += v * b7;\n  t21 += v * b8;\n  t22 += v * b9;\n  t23 += v * b10;\n  t24 += v * b11;\n  t25 += v * b12;\n  t26 += v * b13;\n  t27 += v * b14;\n  t28 += v * b15;\n  v = a[14];\n  t14 += v * b0;\n  t15 += v * b1;\n  t16 += v * b2;\n  t17 += v * b3;\n  t18 += v * b4;\n  t19 += v * b5;\n  t20 += v * b6;\n  t21 += v * b7;\n  t22 += v * b8;\n  t23 += v * b9;\n  t24 += v * b10;\n  t25 += v * b11;\n  t26 += v * b12;\n  t27 += v * b13;\n  t28 += v * b14;\n  t29 += v * b15;\n  v = a[15];\n  t15 += v * b0;\n  t16 += v * b1;\n  t17 += v * b2;\n  t18 += v * b3;\n  t19 += v * b4;\n  t20 += v * b5;\n  t21 += v * b6;\n  t22 += v * b7;\n  t23 += v * b8;\n  t24 += v * b9;\n  t25 += v * b10;\n  t26 += v * b11;\n  t27 += v * b12;\n  t28 += v * b13;\n  t29 += v * b14;\n  t30 += v * b15;\n\n  t0  += 38 * t16;\n  t1  += 38 * t17;\n  t2  += 38 * t18;\n  t3  += 38 * t19;\n  t4  += 38 * t20;\n  t5  += 38 * t21;\n  t6  += 38 * t22;\n  t7  += 38 * t23;\n  t8  += 38 * t24;\n  t9  += 38 * t25;\n  t10 += 38 * t26;\n  t11 += 38 * t27;\n  t12 += 38 * t28;\n  t13 += 38 * t29;\n  t14 += 38 * t30;\n  // t15 left as is\n\n  // first car\n  c = 1;\n  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;\n  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;\n  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;\n  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;\n  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;\n  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;\n  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;\n  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;\n  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;\n  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;\n  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;\n  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;\n  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;\n  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;\n  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;\n  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;\n  t0 += c-1 + 37 * (c-1);\n\n  // second car\n  c = 1;\n  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;\n  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;\n  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;\n  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;\n  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;\n  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;\n  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;\n  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;\n  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;\n  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;\n  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;\n  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;\n  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;\n  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;\n  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;\n  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;\n  t0 += c-1 + 37 * (c-1);\n\n  o[ 0] = t0;\n  o[ 1] = t1;\n  o[ 2] = t2;\n  o[ 3] = t3;\n  o[ 4] = t4;\n  o[ 5] = t5;\n  o[ 6] = t6;\n  o[ 7] = t7;\n  o[ 8] = t8;\n  o[ 9] = t9;\n  o[10] = t10;\n  o[11] = t11;\n  o[12] = t12;\n  o[13] = t13;\n  o[14] = t14;\n  o[15] = t15;\n}\n\nfunction S(o, a) {\n  M(o, a, a);\n}\n\nfunction inv25519(o, i) {\n  var c = gf();\n  var a;\n  for (a = 0; a < 16; a++) c[a] = i[a];\n  for (a = 253; a >= 0; a--) {\n    S(c, c);\n    if(a !== 2 && a !== 4) M(c, c, i);\n  }\n  for (a = 0; a < 16; a++) o[a] = c[a];\n}\n\nfunction pow2523(o, i) {\n  var c = gf();\n  var a;\n  for (a = 0; a < 16; a++) c[a] = i[a];\n  for (a = 250; a >= 0; a--) {\n      S(c, c);\n      if(a !== 1) M(c, c, i);\n  }\n  for (a = 0; a < 16; a++) o[a] = c[a];\n}\n\nfunction crypto_scalarmult(q, n, p) {\n  var z = new Uint8Array(32);\n  var x = new Float64Array(80), r, i;\n  var a = gf(), b = gf(), c = gf(),\n      d = gf(), e = gf(), f = gf();\n  for (i = 0; i < 31; i++) z[i] = n[i];\n  z[31]=(n[31]&127)|64;\n  z[0]&=248;\n  unpack25519(x,p);\n  for (i = 0; i < 16; i++) {\n    b[i]=x[i];\n    d[i]=a[i]=c[i]=0;\n  }\n  a[0]=d[0]=1;\n  for (i=254; i>=0; --i) {\n    r=(z[i>>>3]>>>(i&7))&1;\n    sel25519(a,b,r);\n    sel25519(c,d,r);\n    A(e,a,c);\n    Z(a,a,c);\n    A(c,b,d);\n    Z(b,b,d);\n    S(d,e);\n    S(f,a);\n    M(a,c,a);\n    M(c,b,e);\n    A(e,a,c);\n    Z(a,a,c);\n    S(b,a);\n    Z(c,d,f);\n    M(a,c,_121665);\n    A(a,a,d);\n    M(c,c,a);\n    M(a,d,f);\n    M(d,b,x);\n    S(b,e);\n    sel25519(a,b,r);\n    sel25519(c,d,r);\n  }\n  for (i = 0; i < 16; i++) {\n    x[i+16]=a[i];\n    x[i+32]=c[i];\n    x[i+48]=b[i];\n    x[i+64]=d[i];\n  }\n  var x32 = x.subarray(32);\n  var x16 = x.subarray(16);\n  inv25519(x32,x32);\n  M(x16,x16,x32);\n  pack25519(q,x16);\n  return 0;\n}\n\nfunction crypto_scalarmult_base(q, n) {\n  return crypto_scalarmult(q, n, _9);\n}\n\nfunction crypto_box_keypair(y, x) {\n  randombytes(x, 32);\n  return crypto_scalarmult_base(y, x);\n}\n\nfunction crypto_box_beforenm(k, y, x) {\n  var s = new Uint8Array(32);\n  crypto_scalarmult(s, x, y);\n  return crypto_core_hsalsa20(k, _0, s, sigma);\n}\n\nvar crypto_box_afternm = crypto_secretbox;\nvar crypto_box_open_afternm = crypto_secretbox_open;\n\nfunction crypto_box(c, m, d, n, y, x) {\n  var k = new Uint8Array(32);\n  crypto_box_beforenm(k, y, x);\n  return crypto_box_afternm(c, m, d, n, k);\n}\n\nfunction crypto_box_open(m, c, d, n, y, x) {\n  var k = new Uint8Array(32);\n  crypto_box_beforenm(k, y, x);\n  return crypto_box_open_afternm(m, c, d, n, k);\n}\n\nvar K = [\n  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,\n  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\n  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,\n  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\n  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,\n  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,\n  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\n  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,\n  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\n  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,\n  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,\n  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\n  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,\n  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\n  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,\n  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,\n  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\n  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,\n  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\n  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,\n  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,\n  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\n  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,\n  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\n  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,\n  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,\n  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\n  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,\n  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\n  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,\n  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,\n  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\n  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,\n  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817\n];\n\nfunction crypto_hashblocks_hl(hh, hl, m, n) {\n  var wh = new Int32Array(16), wl = new Int32Array(16),\n      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,\n      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,\n      th, tl, i, j, h, l, a, b, c, d;\n\n  var ah0 = hh[0],\n      ah1 = hh[1],\n      ah2 = hh[2],\n      ah3 = hh[3],\n      ah4 = hh[4],\n      ah5 = hh[5],\n      ah6 = hh[6],\n      ah7 = hh[7],\n\n      al0 = hl[0],\n      al1 = hl[1],\n      al2 = hl[2],\n      al3 = hl[3],\n      al4 = hl[4],\n      al5 = hl[5],\n      al6 = hl[6],\n      al7 = hl[7];\n\n  var pos = 0;\n  while (n >= 128) {\n    for (i = 0; i < 16; i++) {\n      j = 8 * i + pos;\n      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];\n      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];\n    }\n    for (i = 0; i < 80; i++) {\n      bh0 = ah0;\n      bh1 = ah1;\n      bh2 = ah2;\n      bh3 = ah3;\n      bh4 = ah4;\n      bh5 = ah5;\n      bh6 = ah6;\n      bh7 = ah7;\n\n      bl0 = al0;\n      bl1 = al1;\n      bl2 = al2;\n      bl3 = al3;\n      bl4 = al4;\n      bl5 = al5;\n      bl6 = al6;\n      bl7 = al7;\n\n      // add\n      h = ah7;\n      l = al7;\n\n      a = l & 0xffff; b = l >>> 16;\n      c = h & 0xffff; d = h >>> 16;\n\n      // Sigma1\n      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));\n      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // Ch\n      h = (ah4 & ah5) ^ (~ah4 & ah6);\n      l = (al4 & al5) ^ (~al4 & al6);\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // K\n      h = K[i*2];\n      l = K[i*2+1];\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // w\n      h = wh[i%16];\n      l = wl[i%16];\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n\n      th = c & 0xffff | d << 16;\n      tl = a & 0xffff | b << 16;\n\n      // add\n      h = th;\n      l = tl;\n\n      a = l & 0xffff; b = l >>> 16;\n      c = h & 0xffff; d = h >>> 16;\n\n      // Sigma0\n      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));\n      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // Maj\n      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);\n      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n\n      bh7 = (c & 0xffff) | (d << 16);\n      bl7 = (a & 0xffff) | (b << 16);\n\n      // add\n      h = bh3;\n      l = bl3;\n\n      a = l & 0xffff; b = l >>> 16;\n      c = h & 0xffff; d = h >>> 16;\n\n      h = th;\n      l = tl;\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n\n      bh3 = (c & 0xffff) | (d << 16);\n      bl3 = (a & 0xffff) | (b << 16);\n\n      ah1 = bh0;\n      ah2 = bh1;\n      ah3 = bh2;\n      ah4 = bh3;\n      ah5 = bh4;\n      ah6 = bh5;\n      ah7 = bh6;\n      ah0 = bh7;\n\n      al1 = bl0;\n      al2 = bl1;\n      al3 = bl2;\n      al4 = bl3;\n      al5 = bl4;\n      al6 = bl5;\n      al7 = bl6;\n      al0 = bl7;\n\n      if (i%16 === 15) {\n        for (j = 0; j < 16; j++) {\n          // add\n          h = wh[j];\n          l = wl[j];\n\n          a = l & 0xffff; b = l >>> 16;\n          c = h & 0xffff; d = h >>> 16;\n\n          h = wh[(j+9)%16];\n          l = wl[(j+9)%16];\n\n          a += l & 0xffff; b += l >>> 16;\n          c += h & 0xffff; d += h >>> 16;\n\n          // sigma0\n          th = wh[(j+1)%16];\n          tl = wl[(j+1)%16];\n          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);\n          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));\n\n          a += l & 0xffff; b += l >>> 16;\n          c += h & 0xffff; d += h >>> 16;\n\n          // sigma1\n          th = wh[(j+14)%16];\n          tl = wl[(j+14)%16];\n          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);\n          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));\n\n          a += l & 0xffff; b += l >>> 16;\n          c += h & 0xffff; d += h >>> 16;\n\n          b += a >>> 16;\n          c += b >>> 16;\n          d += c >>> 16;\n\n          wh[j] = (c & 0xffff) | (d << 16);\n          wl[j] = (a & 0xffff) | (b << 16);\n        }\n      }\n    }\n\n    // add\n    h = ah0;\n    l = al0;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[0];\n    l = hl[0];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[0] = ah0 = (c & 0xffff) | (d << 16);\n    hl[0] = al0 = (a & 0xffff) | (b << 16);\n\n    h = ah1;\n    l = al1;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[1];\n    l = hl[1];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[1] = ah1 = (c & 0xffff) | (d << 16);\n    hl[1] = al1 = (a & 0xffff) | (b << 16);\n\n    h = ah2;\n    l = al2;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[2];\n    l = hl[2];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[2] = ah2 = (c & 0xffff) | (d << 16);\n    hl[2] = al2 = (a & 0xffff) | (b << 16);\n\n    h = ah3;\n    l = al3;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[3];\n    l = hl[3];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[3] = ah3 = (c & 0xffff) | (d << 16);\n    hl[3] = al3 = (a & 0xffff) | (b << 16);\n\n    h = ah4;\n    l = al4;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[4];\n    l = hl[4];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[4] = ah4 = (c & 0xffff) | (d << 16);\n    hl[4] = al4 = (a & 0xffff) | (b << 16);\n\n    h = ah5;\n    l = al5;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[5];\n    l = hl[5];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[5] = ah5 = (c & 0xffff) | (d << 16);\n    hl[5] = al5 = (a & 0xffff) | (b << 16);\n\n    h = ah6;\n    l = al6;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[6];\n    l = hl[6];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[6] = ah6 = (c & 0xffff) | (d << 16);\n    hl[6] = al6 = (a & 0xffff) | (b << 16);\n\n    h = ah7;\n    l = al7;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[7];\n    l = hl[7];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[7] = ah7 = (c & 0xffff) | (d << 16);\n    hl[7] = al7 = (a & 0xffff) | (b << 16);\n\n    pos += 128;\n    n -= 128;\n  }\n\n  return n;\n}\n\nfunction crypto_hash(out, m, n) {\n  var hh = new Int32Array(8),\n      hl = new Int32Array(8),\n      x = new Uint8Array(256),\n      i, b = n;\n\n  hh[0] = 0x6a09e667;\n  hh[1] = 0xbb67ae85;\n  hh[2] = 0x3c6ef372;\n  hh[3] = 0xa54ff53a;\n  hh[4] = 0x510e527f;\n  hh[5] = 0x9b05688c;\n  hh[6] = 0x1f83d9ab;\n  hh[7] = 0x5be0cd19;\n\n  hl[0] = 0xf3bcc908;\n  hl[1] = 0x84caa73b;\n  hl[2] = 0xfe94f82b;\n  hl[3] = 0x5f1d36f1;\n  hl[4] = 0xade682d1;\n  hl[5] = 0x2b3e6c1f;\n  hl[6] = 0xfb41bd6b;\n  hl[7] = 0x137e2179;\n\n  crypto_hashblocks_hl(hh, hl, m, n);\n  n %= 128;\n\n  for (i = 0; i < n; i++) x[i] = m[b-n+i];\n  x[n] = 128;\n\n  n = 256-128*(n<112?1:0);\n  x[n-9] = 0;\n  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);\n  crypto_hashblocks_hl(hh, hl, x, n);\n\n  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);\n\n  return 0;\n}\n\nfunction add(p, q) {\n  var a = gf(), b = gf(), c = gf(),\n      d = gf(), e = gf(), f = gf(),\n      g = gf(), h = gf(), t = gf();\n\n  Z(a, p[1], p[0]);\n  Z(t, q[1], q[0]);\n  M(a, a, t);\n  A(b, p[0], p[1]);\n  A(t, q[0], q[1]);\n  M(b, b, t);\n  M(c, p[3], q[3]);\n  M(c, c, D2);\n  M(d, p[2], q[2]);\n  A(d, d, d);\n  Z(e, b, a);\n  Z(f, d, c);\n  A(g, d, c);\n  A(h, b, a);\n\n  M(p[0], e, f);\n  M(p[1], h, g);\n  M(p[2], g, f);\n  M(p[3], e, h);\n}\n\nfunction cswap(p, q, b) {\n  var i;\n  for (i = 0; i < 4; i++) {\n    sel25519(p[i], q[i], b);\n  }\n}\n\nfunction pack(r, p) {\n  var tx = gf(), ty = gf(), zi = gf();\n  inv25519(zi, p[2]);\n  M(tx, p[0], zi);\n  M(ty, p[1], zi);\n  pack25519(r, ty);\n  r[31] ^= par25519(tx) << 7;\n}\n\nfunction scalarmult(p, q, s) {\n  var b, i;\n  set25519(p[0], gf0);\n  set25519(p[1], gf1);\n  set25519(p[2], gf1);\n  set25519(p[3], gf0);\n  for (i = 255; i >= 0; --i) {\n    b = (s[(i/8)|0] >> (i&7)) & 1;\n    cswap(p, q, b);\n    add(q, p);\n    add(p, p);\n    cswap(p, q, b);\n  }\n}\n\nfunction scalarbase(p, s) {\n  var q = [gf(), gf(), gf(), gf()];\n  set25519(q[0], X);\n  set25519(q[1], Y);\n  set25519(q[2], gf1);\n  M(q[3], X, Y);\n  scalarmult(p, q, s);\n}\n\nfunction crypto_sign_keypair(pk, sk, seeded) {\n  var d = new Uint8Array(64);\n  var p = [gf(), gf(), gf(), gf()];\n  var i;\n\n  if (!seeded) randombytes(sk, 32);\n  crypto_hash(d, sk, 32);\n  d[0] &= 248;\n  d[31] &= 127;\n  d[31] |= 64;\n\n  scalarbase(p, d);\n  pack(pk, p);\n\n  for (i = 0; i < 32; i++) sk[i+32] = pk[i];\n  return 0;\n}\n\nvar L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);\n\nfunction modL(r, x) {\n  var carry, i, j, k;\n  for (i = 63; i >= 32; --i) {\n    carry = 0;\n    for (j = i - 32, k = i - 12; j < k; ++j) {\n      x[j] += carry - 16 * x[i] * L[j - (i - 32)];\n      carry = Math.floor((x[j] + 128) / 256);\n      x[j] -= carry * 256;\n    }\n    x[j] += carry;\n    x[i] = 0;\n  }\n  carry = 0;\n  for (j = 0; j < 32; j++) {\n    x[j] += carry - (x[31] >> 4) * L[j];\n    carry = x[j] >> 8;\n    x[j] &= 255;\n  }\n  for (j = 0; j < 32; j++) x[j] -= carry * L[j];\n  for (i = 0; i < 32; i++) {\n    x[i+1] += x[i] >> 8;\n    r[i] = x[i] & 255;\n  }\n}\n\nfunction reduce(r) {\n  var x = new Float64Array(64), i;\n  for (i = 0; i < 64; i++) x[i] = r[i];\n  for (i = 0; i < 64; i++) r[i] = 0;\n  modL(r, x);\n}\n\n// Note: difference from C - smlen returned, not passed as argument.\nfunction crypto_sign(sm, m, n, sk) {\n  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);\n  var i, j, x = new Float64Array(64);\n  var p = [gf(), gf(), gf(), gf()];\n\n  crypto_hash(d, sk, 32);\n  d[0] &= 248;\n  d[31] &= 127;\n  d[31] |= 64;\n\n  var smlen = n + 64;\n  for (i = 0; i < n; i++) sm[64 + i] = m[i];\n  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];\n\n  crypto_hash(r, sm.subarray(32), n+32);\n  reduce(r);\n  scalarbase(p, r);\n  pack(sm, p);\n\n  for (i = 32; i < 64; i++) sm[i] = sk[i];\n  crypto_hash(h, sm, n + 64);\n  reduce(h);\n\n  for (i = 0; i < 64; i++) x[i] = 0;\n  for (i = 0; i < 32; i++) x[i] = r[i];\n  for (i = 0; i < 32; i++) {\n    for (j = 0; j < 32; j++) {\n      x[i+j] += h[i] * d[j];\n    }\n  }\n\n  modL(sm.subarray(32), x);\n  return smlen;\n}\n\nfunction unpackneg(r, p) {\n  var t = gf(), chk = gf(), num = gf(),\n      den = gf(), den2 = gf(), den4 = gf(),\n      den6 = gf();\n\n  set25519(r[2], gf1);\n  unpack25519(r[1], p);\n  S(num, r[1]);\n  M(den, num, D);\n  Z(num, num, r[2]);\n  A(den, r[2], den);\n\n  S(den2, den);\n  S(den4, den2);\n  M(den6, den4, den2);\n  M(t, den6, num);\n  M(t, t, den);\n\n  pow2523(t, t);\n  M(t, t, num);\n  M(t, t, den);\n  M(t, t, den);\n  M(r[0], t, den);\n\n  S(chk, r[0]);\n  M(chk, chk, den);\n  if (neq25519(chk, num)) M(r[0], r[0], I);\n\n  S(chk, r[0]);\n  M(chk, chk, den);\n  if (neq25519(chk, num)) return -1;\n\n  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);\n\n  M(r[3], r[0], r[1]);\n  return 0;\n}\n\nfunction crypto_sign_open(m, sm, n, pk) {\n  var i;\n  var t = new Uint8Array(32), h = new Uint8Array(64);\n  var p = [gf(), gf(), gf(), gf()],\n      q = [gf(), gf(), gf(), gf()];\n\n  if (n < 64) return -1;\n\n  if (unpackneg(q, pk)) return -1;\n\n  for (i = 0; i < n; i++) m[i] = sm[i];\n  for (i = 0; i < 32; i++) m[i+32] = pk[i];\n  crypto_hash(h, m, n);\n  reduce(h);\n  scalarmult(p, q, h);\n\n  scalarbase(q, sm.subarray(32));\n  add(p, q);\n  pack(t, p);\n\n  n -= 64;\n  if (crypto_verify_32(sm, 0, t, 0)) {\n    for (i = 0; i < n; i++) m[i] = 0;\n    return -1;\n  }\n\n  for (i = 0; i < n; i++) m[i] = sm[i + 64];\n  return n;\n}\n\nvar crypto_secretbox_KEYBYTES = 32,\n    crypto_secretbox_NONCEBYTES = 24,\n    crypto_secretbox_ZEROBYTES = 32,\n    crypto_secretbox_BOXZEROBYTES = 16,\n    crypto_scalarmult_BYTES = 32,\n    crypto_scalarmult_SCALARBYTES = 32,\n    crypto_box_PUBLICKEYBYTES = 32,\n    crypto_box_SECRETKEYBYTES = 32,\n    crypto_box_BEFORENMBYTES = 32,\n    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,\n    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,\n    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,\n    crypto_sign_BYTES = 64,\n    crypto_sign_PUBLICKEYBYTES = 32,\n    crypto_sign_SECRETKEYBYTES = 64,\n    crypto_sign_SEEDBYTES = 32,\n    crypto_hash_BYTES = 64;\n\nnacl.lowlevel = {\n  crypto_core_hsalsa20: crypto_core_hsalsa20,\n  crypto_stream_xor: crypto_stream_xor,\n  crypto_stream: crypto_stream,\n  crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,\n  crypto_stream_salsa20: crypto_stream_salsa20,\n  crypto_onetimeauth: crypto_onetimeauth,\n  crypto_onetimeauth_verify: crypto_onetimeauth_verify,\n  crypto_verify_16: crypto_verify_16,\n  crypto_verify_32: crypto_verify_32,\n  crypto_secretbox: crypto_secretbox,\n  crypto_secretbox_open: crypto_secretbox_open,\n  crypto_scalarmult: crypto_scalarmult,\n  crypto_scalarmult_base: crypto_scalarmult_base,\n  crypto_box_beforenm: crypto_box_beforenm,\n  crypto_box_afternm: crypto_box_afternm,\n  crypto_box: crypto_box,\n  crypto_box_open: crypto_box_open,\n  crypto_box_keypair: crypto_box_keypair,\n  crypto_hash: crypto_hash,\n  crypto_sign: crypto_sign,\n  crypto_sign_keypair: crypto_sign_keypair,\n  crypto_sign_open: crypto_sign_open,\n\n  crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,\n  crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,\n  crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,\n  crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,\n  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,\n  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,\n  crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,\n  crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,\n  crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,\n  crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,\n  crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,\n  crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,\n  crypto_sign_BYTES: crypto_sign_BYTES,\n  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,\n  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,\n  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,\n  crypto_hash_BYTES: crypto_hash_BYTES,\n\n  gf: gf,\n  D: D,\n  L: L,\n  pack25519: pack25519,\n  unpack25519: unpack25519,\n  M: M,\n  A: A,\n  S: S,\n  Z: Z,\n  pow2523: pow2523,\n  add: add,\n  set25519: set25519,\n  modL: modL,\n  scalarmult: scalarmult,\n  scalarbase: scalarbase,\n};\n\n/* High-level API */\n\nfunction checkLengths(k, n) {\n  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');\n  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');\n}\n\nfunction checkBoxLengths(pk, sk) {\n  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');\n  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');\n}\n\nfunction checkArrayTypes() {\n  for (var i = 0; i < arguments.length; i++) {\n    if (!(arguments[i] instanceof Uint8Array))\n      throw new TypeError('unexpected type, use Uint8Array');\n  }\n}\n\nfunction cleanup(arr) {\n  for (var i = 0; i < arr.length; i++) arr[i] = 0;\n}\n\nnacl.randomBytes = function(n) {\n  var b = new Uint8Array(n);\n  randombytes(b, n);\n  return b;\n};\n\nnacl.secretbox = function(msg, nonce, key) {\n  checkArrayTypes(msg, nonce, key);\n  checkLengths(key, nonce);\n  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);\n  var c = new Uint8Array(m.length);\n  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];\n  crypto_secretbox(c, m, m.length, nonce, key);\n  return c.subarray(crypto_secretbox_BOXZEROBYTES);\n};\n\nnacl.secretbox.open = function(box, nonce, key) {\n  checkArrayTypes(box, nonce, key);\n  checkLengths(key, nonce);\n  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);\n  var m = new Uint8Array(c.length);\n  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];\n  if (c.length < 32) return null;\n  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;\n  return m.subarray(crypto_secretbox_ZEROBYTES);\n};\n\nnacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;\nnacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;\nnacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;\n\nnacl.scalarMult = function(n, p) {\n  checkArrayTypes(n, p);\n  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');\n  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');\n  var q = new Uint8Array(crypto_scalarmult_BYTES);\n  crypto_scalarmult(q, n, p);\n  return q;\n};\n\nnacl.scalarMult.base = function(n) {\n  checkArrayTypes(n);\n  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');\n  var q = new Uint8Array(crypto_scalarmult_BYTES);\n  crypto_scalarmult_base(q, n);\n  return q;\n};\n\nnacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;\nnacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;\n\nnacl.box = function(msg, nonce, publicKey, secretKey) {\n  var k = nacl.box.before(publicKey, secretKey);\n  return nacl.secretbox(msg, nonce, k);\n};\n\nnacl.box.before = function(publicKey, secretKey) {\n  checkArrayTypes(publicKey, secretKey);\n  checkBoxLengths(publicKey, secretKey);\n  var k = new Uint8Array(crypto_box_BEFORENMBYTES);\n  crypto_box_beforenm(k, publicKey, secretKey);\n  return k;\n};\n\nnacl.box.after = nacl.secretbox;\n\nnacl.box.open = function(msg, nonce, publicKey, secretKey) {\n  var k = nacl.box.before(publicKey, secretKey);\n  return nacl.secretbox.open(msg, nonce, k);\n};\n\nnacl.box.open.after = nacl.secretbox.open;\n\nnacl.box.keyPair = function() {\n  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);\n  crypto_box_keypair(pk, sk);\n  return {publicKey: pk, secretKey: sk};\n};\n\nnacl.box.keyPair.fromSecretKey = function(secretKey) {\n  checkArrayTypes(secretKey);\n  if (secretKey.length !== crypto_box_SECRETKEYBYTES)\n    throw new Error('bad secret key size');\n  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n  crypto_scalarmult_base(pk, secretKey);\n  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};\n};\n\nnacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;\nnacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;\nnacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;\nnacl.box.nonceLength = crypto_box_NONCEBYTES;\nnacl.box.overheadLength = nacl.secretbox.overheadLength;\n\nnacl.sign = function(msg, secretKey) {\n  checkArrayTypes(msg, secretKey);\n  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)\n    throw new Error('bad secret key size');\n  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);\n  crypto_sign(signedMsg, msg, msg.length, secretKey);\n  return signedMsg;\n};\n\nnacl.sign.open = function(signedMsg, publicKey) {\n  checkArrayTypes(signedMsg, publicKey);\n  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)\n    throw new Error('bad public key size');\n  var tmp = new Uint8Array(signedMsg.length);\n  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);\n  if (mlen < 0) return null;\n  var m = new Uint8Array(mlen);\n  for (var i = 0; i < m.length; i++) m[i] = tmp[i];\n  return m;\n};\n\nnacl.sign.detached = function(msg, secretKey) {\n  var signedMsg = nacl.sign(msg, secretKey);\n  var sig = new Uint8Array(crypto_sign_BYTES);\n  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];\n  return sig;\n};\n\nnacl.sign.detached.verify = function(msg, sig, publicKey) {\n  checkArrayTypes(msg, sig, publicKey);\n  if (sig.length !== crypto_sign_BYTES)\n    throw new Error('bad signature size');\n  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)\n    throw new Error('bad public key size');\n  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);\n  var m = new Uint8Array(crypto_sign_BYTES + msg.length);\n  var i;\n  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];\n  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];\n  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);\n};\n\nnacl.sign.keyPair = function() {\n  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n  crypto_sign_keypair(pk, sk);\n  return {publicKey: pk, secretKey: sk};\n};\n\nnacl.sign.keyPair.fromSecretKey = function(secretKey) {\n  checkArrayTypes(secretKey);\n  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)\n    throw new Error('bad secret key size');\n  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];\n  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};\n};\n\nnacl.sign.keyPair.fromSeed = function(seed) {\n  checkArrayTypes(seed);\n  if (seed.length !== crypto_sign_SEEDBYTES)\n    throw new Error('bad seed size');\n  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n  for (var i = 0; i < 32; i++) sk[i] = seed[i];\n  crypto_sign_keypair(pk, sk, true);\n  return {publicKey: pk, secretKey: sk};\n};\n\nnacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;\nnacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;\nnacl.sign.seedLength = crypto_sign_SEEDBYTES;\nnacl.sign.signatureLength = crypto_sign_BYTES;\n\nnacl.hash = function(msg) {\n  checkArrayTypes(msg);\n  var h = new Uint8Array(crypto_hash_BYTES);\n  crypto_hash(h, msg, msg.length);\n  return h;\n};\n\nnacl.hash.hashLength = crypto_hash_BYTES;\n\nnacl.verify = function(x, y) {\n  checkArrayTypes(x, y);\n  // Zero length arguments are considered not equal.\n  if (x.length === 0 || y.length === 0) return false;\n  if (x.length !== y.length) return false;\n  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;\n};\n\nnacl.setPRNG = function(fn) {\n  randombytes = fn;\n};\n\n(function() {\n  // Initialize PRNG if environment provides CSPRNG.\n  // If not, methods calling randombytes will throw.\n  var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;\n  if (crypto && crypto.getRandomValues) {\n    // Browsers.\n    var QUOTA = 65536;\n    nacl.setPRNG(function(x, n) {\n      var i, v = new Uint8Array(n);\n      for (i = 0; i < n; i += QUOTA) {\n        crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));\n      }\n      for (i = 0; i < n; i++) x[i] = v[i];\n      cleanup(v);\n    });\n  } else if (true) {\n    // Node.js.\n    crypto = __webpack_require__(/*! crypto */ \"crypto\");\n    if (crypto && crypto.randomBytes) {\n      nacl.setPRNG(function(x, n) {\n        var i, v = crypto.randomBytes(n);\n        for (i = 0; i < n; i++) x[i] = v[i];\n        cleanup(v);\n      });\n    }\n  }\n})();\n\n})( true && module.exports ? module.exports : (self.nacl = self.nacl || {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL3R3ZWV0bmFjbC9uYWNsLWZhc3QuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0NBQStDO0FBQy9DLCtDQUErQztBQUMvQywrQ0FBK0M7QUFDL0MsK0NBQStDO0FBQy9DLCtDQUErQztBQUMvQztBQUNBLCtDQUErQztBQUMvQywrQ0FBK0M7QUFDL0MsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RDtBQUN2RCx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZELHVEQUF1RDtBQUN2RCx1REFBdUQ7QUFDdkQ7QUFDQSx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZELHVEQUF1RDtBQUN2RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsUUFBUTs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjs7QUFFQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBNEI7QUFDbkQsdUJBQXVCLDRCQUE0QjtBQUNuRCx1QkFBdUIsNEJBQTRCO0FBQ25ELHVCQUF1Qiw0QkFBNEI7QUFDbkQsdUJBQXVCLDRCQUE0QjtBQUNuRCx1QkFBdUIsNEJBQTRCO0FBQ25ELHVCQUF1Qiw0QkFBNEI7QUFDbkQsdUJBQXVCLDRCQUE0QjtBQUNuRCx1QkFBdUIsNEJBQTRCO0FBQ25ELHVCQUF1Qiw0QkFBNEI7QUFDbkQsdUJBQXVCLDJCQUEyQjtBQUNsRCx1QkFBdUIsMkJBQTJCO0FBQ2xELHVCQUF1QiwyQkFBMkI7QUFDbEQsdUJBQXVCLDJCQUEyQjtBQUNsRCx1QkFBdUIsMkJBQTJCO0FBQ2xELHVCQUF1QiwyQkFBMkI7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBNEI7QUFDbkQsdUJBQXVCLDRCQUE0QjtBQUNuRCx1QkFBdUIsNEJBQTRCO0FBQ25ELHVCQUF1Qiw0QkFBNEI7QUFDbkQsdUJBQXVCLDRCQUE0QjtBQUNuRCx1QkFBdUIsNEJBQTRCO0FBQ25ELHVCQUF1Qiw0QkFBNEI7QUFDbkQsdUJBQXVCLDRCQUE0QjtBQUNuRCx1QkFBdUIsNEJBQTRCO0FBQ25ELHVCQUF1Qiw0QkFBNEI7QUFDbkQsdUJBQXVCLDJCQUEyQjtBQUNsRCx1QkFBdUIsMkJBQTJCO0FBQ2xELHVCQUF1QiwyQkFBMkI7QUFDbEQsdUJBQXVCLDJCQUEyQjtBQUNsRCx1QkFBdUIsMkJBQTJCO0FBQ2xELHVCQUF1QiwyQkFBMkI7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qix1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkIsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qix1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEIsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qix1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEIsc0JBQXNCOztBQUV0QjtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qix1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUIsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQiwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0IsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckIscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQixvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEIsb0JBQW9COztBQUVwQjtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQixxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckIscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQixvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEIsb0JBQW9COztBQUVwQjtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQixxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckIscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQixvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLE9BQU87QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxPQUFPOztBQUVyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWMsUUFBUTtBQUN0QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxRQUFROztBQUV0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxjQUFjLE9BQU87QUFDckIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7O0FBRUEsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBLEtBQUs7QUFDTCxJQUFJLFNBQVMsSUFBOEI7QUFDM0M7QUFDQSxhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQsQ0FBQyxFQUFFLEtBQTZCLGtFQUFrRSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9ub2RlX21vZHVsZXMvdHdlZXRuYWNsL25hY2wtZmFzdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24obmFjbCkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBQb3J0ZWQgaW4gMjAxNCBieSBEbWl0cnkgQ2hlc3RueWtoIGFuZCBEZXZpIE1hbmRpcmkuXG4vLyBQdWJsaWMgZG9tYWluLlxuLy9cbi8vIEltcGxlbWVudGF0aW9uIGRlcml2ZWQgZnJvbSBUd2VldE5hQ2wgdmVyc2lvbiAyMDE0MDQyNy5cbi8vIFNlZSBmb3IgZGV0YWlsczogaHR0cDovL3R3ZWV0bmFjbC5jci55cC50by9cblxudmFyIGdmID0gZnVuY3Rpb24oaW5pdCkge1xuICB2YXIgaSwgciA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuICBpZiAoaW5pdCkgZm9yIChpID0gMDsgaSA8IGluaXQubGVuZ3RoOyBpKyspIHJbaV0gPSBpbml0W2ldO1xuICByZXR1cm4gcjtcbn07XG5cbi8vICBQbHVnZ2FibGUsIGluaXRpYWxpemVkIGluIGhpZ2gtbGV2ZWwgQVBJIGJlbG93LlxudmFyIHJhbmRvbWJ5dGVzID0gZnVuY3Rpb24oLyogeCwgbiAqLykgeyB0aHJvdyBuZXcgRXJyb3IoJ25vIFBSTkcnKTsgfTtcblxudmFyIF8wID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xudmFyIF85ID0gbmV3IFVpbnQ4QXJyYXkoMzIpOyBfOVswXSA9IDk7XG5cbnZhciBnZjAgPSBnZigpLFxuICAgIGdmMSA9IGdmKFsxXSksXG4gICAgXzEyMTY2NSA9IGdmKFsweGRiNDEsIDFdKSxcbiAgICBEID0gZ2YoWzB4NzhhMywgMHgxMzU5LCAweDRkY2EsIDB4NzVlYiwgMHhkOGFiLCAweDQxNDEsIDB4MGE0ZCwgMHgwMDcwLCAweGU4OTgsIDB4Nzc3OSwgMHg0MDc5LCAweDhjYzcsIDB4ZmU3MywgMHgyYjZmLCAweDZjZWUsIDB4NTIwM10pLFxuICAgIEQyID0gZ2YoWzB4ZjE1OSwgMHgyNmIyLCAweDliOTQsIDB4ZWJkNiwgMHhiMTU2LCAweDgyODMsIDB4MTQ5YSwgMHgwMGUwLCAweGQxMzAsIDB4ZWVmMywgMHg4MGYyLCAweDE5OGUsIDB4ZmNlNywgMHg1NmRmLCAweGQ5ZGMsIDB4MjQwNl0pLFxuICAgIFggPSBnZihbMHhkNTFhLCAweDhmMjUsIDB4MmQ2MCwgMHhjOTU2LCAweGE3YjIsIDB4OTUyNSwgMHhjNzYwLCAweDY5MmMsIDB4ZGM1YywgMHhmZGQ2LCAweGUyMzEsIDB4YzBhNCwgMHg1M2ZlLCAweGNkNmUsIDB4MzZkMywgMHgyMTY5XSksXG4gICAgWSA9IGdmKFsweDY2NTgsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjZdKSxcbiAgICBJID0gZ2YoWzB4YTBiMCwgMHg0YTBlLCAweDFiMjcsIDB4YzRlZSwgMHhlNDc4LCAweGFkMmYsIDB4MTgwNiwgMHgyZjQzLCAweGQ3YTcsIDB4M2RmYiwgMHgwMDk5LCAweDJiNGQsIDB4ZGYwYiwgMHg0ZmMxLCAweDI0ODAsIDB4MmI4M10pO1xuXG5mdW5jdGlvbiB0czY0KHgsIGksIGgsIGwpIHtcbiAgeFtpXSAgID0gKGggPj4gMjQpICYgMHhmZjtcbiAgeFtpKzFdID0gKGggPj4gMTYpICYgMHhmZjtcbiAgeFtpKzJdID0gKGggPj4gIDgpICYgMHhmZjtcbiAgeFtpKzNdID0gaCAmIDB4ZmY7XG4gIHhbaSs0XSA9IChsID4+IDI0KSAgJiAweGZmO1xuICB4W2krNV0gPSAobCA+PiAxNikgICYgMHhmZjtcbiAgeFtpKzZdID0gKGwgPj4gIDgpICAmIDB4ZmY7XG4gIHhbaSs3XSA9IGwgJiAweGZmO1xufVxuXG5mdW5jdGlvbiB2bih4LCB4aSwgeSwgeWksIG4pIHtcbiAgdmFyIGksZCA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIGQgfD0geFt4aStpXV55W3lpK2ldO1xuICByZXR1cm4gKDEgJiAoKGQgLSAxKSA+Pj4gOCkpIC0gMTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3ZlcmlmeV8xNih4LCB4aSwgeSwgeWkpIHtcbiAgcmV0dXJuIHZuKHgseGkseSx5aSwxNik7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b192ZXJpZnlfMzIoeCwgeGksIHksIHlpKSB7XG4gIHJldHVybiB2bih4LHhpLHkseWksMzIpO1xufVxuXG5mdW5jdGlvbiBjb3JlX3NhbHNhMjAobywgcCwgaywgYykge1xuICB2YXIgajAgID0gY1sgMF0gJiAweGZmIHwgKGNbIDFdICYgMHhmZik8PDggfCAoY1sgMl0gJiAweGZmKTw8MTYgfCAoY1sgM10gJiAweGZmKTw8MjQsXG4gICAgICBqMSAgPSBrWyAwXSAmIDB4ZmYgfCAoa1sgMV0gJiAweGZmKTw8OCB8IChrWyAyXSAmIDB4ZmYpPDwxNiB8IChrWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoyICA9IGtbIDRdICYgMHhmZiB8IChrWyA1XSAmIDB4ZmYpPDw4IHwgKGtbIDZdICYgMHhmZik8PDE2IHwgKGtbIDddICYgMHhmZik8PDI0LFxuICAgICAgajMgID0ga1sgOF0gJiAweGZmIHwgKGtbIDldICYgMHhmZik8PDggfCAoa1sxMF0gJiAweGZmKTw8MTYgfCAoa1sxMV0gJiAweGZmKTw8MjQsXG4gICAgICBqNCAgPSBrWzEyXSAmIDB4ZmYgfCAoa1sxM10gJiAweGZmKTw8OCB8IChrWzE0XSAmIDB4ZmYpPDwxNiB8IChrWzE1XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo1ICA9IGNbIDRdICYgMHhmZiB8IChjWyA1XSAmIDB4ZmYpPDw4IHwgKGNbIDZdICYgMHhmZik8PDE2IHwgKGNbIDddICYgMHhmZik8PDI0LFxuICAgICAgajYgID0gcFsgMF0gJiAweGZmIHwgKHBbIDFdICYgMHhmZik8PDggfCAocFsgMl0gJiAweGZmKTw8MTYgfCAocFsgM10gJiAweGZmKTw8MjQsXG4gICAgICBqNyAgPSBwWyA0XSAmIDB4ZmYgfCAocFsgNV0gJiAweGZmKTw8OCB8IChwWyA2XSAmIDB4ZmYpPDwxNiB8IChwWyA3XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo4ICA9IHBbIDhdICYgMHhmZiB8IChwWyA5XSAmIDB4ZmYpPDw4IHwgKHBbMTBdICYgMHhmZik8PDE2IHwgKHBbMTFdICYgMHhmZik8PDI0LFxuICAgICAgajkgID0gcFsxMl0gJiAweGZmIHwgKHBbMTNdICYgMHhmZik8PDggfCAocFsxNF0gJiAweGZmKTw8MTYgfCAocFsxNV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTAgPSBjWyA4XSAmIDB4ZmYgfCAoY1sgOV0gJiAweGZmKTw8OCB8IChjWzEwXSAmIDB4ZmYpPDwxNiB8IChjWzExXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMSA9IGtbMTZdICYgMHhmZiB8IChrWzE3XSAmIDB4ZmYpPDw4IHwgKGtbMThdICYgMHhmZik8PDE2IHwgKGtbMTldICYgMHhmZik8PDI0LFxuICAgICAgajEyID0ga1syMF0gJiAweGZmIHwgKGtbMjFdICYgMHhmZik8PDggfCAoa1syMl0gJiAweGZmKTw8MTYgfCAoa1syM10gJiAweGZmKTw8MjQsXG4gICAgICBqMTMgPSBrWzI0XSAmIDB4ZmYgfCAoa1syNV0gJiAweGZmKTw8OCB8IChrWzI2XSAmIDB4ZmYpPDwxNiB8IChrWzI3XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxNCA9IGtbMjhdICYgMHhmZiB8IChrWzI5XSAmIDB4ZmYpPDw4IHwgKGtbMzBdICYgMHhmZik8PDE2IHwgKGtbMzFdICYgMHhmZik8PDI0LFxuICAgICAgajE1ID0gY1sxMl0gJiAweGZmIHwgKGNbMTNdICYgMHhmZik8PDggfCAoY1sxNF0gJiAweGZmKTw8MTYgfCAoY1sxNV0gJiAweGZmKTw8MjQ7XG5cbiAgdmFyIHgwID0gajAsIHgxID0gajEsIHgyID0gajIsIHgzID0gajMsIHg0ID0gajQsIHg1ID0gajUsIHg2ID0gajYsIHg3ID0gajcsXG4gICAgICB4OCA9IGo4LCB4OSA9IGo5LCB4MTAgPSBqMTAsIHgxMSA9IGoxMSwgeDEyID0gajEyLCB4MTMgPSBqMTMsIHgxNCA9IGoxNCxcbiAgICAgIHgxNSA9IGoxNSwgdTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDIwOyBpICs9IDIpIHtcbiAgICB1ID0geDAgKyB4MTIgfCAwO1xuICAgIHg0IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4NCArIHgwIHwgMDtcbiAgICB4OCBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDggKyB4NCB8IDA7XG4gICAgeDEyIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxMiArIHg4IHwgMDtcbiAgICB4MCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHg1ICsgeDEgfCAwO1xuICAgIHg5IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4OSArIHg1IHwgMDtcbiAgICB4MTMgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgxMyArIHg5IHwgMDtcbiAgICB4MSBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MSArIHgxMyB8IDA7XG4gICAgeDUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTAgKyB4NiB8IDA7XG4gICAgeDE0IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MTQgKyB4MTAgfCAwO1xuICAgIHgyIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MiArIHgxNCB8IDA7XG4gICAgeDYgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDYgKyB4MiB8IDA7XG4gICAgeDEwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDE1ICsgeDExIHwgMDtcbiAgICB4MyBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDMgKyB4MTUgfCAwO1xuICAgIHg3IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4NyArIHgzIHwgMDtcbiAgICB4MTEgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDExICsgeDcgfCAwO1xuICAgIHgxNSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgwICsgeDMgfCAwO1xuICAgIHgxIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MSArIHgwIHwgMDtcbiAgICB4MiBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDIgKyB4MSB8IDA7XG4gICAgeDMgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDMgKyB4MiB8IDA7XG4gICAgeDAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4NSArIHg0IHwgMDtcbiAgICB4NiBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDYgKyB4NSB8IDA7XG4gICAgeDcgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg3ICsgeDYgfCAwO1xuICAgIHg0IF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHg0ICsgeDcgfCAwO1xuICAgIHg1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDEwICsgeDkgfCAwO1xuICAgIHgxMSBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDExICsgeDEwIHwgMDtcbiAgICB4OCBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDggKyB4MTEgfCAwO1xuICAgIHg5IF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHg5ICsgeDggfCAwO1xuICAgIHgxMCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxNSArIHgxNCB8IDA7XG4gICAgeDEyIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MTIgKyB4MTUgfCAwO1xuICAgIHgxMyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDEzICsgeDEyIHwgMDtcbiAgICB4MTQgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDE0ICsgeDEzIHwgMDtcbiAgICB4MTUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcbiAgfVxuICAgeDAgPSAgeDAgKyAgajAgfCAwO1xuICAgeDEgPSAgeDEgKyAgajEgfCAwO1xuICAgeDIgPSAgeDIgKyAgajIgfCAwO1xuICAgeDMgPSAgeDMgKyAgajMgfCAwO1xuICAgeDQgPSAgeDQgKyAgajQgfCAwO1xuICAgeDUgPSAgeDUgKyAgajUgfCAwO1xuICAgeDYgPSAgeDYgKyAgajYgfCAwO1xuICAgeDcgPSAgeDcgKyAgajcgfCAwO1xuICAgeDggPSAgeDggKyAgajggfCAwO1xuICAgeDkgPSAgeDkgKyAgajkgfCAwO1xuICB4MTAgPSB4MTAgKyBqMTAgfCAwO1xuICB4MTEgPSB4MTEgKyBqMTEgfCAwO1xuICB4MTIgPSB4MTIgKyBqMTIgfCAwO1xuICB4MTMgPSB4MTMgKyBqMTMgfCAwO1xuICB4MTQgPSB4MTQgKyBqMTQgfCAwO1xuICB4MTUgPSB4MTUgKyBqMTUgfCAwO1xuXG4gIG9bIDBdID0geDAgPj4+ICAwICYgMHhmZjtcbiAgb1sgMV0gPSB4MCA+Pj4gIDggJiAweGZmO1xuICBvWyAyXSA9IHgwID4+PiAxNiAmIDB4ZmY7XG4gIG9bIDNdID0geDAgPj4+IDI0ICYgMHhmZjtcblxuICBvWyA0XSA9IHgxID4+PiAgMCAmIDB4ZmY7XG4gIG9bIDVdID0geDEgPj4+ICA4ICYgMHhmZjtcbiAgb1sgNl0gPSB4MSA+Pj4gMTYgJiAweGZmO1xuICBvWyA3XSA9IHgxID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sgOF0gPSB4MiA+Pj4gIDAgJiAweGZmO1xuICBvWyA5XSA9IHgyID4+PiAgOCAmIDB4ZmY7XG4gIG9bMTBdID0geDIgPj4+IDE2ICYgMHhmZjtcbiAgb1sxMV0gPSB4MiA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMTJdID0geDMgPj4+ICAwICYgMHhmZjtcbiAgb1sxM10gPSB4MyA+Pj4gIDggJiAweGZmO1xuICBvWzE0XSA9IHgzID4+PiAxNiAmIDB4ZmY7XG4gIG9bMTVdID0geDMgPj4+IDI0ICYgMHhmZjtcblxuICBvWzE2XSA9IHg0ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMTddID0geDQgPj4+ICA4ICYgMHhmZjtcbiAgb1sxOF0gPSB4NCA+Pj4gMTYgJiAweGZmO1xuICBvWzE5XSA9IHg0ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1syMF0gPSB4NSA+Pj4gIDAgJiAweGZmO1xuICBvWzIxXSA9IHg1ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMjJdID0geDUgPj4+IDE2ICYgMHhmZjtcbiAgb1syM10gPSB4NSA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMjRdID0geDYgPj4+ICAwICYgMHhmZjtcbiAgb1syNV0gPSB4NiA+Pj4gIDggJiAweGZmO1xuICBvWzI2XSA9IHg2ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMjddID0geDYgPj4+IDI0ICYgMHhmZjtcblxuICBvWzI4XSA9IHg3ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMjldID0geDcgPj4+ICA4ICYgMHhmZjtcbiAgb1szMF0gPSB4NyA+Pj4gMTYgJiAweGZmO1xuICBvWzMxXSA9IHg3ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1szMl0gPSB4OCA+Pj4gIDAgJiAweGZmO1xuICBvWzMzXSA9IHg4ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMzRdID0geDggPj4+IDE2ICYgMHhmZjtcbiAgb1szNV0gPSB4OCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMzZdID0geDkgPj4+ICAwICYgMHhmZjtcbiAgb1szN10gPSB4OSA+Pj4gIDggJiAweGZmO1xuICBvWzM4XSA9IHg5ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMzldID0geDkgPj4+IDI0ICYgMHhmZjtcblxuICBvWzQwXSA9IHgxMCA+Pj4gIDAgJiAweGZmO1xuICBvWzQxXSA9IHgxMCA+Pj4gIDggJiAweGZmO1xuICBvWzQyXSA9IHgxMCA+Pj4gMTYgJiAweGZmO1xuICBvWzQzXSA9IHgxMCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bNDRdID0geDExID4+PiAgMCAmIDB4ZmY7XG4gIG9bNDVdID0geDExID4+PiAgOCAmIDB4ZmY7XG4gIG9bNDZdID0geDExID4+PiAxNiAmIDB4ZmY7XG4gIG9bNDddID0geDExID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1s0OF0gPSB4MTIgPj4+ICAwICYgMHhmZjtcbiAgb1s0OV0gPSB4MTIgPj4+ICA4ICYgMHhmZjtcbiAgb1s1MF0gPSB4MTIgPj4+IDE2ICYgMHhmZjtcbiAgb1s1MV0gPSB4MTIgPj4+IDI0ICYgMHhmZjtcblxuICBvWzUyXSA9IHgxMyA+Pj4gIDAgJiAweGZmO1xuICBvWzUzXSA9IHgxMyA+Pj4gIDggJiAweGZmO1xuICBvWzU0XSA9IHgxMyA+Pj4gMTYgJiAweGZmO1xuICBvWzU1XSA9IHgxMyA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bNTZdID0geDE0ID4+PiAgMCAmIDB4ZmY7XG4gIG9bNTddID0geDE0ID4+PiAgOCAmIDB4ZmY7XG4gIG9bNThdID0geDE0ID4+PiAxNiAmIDB4ZmY7XG4gIG9bNTldID0geDE0ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1s2MF0gPSB4MTUgPj4+ICAwICYgMHhmZjtcbiAgb1s2MV0gPSB4MTUgPj4+ICA4ICYgMHhmZjtcbiAgb1s2Ml0gPSB4MTUgPj4+IDE2ICYgMHhmZjtcbiAgb1s2M10gPSB4MTUgPj4+IDI0ICYgMHhmZjtcbn1cblxuZnVuY3Rpb24gY29yZV9oc2Fsc2EyMChvLHAsayxjKSB7XG4gIHZhciBqMCAgPSBjWyAwXSAmIDB4ZmYgfCAoY1sgMV0gJiAweGZmKTw8OCB8IChjWyAyXSAmIDB4ZmYpPDwxNiB8IChjWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxICA9IGtbIDBdICYgMHhmZiB8IChrWyAxXSAmIDB4ZmYpPDw4IHwgKGtbIDJdICYgMHhmZik8PDE2IHwgKGtbIDNdICYgMHhmZik8PDI0LFxuICAgICAgajIgID0ga1sgNF0gJiAweGZmIHwgKGtbIDVdICYgMHhmZik8PDggfCAoa1sgNl0gJiAweGZmKTw8MTYgfCAoa1sgN10gJiAweGZmKTw8MjQsXG4gICAgICBqMyAgPSBrWyA4XSAmIDB4ZmYgfCAoa1sgOV0gJiAweGZmKTw8OCB8IChrWzEwXSAmIDB4ZmYpPDwxNiB8IChrWzExXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo0ICA9IGtbMTJdICYgMHhmZiB8IChrWzEzXSAmIDB4ZmYpPDw4IHwgKGtbMTRdICYgMHhmZik8PDE2IHwgKGtbMTVdICYgMHhmZik8PDI0LFxuICAgICAgajUgID0gY1sgNF0gJiAweGZmIHwgKGNbIDVdICYgMHhmZik8PDggfCAoY1sgNl0gJiAweGZmKTw8MTYgfCAoY1sgN10gJiAweGZmKTw8MjQsXG4gICAgICBqNiAgPSBwWyAwXSAmIDB4ZmYgfCAocFsgMV0gJiAweGZmKTw8OCB8IChwWyAyXSAmIDB4ZmYpPDwxNiB8IChwWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo3ICA9IHBbIDRdICYgMHhmZiB8IChwWyA1XSAmIDB4ZmYpPDw4IHwgKHBbIDZdICYgMHhmZik8PDE2IHwgKHBbIDddICYgMHhmZik8PDI0LFxuICAgICAgajggID0gcFsgOF0gJiAweGZmIHwgKHBbIDldICYgMHhmZik8PDggfCAocFsxMF0gJiAweGZmKTw8MTYgfCAocFsxMV0gJiAweGZmKTw8MjQsXG4gICAgICBqOSAgPSBwWzEyXSAmIDB4ZmYgfCAocFsxM10gJiAweGZmKTw8OCB8IChwWzE0XSAmIDB4ZmYpPDwxNiB8IChwWzE1XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMCA9IGNbIDhdICYgMHhmZiB8IChjWyA5XSAmIDB4ZmYpPDw4IHwgKGNbMTBdICYgMHhmZik8PDE2IHwgKGNbMTFdICYgMHhmZik8PDI0LFxuICAgICAgajExID0ga1sxNl0gJiAweGZmIHwgKGtbMTddICYgMHhmZik8PDggfCAoa1sxOF0gJiAweGZmKTw8MTYgfCAoa1sxOV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTIgPSBrWzIwXSAmIDB4ZmYgfCAoa1syMV0gJiAweGZmKTw8OCB8IChrWzIyXSAmIDB4ZmYpPDwxNiB8IChrWzIzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMyA9IGtbMjRdICYgMHhmZiB8IChrWzI1XSAmIDB4ZmYpPDw4IHwgKGtbMjZdICYgMHhmZik8PDE2IHwgKGtbMjddICYgMHhmZik8PDI0LFxuICAgICAgajE0ID0ga1syOF0gJiAweGZmIHwgKGtbMjldICYgMHhmZik8PDggfCAoa1szMF0gJiAweGZmKTw8MTYgfCAoa1szMV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTUgPSBjWzEyXSAmIDB4ZmYgfCAoY1sxM10gJiAweGZmKTw8OCB8IChjWzE0XSAmIDB4ZmYpPDwxNiB8IChjWzE1XSAmIDB4ZmYpPDwyNDtcblxuICB2YXIgeDAgPSBqMCwgeDEgPSBqMSwgeDIgPSBqMiwgeDMgPSBqMywgeDQgPSBqNCwgeDUgPSBqNSwgeDYgPSBqNiwgeDcgPSBqNyxcbiAgICAgIHg4ID0gajgsIHg5ID0gajksIHgxMCA9IGoxMCwgeDExID0gajExLCB4MTIgPSBqMTIsIHgxMyA9IGoxMywgeDE0ID0gajE0LFxuICAgICAgeDE1ID0gajE1LCB1O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjA7IGkgKz0gMikge1xuICAgIHUgPSB4MCArIHgxMiB8IDA7XG4gICAgeDQgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHg0ICsgeDAgfCAwO1xuICAgIHg4IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4OCArIHg0IHwgMDtcbiAgICB4MTIgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDEyICsgeDggfCAwO1xuICAgIHgwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDUgKyB4MSB8IDA7XG4gICAgeDkgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHg5ICsgeDUgfCAwO1xuICAgIHgxMyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDEzICsgeDkgfCAwO1xuICAgIHgxIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxICsgeDEzIHwgMDtcbiAgICB4NSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxMCArIHg2IHwgMDtcbiAgICB4MTQgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxNCArIHgxMCB8IDA7XG4gICAgeDIgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgyICsgeDE0IHwgMDtcbiAgICB4NiBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4NiArIHgyIHwgMDtcbiAgICB4MTAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTUgKyB4MTEgfCAwO1xuICAgIHgzIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MyArIHgxNSB8IDA7XG4gICAgeDcgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg3ICsgeDMgfCAwO1xuICAgIHgxMSBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MTEgKyB4NyB8IDA7XG4gICAgeDE1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDAgKyB4MyB8IDA7XG4gICAgeDEgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxICsgeDAgfCAwO1xuICAgIHgyIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MiArIHgxIHwgMDtcbiAgICB4MyBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MyArIHgyIHwgMDtcbiAgICB4MCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHg1ICsgeDQgfCAwO1xuICAgIHg2IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4NiArIHg1IHwgMDtcbiAgICB4NyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDcgKyB4NiB8IDA7XG4gICAgeDQgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDQgKyB4NyB8IDA7XG4gICAgeDUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTAgKyB4OSB8IDA7XG4gICAgeDExIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MTEgKyB4MTAgfCAwO1xuICAgIHg4IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4OCArIHgxMSB8IDA7XG4gICAgeDkgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDkgKyB4OCB8IDA7XG4gICAgeDEwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDE1ICsgeDE0IHwgMDtcbiAgICB4MTIgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxMiArIHgxNSB8IDA7XG4gICAgeDEzIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MTMgKyB4MTIgfCAwO1xuICAgIHgxNCBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MTQgKyB4MTMgfCAwO1xuICAgIHgxNSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuICB9XG5cbiAgb1sgMF0gPSB4MCA+Pj4gIDAgJiAweGZmO1xuICBvWyAxXSA9IHgwID4+PiAgOCAmIDB4ZmY7XG4gIG9bIDJdID0geDAgPj4+IDE2ICYgMHhmZjtcbiAgb1sgM10gPSB4MCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bIDRdID0geDUgPj4+ICAwICYgMHhmZjtcbiAgb1sgNV0gPSB4NSA+Pj4gIDggJiAweGZmO1xuICBvWyA2XSA9IHg1ID4+PiAxNiAmIDB4ZmY7XG4gIG9bIDddID0geDUgPj4+IDI0ICYgMHhmZjtcblxuICBvWyA4XSA9IHgxMCA+Pj4gIDAgJiAweGZmO1xuICBvWyA5XSA9IHgxMCA+Pj4gIDggJiAweGZmO1xuICBvWzEwXSA9IHgxMCA+Pj4gMTYgJiAweGZmO1xuICBvWzExXSA9IHgxMCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMTJdID0geDE1ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMTNdID0geDE1ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMTRdID0geDE1ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMTVdID0geDE1ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sxNl0gPSB4NiA+Pj4gIDAgJiAweGZmO1xuICBvWzE3XSA9IHg2ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMThdID0geDYgPj4+IDE2ICYgMHhmZjtcbiAgb1sxOV0gPSB4NiA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMjBdID0geDcgPj4+ICAwICYgMHhmZjtcbiAgb1syMV0gPSB4NyA+Pj4gIDggJiAweGZmO1xuICBvWzIyXSA9IHg3ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMjNdID0geDcgPj4+IDI0ICYgMHhmZjtcblxuICBvWzI0XSA9IHg4ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMjVdID0geDggPj4+ICA4ICYgMHhmZjtcbiAgb1syNl0gPSB4OCA+Pj4gMTYgJiAweGZmO1xuICBvWzI3XSA9IHg4ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1syOF0gPSB4OSA+Pj4gIDAgJiAweGZmO1xuICBvWzI5XSA9IHg5ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMzBdID0geDkgPj4+IDE2ICYgMHhmZjtcbiAgb1szMV0gPSB4OSA+Pj4gMjQgJiAweGZmO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fY29yZV9zYWxzYTIwKG91dCxpbnAsayxjKSB7XG4gIGNvcmVfc2Fsc2EyMChvdXQsaW5wLGssYyk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19jb3JlX2hzYWxzYTIwKG91dCxpbnAsayxjKSB7XG4gIGNvcmVfaHNhbHNhMjAob3V0LGlucCxrLGMpO1xufVxuXG52YXIgc2lnbWEgPSBuZXcgVWludDhBcnJheShbMTAxLCAxMjAsIDExMiwgOTcsIDExMCwgMTAwLCAzMiwgNTEsIDUwLCA0NSwgOTgsIDEyMSwgMTE2LCAxMDEsIDMyLCAxMDddKTtcbiAgICAgICAgICAgIC8vIFwiZXhwYW5kIDMyLWJ5dGUga1wiXG5cbmZ1bmN0aW9uIGNyeXB0b19zdHJlYW1fc2Fsc2EyMF94b3IoYyxjcG9zLG0sbXBvcyxiLG4saykge1xuICB2YXIgeiA9IG5ldyBVaW50OEFycmF5KDE2KSwgeCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIHUsIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB6W2ldID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IDg7IGkrKykgeltpXSA9IG5baV07XG4gIHdoaWxlIChiID49IDY0KSB7XG4gICAgY3J5cHRvX2NvcmVfc2Fsc2EyMCh4LHosayxzaWdtYSk7XG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIGNbY3BvcytpXSA9IG1bbXBvcytpXSBeIHhbaV07XG4gICAgdSA9IDE7XG4gICAgZm9yIChpID0gODsgaSA8IDE2OyBpKyspIHtcbiAgICAgIHUgPSB1ICsgKHpbaV0gJiAweGZmKSB8IDA7XG4gICAgICB6W2ldID0gdSAmIDB4ZmY7XG4gICAgICB1ID4+Pj0gODtcbiAgICB9XG4gICAgYiAtPSA2NDtcbiAgICBjcG9zICs9IDY0O1xuICAgIG1wb3MgKz0gNjQ7XG4gIH1cbiAgaWYgKGIgPiAwKSB7XG4gICAgY3J5cHRvX2NvcmVfc2Fsc2EyMCh4LHosayxzaWdtYSk7XG4gICAgZm9yIChpID0gMDsgaSA8IGI7IGkrKykgY1tjcG9zK2ldID0gbVttcG9zK2ldIF4geFtpXTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3N0cmVhbV9zYWxzYTIwKGMsY3BvcyxiLG4saykge1xuICB2YXIgeiA9IG5ldyBVaW50OEFycmF5KDE2KSwgeCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIHUsIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB6W2ldID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IDg7IGkrKykgeltpXSA9IG5baV07XG4gIHdoaWxlIChiID49IDY0KSB7XG4gICAgY3J5cHRvX2NvcmVfc2Fsc2EyMCh4LHosayxzaWdtYSk7XG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIGNbY3BvcytpXSA9IHhbaV07XG4gICAgdSA9IDE7XG4gICAgZm9yIChpID0gODsgaSA8IDE2OyBpKyspIHtcbiAgICAgIHUgPSB1ICsgKHpbaV0gJiAweGZmKSB8IDA7XG4gICAgICB6W2ldID0gdSAmIDB4ZmY7XG4gICAgICB1ID4+Pj0gODtcbiAgICB9XG4gICAgYiAtPSA2NDtcbiAgICBjcG9zICs9IDY0O1xuICB9XG4gIGlmIChiID4gMCkge1xuICAgIGNyeXB0b19jb3JlX3NhbHNhMjAoeCx6LGssc2lnbWEpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBiOyBpKyspIGNbY3BvcytpXSA9IHhbaV07XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zdHJlYW0oYyxjcG9zLGQsbixrKSB7XG4gIHZhciBzID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG9fY29yZV9oc2Fsc2EyMChzLG4sayxzaWdtYSk7XG4gIHZhciBzbiA9IG5ldyBVaW50OEFycmF5KDgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgc25baV0gPSBuW2krMTZdO1xuICByZXR1cm4gY3J5cHRvX3N0cmVhbV9zYWxzYTIwKGMsY3BvcyxkLHNuLHMpO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc3RyZWFtX3hvcihjLGNwb3MsbSxtcG9zLGQsbixrKSB7XG4gIHZhciBzID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG9fY29yZV9oc2Fsc2EyMChzLG4sayxzaWdtYSk7XG4gIHZhciBzbiA9IG5ldyBVaW50OEFycmF5KDgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgc25baV0gPSBuW2krMTZdO1xuICByZXR1cm4gY3J5cHRvX3N0cmVhbV9zYWxzYTIwX3hvcihjLGNwb3MsbSxtcG9zLGQsc24scyk7XG59XG5cbi8qXG4qIFBvcnQgb2YgQW5kcmV3IE1vb24ncyBQb2x5MTMwNS1kb25uYS0xNi4gUHVibGljIGRvbWFpbi5cbiogaHR0cHM6Ly9naXRodWIuY29tL2Zsb29keWJlcnJ5L3BvbHkxMzA1LWRvbm5hXG4qL1xuXG52YXIgcG9seTEzMDUgPSBmdW5jdGlvbihrZXkpIHtcbiAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheSgxNik7XG4gIHRoaXMuciA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG4gIHRoaXMuaCA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG4gIHRoaXMucGFkID0gbmV3IFVpbnQxNkFycmF5KDgpO1xuICB0aGlzLmxlZnRvdmVyID0gMDtcbiAgdGhpcy5maW4gPSAwO1xuXG4gIHZhciB0MCwgdDEsIHQyLCB0MywgdDQsIHQ1LCB0NiwgdDc7XG5cbiAgdDAgPSBrZXlbIDBdICYgMHhmZiB8IChrZXlbIDFdICYgMHhmZikgPDwgODsgdGhpcy5yWzBdID0gKCB0MCAgICAgICAgICAgICAgICAgICAgICkgJiAweDFmZmY7XG4gIHQxID0ga2V5WyAyXSAmIDB4ZmYgfCAoa2V5WyAzXSAmIDB4ZmYpIDw8IDg7IHRoaXMuclsxXSA9ICgodDAgPj4+IDEzKSB8ICh0MSA8PCAgMykpICYgMHgxZmZmO1xuICB0MiA9IGtleVsgNF0gJiAweGZmIHwgKGtleVsgNV0gJiAweGZmKSA8PCA4OyB0aGlzLnJbMl0gPSAoKHQxID4+PiAxMCkgfCAodDIgPDwgIDYpKSAmIDB4MWYwMztcbiAgdDMgPSBrZXlbIDZdICYgMHhmZiB8IChrZXlbIDddICYgMHhmZikgPDwgODsgdGhpcy5yWzNdID0gKCh0MiA+Pj4gIDcpIHwgKHQzIDw8ICA5KSkgJiAweDFmZmY7XG4gIHQ0ID0ga2V5WyA4XSAmIDB4ZmYgfCAoa2V5WyA5XSAmIDB4ZmYpIDw8IDg7IHRoaXMucls0XSA9ICgodDMgPj4+ICA0KSB8ICh0NCA8PCAxMikpICYgMHgwMGZmO1xuICB0aGlzLnJbNV0gPSAoKHQ0ID4+PiAgMSkpICYgMHgxZmZlO1xuICB0NSA9IGtleVsxMF0gJiAweGZmIHwgKGtleVsxMV0gJiAweGZmKSA8PCA4OyB0aGlzLnJbNl0gPSAoKHQ0ID4+PiAxNCkgfCAodDUgPDwgIDIpKSAmIDB4MWZmZjtcbiAgdDYgPSBrZXlbMTJdICYgMHhmZiB8IChrZXlbMTNdICYgMHhmZikgPDwgODsgdGhpcy5yWzddID0gKCh0NSA+Pj4gMTEpIHwgKHQ2IDw8ICA1KSkgJiAweDFmODE7XG4gIHQ3ID0ga2V5WzE0XSAmIDB4ZmYgfCAoa2V5WzE1XSAmIDB4ZmYpIDw8IDg7IHRoaXMucls4XSA9ICgodDYgPj4+ICA4KSB8ICh0NyA8PCAgOCkpICYgMHgxZmZmO1xuICB0aGlzLnJbOV0gPSAoKHQ3ID4+PiAgNSkpICYgMHgwMDdmO1xuXG4gIHRoaXMucGFkWzBdID0ga2V5WzE2XSAmIDB4ZmYgfCAoa2V5WzE3XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzFdID0ga2V5WzE4XSAmIDB4ZmYgfCAoa2V5WzE5XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzJdID0ga2V5WzIwXSAmIDB4ZmYgfCAoa2V5WzIxXSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzNdID0ga2V5WzIyXSAmIDB4ZmYgfCAoa2V5WzIzXSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzRdID0ga2V5WzI0XSAmIDB4ZmYgfCAoa2V5WzI1XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzVdID0ga2V5WzI2XSAmIDB4ZmYgfCAoa2V5WzI3XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzZdID0ga2V5WzI4XSAmIDB4ZmYgfCAoa2V5WzI5XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzddID0ga2V5WzMwXSAmIDB4ZmYgfCAoa2V5WzMxXSAmIDB4ZmYpIDw8IDg7XG59O1xuXG5wb2x5MTMwNS5wcm90b3R5cGUuYmxvY2tzID0gZnVuY3Rpb24obSwgbXBvcywgYnl0ZXMpIHtcbiAgdmFyIGhpYml0ID0gdGhpcy5maW4gPyAwIDogKDEgPDwgMTEpO1xuICB2YXIgdDAsIHQxLCB0MiwgdDMsIHQ0LCB0NSwgdDYsIHQ3LCBjO1xuICB2YXIgZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCwgZDk7XG5cbiAgdmFyIGgwID0gdGhpcy5oWzBdLFxuICAgICAgaDEgPSB0aGlzLmhbMV0sXG4gICAgICBoMiA9IHRoaXMuaFsyXSxcbiAgICAgIGgzID0gdGhpcy5oWzNdLFxuICAgICAgaDQgPSB0aGlzLmhbNF0sXG4gICAgICBoNSA9IHRoaXMuaFs1XSxcbiAgICAgIGg2ID0gdGhpcy5oWzZdLFxuICAgICAgaDcgPSB0aGlzLmhbN10sXG4gICAgICBoOCA9IHRoaXMuaFs4XSxcbiAgICAgIGg5ID0gdGhpcy5oWzldO1xuXG4gIHZhciByMCA9IHRoaXMuclswXSxcbiAgICAgIHIxID0gdGhpcy5yWzFdLFxuICAgICAgcjIgPSB0aGlzLnJbMl0sXG4gICAgICByMyA9IHRoaXMuclszXSxcbiAgICAgIHI0ID0gdGhpcy5yWzRdLFxuICAgICAgcjUgPSB0aGlzLnJbNV0sXG4gICAgICByNiA9IHRoaXMucls2XSxcbiAgICAgIHI3ID0gdGhpcy5yWzddLFxuICAgICAgcjggPSB0aGlzLnJbOF0sXG4gICAgICByOSA9IHRoaXMucls5XTtcblxuICB3aGlsZSAoYnl0ZXMgPj0gMTYpIHtcbiAgICB0MCA9IG1bbXBvcysgMF0gJiAweGZmIHwgKG1bbXBvcysgMV0gJiAweGZmKSA8PCA4OyBoMCArPSAoIHQwICAgICAgICAgICAgICAgICAgICAgKSAmIDB4MWZmZjtcbiAgICB0MSA9IG1bbXBvcysgMl0gJiAweGZmIHwgKG1bbXBvcysgM10gJiAweGZmKSA8PCA4OyBoMSArPSAoKHQwID4+PiAxMykgfCAodDEgPDwgIDMpKSAmIDB4MWZmZjtcbiAgICB0MiA9IG1bbXBvcysgNF0gJiAweGZmIHwgKG1bbXBvcysgNV0gJiAweGZmKSA8PCA4OyBoMiArPSAoKHQxID4+PiAxMCkgfCAodDIgPDwgIDYpKSAmIDB4MWZmZjtcbiAgICB0MyA9IG1bbXBvcysgNl0gJiAweGZmIHwgKG1bbXBvcysgN10gJiAweGZmKSA8PCA4OyBoMyArPSAoKHQyID4+PiAgNykgfCAodDMgPDwgIDkpKSAmIDB4MWZmZjtcbiAgICB0NCA9IG1bbXBvcysgOF0gJiAweGZmIHwgKG1bbXBvcysgOV0gJiAweGZmKSA8PCA4OyBoNCArPSAoKHQzID4+PiAgNCkgfCAodDQgPDwgMTIpKSAmIDB4MWZmZjtcbiAgICBoNSArPSAoKHQ0ID4+PiAgMSkpICYgMHgxZmZmO1xuICAgIHQ1ID0gbVttcG9zKzEwXSAmIDB4ZmYgfCAobVttcG9zKzExXSAmIDB4ZmYpIDw8IDg7IGg2ICs9ICgodDQgPj4+IDE0KSB8ICh0NSA8PCAgMikpICYgMHgxZmZmO1xuICAgIHQ2ID0gbVttcG9zKzEyXSAmIDB4ZmYgfCAobVttcG9zKzEzXSAmIDB4ZmYpIDw8IDg7IGg3ICs9ICgodDUgPj4+IDExKSB8ICh0NiA8PCAgNSkpICYgMHgxZmZmO1xuICAgIHQ3ID0gbVttcG9zKzE0XSAmIDB4ZmYgfCAobVttcG9zKzE1XSAmIDB4ZmYpIDw8IDg7IGg4ICs9ICgodDYgPj4+ICA4KSB8ICh0NyA8PCAgOCkpICYgMHgxZmZmO1xuICAgIGg5ICs9ICgodDcgPj4+IDUpKSB8IGhpYml0O1xuXG4gICAgYyA9IDA7XG5cbiAgICBkMCA9IGM7XG4gICAgZDAgKz0gaDAgKiByMDtcbiAgICBkMCArPSBoMSAqICg1ICogcjkpO1xuICAgIGQwICs9IGgyICogKDUgKiByOCk7XG4gICAgZDAgKz0gaDMgKiAoNSAqIHI3KTtcbiAgICBkMCArPSBoNCAqICg1ICogcjYpO1xuICAgIGMgPSAoZDAgPj4+IDEzKTsgZDAgJj0gMHgxZmZmO1xuICAgIGQwICs9IGg1ICogKDUgKiByNSk7XG4gICAgZDAgKz0gaDYgKiAoNSAqIHI0KTtcbiAgICBkMCArPSBoNyAqICg1ICogcjMpO1xuICAgIGQwICs9IGg4ICogKDUgKiByMik7XG4gICAgZDAgKz0gaDkgKiAoNSAqIHIxKTtcbiAgICBjICs9IChkMCA+Pj4gMTMpOyBkMCAmPSAweDFmZmY7XG5cbiAgICBkMSA9IGM7XG4gICAgZDEgKz0gaDAgKiByMTtcbiAgICBkMSArPSBoMSAqIHIwO1xuICAgIGQxICs9IGgyICogKDUgKiByOSk7XG4gICAgZDEgKz0gaDMgKiAoNSAqIHI4KTtcbiAgICBkMSArPSBoNCAqICg1ICogcjcpO1xuICAgIGMgPSAoZDEgPj4+IDEzKTsgZDEgJj0gMHgxZmZmO1xuICAgIGQxICs9IGg1ICogKDUgKiByNik7XG4gICAgZDEgKz0gaDYgKiAoNSAqIHI1KTtcbiAgICBkMSArPSBoNyAqICg1ICogcjQpO1xuICAgIGQxICs9IGg4ICogKDUgKiByMyk7XG4gICAgZDEgKz0gaDkgKiAoNSAqIHIyKTtcbiAgICBjICs9IChkMSA+Pj4gMTMpOyBkMSAmPSAweDFmZmY7XG5cbiAgICBkMiA9IGM7XG4gICAgZDIgKz0gaDAgKiByMjtcbiAgICBkMiArPSBoMSAqIHIxO1xuICAgIGQyICs9IGgyICogcjA7XG4gICAgZDIgKz0gaDMgKiAoNSAqIHI5KTtcbiAgICBkMiArPSBoNCAqICg1ICogcjgpO1xuICAgIGMgPSAoZDIgPj4+IDEzKTsgZDIgJj0gMHgxZmZmO1xuICAgIGQyICs9IGg1ICogKDUgKiByNyk7XG4gICAgZDIgKz0gaDYgKiAoNSAqIHI2KTtcbiAgICBkMiArPSBoNyAqICg1ICogcjUpO1xuICAgIGQyICs9IGg4ICogKDUgKiByNCk7XG4gICAgZDIgKz0gaDkgKiAoNSAqIHIzKTtcbiAgICBjICs9IChkMiA+Pj4gMTMpOyBkMiAmPSAweDFmZmY7XG5cbiAgICBkMyA9IGM7XG4gICAgZDMgKz0gaDAgKiByMztcbiAgICBkMyArPSBoMSAqIHIyO1xuICAgIGQzICs9IGgyICogcjE7XG4gICAgZDMgKz0gaDMgKiByMDtcbiAgICBkMyArPSBoNCAqICg1ICogcjkpO1xuICAgIGMgPSAoZDMgPj4+IDEzKTsgZDMgJj0gMHgxZmZmO1xuICAgIGQzICs9IGg1ICogKDUgKiByOCk7XG4gICAgZDMgKz0gaDYgKiAoNSAqIHI3KTtcbiAgICBkMyArPSBoNyAqICg1ICogcjYpO1xuICAgIGQzICs9IGg4ICogKDUgKiByNSk7XG4gICAgZDMgKz0gaDkgKiAoNSAqIHI0KTtcbiAgICBjICs9IChkMyA+Pj4gMTMpOyBkMyAmPSAweDFmZmY7XG5cbiAgICBkNCA9IGM7XG4gICAgZDQgKz0gaDAgKiByNDtcbiAgICBkNCArPSBoMSAqIHIzO1xuICAgIGQ0ICs9IGgyICogcjI7XG4gICAgZDQgKz0gaDMgKiByMTtcbiAgICBkNCArPSBoNCAqIHIwO1xuICAgIGMgPSAoZDQgPj4+IDEzKTsgZDQgJj0gMHgxZmZmO1xuICAgIGQ0ICs9IGg1ICogKDUgKiByOSk7XG4gICAgZDQgKz0gaDYgKiAoNSAqIHI4KTtcbiAgICBkNCArPSBoNyAqICg1ICogcjcpO1xuICAgIGQ0ICs9IGg4ICogKDUgKiByNik7XG4gICAgZDQgKz0gaDkgKiAoNSAqIHI1KTtcbiAgICBjICs9IChkNCA+Pj4gMTMpOyBkNCAmPSAweDFmZmY7XG5cbiAgICBkNSA9IGM7XG4gICAgZDUgKz0gaDAgKiByNTtcbiAgICBkNSArPSBoMSAqIHI0O1xuICAgIGQ1ICs9IGgyICogcjM7XG4gICAgZDUgKz0gaDMgKiByMjtcbiAgICBkNSArPSBoNCAqIHIxO1xuICAgIGMgPSAoZDUgPj4+IDEzKTsgZDUgJj0gMHgxZmZmO1xuICAgIGQ1ICs9IGg1ICogcjA7XG4gICAgZDUgKz0gaDYgKiAoNSAqIHI5KTtcbiAgICBkNSArPSBoNyAqICg1ICogcjgpO1xuICAgIGQ1ICs9IGg4ICogKDUgKiByNyk7XG4gICAgZDUgKz0gaDkgKiAoNSAqIHI2KTtcbiAgICBjICs9IChkNSA+Pj4gMTMpOyBkNSAmPSAweDFmZmY7XG5cbiAgICBkNiA9IGM7XG4gICAgZDYgKz0gaDAgKiByNjtcbiAgICBkNiArPSBoMSAqIHI1O1xuICAgIGQ2ICs9IGgyICogcjQ7XG4gICAgZDYgKz0gaDMgKiByMztcbiAgICBkNiArPSBoNCAqIHIyO1xuICAgIGMgPSAoZDYgPj4+IDEzKTsgZDYgJj0gMHgxZmZmO1xuICAgIGQ2ICs9IGg1ICogcjE7XG4gICAgZDYgKz0gaDYgKiByMDtcbiAgICBkNiArPSBoNyAqICg1ICogcjkpO1xuICAgIGQ2ICs9IGg4ICogKDUgKiByOCk7XG4gICAgZDYgKz0gaDkgKiAoNSAqIHI3KTtcbiAgICBjICs9IChkNiA+Pj4gMTMpOyBkNiAmPSAweDFmZmY7XG5cbiAgICBkNyA9IGM7XG4gICAgZDcgKz0gaDAgKiByNztcbiAgICBkNyArPSBoMSAqIHI2O1xuICAgIGQ3ICs9IGgyICogcjU7XG4gICAgZDcgKz0gaDMgKiByNDtcbiAgICBkNyArPSBoNCAqIHIzO1xuICAgIGMgPSAoZDcgPj4+IDEzKTsgZDcgJj0gMHgxZmZmO1xuICAgIGQ3ICs9IGg1ICogcjI7XG4gICAgZDcgKz0gaDYgKiByMTtcbiAgICBkNyArPSBoNyAqIHIwO1xuICAgIGQ3ICs9IGg4ICogKDUgKiByOSk7XG4gICAgZDcgKz0gaDkgKiAoNSAqIHI4KTtcbiAgICBjICs9IChkNyA+Pj4gMTMpOyBkNyAmPSAweDFmZmY7XG5cbiAgICBkOCA9IGM7XG4gICAgZDggKz0gaDAgKiByODtcbiAgICBkOCArPSBoMSAqIHI3O1xuICAgIGQ4ICs9IGgyICogcjY7XG4gICAgZDggKz0gaDMgKiByNTtcbiAgICBkOCArPSBoNCAqIHI0O1xuICAgIGMgPSAoZDggPj4+IDEzKTsgZDggJj0gMHgxZmZmO1xuICAgIGQ4ICs9IGg1ICogcjM7XG4gICAgZDggKz0gaDYgKiByMjtcbiAgICBkOCArPSBoNyAqIHIxO1xuICAgIGQ4ICs9IGg4ICogcjA7XG4gICAgZDggKz0gaDkgKiAoNSAqIHI5KTtcbiAgICBjICs9IChkOCA+Pj4gMTMpOyBkOCAmPSAweDFmZmY7XG5cbiAgICBkOSA9IGM7XG4gICAgZDkgKz0gaDAgKiByOTtcbiAgICBkOSArPSBoMSAqIHI4O1xuICAgIGQ5ICs9IGgyICogcjc7XG4gICAgZDkgKz0gaDMgKiByNjtcbiAgICBkOSArPSBoNCAqIHI1O1xuICAgIGMgPSAoZDkgPj4+IDEzKTsgZDkgJj0gMHgxZmZmO1xuICAgIGQ5ICs9IGg1ICogcjQ7XG4gICAgZDkgKz0gaDYgKiByMztcbiAgICBkOSArPSBoNyAqIHIyO1xuICAgIGQ5ICs9IGg4ICogcjE7XG4gICAgZDkgKz0gaDkgKiByMDtcbiAgICBjICs9IChkOSA+Pj4gMTMpOyBkOSAmPSAweDFmZmY7XG5cbiAgICBjID0gKCgoYyA8PCAyKSArIGMpKSB8IDA7XG4gICAgYyA9IChjICsgZDApIHwgMDtcbiAgICBkMCA9IGMgJiAweDFmZmY7XG4gICAgYyA9IChjID4+PiAxMyk7XG4gICAgZDEgKz0gYztcblxuICAgIGgwID0gZDA7XG4gICAgaDEgPSBkMTtcbiAgICBoMiA9IGQyO1xuICAgIGgzID0gZDM7XG4gICAgaDQgPSBkNDtcbiAgICBoNSA9IGQ1O1xuICAgIGg2ID0gZDY7XG4gICAgaDcgPSBkNztcbiAgICBoOCA9IGQ4O1xuICAgIGg5ID0gZDk7XG5cbiAgICBtcG9zICs9IDE2O1xuICAgIGJ5dGVzIC09IDE2O1xuICB9XG4gIHRoaXMuaFswXSA9IGgwO1xuICB0aGlzLmhbMV0gPSBoMTtcbiAgdGhpcy5oWzJdID0gaDI7XG4gIHRoaXMuaFszXSA9IGgzO1xuICB0aGlzLmhbNF0gPSBoNDtcbiAgdGhpcy5oWzVdID0gaDU7XG4gIHRoaXMuaFs2XSA9IGg2O1xuICB0aGlzLmhbN10gPSBoNztcbiAgdGhpcy5oWzhdID0gaDg7XG4gIHRoaXMuaFs5XSA9IGg5O1xufTtcblxucG9seTEzMDUucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uKG1hYywgbWFjcG9zKSB7XG4gIHZhciBnID0gbmV3IFVpbnQxNkFycmF5KDEwKTtcbiAgdmFyIGMsIG1hc2ssIGYsIGk7XG5cbiAgaWYgKHRoaXMubGVmdG92ZXIpIHtcbiAgICBpID0gdGhpcy5sZWZ0b3ZlcjtcbiAgICB0aGlzLmJ1ZmZlcltpKytdID0gMTtcbiAgICBmb3IgKDsgaSA8IDE2OyBpKyspIHRoaXMuYnVmZmVyW2ldID0gMDtcbiAgICB0aGlzLmZpbiA9IDE7XG4gICAgdGhpcy5ibG9ja3ModGhpcy5idWZmZXIsIDAsIDE2KTtcbiAgfVxuXG4gIGMgPSB0aGlzLmhbMV0gPj4+IDEzO1xuICB0aGlzLmhbMV0gJj0gMHgxZmZmO1xuICBmb3IgKGkgPSAyOyBpIDwgMTA7IGkrKykge1xuICAgIHRoaXMuaFtpXSArPSBjO1xuICAgIGMgPSB0aGlzLmhbaV0gPj4+IDEzO1xuICAgIHRoaXMuaFtpXSAmPSAweDFmZmY7XG4gIH1cbiAgdGhpcy5oWzBdICs9IChjICogNSk7XG4gIGMgPSB0aGlzLmhbMF0gPj4+IDEzO1xuICB0aGlzLmhbMF0gJj0gMHgxZmZmO1xuICB0aGlzLmhbMV0gKz0gYztcbiAgYyA9IHRoaXMuaFsxXSA+Pj4gMTM7XG4gIHRoaXMuaFsxXSAmPSAweDFmZmY7XG4gIHRoaXMuaFsyXSArPSBjO1xuXG4gIGdbMF0gPSB0aGlzLmhbMF0gKyA1O1xuICBjID0gZ1swXSA+Pj4gMTM7XG4gIGdbMF0gJj0gMHgxZmZmO1xuICBmb3IgKGkgPSAxOyBpIDwgMTA7IGkrKykge1xuICAgIGdbaV0gPSB0aGlzLmhbaV0gKyBjO1xuICAgIGMgPSBnW2ldID4+PiAxMztcbiAgICBnW2ldICY9IDB4MWZmZjtcbiAgfVxuICBnWzldIC09ICgxIDw8IDEzKTtcblxuICBtYXNrID0gKGMgXiAxKSAtIDE7XG4gIGZvciAoaSA9IDA7IGkgPCAxMDsgaSsrKSBnW2ldICY9IG1hc2s7XG4gIG1hc2sgPSB+bWFzaztcbiAgZm9yIChpID0gMDsgaSA8IDEwOyBpKyspIHRoaXMuaFtpXSA9ICh0aGlzLmhbaV0gJiBtYXNrKSB8IGdbaV07XG5cbiAgdGhpcy5oWzBdID0gKCh0aGlzLmhbMF0gICAgICAgKSB8ICh0aGlzLmhbMV0gPDwgMTMpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbMV0gPSAoKHRoaXMuaFsxXSA+Pj4gIDMpIHwgKHRoaXMuaFsyXSA8PCAxMCkgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG4gIHRoaXMuaFsyXSA9ICgodGhpcy5oWzJdID4+PiAgNikgfCAodGhpcy5oWzNdIDw8ICA3KSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzNdID0gKCh0aGlzLmhbM10gPj4+ICA5KSB8ICh0aGlzLmhbNF0gPDwgIDQpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbNF0gPSAoKHRoaXMuaFs0XSA+Pj4gMTIpIHwgKHRoaXMuaFs1XSA8PCAgMSkgfCAodGhpcy5oWzZdIDw8IDE0KSkgJiAweGZmZmY7XG4gIHRoaXMuaFs1XSA9ICgodGhpcy5oWzZdID4+PiAgMikgfCAodGhpcy5oWzddIDw8IDExKSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzZdID0gKCh0aGlzLmhbN10gPj4+ICA1KSB8ICh0aGlzLmhbOF0gPDwgIDgpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbN10gPSAoKHRoaXMuaFs4XSA+Pj4gIDgpIHwgKHRoaXMuaFs5XSA8PCAgNSkgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG5cbiAgZiA9IHRoaXMuaFswXSArIHRoaXMucGFkWzBdO1xuICB0aGlzLmhbMF0gPSBmICYgMHhmZmZmO1xuICBmb3IgKGkgPSAxOyBpIDwgODsgaSsrKSB7XG4gICAgZiA9ICgoKHRoaXMuaFtpXSArIHRoaXMucGFkW2ldKSB8IDApICsgKGYgPj4+IDE2KSkgfCAwO1xuICAgIHRoaXMuaFtpXSA9IGYgJiAweGZmZmY7XG4gIH1cblxuICBtYWNbbWFjcG9zKyAwXSA9ICh0aGlzLmhbMF0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysgMV0gPSAodGhpcy5oWzBdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDJdID0gKHRoaXMuaFsxXSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyAzXSA9ICh0aGlzLmhbMV0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysgNF0gPSAodGhpcy5oWzJdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDVdID0gKHRoaXMuaFsyXSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA2XSA9ICh0aGlzLmhbM10gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysgN10gPSAodGhpcy5oWzNdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDhdID0gKHRoaXMuaFs0XSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA5XSA9ICh0aGlzLmhbNF0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysxMF0gPSAodGhpcy5oWzVdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTFdID0gKHRoaXMuaFs1XSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzEyXSA9ICh0aGlzLmhbNl0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysxM10gPSAodGhpcy5oWzZdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTRdID0gKHRoaXMuaFs3XSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzE1XSA9ICh0aGlzLmhbN10gPj4+IDgpICYgMHhmZjtcbn07XG5cbnBvbHkxMzA1LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihtLCBtcG9zLCBieXRlcykge1xuICB2YXIgaSwgd2FudDtcblxuICBpZiAodGhpcy5sZWZ0b3Zlcikge1xuICAgIHdhbnQgPSAoMTYgLSB0aGlzLmxlZnRvdmVyKTtcbiAgICBpZiAod2FudCA+IGJ5dGVzKVxuICAgICAgd2FudCA9IGJ5dGVzO1xuICAgIGZvciAoaSA9IDA7IGkgPCB3YW50OyBpKyspXG4gICAgICB0aGlzLmJ1ZmZlclt0aGlzLmxlZnRvdmVyICsgaV0gPSBtW21wb3MraV07XG4gICAgYnl0ZXMgLT0gd2FudDtcbiAgICBtcG9zICs9IHdhbnQ7XG4gICAgdGhpcy5sZWZ0b3ZlciArPSB3YW50O1xuICAgIGlmICh0aGlzLmxlZnRvdmVyIDwgMTYpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5ibG9ja3ModGhpcy5idWZmZXIsIDAsIDE2KTtcbiAgICB0aGlzLmxlZnRvdmVyID0gMDtcbiAgfVxuXG4gIGlmIChieXRlcyA+PSAxNikge1xuICAgIHdhbnQgPSBieXRlcyAtIChieXRlcyAlIDE2KTtcbiAgICB0aGlzLmJsb2NrcyhtLCBtcG9zLCB3YW50KTtcbiAgICBtcG9zICs9IHdhbnQ7XG4gICAgYnl0ZXMgLT0gd2FudDtcbiAgfVxuXG4gIGlmIChieXRlcykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBieXRlczsgaSsrKVxuICAgICAgdGhpcy5idWZmZXJbdGhpcy5sZWZ0b3ZlciArIGldID0gbVttcG9zK2ldO1xuICAgIHRoaXMubGVmdG92ZXIgKz0gYnl0ZXM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyeXB0b19vbmV0aW1lYXV0aChvdXQsIG91dHBvcywgbSwgbXBvcywgbiwgaykge1xuICB2YXIgcyA9IG5ldyBwb2x5MTMwNShrKTtcbiAgcy51cGRhdGUobSwgbXBvcywgbik7XG4gIHMuZmluaXNoKG91dCwgb3V0cG9zKTtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnkoaCwgaHBvcywgbSwgbXBvcywgbiwgaykge1xuICB2YXIgeCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgY3J5cHRvX29uZXRpbWVhdXRoKHgsMCxtLG1wb3MsbixrKTtcbiAgcmV0dXJuIGNyeXB0b192ZXJpZnlfMTYoaCxocG9zLHgsMCk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zZWNyZXRib3goYyxtLGQsbixrKSB7XG4gIHZhciBpO1xuICBpZiAoZCA8IDMyKSByZXR1cm4gLTE7XG4gIGNyeXB0b19zdHJlYW1feG9yKGMsMCxtLDAsZCxuLGspO1xuICBjcnlwdG9fb25ldGltZWF1dGgoYywgMTYsIGMsIDMyLCBkIC0gMzIsIGMpO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykgY1tpXSA9IDA7XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2VjcmV0Ym94X29wZW4obSxjLGQsbixrKSB7XG4gIHZhciBpO1xuICB2YXIgeCA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgaWYgKGQgPCAzMikgcmV0dXJuIC0xO1xuICBjcnlwdG9fc3RyZWFtKHgsMCwzMixuLGspO1xuICBpZiAoY3J5cHRvX29uZXRpbWVhdXRoX3ZlcmlmeShjLCAxNixjLCAzMixkIC0gMzIseCkgIT09IDApIHJldHVybiAtMTtcbiAgY3J5cHRvX3N0cmVhbV94b3IobSwwLGMsMCxkLG4sayk7XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSBtW2ldID0gMDtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIHNldDI1NTE5KHIsIGEpIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSByW2ldID0gYVtpXXwwO1xufVxuXG5mdW5jdGlvbiBjYXIyNTUxOShvKSB7XG4gIHZhciBpLCB2LCBjID0gMTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB2ID0gb1tpXSArIGMgKyA2NTUzNTtcbiAgICBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpO1xuICAgIG9baV0gPSB2IC0gYyAqIDY1NTM2O1xuICB9XG4gIG9bMF0gKz0gYy0xICsgMzcgKiAoYy0xKTtcbn1cblxuZnVuY3Rpb24gc2VsMjU1MTkocCwgcSwgYikge1xuICB2YXIgdCwgYyA9IH4oYi0xKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgdCA9IGMgJiAocFtpXSBeIHFbaV0pO1xuICAgIHBbaV0gXj0gdDtcbiAgICBxW2ldIF49IHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFjazI1NTE5KG8sIG4pIHtcbiAgdmFyIGksIGosIGI7XG4gIHZhciBtID0gZ2YoKSwgdCA9IGdmKCk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB0W2ldID0gbltpXTtcbiAgY2FyMjU1MTkodCk7XG4gIGNhcjI1NTE5KHQpO1xuICBjYXIyNTUxOSh0KTtcbiAgZm9yIChqID0gMDsgaiA8IDI7IGorKykge1xuICAgIG1bMF0gPSB0WzBdIC0gMHhmZmVkO1xuICAgIGZvciAoaSA9IDE7IGkgPCAxNTsgaSsrKSB7XG4gICAgICBtW2ldID0gdFtpXSAtIDB4ZmZmZiAtICgobVtpLTFdPj4xNikgJiAxKTtcbiAgICAgIG1baS0xXSAmPSAweGZmZmY7XG4gICAgfVxuICAgIG1bMTVdID0gdFsxNV0gLSAweDdmZmYgLSAoKG1bMTRdPj4xNikgJiAxKTtcbiAgICBiID0gKG1bMTVdPj4xNikgJiAxO1xuICAgIG1bMTRdICY9IDB4ZmZmZjtcbiAgICBzZWwyNTUxOSh0LCBtLCAxLWIpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgb1syKmldID0gdFtpXSAmIDB4ZmY7XG4gICAgb1syKmkrMV0gPSB0W2ldPj44O1xuICB9XG59XG5cbmZ1bmN0aW9uIG5lcTI1NTE5KGEsIGIpIHtcbiAgdmFyIGMgPSBuZXcgVWludDhBcnJheSgzMiksIGQgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIHBhY2syNTUxOShjLCBhKTtcbiAgcGFjazI1NTE5KGQsIGIpO1xuICByZXR1cm4gY3J5cHRvX3ZlcmlmeV8zMihjLCAwLCBkLCAwKTtcbn1cblxuZnVuY3Rpb24gcGFyMjU1MTkoYSkge1xuICB2YXIgZCA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgcGFjazI1NTE5KGQsIGEpO1xuICByZXR1cm4gZFswXSAmIDE7XG59XG5cbmZ1bmN0aW9uIHVucGFjazI1NTE5KG8sIG4pIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSBvW2ldID0gblsyKmldICsgKG5bMippKzFdIDw8IDgpO1xuICBvWzE1XSAmPSAweDdmZmY7XG59XG5cbmZ1bmN0aW9uIEEobywgYSwgYikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIG9baV0gPSBhW2ldICsgYltpXTtcbn1cblxuZnVuY3Rpb24gWihvLCBhLCBiKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykgb1tpXSA9IGFbaV0gLSBiW2ldO1xufVxuXG5mdW5jdGlvbiBNKG8sIGEsIGIpIHtcbiAgdmFyIHYsIGMsXG4gICAgIHQwID0gMCwgIHQxID0gMCwgIHQyID0gMCwgIHQzID0gMCwgIHQ0ID0gMCwgIHQ1ID0gMCwgIHQ2ID0gMCwgIHQ3ID0gMCxcbiAgICAgdDggPSAwLCAgdDkgPSAwLCB0MTAgPSAwLCB0MTEgPSAwLCB0MTIgPSAwLCB0MTMgPSAwLCB0MTQgPSAwLCB0MTUgPSAwLFxuICAgIHQxNiA9IDAsIHQxNyA9IDAsIHQxOCA9IDAsIHQxOSA9IDAsIHQyMCA9IDAsIHQyMSA9IDAsIHQyMiA9IDAsIHQyMyA9IDAsXG4gICAgdDI0ID0gMCwgdDI1ID0gMCwgdDI2ID0gMCwgdDI3ID0gMCwgdDI4ID0gMCwgdDI5ID0gMCwgdDMwID0gMCxcbiAgICBiMCA9IGJbMF0sXG4gICAgYjEgPSBiWzFdLFxuICAgIGIyID0gYlsyXSxcbiAgICBiMyA9IGJbM10sXG4gICAgYjQgPSBiWzRdLFxuICAgIGI1ID0gYls1XSxcbiAgICBiNiA9IGJbNl0sXG4gICAgYjcgPSBiWzddLFxuICAgIGI4ID0gYls4XSxcbiAgICBiOSA9IGJbOV0sXG4gICAgYjEwID0gYlsxMF0sXG4gICAgYjExID0gYlsxMV0sXG4gICAgYjEyID0gYlsxMl0sXG4gICAgYjEzID0gYlsxM10sXG4gICAgYjE0ID0gYlsxNF0sXG4gICAgYjE1ID0gYlsxNV07XG5cbiAgdiA9IGFbMF07XG4gIHQwICs9IHYgKiBiMDtcbiAgdDEgKz0gdiAqIGIxO1xuICB0MiArPSB2ICogYjI7XG4gIHQzICs9IHYgKiBiMztcbiAgdDQgKz0gdiAqIGI0O1xuICB0NSArPSB2ICogYjU7XG4gIHQ2ICs9IHYgKiBiNjtcbiAgdDcgKz0gdiAqIGI3O1xuICB0OCArPSB2ICogYjg7XG4gIHQ5ICs9IHYgKiBiOTtcbiAgdDEwICs9IHYgKiBiMTA7XG4gIHQxMSArPSB2ICogYjExO1xuICB0MTIgKz0gdiAqIGIxMjtcbiAgdDEzICs9IHYgKiBiMTM7XG4gIHQxNCArPSB2ICogYjE0O1xuICB0MTUgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMV07XG4gIHQxICs9IHYgKiBiMDtcbiAgdDIgKz0gdiAqIGIxO1xuICB0MyArPSB2ICogYjI7XG4gIHQ0ICs9IHYgKiBiMztcbiAgdDUgKz0gdiAqIGI0O1xuICB0NiArPSB2ICogYjU7XG4gIHQ3ICs9IHYgKiBiNjtcbiAgdDggKz0gdiAqIGI3O1xuICB0OSArPSB2ICogYjg7XG4gIHQxMCArPSB2ICogYjk7XG4gIHQxMSArPSB2ICogYjEwO1xuICB0MTIgKz0gdiAqIGIxMTtcbiAgdDEzICs9IHYgKiBiMTI7XG4gIHQxNCArPSB2ICogYjEzO1xuICB0MTUgKz0gdiAqIGIxNDtcbiAgdDE2ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzJdO1xuICB0MiArPSB2ICogYjA7XG4gIHQzICs9IHYgKiBiMTtcbiAgdDQgKz0gdiAqIGIyO1xuICB0NSArPSB2ICogYjM7XG4gIHQ2ICs9IHYgKiBiNDtcbiAgdDcgKz0gdiAqIGI1O1xuICB0OCArPSB2ICogYjY7XG4gIHQ5ICs9IHYgKiBiNztcbiAgdDEwICs9IHYgKiBiODtcbiAgdDExICs9IHYgKiBiOTtcbiAgdDEyICs9IHYgKiBiMTA7XG4gIHQxMyArPSB2ICogYjExO1xuICB0MTQgKz0gdiAqIGIxMjtcbiAgdDE1ICs9IHYgKiBiMTM7XG4gIHQxNiArPSB2ICogYjE0O1xuICB0MTcgKz0gdiAqIGIxNTtcbiAgdiA9IGFbM107XG4gIHQzICs9IHYgKiBiMDtcbiAgdDQgKz0gdiAqIGIxO1xuICB0NSArPSB2ICogYjI7XG4gIHQ2ICs9IHYgKiBiMztcbiAgdDcgKz0gdiAqIGI0O1xuICB0OCArPSB2ICogYjU7XG4gIHQ5ICs9IHYgKiBiNjtcbiAgdDEwICs9IHYgKiBiNztcbiAgdDExICs9IHYgKiBiODtcbiAgdDEyICs9IHYgKiBiOTtcbiAgdDEzICs9IHYgKiBiMTA7XG4gIHQxNCArPSB2ICogYjExO1xuICB0MTUgKz0gdiAqIGIxMjtcbiAgdDE2ICs9IHYgKiBiMTM7XG4gIHQxNyArPSB2ICogYjE0O1xuICB0MTggKz0gdiAqIGIxNTtcbiAgdiA9IGFbNF07XG4gIHQ0ICs9IHYgKiBiMDtcbiAgdDUgKz0gdiAqIGIxO1xuICB0NiArPSB2ICogYjI7XG4gIHQ3ICs9IHYgKiBiMztcbiAgdDggKz0gdiAqIGI0O1xuICB0OSArPSB2ICogYjU7XG4gIHQxMCArPSB2ICogYjY7XG4gIHQxMSArPSB2ICogYjc7XG4gIHQxMiArPSB2ICogYjg7XG4gIHQxMyArPSB2ICogYjk7XG4gIHQxNCArPSB2ICogYjEwO1xuICB0MTUgKz0gdiAqIGIxMTtcbiAgdDE2ICs9IHYgKiBiMTI7XG4gIHQxNyArPSB2ICogYjEzO1xuICB0MTggKz0gdiAqIGIxNDtcbiAgdDE5ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzVdO1xuICB0NSArPSB2ICogYjA7XG4gIHQ2ICs9IHYgKiBiMTtcbiAgdDcgKz0gdiAqIGIyO1xuICB0OCArPSB2ICogYjM7XG4gIHQ5ICs9IHYgKiBiNDtcbiAgdDEwICs9IHYgKiBiNTtcbiAgdDExICs9IHYgKiBiNjtcbiAgdDEyICs9IHYgKiBiNztcbiAgdDEzICs9IHYgKiBiODtcbiAgdDE0ICs9IHYgKiBiOTtcbiAgdDE1ICs9IHYgKiBiMTA7XG4gIHQxNiArPSB2ICogYjExO1xuICB0MTcgKz0gdiAqIGIxMjtcbiAgdDE4ICs9IHYgKiBiMTM7XG4gIHQxOSArPSB2ICogYjE0O1xuICB0MjAgKz0gdiAqIGIxNTtcbiAgdiA9IGFbNl07XG4gIHQ2ICs9IHYgKiBiMDtcbiAgdDcgKz0gdiAqIGIxO1xuICB0OCArPSB2ICogYjI7XG4gIHQ5ICs9IHYgKiBiMztcbiAgdDEwICs9IHYgKiBiNDtcbiAgdDExICs9IHYgKiBiNTtcbiAgdDEyICs9IHYgKiBiNjtcbiAgdDEzICs9IHYgKiBiNztcbiAgdDE0ICs9IHYgKiBiODtcbiAgdDE1ICs9IHYgKiBiOTtcbiAgdDE2ICs9IHYgKiBiMTA7XG4gIHQxNyArPSB2ICogYjExO1xuICB0MTggKz0gdiAqIGIxMjtcbiAgdDE5ICs9IHYgKiBiMTM7XG4gIHQyMCArPSB2ICogYjE0O1xuICB0MjEgKz0gdiAqIGIxNTtcbiAgdiA9IGFbN107XG4gIHQ3ICs9IHYgKiBiMDtcbiAgdDggKz0gdiAqIGIxO1xuICB0OSArPSB2ICogYjI7XG4gIHQxMCArPSB2ICogYjM7XG4gIHQxMSArPSB2ICogYjQ7XG4gIHQxMiArPSB2ICogYjU7XG4gIHQxMyArPSB2ICogYjY7XG4gIHQxNCArPSB2ICogYjc7XG4gIHQxNSArPSB2ICogYjg7XG4gIHQxNiArPSB2ICogYjk7XG4gIHQxNyArPSB2ICogYjEwO1xuICB0MTggKz0gdiAqIGIxMTtcbiAgdDE5ICs9IHYgKiBiMTI7XG4gIHQyMCArPSB2ICogYjEzO1xuICB0MjEgKz0gdiAqIGIxNDtcbiAgdDIyICs9IHYgKiBiMTU7XG4gIHYgPSBhWzhdO1xuICB0OCArPSB2ICogYjA7XG4gIHQ5ICs9IHYgKiBiMTtcbiAgdDEwICs9IHYgKiBiMjtcbiAgdDExICs9IHYgKiBiMztcbiAgdDEyICs9IHYgKiBiNDtcbiAgdDEzICs9IHYgKiBiNTtcbiAgdDE0ICs9IHYgKiBiNjtcbiAgdDE1ICs9IHYgKiBiNztcbiAgdDE2ICs9IHYgKiBiODtcbiAgdDE3ICs9IHYgKiBiOTtcbiAgdDE4ICs9IHYgKiBiMTA7XG4gIHQxOSArPSB2ICogYjExO1xuICB0MjAgKz0gdiAqIGIxMjtcbiAgdDIxICs9IHYgKiBiMTM7XG4gIHQyMiArPSB2ICogYjE0O1xuICB0MjMgKz0gdiAqIGIxNTtcbiAgdiA9IGFbOV07XG4gIHQ5ICs9IHYgKiBiMDtcbiAgdDEwICs9IHYgKiBiMTtcbiAgdDExICs9IHYgKiBiMjtcbiAgdDEyICs9IHYgKiBiMztcbiAgdDEzICs9IHYgKiBiNDtcbiAgdDE0ICs9IHYgKiBiNTtcbiAgdDE1ICs9IHYgKiBiNjtcbiAgdDE2ICs9IHYgKiBiNztcbiAgdDE3ICs9IHYgKiBiODtcbiAgdDE4ICs9IHYgKiBiOTtcbiAgdDE5ICs9IHYgKiBiMTA7XG4gIHQyMCArPSB2ICogYjExO1xuICB0MjEgKz0gdiAqIGIxMjtcbiAgdDIyICs9IHYgKiBiMTM7XG4gIHQyMyArPSB2ICogYjE0O1xuICB0MjQgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTBdO1xuICB0MTAgKz0gdiAqIGIwO1xuICB0MTEgKz0gdiAqIGIxO1xuICB0MTIgKz0gdiAqIGIyO1xuICB0MTMgKz0gdiAqIGIzO1xuICB0MTQgKz0gdiAqIGI0O1xuICB0MTUgKz0gdiAqIGI1O1xuICB0MTYgKz0gdiAqIGI2O1xuICB0MTcgKz0gdiAqIGI3O1xuICB0MTggKz0gdiAqIGI4O1xuICB0MTkgKz0gdiAqIGI5O1xuICB0MjAgKz0gdiAqIGIxMDtcbiAgdDIxICs9IHYgKiBiMTE7XG4gIHQyMiArPSB2ICogYjEyO1xuICB0MjMgKz0gdiAqIGIxMztcbiAgdDI0ICs9IHYgKiBiMTQ7XG4gIHQyNSArPSB2ICogYjE1O1xuICB2ID0gYVsxMV07XG4gIHQxMSArPSB2ICogYjA7XG4gIHQxMiArPSB2ICogYjE7XG4gIHQxMyArPSB2ICogYjI7XG4gIHQxNCArPSB2ICogYjM7XG4gIHQxNSArPSB2ICogYjQ7XG4gIHQxNiArPSB2ICogYjU7XG4gIHQxNyArPSB2ICogYjY7XG4gIHQxOCArPSB2ICogYjc7XG4gIHQxOSArPSB2ICogYjg7XG4gIHQyMCArPSB2ICogYjk7XG4gIHQyMSArPSB2ICogYjEwO1xuICB0MjIgKz0gdiAqIGIxMTtcbiAgdDIzICs9IHYgKiBiMTI7XG4gIHQyNCArPSB2ICogYjEzO1xuICB0MjUgKz0gdiAqIGIxNDtcbiAgdDI2ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzEyXTtcbiAgdDEyICs9IHYgKiBiMDtcbiAgdDEzICs9IHYgKiBiMTtcbiAgdDE0ICs9IHYgKiBiMjtcbiAgdDE1ICs9IHYgKiBiMztcbiAgdDE2ICs9IHYgKiBiNDtcbiAgdDE3ICs9IHYgKiBiNTtcbiAgdDE4ICs9IHYgKiBiNjtcbiAgdDE5ICs9IHYgKiBiNztcbiAgdDIwICs9IHYgKiBiODtcbiAgdDIxICs9IHYgKiBiOTtcbiAgdDIyICs9IHYgKiBiMTA7XG4gIHQyMyArPSB2ICogYjExO1xuICB0MjQgKz0gdiAqIGIxMjtcbiAgdDI1ICs9IHYgKiBiMTM7XG4gIHQyNiArPSB2ICogYjE0O1xuICB0MjcgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTNdO1xuICB0MTMgKz0gdiAqIGIwO1xuICB0MTQgKz0gdiAqIGIxO1xuICB0MTUgKz0gdiAqIGIyO1xuICB0MTYgKz0gdiAqIGIzO1xuICB0MTcgKz0gdiAqIGI0O1xuICB0MTggKz0gdiAqIGI1O1xuICB0MTkgKz0gdiAqIGI2O1xuICB0MjAgKz0gdiAqIGI3O1xuICB0MjEgKz0gdiAqIGI4O1xuICB0MjIgKz0gdiAqIGI5O1xuICB0MjMgKz0gdiAqIGIxMDtcbiAgdDI0ICs9IHYgKiBiMTE7XG4gIHQyNSArPSB2ICogYjEyO1xuICB0MjYgKz0gdiAqIGIxMztcbiAgdDI3ICs9IHYgKiBiMTQ7XG4gIHQyOCArPSB2ICogYjE1O1xuICB2ID0gYVsxNF07XG4gIHQxNCArPSB2ICogYjA7XG4gIHQxNSArPSB2ICogYjE7XG4gIHQxNiArPSB2ICogYjI7XG4gIHQxNyArPSB2ICogYjM7XG4gIHQxOCArPSB2ICogYjQ7XG4gIHQxOSArPSB2ICogYjU7XG4gIHQyMCArPSB2ICogYjY7XG4gIHQyMSArPSB2ICogYjc7XG4gIHQyMiArPSB2ICogYjg7XG4gIHQyMyArPSB2ICogYjk7XG4gIHQyNCArPSB2ICogYjEwO1xuICB0MjUgKz0gdiAqIGIxMTtcbiAgdDI2ICs9IHYgKiBiMTI7XG4gIHQyNyArPSB2ICogYjEzO1xuICB0MjggKz0gdiAqIGIxNDtcbiAgdDI5ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzE1XTtcbiAgdDE1ICs9IHYgKiBiMDtcbiAgdDE2ICs9IHYgKiBiMTtcbiAgdDE3ICs9IHYgKiBiMjtcbiAgdDE4ICs9IHYgKiBiMztcbiAgdDE5ICs9IHYgKiBiNDtcbiAgdDIwICs9IHYgKiBiNTtcbiAgdDIxICs9IHYgKiBiNjtcbiAgdDIyICs9IHYgKiBiNztcbiAgdDIzICs9IHYgKiBiODtcbiAgdDI0ICs9IHYgKiBiOTtcbiAgdDI1ICs9IHYgKiBiMTA7XG4gIHQyNiArPSB2ICogYjExO1xuICB0MjcgKz0gdiAqIGIxMjtcbiAgdDI4ICs9IHYgKiBiMTM7XG4gIHQyOSArPSB2ICogYjE0O1xuICB0MzAgKz0gdiAqIGIxNTtcblxuICB0MCAgKz0gMzggKiB0MTY7XG4gIHQxICArPSAzOCAqIHQxNztcbiAgdDIgICs9IDM4ICogdDE4O1xuICB0MyAgKz0gMzggKiB0MTk7XG4gIHQ0ICArPSAzOCAqIHQyMDtcbiAgdDUgICs9IDM4ICogdDIxO1xuICB0NiAgKz0gMzggKiB0MjI7XG4gIHQ3ICArPSAzOCAqIHQyMztcbiAgdDggICs9IDM4ICogdDI0O1xuICB0OSAgKz0gMzggKiB0MjU7XG4gIHQxMCArPSAzOCAqIHQyNjtcbiAgdDExICs9IDM4ICogdDI3O1xuICB0MTIgKz0gMzggKiB0Mjg7XG4gIHQxMyArPSAzOCAqIHQyOTtcbiAgdDE0ICs9IDM4ICogdDMwO1xuICAvLyB0MTUgbGVmdCBhcyBpc1xuXG4gIC8vIGZpcnN0IGNhclxuICBjID0gMTtcbiAgdiA9ICB0MCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQwID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQxID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQyID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQzID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ0ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ1ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ2ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ3ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0OCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ4ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0OSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ5ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEwID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDExID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEyID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEzID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxNCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDE0ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxNSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDE1ID0gdiAtIGMgKiA2NTUzNjtcbiAgdDAgKz0gYy0xICsgMzcgKiAoYy0xKTtcblxuICAvLyBzZWNvbmQgY2FyXG4gIGMgPSAxO1xuICB2ID0gIHQwICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDAgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQxICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDEgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQyICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDIgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQzICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDMgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ0ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDQgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ1ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDUgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ2ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDYgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ3ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDcgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ4ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDggPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ5ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDkgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEwICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTAgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDExICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTEgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEyICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTIgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEzICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTMgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDE0ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTQgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDE1ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTUgPSB2IC0gYyAqIDY1NTM2O1xuICB0MCArPSBjLTEgKyAzNyAqIChjLTEpO1xuXG4gIG9bIDBdID0gdDA7XG4gIG9bIDFdID0gdDE7XG4gIG9bIDJdID0gdDI7XG4gIG9bIDNdID0gdDM7XG4gIG9bIDRdID0gdDQ7XG4gIG9bIDVdID0gdDU7XG4gIG9bIDZdID0gdDY7XG4gIG9bIDddID0gdDc7XG4gIG9bIDhdID0gdDg7XG4gIG9bIDldID0gdDk7XG4gIG9bMTBdID0gdDEwO1xuICBvWzExXSA9IHQxMTtcbiAgb1sxMl0gPSB0MTI7XG4gIG9bMTNdID0gdDEzO1xuICBvWzE0XSA9IHQxNDtcbiAgb1sxNV0gPSB0MTU7XG59XG5cbmZ1bmN0aW9uIFMobywgYSkge1xuICBNKG8sIGEsIGEpO1xufVxuXG5mdW5jdGlvbiBpbnYyNTUxOShvLCBpKSB7XG4gIHZhciBjID0gZ2YoKTtcbiAgdmFyIGE7XG4gIGZvciAoYSA9IDA7IGEgPCAxNjsgYSsrKSBjW2FdID0gaVthXTtcbiAgZm9yIChhID0gMjUzOyBhID49IDA7IGEtLSkge1xuICAgIFMoYywgYyk7XG4gICAgaWYoYSAhPT0gMiAmJiBhICE9PSA0KSBNKGMsIGMsIGkpO1xuICB9XG4gIGZvciAoYSA9IDA7IGEgPCAxNjsgYSsrKSBvW2FdID0gY1thXTtcbn1cblxuZnVuY3Rpb24gcG93MjUyMyhvLCBpKSB7XG4gIHZhciBjID0gZ2YoKTtcbiAgdmFyIGE7XG4gIGZvciAoYSA9IDA7IGEgPCAxNjsgYSsrKSBjW2FdID0gaVthXTtcbiAgZm9yIChhID0gMjUwOyBhID49IDA7IGEtLSkge1xuICAgICAgUyhjLCBjKTtcbiAgICAgIGlmKGEgIT09IDEpIE0oYywgYywgaSk7XG4gIH1cbiAgZm9yIChhID0gMDsgYSA8IDE2OyBhKyspIG9bYV0gPSBjW2FdO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2NhbGFybXVsdChxLCBuLCBwKSB7XG4gIHZhciB6ID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICB2YXIgeCA9IG5ldyBGbG9hdDY0QXJyYXkoODApLCByLCBpO1xuICB2YXIgYSA9IGdmKCksIGIgPSBnZigpLCBjID0gZ2YoKSxcbiAgICAgIGQgPSBnZigpLCBlID0gZ2YoKSwgZiA9IGdmKCk7XG4gIGZvciAoaSA9IDA7IGkgPCAzMTsgaSsrKSB6W2ldID0gbltpXTtcbiAgelszMV09KG5bMzFdJjEyNyl8NjQ7XG4gIHpbMF0mPTI0ODtcbiAgdW5wYWNrMjU1MTkoeCxwKTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICBiW2ldPXhbaV07XG4gICAgZFtpXT1hW2ldPWNbaV09MDtcbiAgfVxuICBhWzBdPWRbMF09MTtcbiAgZm9yIChpPTI1NDsgaT49MDsgLS1pKSB7XG4gICAgcj0oeltpPj4+M10+Pj4oaSY3KSkmMTtcbiAgICBzZWwyNTUxOShhLGIscik7XG4gICAgc2VsMjU1MTkoYyxkLHIpO1xuICAgIEEoZSxhLGMpO1xuICAgIFooYSxhLGMpO1xuICAgIEEoYyxiLGQpO1xuICAgIFooYixiLGQpO1xuICAgIFMoZCxlKTtcbiAgICBTKGYsYSk7XG4gICAgTShhLGMsYSk7XG4gICAgTShjLGIsZSk7XG4gICAgQShlLGEsYyk7XG4gICAgWihhLGEsYyk7XG4gICAgUyhiLGEpO1xuICAgIFooYyxkLGYpO1xuICAgIE0oYSxjLF8xMjE2NjUpO1xuICAgIEEoYSxhLGQpO1xuICAgIE0oYyxjLGEpO1xuICAgIE0oYSxkLGYpO1xuICAgIE0oZCxiLHgpO1xuICAgIFMoYixlKTtcbiAgICBzZWwyNTUxOShhLGIscik7XG4gICAgc2VsMjU1MTkoYyxkLHIpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgeFtpKzE2XT1hW2ldO1xuICAgIHhbaSszMl09Y1tpXTtcbiAgICB4W2krNDhdPWJbaV07XG4gICAgeFtpKzY0XT1kW2ldO1xuICB9XG4gIHZhciB4MzIgPSB4LnN1YmFycmF5KDMyKTtcbiAgdmFyIHgxNiA9IHguc3ViYXJyYXkoMTYpO1xuICBpbnYyNTUxOSh4MzIseDMyKTtcbiAgTSh4MTYseDE2LHgzMik7XG4gIHBhY2syNTUxOShxLHgxNik7XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2NhbGFybXVsdF9iYXNlKHEsIG4pIHtcbiAgcmV0dXJuIGNyeXB0b19zY2FsYXJtdWx0KHEsIG4sIF85KTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX2JveF9rZXlwYWlyKHksIHgpIHtcbiAgcmFuZG9tYnl0ZXMoeCwgMzIpO1xuICByZXR1cm4gY3J5cHRvX3NjYWxhcm11bHRfYmFzZSh5LCB4KTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX2JveF9iZWZvcmVubShrLCB5LCB4KSB7XG4gIHZhciBzID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG9fc2NhbGFybXVsdChzLCB4LCB5KTtcbiAgcmV0dXJuIGNyeXB0b19jb3JlX2hzYWxzYTIwKGssIF8wLCBzLCBzaWdtYSk7XG59XG5cbnZhciBjcnlwdG9fYm94X2FmdGVybm0gPSBjcnlwdG9fc2VjcmV0Ym94O1xudmFyIGNyeXB0b19ib3hfb3Blbl9hZnRlcm5tID0gY3J5cHRvX3NlY3JldGJveF9vcGVuO1xuXG5mdW5jdGlvbiBjcnlwdG9fYm94KGMsIG0sIGQsIG4sIHksIHgpIHtcbiAgdmFyIGsgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGNyeXB0b19ib3hfYmVmb3Jlbm0oaywgeSwgeCk7XG4gIHJldHVybiBjcnlwdG9fYm94X2FmdGVybm0oYywgbSwgZCwgbiwgayk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19ib3hfb3BlbihtLCBjLCBkLCBuLCB5LCB4KSB7XG4gIHZhciBrID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG9fYm94X2JlZm9yZW5tKGssIHksIHgpO1xuICByZXR1cm4gY3J5cHRvX2JveF9vcGVuX2FmdGVybm0obSwgYywgZCwgbiwgayk7XG59XG5cbnZhciBLID0gW1xuICAweDQyOGEyZjk4LCAweGQ3MjhhZTIyLCAweDcxMzc0NDkxLCAweDIzZWY2NWNkLFxuICAweGI1YzBmYmNmLCAweGVjNGQzYjJmLCAweGU5YjVkYmE1LCAweDgxODlkYmJjLFxuICAweDM5NTZjMjViLCAweGYzNDhiNTM4LCAweDU5ZjExMWYxLCAweGI2MDVkMDE5LFxuICAweDkyM2Y4MmE0LCAweGFmMTk0ZjliLCAweGFiMWM1ZWQ1LCAweGRhNmQ4MTE4LFxuICAweGQ4MDdhYTk4LCAweGEzMDMwMjQyLCAweDEyODM1YjAxLCAweDQ1NzA2ZmJlLFxuICAweDI0MzE4NWJlLCAweDRlZTRiMjhjLCAweDU1MGM3ZGMzLCAweGQ1ZmZiNGUyLFxuICAweDcyYmU1ZDc0LCAweGYyN2I4OTZmLCAweDgwZGViMWZlLCAweDNiMTY5NmIxLFxuICAweDliZGMwNmE3LCAweDI1YzcxMjM1LCAweGMxOWJmMTc0LCAweGNmNjkyNjk0LFxuICAweGU0OWI2OWMxLCAweDllZjE0YWQyLCAweGVmYmU0Nzg2LCAweDM4NGYyNWUzLFxuICAweDBmYzE5ZGM2LCAweDhiOGNkNWI1LCAweDI0MGNhMWNjLCAweDc3YWM5YzY1LFxuICAweDJkZTkyYzZmLCAweDU5MmIwMjc1LCAweDRhNzQ4NGFhLCAweDZlYTZlNDgzLFxuICAweDVjYjBhOWRjLCAweGJkNDFmYmQ0LCAweDc2Zjk4OGRhLCAweDgzMTE1M2I1LFxuICAweDk4M2U1MTUyLCAweGVlNjZkZmFiLCAweGE4MzFjNjZkLCAweDJkYjQzMjEwLFxuICAweGIwMDMyN2M4LCAweDk4ZmIyMTNmLCAweGJmNTk3ZmM3LCAweGJlZWYwZWU0LFxuICAweGM2ZTAwYmYzLCAweDNkYTg4ZmMyLCAweGQ1YTc5MTQ3LCAweDkzMGFhNzI1LFxuICAweDA2Y2E2MzUxLCAweGUwMDM4MjZmLCAweDE0MjkyOTY3LCAweDBhMGU2ZTcwLFxuICAweDI3YjcwYTg1LCAweDQ2ZDIyZmZjLCAweDJlMWIyMTM4LCAweDVjMjZjOTI2LFxuICAweDRkMmM2ZGZjLCAweDVhYzQyYWVkLCAweDUzMzgwZDEzLCAweDlkOTViM2RmLFxuICAweDY1MGE3MzU0LCAweDhiYWY2M2RlLCAweDc2NmEwYWJiLCAweDNjNzdiMmE4LFxuICAweDgxYzJjOTJlLCAweDQ3ZWRhZWU2LCAweDkyNzIyYzg1LCAweDE0ODIzNTNiLFxuICAweGEyYmZlOGExLCAweDRjZjEwMzY0LCAweGE4MWE2NjRiLCAweGJjNDIzMDAxLFxuICAweGMyNGI4YjcwLCAweGQwZjg5NzkxLCAweGM3NmM1MWEzLCAweDA2NTRiZTMwLFxuICAweGQxOTJlODE5LCAweGQ2ZWY1MjE4LCAweGQ2OTkwNjI0LCAweDU1NjVhOTEwLFxuICAweGY0MGUzNTg1LCAweDU3NzEyMDJhLCAweDEwNmFhMDcwLCAweDMyYmJkMWI4LFxuICAweDE5YTRjMTE2LCAweGI4ZDJkMGM4LCAweDFlMzc2YzA4LCAweDUxNDFhYjUzLFxuICAweDI3NDg3NzRjLCAweGRmOGVlYjk5LCAweDM0YjBiY2I1LCAweGUxOWI0OGE4LFxuICAweDM5MWMwY2IzLCAweGM1Yzk1YTYzLCAweDRlZDhhYTRhLCAweGUzNDE4YWNiLFxuICAweDViOWNjYTRmLCAweDc3NjNlMzczLCAweDY4MmU2ZmYzLCAweGQ2YjJiOGEzLFxuICAweDc0OGY4MmVlLCAweDVkZWZiMmZjLCAweDc4YTU2MzZmLCAweDQzMTcyZjYwLFxuICAweDg0Yzg3ODE0LCAweGExZjBhYjcyLCAweDhjYzcwMjA4LCAweDFhNjQzOWVjLFxuICAweDkwYmVmZmZhLCAweDIzNjMxZTI4LCAweGE0NTA2Y2ViLCAweGRlODJiZGU5LFxuICAweGJlZjlhM2Y3LCAweGIyYzY3OTE1LCAweGM2NzE3OGYyLCAweGUzNzI1MzJiLFxuICAweGNhMjczZWNlLCAweGVhMjY2MTljLCAweGQxODZiOGM3LCAweDIxYzBjMjA3LFxuICAweGVhZGE3ZGQ2LCAweGNkZTBlYjFlLCAweGY1N2Q0ZjdmLCAweGVlNmVkMTc4LFxuICAweDA2ZjA2N2FhLCAweDcyMTc2ZmJhLCAweDBhNjM3ZGM1LCAweGEyYzg5OGE2LFxuICAweDExM2Y5ODA0LCAweGJlZjkwZGFlLCAweDFiNzEwYjM1LCAweDEzMWM0NzFiLFxuICAweDI4ZGI3N2Y1LCAweDIzMDQ3ZDg0LCAweDMyY2FhYjdiLCAweDQwYzcyNDkzLFxuICAweDNjOWViZTBhLCAweDE1YzliZWJjLCAweDQzMWQ2N2M0LCAweDljMTAwZDRjLFxuICAweDRjYzVkNGJlLCAweGNiM2U0MmI2LCAweDU5N2YyOTljLCAweGZjNjU3ZTJhLFxuICAweDVmY2I2ZmFiLCAweDNhZDZmYWVjLCAweDZjNDQxOThjLCAweDRhNDc1ODE3XG5dO1xuXG5mdW5jdGlvbiBjcnlwdG9faGFzaGJsb2Nrc19obChoaCwgaGwsIG0sIG4pIHtcbiAgdmFyIHdoID0gbmV3IEludDMyQXJyYXkoMTYpLCB3bCA9IG5ldyBJbnQzMkFycmF5KDE2KSxcbiAgICAgIGJoMCwgYmgxLCBiaDIsIGJoMywgYmg0LCBiaDUsIGJoNiwgYmg3LFxuICAgICAgYmwwLCBibDEsIGJsMiwgYmwzLCBibDQsIGJsNSwgYmw2LCBibDcsXG4gICAgICB0aCwgdGwsIGksIGosIGgsIGwsIGEsIGIsIGMsIGQ7XG5cbiAgdmFyIGFoMCA9IGhoWzBdLFxuICAgICAgYWgxID0gaGhbMV0sXG4gICAgICBhaDIgPSBoaFsyXSxcbiAgICAgIGFoMyA9IGhoWzNdLFxuICAgICAgYWg0ID0gaGhbNF0sXG4gICAgICBhaDUgPSBoaFs1XSxcbiAgICAgIGFoNiA9IGhoWzZdLFxuICAgICAgYWg3ID0gaGhbN10sXG5cbiAgICAgIGFsMCA9IGhsWzBdLFxuICAgICAgYWwxID0gaGxbMV0sXG4gICAgICBhbDIgPSBobFsyXSxcbiAgICAgIGFsMyA9IGhsWzNdLFxuICAgICAgYWw0ID0gaGxbNF0sXG4gICAgICBhbDUgPSBobFs1XSxcbiAgICAgIGFsNiA9IGhsWzZdLFxuICAgICAgYWw3ID0gaGxbN107XG5cbiAgdmFyIHBvcyA9IDA7XG4gIHdoaWxlIChuID49IDEyOCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICBqID0gOCAqIGkgKyBwb3M7XG4gICAgICB3aFtpXSA9IChtW2orMF0gPDwgMjQpIHwgKG1baisxXSA8PCAxNikgfCAobVtqKzJdIDw8IDgpIHwgbVtqKzNdO1xuICAgICAgd2xbaV0gPSAobVtqKzRdIDw8IDI0KSB8IChtW2orNV0gPDwgMTYpIHwgKG1bais2XSA8PCA4KSB8IG1bais3XTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IDgwOyBpKyspIHtcbiAgICAgIGJoMCA9IGFoMDtcbiAgICAgIGJoMSA9IGFoMTtcbiAgICAgIGJoMiA9IGFoMjtcbiAgICAgIGJoMyA9IGFoMztcbiAgICAgIGJoNCA9IGFoNDtcbiAgICAgIGJoNSA9IGFoNTtcbiAgICAgIGJoNiA9IGFoNjtcbiAgICAgIGJoNyA9IGFoNztcblxuICAgICAgYmwwID0gYWwwO1xuICAgICAgYmwxID0gYWwxO1xuICAgICAgYmwyID0gYWwyO1xuICAgICAgYmwzID0gYWwzO1xuICAgICAgYmw0ID0gYWw0O1xuICAgICAgYmw1ID0gYWw1O1xuICAgICAgYmw2ID0gYWw2O1xuICAgICAgYmw3ID0gYWw3O1xuXG4gICAgICAvLyBhZGRcbiAgICAgIGggPSBhaDc7XG4gICAgICBsID0gYWw3O1xuXG4gICAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgICAgLy8gU2lnbWExXG4gICAgICBoID0gKChhaDQgPj4+IDE0KSB8IChhbDQgPDwgKDMyLTE0KSkpIF4gKChhaDQgPj4+IDE4KSB8IChhbDQgPDwgKDMyLTE4KSkpIF4gKChhbDQgPj4+ICg0MS0zMikpIHwgKGFoNCA8PCAoMzItKDQxLTMyKSkpKTtcbiAgICAgIGwgPSAoKGFsNCA+Pj4gMTQpIHwgKGFoNCA8PCAoMzItMTQpKSkgXiAoKGFsNCA+Pj4gMTgpIHwgKGFoNCA8PCAoMzItMTgpKSkgXiAoKGFoNCA+Pj4gKDQxLTMyKSkgfCAoYWw0IDw8ICgzMi0oNDEtMzIpKSkpO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIC8vIENoXG4gICAgICBoID0gKGFoNCAmIGFoNSkgXiAofmFoNCAmIGFoNik7XG4gICAgICBsID0gKGFsNCAmIGFsNSkgXiAofmFsNCAmIGFsNik7XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgLy8gS1xuICAgICAgaCA9IEtbaSoyXTtcbiAgICAgIGwgPSBLW2kqMisxXTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAvLyB3XG4gICAgICBoID0gd2hbaSUxNl07XG4gICAgICBsID0gd2xbaSUxNl07XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgYiArPSBhID4+PiAxNjtcbiAgICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgICB0aCA9IGMgJiAweGZmZmYgfCBkIDw8IDE2O1xuICAgICAgdGwgPSBhICYgMHhmZmZmIHwgYiA8PCAxNjtcblxuICAgICAgLy8gYWRkXG4gICAgICBoID0gdGg7XG4gICAgICBsID0gdGw7XG5cbiAgICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgICAvLyBTaWdtYTBcbiAgICAgIGggPSAoKGFoMCA+Pj4gMjgpIHwgKGFsMCA8PCAoMzItMjgpKSkgXiAoKGFsMCA+Pj4gKDM0LTMyKSkgfCAoYWgwIDw8ICgzMi0oMzQtMzIpKSkpIF4gKChhbDAgPj4+ICgzOS0zMikpIHwgKGFoMCA8PCAoMzItKDM5LTMyKSkpKTtcbiAgICAgIGwgPSAoKGFsMCA+Pj4gMjgpIHwgKGFoMCA8PCAoMzItMjgpKSkgXiAoKGFoMCA+Pj4gKDM0LTMyKSkgfCAoYWwwIDw8ICgzMi0oMzQtMzIpKSkpIF4gKChhaDAgPj4+ICgzOS0zMikpIHwgKGFsMCA8PCAoMzItKDM5LTMyKSkpKTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAvLyBNYWpcbiAgICAgIGggPSAoYWgwICYgYWgxKSBeIChhaDAgJiBhaDIpIF4gKGFoMSAmIGFoMik7XG4gICAgICBsID0gKGFsMCAmIGFsMSkgXiAoYWwwICYgYWwyKSBeIChhbDEgJiBhbDIpO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgICBjICs9IGIgPj4+IDE2O1xuICAgICAgZCArPSBjID4+PiAxNjtcblxuICAgICAgYmg3ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgICAgYmw3ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgICAvLyBhZGRcbiAgICAgIGggPSBiaDM7XG4gICAgICBsID0gYmwzO1xuXG4gICAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgICAgaCA9IHRoO1xuICAgICAgbCA9IHRsO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgICBjICs9IGIgPj4+IDE2O1xuICAgICAgZCArPSBjID4+PiAxNjtcblxuICAgICAgYmgzID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgICAgYmwzID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgICBhaDEgPSBiaDA7XG4gICAgICBhaDIgPSBiaDE7XG4gICAgICBhaDMgPSBiaDI7XG4gICAgICBhaDQgPSBiaDM7XG4gICAgICBhaDUgPSBiaDQ7XG4gICAgICBhaDYgPSBiaDU7XG4gICAgICBhaDcgPSBiaDY7XG4gICAgICBhaDAgPSBiaDc7XG5cbiAgICAgIGFsMSA9IGJsMDtcbiAgICAgIGFsMiA9IGJsMTtcbiAgICAgIGFsMyA9IGJsMjtcbiAgICAgIGFsNCA9IGJsMztcbiAgICAgIGFsNSA9IGJsNDtcbiAgICAgIGFsNiA9IGJsNTtcbiAgICAgIGFsNyA9IGJsNjtcbiAgICAgIGFsMCA9IGJsNztcblxuICAgICAgaWYgKGklMTYgPT09IDE1KSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCAxNjsgaisrKSB7XG4gICAgICAgICAgLy8gYWRkXG4gICAgICAgICAgaCA9IHdoW2pdO1xuICAgICAgICAgIGwgPSB3bFtqXTtcblxuICAgICAgICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgICAgICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgICAgICAgIGggPSB3aFsoais5KSUxNl07XG4gICAgICAgICAgbCA9IHdsWyhqKzkpJTE2XTtcblxuICAgICAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgICAgICAvLyBzaWdtYTBcbiAgICAgICAgICB0aCA9IHdoWyhqKzEpJTE2XTtcbiAgICAgICAgICB0bCA9IHdsWyhqKzEpJTE2XTtcbiAgICAgICAgICBoID0gKCh0aCA+Pj4gMSkgfCAodGwgPDwgKDMyLTEpKSkgXiAoKHRoID4+PiA4KSB8ICh0bCA8PCAoMzItOCkpKSBeICh0aCA+Pj4gNyk7XG4gICAgICAgICAgbCA9ICgodGwgPj4+IDEpIHwgKHRoIDw8ICgzMi0xKSkpIF4gKCh0bCA+Pj4gOCkgfCAodGggPDwgKDMyLTgpKSkgXiAoKHRsID4+PiA3KSB8ICh0aCA8PCAoMzItNykpKTtcblxuICAgICAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgICAgICAvLyBzaWdtYTFcbiAgICAgICAgICB0aCA9IHdoWyhqKzE0KSUxNl07XG4gICAgICAgICAgdGwgPSB3bFsoaisxNCklMTZdO1xuICAgICAgICAgIGggPSAoKHRoID4+PiAxOSkgfCAodGwgPDwgKDMyLTE5KSkpIF4gKCh0bCA+Pj4gKDYxLTMyKSkgfCAodGggPDwgKDMyLSg2MS0zMikpKSkgXiAodGggPj4+IDYpO1xuICAgICAgICAgIGwgPSAoKHRsID4+PiAxOSkgfCAodGggPDwgKDMyLTE5KSkpIF4gKCh0aCA+Pj4gKDYxLTMyKSkgfCAodGwgPDwgKDMyLSg2MS0zMikpKSkgXiAoKHRsID4+PiA2KSB8ICh0aCA8PCAoMzItNikpKTtcblxuICAgICAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgICAgICBiICs9IGEgPj4+IDE2O1xuICAgICAgICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgICAgICAgZCArPSBjID4+PiAxNjtcblxuICAgICAgICAgIHdoW2pdID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgICAgICAgIHdsW2pdID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkXG4gICAgaCA9IGFoMDtcbiAgICBsID0gYWwwO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzBdO1xuICAgIGwgPSBobFswXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzBdID0gYWgwID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzBdID0gYWwwID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoMTtcbiAgICBsID0gYWwxO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzFdO1xuICAgIGwgPSBobFsxXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzFdID0gYWgxID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzFdID0gYWwxID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoMjtcbiAgICBsID0gYWwyO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzJdO1xuICAgIGwgPSBobFsyXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzJdID0gYWgyID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzJdID0gYWwyID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoMztcbiAgICBsID0gYWwzO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzNdO1xuICAgIGwgPSBobFszXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzNdID0gYWgzID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzNdID0gYWwzID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNDtcbiAgICBsID0gYWw0O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzRdO1xuICAgIGwgPSBobFs0XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzRdID0gYWg0ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzRdID0gYWw0ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNTtcbiAgICBsID0gYWw1O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzVdO1xuICAgIGwgPSBobFs1XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzVdID0gYWg1ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzVdID0gYWw1ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNjtcbiAgICBsID0gYWw2O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzZdO1xuICAgIGwgPSBobFs2XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzZdID0gYWg2ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzZdID0gYWw2ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNztcbiAgICBsID0gYWw3O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzddO1xuICAgIGwgPSBobFs3XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzddID0gYWg3ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzddID0gYWw3ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgcG9zICs9IDEyODtcbiAgICBuIC09IDEyODtcbiAgfVxuXG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9faGFzaChvdXQsIG0sIG4pIHtcbiAgdmFyIGhoID0gbmV3IEludDMyQXJyYXkoOCksXG4gICAgICBobCA9IG5ldyBJbnQzMkFycmF5KDgpLFxuICAgICAgeCA9IG5ldyBVaW50OEFycmF5KDI1NiksXG4gICAgICBpLCBiID0gbjtcblxuICBoaFswXSA9IDB4NmEwOWU2Njc7XG4gIGhoWzFdID0gMHhiYjY3YWU4NTtcbiAgaGhbMl0gPSAweDNjNmVmMzcyO1xuICBoaFszXSA9IDB4YTU0ZmY1M2E7XG4gIGhoWzRdID0gMHg1MTBlNTI3ZjtcbiAgaGhbNV0gPSAweDliMDU2ODhjO1xuICBoaFs2XSA9IDB4MWY4M2Q5YWI7XG4gIGhoWzddID0gMHg1YmUwY2QxOTtcblxuICBobFswXSA9IDB4ZjNiY2M5MDg7XG4gIGhsWzFdID0gMHg4NGNhYTczYjtcbiAgaGxbMl0gPSAweGZlOTRmODJiO1xuICBobFszXSA9IDB4NWYxZDM2ZjE7XG4gIGhsWzRdID0gMHhhZGU2ODJkMTtcbiAgaGxbNV0gPSAweDJiM2U2YzFmO1xuICBobFs2XSA9IDB4ZmI0MWJkNmI7XG4gIGhsWzddID0gMHgxMzdlMjE3OTtcblxuICBjcnlwdG9faGFzaGJsb2Nrc19obChoaCwgaGwsIG0sIG4pO1xuICBuICU9IDEyODtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB4W2ldID0gbVtiLW4raV07XG4gIHhbbl0gPSAxMjg7XG5cbiAgbiA9IDI1Ni0xMjgqKG48MTEyPzE6MCk7XG4gIHhbbi05XSA9IDA7XG4gIHRzNjQoeCwgbi04LCAgKGIgLyAweDIwMDAwMDAwKSB8IDAsIGIgPDwgMyk7XG4gIGNyeXB0b19oYXNoYmxvY2tzX2hsKGhoLCBobCwgeCwgbik7XG5cbiAgZm9yIChpID0gMDsgaSA8IDg7IGkrKykgdHM2NChvdXQsIDgqaSwgaGhbaV0sIGhsW2ldKTtcblxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gYWRkKHAsIHEpIHtcbiAgdmFyIGEgPSBnZigpLCBiID0gZ2YoKSwgYyA9IGdmKCksXG4gICAgICBkID0gZ2YoKSwgZSA9IGdmKCksIGYgPSBnZigpLFxuICAgICAgZyA9IGdmKCksIGggPSBnZigpLCB0ID0gZ2YoKTtcblxuICBaKGEsIHBbMV0sIHBbMF0pO1xuICBaKHQsIHFbMV0sIHFbMF0pO1xuICBNKGEsIGEsIHQpO1xuICBBKGIsIHBbMF0sIHBbMV0pO1xuICBBKHQsIHFbMF0sIHFbMV0pO1xuICBNKGIsIGIsIHQpO1xuICBNKGMsIHBbM10sIHFbM10pO1xuICBNKGMsIGMsIEQyKTtcbiAgTShkLCBwWzJdLCBxWzJdKTtcbiAgQShkLCBkLCBkKTtcbiAgWihlLCBiLCBhKTtcbiAgWihmLCBkLCBjKTtcbiAgQShnLCBkLCBjKTtcbiAgQShoLCBiLCBhKTtcblxuICBNKHBbMF0sIGUsIGYpO1xuICBNKHBbMV0sIGgsIGcpO1xuICBNKHBbMl0sIGcsIGYpO1xuICBNKHBbM10sIGUsIGgpO1xufVxuXG5mdW5jdGlvbiBjc3dhcChwLCBxLCBiKSB7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgc2VsMjU1MTkocFtpXSwgcVtpXSwgYik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFjayhyLCBwKSB7XG4gIHZhciB0eCA9IGdmKCksIHR5ID0gZ2YoKSwgemkgPSBnZigpO1xuICBpbnYyNTUxOSh6aSwgcFsyXSk7XG4gIE0odHgsIHBbMF0sIHppKTtcbiAgTSh0eSwgcFsxXSwgemkpO1xuICBwYWNrMjU1MTkociwgdHkpO1xuICByWzMxXSBePSBwYXIyNTUxOSh0eCkgPDwgNztcbn1cblxuZnVuY3Rpb24gc2NhbGFybXVsdChwLCBxLCBzKSB7XG4gIHZhciBiLCBpO1xuICBzZXQyNTUxOShwWzBdLCBnZjApO1xuICBzZXQyNTUxOShwWzFdLCBnZjEpO1xuICBzZXQyNTUxOShwWzJdLCBnZjEpO1xuICBzZXQyNTUxOShwWzNdLCBnZjApO1xuICBmb3IgKGkgPSAyNTU7IGkgPj0gMDsgLS1pKSB7XG4gICAgYiA9IChzWyhpLzgpfDBdID4+IChpJjcpKSAmIDE7XG4gICAgY3N3YXAocCwgcSwgYik7XG4gICAgYWRkKHEsIHApO1xuICAgIGFkZChwLCBwKTtcbiAgICBjc3dhcChwLCBxLCBiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY2FsYXJiYXNlKHAsIHMpIHtcbiAgdmFyIHEgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV07XG4gIHNldDI1NTE5KHFbMF0sIFgpO1xuICBzZXQyNTUxOShxWzFdLCBZKTtcbiAgc2V0MjU1MTkocVsyXSwgZ2YxKTtcbiAgTShxWzNdLCBYLCBZKTtcbiAgc2NhbGFybXVsdChwLCBxLCBzKTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NpZ25fa2V5cGFpcihwaywgc2ssIHNlZWRlZCkge1xuICB2YXIgZCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIHAgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV07XG4gIHZhciBpO1xuXG4gIGlmICghc2VlZGVkKSByYW5kb21ieXRlcyhzaywgMzIpO1xuICBjcnlwdG9faGFzaChkLCBzaywgMzIpO1xuICBkWzBdICY9IDI0ODtcbiAgZFszMV0gJj0gMTI3O1xuICBkWzMxXSB8PSA2NDtcblxuICBzY2FsYXJiYXNlKHAsIGQpO1xuICBwYWNrKHBrLCBwKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykgc2tbaSszMl0gPSBwa1tpXTtcbiAgcmV0dXJuIDA7XG59XG5cbnZhciBMID0gbmV3IEZsb2F0NjRBcnJheShbMHhlZCwgMHhkMywgMHhmNSwgMHg1YywgMHgxYSwgMHg2MywgMHgxMiwgMHg1OCwgMHhkNiwgMHg5YywgMHhmNywgMHhhMiwgMHhkZSwgMHhmOSwgMHhkZSwgMHgxNCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMHgxMF0pO1xuXG5mdW5jdGlvbiBtb2RMKHIsIHgpIHtcbiAgdmFyIGNhcnJ5LCBpLCBqLCBrO1xuICBmb3IgKGkgPSA2MzsgaSA+PSAzMjsgLS1pKSB7XG4gICAgY2FycnkgPSAwO1xuICAgIGZvciAoaiA9IGkgLSAzMiwgayA9IGkgLSAxMjsgaiA8IGs7ICsraikge1xuICAgICAgeFtqXSArPSBjYXJyeSAtIDE2ICogeFtpXSAqIExbaiAtIChpIC0gMzIpXTtcbiAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcigoeFtqXSArIDEyOCkgLyAyNTYpO1xuICAgICAgeFtqXSAtPSBjYXJyeSAqIDI1NjtcbiAgICB9XG4gICAgeFtqXSArPSBjYXJyeTtcbiAgICB4W2ldID0gMDtcbiAgfVxuICBjYXJyeSA9IDA7XG4gIGZvciAoaiA9IDA7IGogPCAzMjsgaisrKSB7XG4gICAgeFtqXSArPSBjYXJyeSAtICh4WzMxXSA+PiA0KSAqIExbal07XG4gICAgY2FycnkgPSB4W2pdID4+IDg7XG4gICAgeFtqXSAmPSAyNTU7XG4gIH1cbiAgZm9yIChqID0gMDsgaiA8IDMyOyBqKyspIHhbal0gLT0gY2FycnkgKiBMW2pdO1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgIHhbaSsxXSArPSB4W2ldID4+IDg7XG4gICAgcltpXSA9IHhbaV0gJiAyNTU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVkdWNlKHIpIHtcbiAgdmFyIHggPSBuZXcgRmxvYXQ2NEFycmF5KDY0KSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIHhbaV0gPSByW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykgcltpXSA9IDA7XG4gIG1vZEwociwgeCk7XG59XG5cbi8vIE5vdGU6IGRpZmZlcmVuY2UgZnJvbSBDIC0gc21sZW4gcmV0dXJuZWQsIG5vdCBwYXNzZWQgYXMgYXJndW1lbnQuXG5mdW5jdGlvbiBjcnlwdG9fc2lnbihzbSwgbSwgbiwgc2spIHtcbiAgdmFyIGQgPSBuZXcgVWludDhBcnJheSg2NCksIGggPSBuZXcgVWludDhBcnJheSg2NCksIHIgPSBuZXcgVWludDhBcnJheSg2NCk7XG4gIHZhciBpLCBqLCB4ID0gbmV3IEZsb2F0NjRBcnJheSg2NCk7XG4gIHZhciBwID0gW2dmKCksIGdmKCksIGdmKCksIGdmKCldO1xuXG4gIGNyeXB0b19oYXNoKGQsIHNrLCAzMik7XG4gIGRbMF0gJj0gMjQ4O1xuICBkWzMxXSAmPSAxMjc7XG4gIGRbMzFdIHw9IDY0O1xuXG4gIHZhciBzbWxlbiA9IG4gKyA2NDtcbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgc21bNjQgKyBpXSA9IG1baV07XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSBzbVszMiArIGldID0gZFszMiArIGldO1xuXG4gIGNyeXB0b19oYXNoKHIsIHNtLnN1YmFycmF5KDMyKSwgbiszMik7XG4gIHJlZHVjZShyKTtcbiAgc2NhbGFyYmFzZShwLCByKTtcbiAgcGFjayhzbSwgcCk7XG5cbiAgZm9yIChpID0gMzI7IGkgPCA2NDsgaSsrKSBzbVtpXSA9IHNrW2ldO1xuICBjcnlwdG9faGFzaChoLCBzbSwgbiArIDY0KTtcbiAgcmVkdWNlKGgpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSB4W2ldID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHhbaV0gPSByW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgIGZvciAoaiA9IDA7IGogPCAzMjsgaisrKSB7XG4gICAgICB4W2kral0gKz0gaFtpXSAqIGRbal07XG4gICAgfVxuICB9XG5cbiAgbW9kTChzbS5zdWJhcnJheSgzMiksIHgpO1xuICByZXR1cm4gc21sZW47XG59XG5cbmZ1bmN0aW9uIHVucGFja25lZyhyLCBwKSB7XG4gIHZhciB0ID0gZ2YoKSwgY2hrID0gZ2YoKSwgbnVtID0gZ2YoKSxcbiAgICAgIGRlbiA9IGdmKCksIGRlbjIgPSBnZigpLCBkZW40ID0gZ2YoKSxcbiAgICAgIGRlbjYgPSBnZigpO1xuXG4gIHNldDI1NTE5KHJbMl0sIGdmMSk7XG4gIHVucGFjazI1NTE5KHJbMV0sIHApO1xuICBTKG51bSwgclsxXSk7XG4gIE0oZGVuLCBudW0sIEQpO1xuICBaKG51bSwgbnVtLCByWzJdKTtcbiAgQShkZW4sIHJbMl0sIGRlbik7XG5cbiAgUyhkZW4yLCBkZW4pO1xuICBTKGRlbjQsIGRlbjIpO1xuICBNKGRlbjYsIGRlbjQsIGRlbjIpO1xuICBNKHQsIGRlbjYsIG51bSk7XG4gIE0odCwgdCwgZGVuKTtcblxuICBwb3cyNTIzKHQsIHQpO1xuICBNKHQsIHQsIG51bSk7XG4gIE0odCwgdCwgZGVuKTtcbiAgTSh0LCB0LCBkZW4pO1xuICBNKHJbMF0sIHQsIGRlbik7XG5cbiAgUyhjaGssIHJbMF0pO1xuICBNKGNoaywgY2hrLCBkZW4pO1xuICBpZiAobmVxMjU1MTkoY2hrLCBudW0pKSBNKHJbMF0sIHJbMF0sIEkpO1xuXG4gIFMoY2hrLCByWzBdKTtcbiAgTShjaGssIGNoaywgZGVuKTtcbiAgaWYgKG5lcTI1NTE5KGNoaywgbnVtKSkgcmV0dXJuIC0xO1xuXG4gIGlmIChwYXIyNTUxOShyWzBdKSA9PT0gKHBbMzFdPj43KSkgWihyWzBdLCBnZjAsIHJbMF0pO1xuXG4gIE0oclszXSwgclswXSwgclsxXSk7XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2lnbl9vcGVuKG0sIHNtLCBuLCBwaykge1xuICB2YXIgaTtcbiAgdmFyIHQgPSBuZXcgVWludDhBcnJheSgzMiksIGggPSBuZXcgVWludDhBcnJheSg2NCk7XG4gIHZhciBwID0gW2dmKCksIGdmKCksIGdmKCksIGdmKCldLFxuICAgICAgcSA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXTtcblxuICBpZiAobiA8IDY0KSByZXR1cm4gLTE7XG5cbiAgaWYgKHVucGFja25lZyhxLCBwaykpIHJldHVybiAtMTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBtW2ldID0gc21baV07XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSBtW2krMzJdID0gcGtbaV07XG4gIGNyeXB0b19oYXNoKGgsIG0sIG4pO1xuICByZWR1Y2UoaCk7XG4gIHNjYWxhcm11bHQocCwgcSwgaCk7XG5cbiAgc2NhbGFyYmFzZShxLCBzbS5zdWJhcnJheSgzMikpO1xuICBhZGQocCwgcSk7XG4gIHBhY2sodCwgcCk7XG5cbiAgbiAtPSA2NDtcbiAgaWYgKGNyeXB0b192ZXJpZnlfMzIoc20sIDAsIHQsIDApKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgbVtpXSA9IDA7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgbVtpXSA9IHNtW2kgKyA2NF07XG4gIHJldHVybiBuO1xufVxuXG52YXIgY3J5cHRvX3NlY3JldGJveF9LRVlCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUyA9IDI0LFxuICAgIGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTID0gMzIsXG4gICAgY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMgPSAxNixcbiAgICBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUyA9IDMyLFxuICAgIGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTID0gMzIsXG4gICAgY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVMgPSAzMixcbiAgICBjcnlwdG9fYm94X0JFRk9SRU5NQllURVMgPSAzMixcbiAgICBjcnlwdG9fYm94X05PTkNFQllURVMgPSBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVMsXG4gICAgY3J5cHRvX2JveF9aRVJPQllURVMgPSBjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUyxcbiAgICBjcnlwdG9fYm94X0JPWFpFUk9CWVRFUyA9IGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTLFxuICAgIGNyeXB0b19zaWduX0JZVEVTID0gNjQsXG4gICAgY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMgPSAzMixcbiAgICBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUyA9IDY0LFxuICAgIGNyeXB0b19zaWduX1NFRURCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19oYXNoX0JZVEVTID0gNjQ7XG5cbm5hY2wubG93bGV2ZWwgPSB7XG4gIGNyeXB0b19jb3JlX2hzYWxzYTIwOiBjcnlwdG9fY29yZV9oc2Fsc2EyMCxcbiAgY3J5cHRvX3N0cmVhbV94b3I6IGNyeXB0b19zdHJlYW1feG9yLFxuICBjcnlwdG9fc3RyZWFtOiBjcnlwdG9fc3RyZWFtLFxuICBjcnlwdG9fc3RyZWFtX3NhbHNhMjBfeG9yOiBjcnlwdG9fc3RyZWFtX3NhbHNhMjBfeG9yLFxuICBjcnlwdG9fc3RyZWFtX3NhbHNhMjA6IGNyeXB0b19zdHJlYW1fc2Fsc2EyMCxcbiAgY3J5cHRvX29uZXRpbWVhdXRoOiBjcnlwdG9fb25ldGltZWF1dGgsXG4gIGNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnk6IGNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnksXG4gIGNyeXB0b192ZXJpZnlfMTY6IGNyeXB0b192ZXJpZnlfMTYsXG4gIGNyeXB0b192ZXJpZnlfMzI6IGNyeXB0b192ZXJpZnlfMzIsXG4gIGNyeXB0b19zZWNyZXRib3g6IGNyeXB0b19zZWNyZXRib3gsXG4gIGNyeXB0b19zZWNyZXRib3hfb3BlbjogY3J5cHRvX3NlY3JldGJveF9vcGVuLFxuICBjcnlwdG9fc2NhbGFybXVsdDogY3J5cHRvX3NjYWxhcm11bHQsXG4gIGNyeXB0b19zY2FsYXJtdWx0X2Jhc2U6IGNyeXB0b19zY2FsYXJtdWx0X2Jhc2UsXG4gIGNyeXB0b19ib3hfYmVmb3Jlbm06IGNyeXB0b19ib3hfYmVmb3Jlbm0sXG4gIGNyeXB0b19ib3hfYWZ0ZXJubTogY3J5cHRvX2JveF9hZnRlcm5tLFxuICBjcnlwdG9fYm94OiBjcnlwdG9fYm94LFxuICBjcnlwdG9fYm94X29wZW46IGNyeXB0b19ib3hfb3BlbixcbiAgY3J5cHRvX2JveF9rZXlwYWlyOiBjcnlwdG9fYm94X2tleXBhaXIsXG4gIGNyeXB0b19oYXNoOiBjcnlwdG9faGFzaCxcbiAgY3J5cHRvX3NpZ246IGNyeXB0b19zaWduLFxuICBjcnlwdG9fc2lnbl9rZXlwYWlyOiBjcnlwdG9fc2lnbl9rZXlwYWlyLFxuICBjcnlwdG9fc2lnbl9vcGVuOiBjcnlwdG9fc2lnbl9vcGVuLFxuXG4gIGNyeXB0b19zZWNyZXRib3hfS0VZQllURVM6IGNyeXB0b19zZWNyZXRib3hfS0VZQllURVMsXG4gIGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUzogY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTLFxuICBjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUzogY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMsXG4gIGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTOiBjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyxcbiAgY3J5cHRvX3NjYWxhcm11bHRfQllURVM6IGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTLFxuICBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUzogY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVMsXG4gIGNyeXB0b19ib3hfUFVCTElDS0VZQllURVM6IGNyeXB0b19ib3hfUFVCTElDS0VZQllURVMsXG4gIGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVM6IGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVMsXG4gIGNyeXB0b19ib3hfQkVGT1JFTk1CWVRFUzogY3J5cHRvX2JveF9CRUZPUkVOTUJZVEVTLFxuICBjcnlwdG9fYm94X05PTkNFQllURVM6IGNyeXB0b19ib3hfTk9OQ0VCWVRFUyxcbiAgY3J5cHRvX2JveF9aRVJPQllURVM6IGNyeXB0b19ib3hfWkVST0JZVEVTLFxuICBjcnlwdG9fYm94X0JPWFpFUk9CWVRFUzogY3J5cHRvX2JveF9CT1haRVJPQllURVMsXG4gIGNyeXB0b19zaWduX0JZVEVTOiBjcnlwdG9fc2lnbl9CWVRFUyxcbiAgY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVM6IGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTLFxuICBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUzogY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMsXG4gIGNyeXB0b19zaWduX1NFRURCWVRFUzogY3J5cHRvX3NpZ25fU0VFREJZVEVTLFxuICBjcnlwdG9faGFzaF9CWVRFUzogY3J5cHRvX2hhc2hfQllURVMsXG5cbiAgZ2Y6IGdmLFxuICBEOiBELFxuICBMOiBMLFxuICBwYWNrMjU1MTk6IHBhY2syNTUxOSxcbiAgdW5wYWNrMjU1MTk6IHVucGFjazI1NTE5LFxuICBNOiBNLFxuICBBOiBBLFxuICBTOiBTLFxuICBaOiBaLFxuICBwb3cyNTIzOiBwb3cyNTIzLFxuICBhZGQ6IGFkZCxcbiAgc2V0MjU1MTk6IHNldDI1NTE5LFxuICBtb2RMOiBtb2RMLFxuICBzY2FsYXJtdWx0OiBzY2FsYXJtdWx0LFxuICBzY2FsYXJiYXNlOiBzY2FsYXJiYXNlLFxufTtcblxuLyogSGlnaC1sZXZlbCBBUEkgKi9cblxuZnVuY3Rpb24gY2hlY2tMZW5ndGhzKGssIG4pIHtcbiAgaWYgKGsubGVuZ3RoICE9PSBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBrZXkgc2l6ZScpO1xuICBpZiAobi5sZW5ndGggIT09IGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgbm9uY2Ugc2l6ZScpO1xufVxuXG5mdW5jdGlvbiBjaGVja0JveExlbmd0aHMocGssIHNrKSB7XG4gIGlmIChway5sZW5ndGggIT09IGNyeXB0b19ib3hfUFVCTElDS0VZQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIHB1YmxpYyBrZXkgc2l6ZScpO1xuICBpZiAoc2subGVuZ3RoICE9PSBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWNyZXQga2V5IHNpemUnKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tBcnJheVR5cGVzKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghKGFyZ3VtZW50c1tpXSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5leHBlY3RlZCB0eXBlLCB1c2UgVWludDhBcnJheScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFudXAoYXJyKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnJbaV0gPSAwO1xufVxuXG5uYWNsLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24obikge1xuICB2YXIgYiA9IG5ldyBVaW50OEFycmF5KG4pO1xuICByYW5kb21ieXRlcyhiLCBuKTtcbiAgcmV0dXJuIGI7XG59O1xuXG5uYWNsLnNlY3JldGJveCA9IGZ1bmN0aW9uKG1zZywgbm9uY2UsIGtleSkge1xuICBjaGVja0FycmF5VHlwZXMobXNnLCBub25jZSwga2V5KTtcbiAgY2hlY2tMZW5ndGhzKGtleSwgbm9uY2UpO1xuICB2YXIgbSA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTICsgbXNnLmxlbmd0aCk7XG4gIHZhciBjID0gbmV3IFVpbnQ4QXJyYXkobS5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykgbVtpK2NyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTXSA9IG1zZ1tpXTtcbiAgY3J5cHRvX3NlY3JldGJveChjLCBtLCBtLmxlbmd0aCwgbm9uY2UsIGtleSk7XG4gIHJldHVybiBjLnN1YmFycmF5KGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTKTtcbn07XG5cbm5hY2wuc2VjcmV0Ym94Lm9wZW4gPSBmdW5jdGlvbihib3gsIG5vbmNlLCBrZXkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKGJveCwgbm9uY2UsIGtleSk7XG4gIGNoZWNrTGVuZ3RocyhrZXksIG5vbmNlKTtcbiAgdmFyIGMgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyArIGJveC5sZW5ndGgpO1xuICB2YXIgbSA9IG5ldyBVaW50OEFycmF5KGMubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3gubGVuZ3RoOyBpKyspIGNbaStjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFU10gPSBib3hbaV07XG4gIGlmIChjLmxlbmd0aCA8IDMyKSByZXR1cm4gbnVsbDtcbiAgaWYgKGNyeXB0b19zZWNyZXRib3hfb3BlbihtLCBjLCBjLmxlbmd0aCwgbm9uY2UsIGtleSkgIT09IDApIHJldHVybiBudWxsO1xuICByZXR1cm4gbS5zdWJhcnJheShjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUyk7XG59O1xuXG5uYWNsLnNlY3JldGJveC5rZXlMZW5ndGggPSBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTO1xubmFjbC5zZWNyZXRib3gubm9uY2VMZW5ndGggPSBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVM7XG5uYWNsLnNlY3JldGJveC5vdmVyaGVhZExlbmd0aCA9IGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTO1xuXG5uYWNsLnNjYWxhck11bHQgPSBmdW5jdGlvbihuLCBwKSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhuLCBwKTtcbiAgaWYgKG4ubGVuZ3RoICE9PSBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgbiBzaXplJyk7XG4gIGlmIChwLmxlbmd0aCAhPT0gY3J5cHRvX3NjYWxhcm11bHRfQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIHAgc2l6ZScpO1xuICB2YXIgcSA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTKTtcbiAgY3J5cHRvX3NjYWxhcm11bHQocSwgbiwgcCk7XG4gIHJldHVybiBxO1xufTtcblxubmFjbC5zY2FsYXJNdWx0LmJhc2UgPSBmdW5jdGlvbihuKSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhuKTtcbiAgaWYgKG4ubGVuZ3RoICE9PSBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgbiBzaXplJyk7XG4gIHZhciBxID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NjYWxhcm11bHRfQllURVMpO1xuICBjcnlwdG9fc2NhbGFybXVsdF9iYXNlKHEsIG4pO1xuICByZXR1cm4gcTtcbn07XG5cbm5hY2wuc2NhbGFyTXVsdC5zY2FsYXJMZW5ndGggPSBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUztcbm5hY2wuc2NhbGFyTXVsdC5ncm91cEVsZW1lbnRMZW5ndGggPSBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUztcblxubmFjbC5ib3ggPSBmdW5jdGlvbihtc2csIG5vbmNlLCBwdWJsaWNLZXksIHNlY3JldEtleSkge1xuICB2YXIgayA9IG5hY2wuYm94LmJlZm9yZShwdWJsaWNLZXksIHNlY3JldEtleSk7XG4gIHJldHVybiBuYWNsLnNlY3JldGJveChtc2csIG5vbmNlLCBrKTtcbn07XG5cbm5hY2wuYm94LmJlZm9yZSA9IGZ1bmN0aW9uKHB1YmxpY0tleSwgc2VjcmV0S2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhwdWJsaWNLZXksIHNlY3JldEtleSk7XG4gIGNoZWNrQm94TGVuZ3RocyhwdWJsaWNLZXksIHNlY3JldEtleSk7XG4gIHZhciBrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX2JveF9CRUZPUkVOTUJZVEVTKTtcbiAgY3J5cHRvX2JveF9iZWZvcmVubShrLCBwdWJsaWNLZXksIHNlY3JldEtleSk7XG4gIHJldHVybiBrO1xufTtcblxubmFjbC5ib3guYWZ0ZXIgPSBuYWNsLnNlY3JldGJveDtcblxubmFjbC5ib3gub3BlbiA9IGZ1bmN0aW9uKG1zZywgbm9uY2UsIHB1YmxpY0tleSwgc2VjcmV0S2V5KSB7XG4gIHZhciBrID0gbmFjbC5ib3guYmVmb3JlKHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgcmV0dXJuIG5hY2wuc2VjcmV0Ym94Lm9wZW4obXNnLCBub25jZSwgayk7XG59O1xuXG5uYWNsLmJveC5vcGVuLmFmdGVyID0gbmFjbC5zZWNyZXRib3gub3BlbjtcblxubmFjbC5ib3gua2V5UGFpciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTKTtcbiAgdmFyIHNrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUyk7XG4gIGNyeXB0b19ib3hfa2V5cGFpcihwaywgc2spO1xuICByZXR1cm4ge3B1YmxpY0tleTogcGssIHNlY3JldEtleTogc2t9O1xufTtcblxubmFjbC5ib3gua2V5UGFpci5mcm9tU2VjcmV0S2V5ID0gZnVuY3Rpb24oc2VjcmV0S2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhzZWNyZXRLZXkpO1xuICBpZiAoc2VjcmV0S2V5Lmxlbmd0aCAhPT0gY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWNyZXQga2V5IHNpemUnKTtcbiAgdmFyIHBrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUyk7XG4gIGNyeXB0b19zY2FsYXJtdWx0X2Jhc2UocGssIHNlY3JldEtleSk7XG4gIHJldHVybiB7cHVibGljS2V5OiBwaywgc2VjcmV0S2V5OiBuZXcgVWludDhBcnJheShzZWNyZXRLZXkpfTtcbn07XG5cbm5hY2wuYm94LnB1YmxpY0tleUxlbmd0aCA9IGNyeXB0b19ib3hfUFVCTElDS0VZQllURVM7XG5uYWNsLmJveC5zZWNyZXRLZXlMZW5ndGggPSBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTO1xubmFjbC5ib3guc2hhcmVkS2V5TGVuZ3RoID0gY3J5cHRvX2JveF9CRUZPUkVOTUJZVEVTO1xubmFjbC5ib3gubm9uY2VMZW5ndGggPSBjcnlwdG9fYm94X05PTkNFQllURVM7XG5uYWNsLmJveC5vdmVyaGVhZExlbmd0aCA9IG5hY2wuc2VjcmV0Ym94Lm92ZXJoZWFkTGVuZ3RoO1xuXG5uYWNsLnNpZ24gPSBmdW5jdGlvbihtc2csIHNlY3JldEtleSkge1xuICBjaGVja0FycmF5VHlwZXMobXNnLCBzZWNyZXRLZXkpO1xuICBpZiAoc2VjcmV0S2V5Lmxlbmd0aCAhPT0gY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VjcmV0IGtleSBzaXplJyk7XG4gIHZhciBzaWduZWRNc2cgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9CWVRFUyttc2cubGVuZ3RoKTtcbiAgY3J5cHRvX3NpZ24oc2lnbmVkTXNnLCBtc2csIG1zZy5sZW5ndGgsIHNlY3JldEtleSk7XG4gIHJldHVybiBzaWduZWRNc2c7XG59O1xuXG5uYWNsLnNpZ24ub3BlbiA9IGZ1bmN0aW9uKHNpZ25lZE1zZywgcHVibGljS2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhzaWduZWRNc2csIHB1YmxpY0tleSk7XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwdWJsaWMga2V5IHNpemUnKTtcbiAgdmFyIHRtcCA9IG5ldyBVaW50OEFycmF5KHNpZ25lZE1zZy5sZW5ndGgpO1xuICB2YXIgbWxlbiA9IGNyeXB0b19zaWduX29wZW4odG1wLCBzaWduZWRNc2csIHNpZ25lZE1zZy5sZW5ndGgsIHB1YmxpY0tleSk7XG4gIGlmIChtbGVuIDwgMCkgcmV0dXJuIG51bGw7XG4gIHZhciBtID0gbmV3IFVpbnQ4QXJyYXkobWxlbik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKykgbVtpXSA9IHRtcFtpXTtcbiAgcmV0dXJuIG07XG59O1xuXG5uYWNsLnNpZ24uZGV0YWNoZWQgPSBmdW5jdGlvbihtc2csIHNlY3JldEtleSkge1xuICB2YXIgc2lnbmVkTXNnID0gbmFjbC5zaWduKG1zZywgc2VjcmV0S2V5KTtcbiAgdmFyIHNpZyA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX0JZVEVTKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWcubGVuZ3RoOyBpKyspIHNpZ1tpXSA9IHNpZ25lZE1zZ1tpXTtcbiAgcmV0dXJuIHNpZztcbn07XG5cbm5hY2wuc2lnbi5kZXRhY2hlZC52ZXJpZnkgPSBmdW5jdGlvbihtc2csIHNpZywgcHVibGljS2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhtc2csIHNpZywgcHVibGljS2V5KTtcbiAgaWYgKHNpZy5sZW5ndGggIT09IGNyeXB0b19zaWduX0JZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNpZ25hdHVyZSBzaXplJyk7XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwdWJsaWMga2V5IHNpemUnKTtcbiAgdmFyIHNtID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fQllURVMgKyBtc2cubGVuZ3RoKTtcbiAgdmFyIG0gPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9CWVRFUyArIG1zZy5sZW5ndGgpO1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IGNyeXB0b19zaWduX0JZVEVTOyBpKyspIHNtW2ldID0gc2lnW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSBzbVtpK2NyeXB0b19zaWduX0JZVEVTXSA9IG1zZ1tpXTtcbiAgcmV0dXJuIChjcnlwdG9fc2lnbl9vcGVuKG0sIHNtLCBzbS5sZW5ndGgsIHB1YmxpY0tleSkgPj0gMCk7XG59O1xuXG5uYWNsLnNpZ24ua2V5UGFpciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyk7XG4gIHZhciBzayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTKTtcbiAgY3J5cHRvX3NpZ25fa2V5cGFpcihwaywgc2spO1xuICByZXR1cm4ge3B1YmxpY0tleTogcGssIHNlY3JldEtleTogc2t9O1xufTtcblxubmFjbC5zaWduLmtleVBhaXIuZnJvbVNlY3JldEtleSA9IGZ1bmN0aW9uKHNlY3JldEtleSkge1xuICBjaGVja0FycmF5VHlwZXMoc2VjcmV0S2V5KTtcbiAgaWYgKHNlY3JldEtleS5sZW5ndGggIT09IGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xuICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGsubGVuZ3RoOyBpKyspIHBrW2ldID0gc2VjcmV0S2V5WzMyK2ldO1xuICByZXR1cm4ge3B1YmxpY0tleTogcGssIHNlY3JldEtleTogbmV3IFVpbnQ4QXJyYXkoc2VjcmV0S2V5KX07XG59O1xuXG5uYWNsLnNpZ24ua2V5UGFpci5mcm9tU2VlZCA9IGZ1bmN0aW9uKHNlZWQpIHtcbiAgY2hlY2tBcnJheVR5cGVzKHNlZWQpO1xuICBpZiAoc2VlZC5sZW5ndGggIT09IGNyeXB0b19zaWduX1NFRURCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWVkIHNpemUnKTtcbiAgdmFyIHBrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMpO1xuICB2YXIgc2sgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykgc2tbaV0gPSBzZWVkW2ldO1xuICBjcnlwdG9fc2lnbl9rZXlwYWlyKHBrLCBzaywgdHJ1ZSk7XG4gIHJldHVybiB7cHVibGljS2V5OiBwaywgc2VjcmV0S2V5OiBza307XG59O1xuXG5uYWNsLnNpZ24ucHVibGljS2V5TGVuZ3RoID0gY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVM7XG5uYWNsLnNpZ24uc2VjcmV0S2V5TGVuZ3RoID0gY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVM7XG5uYWNsLnNpZ24uc2VlZExlbmd0aCA9IGNyeXB0b19zaWduX1NFRURCWVRFUztcbm5hY2wuc2lnbi5zaWduYXR1cmVMZW5ndGggPSBjcnlwdG9fc2lnbl9CWVRFUztcblxubmFjbC5oYXNoID0gZnVuY3Rpb24obXNnKSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhtc2cpO1xuICB2YXIgaCA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19oYXNoX0JZVEVTKTtcbiAgY3J5cHRvX2hhc2goaCwgbXNnLCBtc2cubGVuZ3RoKTtcbiAgcmV0dXJuIGg7XG59O1xuXG5uYWNsLmhhc2guaGFzaExlbmd0aCA9IGNyeXB0b19oYXNoX0JZVEVTO1xuXG5uYWNsLnZlcmlmeSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKHgsIHkpO1xuICAvLyBaZXJvIGxlbmd0aCBhcmd1bWVudHMgYXJlIGNvbnNpZGVyZWQgbm90IGVxdWFsLlxuICBpZiAoeC5sZW5ndGggPT09IDAgfHwgeS5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcbiAgaWYgKHgubGVuZ3RoICE9PSB5Lmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gKHZuKHgsIDAsIHksIDAsIHgubGVuZ3RoKSA9PT0gMCkgPyB0cnVlIDogZmFsc2U7XG59O1xuXG5uYWNsLnNldFBSTkcgPSBmdW5jdGlvbihmbikge1xuICByYW5kb21ieXRlcyA9IGZuO1xufTtcblxuKGZ1bmN0aW9uKCkge1xuICAvLyBJbml0aWFsaXplIFBSTkcgaWYgZW52aXJvbm1lbnQgcHJvdmlkZXMgQ1NQUk5HLlxuICAvLyBJZiBub3QsIG1ldGhvZHMgY2FsbGluZyByYW5kb21ieXRlcyB3aWxsIHRocm93LlxuICB2YXIgY3J5cHRvID0gdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gKHNlbGYuY3J5cHRvIHx8IHNlbGYubXNDcnlwdG8pIDogbnVsbDtcbiAgaWYgKGNyeXB0byAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gQnJvd3NlcnMuXG4gICAgdmFyIFFVT1RBID0gNjU1MzY7XG4gICAgbmFjbC5zZXRQUk5HKGZ1bmN0aW9uKHgsIG4pIHtcbiAgICAgIHZhciBpLCB2ID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSArPSBRVU9UQSkge1xuICAgICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHYuc3ViYXJyYXkoaSwgaSArIE1hdGgubWluKG4gLSBpLCBRVU9UQSkpKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHhbaV0gPSB2W2ldO1xuICAgICAgY2xlYW51cCh2KTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBOb2RlLmpzLlxuICAgIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuICAgIGlmIChjcnlwdG8gJiYgY3J5cHRvLnJhbmRvbUJ5dGVzKSB7XG4gICAgICBuYWNsLnNldFBSTkcoZnVuY3Rpb24oeCwgbikge1xuICAgICAgICB2YXIgaSwgdiA9IGNyeXB0by5yYW5kb21CeXRlcyhuKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgeFtpXSA9IHZbaV07XG4gICAgICAgIGNsZWFudXAodik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn0pKCk7XG5cbn0pKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzID8gbW9kdWxlLmV4cG9ydHMgOiAoc2VsZi5uYWNsID0gc2VsZi5uYWNsIHx8IHt9KSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/eth-sig-util/node_modules/tweetnacl/nacl-fast.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/superstruct/dist/error.cjs":
/*!***************************************************************!*\
  !*** ../../node_modules/@metamask/superstruct/dist/error.cjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/**\n * A `StructFailure` represents a single specific failure in validation.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StructError = void 0;\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nclass StructError extends TypeError {\n    constructor(failure, failures) {\n        let cached;\n        const { message, explanation, ...rest } = failure;\n        const { path } = failure;\n        const cause = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;\n        super(explanation ?? cause);\n        if (explanation !== null && explanation !== undefined) {\n            this.cause = cause;\n        }\n        Object.assign(this, rest);\n        this.name = this.constructor.name;\n        this.failures = () => {\n            return (cached ?? (cached = [failure, ...failures()]));\n        };\n    }\n}\nexports.StructError = StructError;\n//# sourceMappingURL=error.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zdXBlcnN0cnVjdC9kaXN0L2Vycm9yLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQ0FBZ0M7QUFDaEQsZ0JBQWdCLE9BQU87QUFDdkIsZ0VBQWdFLGdCQUFnQixLQUFLLFFBQVE7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3N1cGVyc3RydWN0L2Rpc3QvZXJyb3IuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBBIGBTdHJ1Y3RGYWlsdXJlYCByZXByZXNlbnRzIGEgc2luZ2xlIHNwZWNpZmljIGZhaWx1cmUgaW4gdmFsaWRhdGlvbi5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdHJ1Y3RFcnJvciA9IHZvaWQgMDtcbi8qKlxuICogYFN0cnVjdEVycm9yYCBvYmplY3RzIGFyZSB0aHJvd24gKG9yIHJldHVybmVkKSB3aGVuIHZhbGlkYXRpb24gZmFpbHMuXG4gKlxuICogVmFsaWRhdGlvbiBsb2dpYyBpcyBkZXNpZ24gdG8gZXhpdCBlYXJseSBmb3IgbWF4aW11bSBwZXJmb3JtYW5jZS4gVGhlIGVycm9yXG4gKiByZXByZXNlbnRzIHRoZSBmaXJzdCBlcnJvciBlbmNvdW50ZXJlZCBkdXJpbmcgdmFsaWRhdGlvbi4gRm9yIG1vcmUgZGV0YWlsLFxuICogdGhlIGBlcnJvci5mYWlsdXJlc2AgcHJvcGVydHkgaXMgYSBnZW5lcmF0b3IgZnVuY3Rpb24gdGhhdCBjYW4gYmUgcnVuIHRvXG4gKiBjb250aW51ZSB2YWxpZGF0aW9uIGFuZCByZWNlaXZlIGFsbCB0aGUgZmFpbHVyZXMgaW4gdGhlIGRhdGEuXG4gKi9cbmNsYXNzIFN0cnVjdEVycm9yIGV4dGVuZHMgVHlwZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihmYWlsdXJlLCBmYWlsdXJlcykge1xuICAgICAgICBsZXQgY2FjaGVkO1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2UsIGV4cGxhbmF0aW9uLCAuLi5yZXN0IH0gPSBmYWlsdXJlO1xuICAgICAgICBjb25zdCB7IHBhdGggfSA9IGZhaWx1cmU7XG4gICAgICAgIGNvbnN0IGNhdXNlID0gcGF0aC5sZW5ndGggPT09IDAgPyBtZXNzYWdlIDogYEF0IHBhdGg6ICR7cGF0aC5qb2luKCcuJyl9IC0tICR7bWVzc2FnZX1gO1xuICAgICAgICBzdXBlcihleHBsYW5hdGlvbiA/PyBjYXVzZSk7XG4gICAgICAgIGlmIChleHBsYW5hdGlvbiAhPT0gbnVsbCAmJiBleHBsYW5hdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCByZXN0KTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICB0aGlzLmZhaWx1cmVzID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChjYWNoZWQgPz8gKGNhY2hlZCA9IFtmYWlsdXJlLCAuLi5mYWlsdXJlcygpXSkpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuU3RydWN0RXJyb3IgPSBTdHJ1Y3RFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yLmNqcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/superstruct/dist/error.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/superstruct/dist/index.cjs":
/*!***************************************************************!*\
  !*** ../../node_modules/@metamask/superstruct/dist/index.cjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./error.cjs */ \"(rsc)/../../node_modules/@metamask/superstruct/dist/error.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./struct.cjs */ \"(rsc)/../../node_modules/@metamask/superstruct/dist/struct.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./structs/coercions.cjs */ \"(rsc)/../../node_modules/@metamask/superstruct/dist/structs/coercions.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./structs/refinements.cjs */ \"(rsc)/../../node_modules/@metamask/superstruct/dist/structs/refinements.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./structs/types.cjs */ \"(rsc)/../../node_modules/@metamask/superstruct/dist/structs/types.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./structs/utilities.cjs */ \"(rsc)/../../node_modules/@metamask/superstruct/dist/structs/utilities.cjs\"), exports);\n//# sourceMappingURL=index.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zdXBlcnN0cnVjdC9kaXN0L2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsa0ZBQWE7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLG9GQUFjO0FBQ25DLGFBQWEsbUJBQU8sQ0FBQywwR0FBeUI7QUFDOUMsYUFBYSxtQkFBTyxDQUFDLDhHQUEyQjtBQUNoRCxhQUFhLG1CQUFPLENBQUMsa0dBQXFCO0FBQzFDLGFBQWEsbUJBQU8sQ0FBQywwR0FBeUI7QUFDOUMiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zdXBlcnN0cnVjdC9kaXN0L2luZGV4LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Vycm9yLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3RydWN0LmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3RydWN0cy9jb2VyY2lvbnMuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zdHJ1Y3RzL3JlZmluZW1lbnRzLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3RydWN0cy90eXBlcy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3N0cnVjdHMvdXRpbGl0aWVzLmNqc1wiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5janMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/superstruct/dist/index.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/superstruct/dist/struct.cjs":
/*!****************************************************************!*\
  !*** ../../node_modules/@metamask/superstruct/dist/struct.cjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validate = exports.is = exports.mask = exports.create = exports.assert = exports.ExactOptionalStruct = exports.Struct = void 0;\nconst error_js_1 = __webpack_require__(/*! ./error.cjs */ \"(rsc)/../../node_modules/@metamask/superstruct/dist/error.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.cjs */ \"(rsc)/../../node_modules/@metamask/superstruct/dist/utils.cjs\");\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\nclass Struct {\n    constructor(props) {\n        const { type, schema, validator, refiner, coercer = (value) => value, entries = function* () {\n            /* noop */\n        }, } = props;\n        this.type = type;\n        this.schema = schema;\n        this.entries = entries;\n        this.coercer = coercer;\n        if (validator) {\n            this.validator = (value, context) => {\n                const result = validator(value, context);\n                return (0, utils_js_1.toFailures)(result, context, this, value);\n            };\n        }\n        else {\n            this.validator = () => [];\n        }\n        if (refiner) {\n            this.refiner = (value, context) => {\n                const result = refiner(value, context);\n                return (0, utils_js_1.toFailures)(result, context, this, value);\n            };\n        }\n        else {\n            this.refiner = () => [];\n        }\n    }\n    /**\n     * Assert that a value passes the struct's validation, throwing if it doesn't.\n     */\n    assert(value, message) {\n        return assert(value, this, message);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */\n    create(value, message) {\n        return create(value, this, message);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */\n    is(value) {\n        return is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema.\n     */\n    mask(value, message) {\n        return mask(value, this, message);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `withCoercion` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful.\n     */\n    validate(value, options = {}) {\n        return validate(value, this, options);\n    }\n}\nexports.Struct = Struct;\n// String instead of a Symbol in case of multiple different versions of this library.\nconst ExactOptionalBrand = 'EXACT_OPTIONAL';\n/**\n * An `ExactOptionalStruct` is a `Struct` that is used to create exactly optional\n * properties of `object()` structs.\n */\nclass ExactOptionalStruct extends Struct {\n    constructor(props) {\n        super({\n            ...props,\n            type: `exact optional ${props.type}`,\n        });\n        this.brand = ExactOptionalBrand;\n    }\n    static isExactOptional(value) {\n        return ((0, utils_js_1.isObject)(value) && 'brand' in value && value.brand === ExactOptionalBrand);\n    }\n}\nexports.ExactOptionalStruct = ExactOptionalStruct;\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param message - An optional message to include in the error.\n */\nfunction assert(value, struct, message) {\n    const result = validate(value, struct, { message });\n    if (result[0]) {\n        throw result[0];\n    }\n}\nexports.assert = assert;\n/**\n * Create a value with the coercion logic of struct and validate it.\n *\n * @param value - The value to coerce and validate.\n * @param struct - The struct to validate against.\n * @param message - An optional message to include in the error.\n * @returns The coerced and validated value.\n */\nfunction create(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\nexports.create = create;\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n *\n * @param value - The value to mask.\n * @param struct - The struct to mask against.\n * @param message - An optional message to include in the error.\n * @returns The masked value.\n */\nfunction mask(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, mask: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\nexports.mask = mask;\n/**\n * Check if a value passes a struct.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @returns `true` if the value passes the struct, `false` otherwise.\n */\nfunction is(value, struct) {\n    const result = validate(value, struct);\n    return !result[0];\n}\nexports.is = is;\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param options - Optional settings.\n * @param options.coerce - Whether to coerce the value before validating it.\n * @param options.mask - Whether to mask the value before validating it.\n * @param options.message - An optional message to include in the error.\n * @returns A tuple containing the error (if invalid) and the validated value.\n */\nfunction validate(value, struct, options = {}) {\n    const tuples = (0, utils_js_1.run)(value, struct, options);\n    const tuple = (0, utils_js_1.shiftIterator)(tuples);\n    if (tuple[0]) {\n        const error = new error_js_1.StructError(tuple[0], function* () {\n            for (const innerTuple of tuples) {\n                if (innerTuple[0]) {\n                    yield innerTuple[0];\n                }\n            }\n        });\n        return [error, undefined];\n    }\n    const validatedValue = tuple[1];\n    return [undefined, validatedValue];\n}\nexports.validate = validate;\n//# sourceMappingURL=struct.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zdXBlcnN0cnVjdC9kaXN0L3N0cnVjdC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLEdBQUcsVUFBVSxHQUFHLFlBQVksR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLDJCQUEyQixHQUFHLGNBQWM7QUFDN0gsbUJBQW1CLG1CQUFPLENBQUMsa0ZBQWE7QUFDeEMsbUJBQW1CLG1CQUFPLENBQUMsa0ZBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxXQUFXO0FBQy9DLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx1QkFBdUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG1DQUFtQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQiIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3N1cGVyc3RydWN0L2Rpc3Qvc3RydWN0LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGUgPSBleHBvcnRzLmlzID0gZXhwb3J0cy5tYXNrID0gZXhwb3J0cy5jcmVhdGUgPSBleHBvcnRzLmFzc2VydCA9IGV4cG9ydHMuRXhhY3RPcHRpb25hbFN0cnVjdCA9IGV4cG9ydHMuU3RydWN0ID0gdm9pZCAwO1xuY29uc3QgZXJyb3JfanNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yLmNqc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5janNcIik7XG4vKipcbiAqIGBTdHJ1Y3RgIG9iamVjdHMgZW5jYXBzdWxhdGUgdGhlIHZhbGlkYXRpb24gbG9naWMgZm9yIGEgc3BlY2lmaWMgdHlwZSBvZlxuICogdmFsdWVzLiBPbmNlIGNvbnN0cnVjdGVkLCB5b3UgdXNlIHRoZSBgYXNzZXJ0YCwgYGlzYCBvciBgdmFsaWRhdGVgIGhlbHBlcnMgdG9cbiAqIHZhbGlkYXRlIHVua25vd24gaW5wdXQgZGF0YSBhZ2FpbnN0IHRoZSBzdHJ1Y3QuXG4gKi9cbmNsYXNzIFN0cnVjdCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgY29uc3QgeyB0eXBlLCBzY2hlbWEsIHZhbGlkYXRvciwgcmVmaW5lciwgY29lcmNlciA9ICh2YWx1ZSkgPT4gdmFsdWUsIGVudHJpZXMgPSBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLyogbm9vcCAqL1xuICAgICAgICB9LCB9ID0gcHJvcHM7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xuICAgICAgICB0aGlzLmNvZXJjZXIgPSBjb2VyY2VyO1xuICAgICAgICBpZiAodmFsaWRhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRvciA9ICh2YWx1ZSwgY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRvcih2YWx1ZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc19qc18xLnRvRmFpbHVyZXMpKHJlc3VsdCwgY29udGV4dCwgdGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdG9yID0gKCkgPT4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZmluZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVmaW5lciA9ICh2YWx1ZSwgY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlZmluZXIodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfanNfMS50b0ZhaWx1cmVzKShyZXN1bHQsIGNvbnRleHQsIHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlZmluZXIgPSAoKSA9PiBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlcnQgdGhhdCBhIHZhbHVlIHBhc3NlcyB0aGUgc3RydWN0J3MgdmFsaWRhdGlvbiwgdGhyb3dpbmcgaWYgaXQgZG9lc24ndC5cbiAgICAgKi9cbiAgICBhc3NlcnQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIGFzc2VydCh2YWx1ZSwgdGhpcywgbWVzc2FnZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHZhbHVlIHdpdGggdGhlIHN0cnVjdCdzIGNvZXJjaW9uIGxvZ2ljLCB0aGVuIHZhbGlkYXRlIGl0LlxuICAgICAqL1xuICAgIGNyZWF0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlKHZhbHVlLCB0aGlzLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB2YWx1ZSBwYXNzZXMgdGhlIHN0cnVjdCdzIHZhbGlkYXRpb24uXG4gICAgICovXG4gICAgaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzKHZhbHVlLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFzayBhIHZhbHVlLCBjb2VyY2luZyBhbmQgdmFsaWRhdGluZyBpdCwgYnV0IHJldHVybmluZyBvbmx5IHRoZSBzdWJzZXQgb2ZcbiAgICAgKiBwcm9wZXJ0aWVzIGRlZmluZWQgYnkgdGhlIHN0cnVjdCdzIHNjaGVtYS5cbiAgICAgKi9cbiAgICBtYXNrKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBtYXNrKHZhbHVlLCB0aGlzLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgYSB2YWx1ZSB3aXRoIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uIGxvZ2ljLCByZXR1cm5pbmcgYSB0dXBsZVxuICAgICAqIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LlxuICAgICAqXG4gICAgICogWW91IG1heSBvcHRpb25hbGx5IHBhc3MgYHRydWVgIGZvciB0aGUgYHdpdGhDb2VyY2lvbmAgYXJndW1lbnQgdG8gY29lcmNlXG4gICAgICogdGhlIHZhbHVlIGJlZm9yZSBhdHRlbXB0aW5nIHRvIHZhbGlkYXRlIGl0LiBJZiB5b3UgZG8sIHRoZSByZXN1bHQgd2lsbFxuICAgICAqIGNvbnRhaW4gdGhlIGNvZXJjZWQgcmVzdWx0IHdoZW4gc3VjY2Vzc2Z1bC5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZSh2YWx1ZSwgdGhpcywgb3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5TdHJ1Y3QgPSBTdHJ1Y3Q7XG4vLyBTdHJpbmcgaW5zdGVhZCBvZiBhIFN5bWJvbCBpbiBjYXNlIG9mIG11bHRpcGxlIGRpZmZlcmVudCB2ZXJzaW9ucyBvZiB0aGlzIGxpYnJhcnkuXG5jb25zdCBFeGFjdE9wdGlvbmFsQnJhbmQgPSAnRVhBQ1RfT1BUSU9OQUwnO1xuLyoqXG4gKiBBbiBgRXhhY3RPcHRpb25hbFN0cnVjdGAgaXMgYSBgU3RydWN0YCB0aGF0IGlzIHVzZWQgdG8gY3JlYXRlIGV4YWN0bHkgb3B0aW9uYWxcbiAqIHByb3BlcnRpZXMgb2YgYG9iamVjdCgpYCBzdHJ1Y3RzLlxuICovXG5jbGFzcyBFeGFjdE9wdGlvbmFsU3RydWN0IGV4dGVuZHMgU3RydWN0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgICAgIHR5cGU6IGBleGFjdCBvcHRpb25hbCAke3Byb3BzLnR5cGV9YCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYnJhbmQgPSBFeGFjdE9wdGlvbmFsQnJhbmQ7XG4gICAgfVxuICAgIHN0YXRpYyBpc0V4YWN0T3B0aW9uYWwodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICgoMCwgdXRpbHNfanNfMS5pc09iamVjdCkodmFsdWUpICYmICdicmFuZCcgaW4gdmFsdWUgJiYgdmFsdWUuYnJhbmQgPT09IEV4YWN0T3B0aW9uYWxCcmFuZCk7XG4gICAgfVxufVxuZXhwb3J0cy5FeGFjdE9wdGlvbmFsU3RydWN0ID0gRXhhY3RPcHRpb25hbFN0cnVjdDtcbi8qKlxuICogQXNzZXJ0IHRoYXQgYSB2YWx1ZSBwYXNzZXMgYSBzdHJ1Y3QsIHRocm93aW5nIGlmIGl0IGRvZXNuJ3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHZhbGlkYXRlLlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgdG8gdmFsaWRhdGUgYWdhaW5zdC5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gQW4gb3B0aW9uYWwgbWVzc2FnZSB0byBpbmNsdWRlIGluIHRoZSBlcnJvci5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KHZhbHVlLCBzdHJ1Y3QsIG1lc3NhZ2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0LCB7IG1lc3NhZ2UgfSk7XG4gICAgaWYgKHJlc3VsdFswXSkge1xuICAgICAgICB0aHJvdyByZXN1bHRbMF07XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG4vKipcbiAqIENyZWF0ZSBhIHZhbHVlIHdpdGggdGhlIGNvZXJjaW9uIGxvZ2ljIG9mIHN0cnVjdCBhbmQgdmFsaWRhdGUgaXQuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvZXJjZSBhbmQgdmFsaWRhdGUuXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byB2YWxpZGF0ZSBhZ2FpbnN0LlxuICogQHBhcmFtIG1lc3NhZ2UgLSBBbiBvcHRpb25hbCBtZXNzYWdlIHRvIGluY2x1ZGUgaW4gdGhlIGVycm9yLlxuICogQHJldHVybnMgVGhlIGNvZXJjZWQgYW5kIHZhbGlkYXRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlKHZhbHVlLCBzdHJ1Y3QsIG1lc3NhZ2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0LCB7IGNvZXJjZTogdHJ1ZSwgbWVzc2FnZSB9KTtcbiAgICBpZiAocmVzdWx0WzBdKSB7XG4gICAgICAgIHRocm93IHJlc3VsdFswXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHRbMV07XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG4vKipcbiAqIE1hc2sgYSB2YWx1ZSwgcmV0dXJuaW5nIG9ubHkgdGhlIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGRlZmluZWQgYnkgYSBzdHJ1Y3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIG1hc2suXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byBtYXNrIGFnYWluc3QuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIEFuIG9wdGlvbmFsIG1lc3NhZ2UgdG8gaW5jbHVkZSBpbiB0aGUgZXJyb3IuXG4gKiBAcmV0dXJucyBUaGUgbWFza2VkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXNrKHZhbHVlLCBzdHJ1Y3QsIG1lc3NhZ2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0LCB7IGNvZXJjZTogdHJ1ZSwgbWFzazogdHJ1ZSwgbWVzc2FnZSB9KTtcbiAgICBpZiAocmVzdWx0WzBdKSB7XG4gICAgICAgIHRocm93IHJlc3VsdFswXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHRbMV07XG4gICAgfVxufVxuZXhwb3J0cy5tYXNrID0gbWFzaztcbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBwYXNzZXMgYSBzdHJ1Y3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHZhbGlkYXRlLlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgdG8gdmFsaWRhdGUgYWdhaW5zdC5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgcGFzc2VzIHRoZSBzdHJ1Y3QsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpcyh2YWx1ZSwgc3RydWN0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCk7XG4gICAgcmV0dXJuICFyZXN1bHRbMF07XG59XG5leHBvcnRzLmlzID0gaXM7XG4vKipcbiAqIFZhbGlkYXRlIGEgdmFsdWUgYWdhaW5zdCBhIHN0cnVjdCwgcmV0dXJuaW5nIGFuIGVycm9yIGlmIGludmFsaWQsIG9yIHRoZVxuICogdmFsdWUgKHdpdGggcG90ZW50aWFsIGNvZXJjaW9uKSBpZiB2YWxpZC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdmFsaWRhdGUuXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byB2YWxpZGF0ZSBhZ2FpbnN0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBzZXR0aW5ncy5cbiAqIEBwYXJhbSBvcHRpb25zLmNvZXJjZSAtIFdoZXRoZXIgdG8gY29lcmNlIHRoZSB2YWx1ZSBiZWZvcmUgdmFsaWRhdGluZyBpdC5cbiAqIEBwYXJhbSBvcHRpb25zLm1hc2sgLSBXaGV0aGVyIHRvIG1hc2sgdGhlIHZhbHVlIGJlZm9yZSB2YWxpZGF0aW5nIGl0LlxuICogQHBhcmFtIG9wdGlvbnMubWVzc2FnZSAtIEFuIG9wdGlvbmFsIG1lc3NhZ2UgdG8gaW5jbHVkZSBpbiB0aGUgZXJyb3IuXG4gKiBAcmV0dXJucyBBIHR1cGxlIGNvbnRhaW5pbmcgdGhlIGVycm9yIChpZiBpbnZhbGlkKSBhbmQgdGhlIHZhbGlkYXRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgdHVwbGVzID0gKDAsIHV0aWxzX2pzXzEucnVuKSh2YWx1ZSwgc3RydWN0LCBvcHRpb25zKTtcbiAgICBjb25zdCB0dXBsZSA9ICgwLCB1dGlsc19qc18xLnNoaWZ0SXRlcmF0b3IpKHR1cGxlcyk7XG4gICAgaWYgKHR1cGxlWzBdKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IGVycm9yX2pzXzEuU3RydWN0RXJyb3IodHVwbGVbMF0sIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlubmVyVHVwbGUgb2YgdHVwbGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyVHVwbGVbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgaW5uZXJUdXBsZVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW2Vycm9yLCB1bmRlZmluZWRdO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZGF0ZWRWYWx1ZSA9IHR1cGxlWzFdO1xuICAgIHJldHVybiBbdW5kZWZpbmVkLCB2YWxpZGF0ZWRWYWx1ZV07XG59XG5leHBvcnRzLnZhbGlkYXRlID0gdmFsaWRhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJ1Y3QuY2pzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/superstruct/dist/struct.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/superstruct/dist/structs/coercions.cjs":
/*!***************************************************************************!*\
  !*** ../../node_modules/@metamask/superstruct/dist/structs/coercions.cjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.trimmed = exports.defaulted = exports.coerce = void 0;\nconst struct_js_1 = __webpack_require__(/*! ../struct.cjs */ \"(rsc)/../../node_modules/@metamask/superstruct/dist/struct.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ../utils.cjs */ \"(rsc)/../../node_modules/@metamask/superstruct/dist/utils.cjs\");\nconst types_js_1 = __webpack_require__(/*! ./types.cjs */ \"(rsc)/../../node_modules/@metamask/superstruct/dist/structs/types.cjs\");\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validation—for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n *\n * @param struct - The struct to augment.\n * @param condition - A struct that the input must pass to be coerced.\n * @param coercer - A function that takes the input and returns the coerced\n * value.\n * @returns A new struct that will coerce its input before validating it.\n */\nfunction coerce(struct, condition, coercer) {\n    return new struct_js_1.Struct({\n        ...struct,\n        coercer: (value, ctx) => {\n            return (0, struct_js_1.is)(value, condition)\n                ? struct.coercer(coercer(value, ctx), ctx)\n                : struct.coercer(value, ctx);\n        },\n    });\n}\nexports.coerce = coerce;\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n *\n * @param struct - The struct to augment.\n * @param fallback - The value to use when the input is `undefined`.\n * @param options - An optional options object.\n * @param options.strict - When `true`, the fallback will only be used when the\n * input is `undefined`. When `false`, the fallback will be used when the input\n * is `undefined` or when the input is a plain object and the fallback is a\n * plain object, and any keys in the fallback are missing from the input.\n * @returns A new struct that will replace `undefined` inputs with a default.\n */\nfunction defaulted(struct, fallback, options = {}) {\n    return coerce(struct, (0, types_js_1.unknown)(), (value) => {\n        const result = typeof fallback === 'function' ? fallback() : fallback;\n        if (value === undefined) {\n            return result;\n        }\n        if (!options.strict && (0, utils_js_1.isPlainObject)(value) && (0, utils_js_1.isPlainObject)(result)) {\n            const ret = { ...value };\n            let changed = false;\n            for (const key in result) {\n                if (ret[key] === undefined) {\n                    ret[key] = result[key];\n                    changed = true;\n                }\n            }\n            if (changed) {\n                return ret;\n            }\n        }\n        return value;\n    });\n}\nexports.defaulted = defaulted;\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will trim string inputs before validating them.\n */\nfunction trimmed(struct) {\n    return coerce(struct, (0, types_js_1.string)(), (value) => value.trim());\n}\nexports.trimmed = trimmed;\n//# sourceMappingURL=coercions.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zdXBlcnN0cnVjdC9kaXN0L3N0cnVjdHMvY29lcmNpb25zLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLEdBQUcsaUJBQWlCLEdBQUcsY0FBYztBQUNwRCxvQkFBb0IsbUJBQU8sQ0FBQyxxRkFBZTtBQUMzQyxtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBYztBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQywwRkFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zdXBlcnN0cnVjdC9kaXN0L3N0cnVjdHMvY29lcmNpb25zLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudHJpbW1lZCA9IGV4cG9ydHMuZGVmYXVsdGVkID0gZXhwb3J0cy5jb2VyY2UgPSB2b2lkIDA7XG5jb25zdCBzdHJ1Y3RfanNfMSA9IHJlcXVpcmUoXCIuLi9zdHJ1Y3QuY2pzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy5janNcIik7XG5jb25zdCB0eXBlc19qc18xID0gcmVxdWlyZShcIi4vdHlwZXMuY2pzXCIpO1xuLyoqXG4gKiBBdWdtZW50IGEgYFN0cnVjdGAgdG8gYWRkIGFuIGFkZGl0aW9uYWwgY29lcmNpb24gc3RlcCB0byBpdHMgaW5wdXQuXG4gKlxuICogVGhpcyBhbGxvd3MgeW91IHRvIHRyYW5zZm9ybSBpbnB1dCBkYXRhIGJlZm9yZSB2YWxpZGF0aW5nIGl0LCB0byBpbmNyZWFzZSB0aGVcbiAqIGxpa2VsaWhvb2QgdGhhdCBpdCBwYXNzZXMgdmFsaWRhdGlvbuKAlGZvciBleGFtcGxlIGZvciBkZWZhdWx0IHZhbHVlcywgcGFyc2luZ1xuICogZGlmZmVyZW50IGZvcm1hdHMsIGV0Yy5cbiAqXG4gKiBOb3RlOiBZb3UgbXVzdCB1c2UgYGNyZWF0ZSh2YWx1ZSwgU3RydWN0KWAgb24gdGhlIHZhbHVlIHRvIGhhdmUgdGhlIGNvZXJjaW9uXG4gKiB0YWtlIGVmZmVjdCEgVXNpbmcgc2ltcGx5IGBhc3NlcnQoKWAgb3IgYGlzKClgIHdpbGwgbm90IHVzZSBjb2VyY2lvbi5cbiAqXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byBhdWdtZW50LlxuICogQHBhcmFtIGNvbmRpdGlvbiAtIEEgc3RydWN0IHRoYXQgdGhlIGlucHV0IG11c3QgcGFzcyB0byBiZSBjb2VyY2VkLlxuICogQHBhcmFtIGNvZXJjZXIgLSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIGlucHV0IGFuZCByZXR1cm5zIHRoZSBjb2VyY2VkXG4gKiB2YWx1ZS5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgY29lcmNlIGl0cyBpbnB1dCBiZWZvcmUgdmFsaWRhdGluZyBpdC5cbiAqL1xuZnVuY3Rpb24gY29lcmNlKHN0cnVjdCwgY29uZGl0aW9uLCBjb2VyY2VyKSB7XG4gICAgcmV0dXJuIG5ldyBzdHJ1Y3RfanNfMS5TdHJ1Y3Qoe1xuICAgICAgICAuLi5zdHJ1Y3QsXG4gICAgICAgIGNvZXJjZXI6ICh2YWx1ZSwgY3R4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHN0cnVjdF9qc18xLmlzKSh2YWx1ZSwgY29uZGl0aW9uKVxuICAgICAgICAgICAgICAgID8gc3RydWN0LmNvZXJjZXIoY29lcmNlcih2YWx1ZSwgY3R4KSwgY3R4KVxuICAgICAgICAgICAgICAgIDogc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byByZXBsYWNlIGB1bmRlZmluZWRgIHZhbHVlcyB3aXRoIGEgZGVmYXVsdC5cbiAqXG4gKiBOb3RlOiBZb3UgbXVzdCB1c2UgYGNyZWF0ZSh2YWx1ZSwgU3RydWN0KWAgb24gdGhlIHZhbHVlIHRvIGhhdmUgdGhlIGNvZXJjaW9uXG4gKiB0YWtlIGVmZmVjdCEgVXNpbmcgc2ltcGx5IGBhc3NlcnQoKWAgb3IgYGlzKClgIHdpbGwgbm90IHVzZSBjb2VyY2lvbi5cbiAqXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byBhdWdtZW50LlxuICogQHBhcmFtIGZhbGxiYWNrIC0gVGhlIHZhbHVlIHRvIHVzZSB3aGVuIHRoZSBpbnB1dCBpcyBgdW5kZWZpbmVkYC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0gb3B0aW9ucy5zdHJpY3QgLSBXaGVuIGB0cnVlYCwgdGhlIGZhbGxiYWNrIHdpbGwgb25seSBiZSB1c2VkIHdoZW4gdGhlXG4gKiBpbnB1dCBpcyBgdW5kZWZpbmVkYC4gV2hlbiBgZmFsc2VgLCB0aGUgZmFsbGJhY2sgd2lsbCBiZSB1c2VkIHdoZW4gdGhlIGlucHV0XG4gKiBpcyBgdW5kZWZpbmVkYCBvciB3aGVuIHRoZSBpbnB1dCBpcyBhIHBsYWluIG9iamVjdCBhbmQgdGhlIGZhbGxiYWNrIGlzIGFcbiAqIHBsYWluIG9iamVjdCwgYW5kIGFueSBrZXlzIGluIHRoZSBmYWxsYmFjayBhcmUgbWlzc2luZyBmcm9tIHRoZSBpbnB1dC5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgcmVwbGFjZSBgdW5kZWZpbmVkYCBpbnB1dHMgd2l0aCBhIGRlZmF1bHQuXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRlZChzdHJ1Y3QsIGZhbGxiYWNrLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gY29lcmNlKHN0cnVjdCwgKDAsIHR5cGVzX2pzXzEudW5rbm93bikoKSwgKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHR5cGVvZiBmYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGZhbGxiYWNrKCkgOiBmYWxsYmFjaztcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zLnN0cmljdCAmJiAoMCwgdXRpbHNfanNfMS5pc1BsYWluT2JqZWN0KSh2YWx1ZSkgJiYgKDAsIHV0aWxzX2pzXzEuaXNQbGFpbk9iamVjdCkocmVzdWx0KSkge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0geyAuLi52YWx1ZSB9O1xuICAgICAgICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXRba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldFtrZXldID0gcmVzdWx0W2tleV07XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG59XG5leHBvcnRzLmRlZmF1bHRlZCA9IGRlZmF1bHRlZDtcbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byB0cmltIHN0cmluZyBpbnB1dHMuXG4gKlxuICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICogdGFrZSBlZmZlY3QhIFVzaW5nIHNpbXBseSBgYXNzZXJ0KClgIG9yIGBpcygpYCB3aWxsIG5vdCB1c2UgY29lcmNpb24uXG4gKlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgdG8gYXVnbWVudC5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgdHJpbSBzdHJpbmcgaW5wdXRzIGJlZm9yZSB2YWxpZGF0aW5nIHRoZW0uXG4gKi9cbmZ1bmN0aW9uIHRyaW1tZWQoc3RydWN0KSB7XG4gICAgcmV0dXJuIGNvZXJjZShzdHJ1Y3QsICgwLCB0eXBlc19qc18xLnN0cmluZykoKSwgKHZhbHVlKSA9PiB2YWx1ZS50cmltKCkpO1xufVxuZXhwb3J0cy50cmltbWVkID0gdHJpbW1lZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZXJjaW9ucy5janMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/superstruct/dist/structs/coercions.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/superstruct/dist/structs/refinements.cjs":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@metamask/superstruct/dist/structs/refinements.cjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.refine = exports.size = exports.pattern = exports.nonempty = exports.min = exports.max = exports.empty = void 0;\nconst struct_js_1 = __webpack_require__(/*! ../struct.cjs */ \"(rsc)/../../node_modules/@metamask/superstruct/dist/struct.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ../utils.cjs */ \"(rsc)/../../node_modules/@metamask/superstruct/dist/utils.cjs\");\n/**\n * Ensure that a string, array, map, or set is empty.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will only accept empty values.\n */\nfunction empty(struct) {\n    return refine(struct, 'empty', (value) => {\n        // eslint-disable-next-line @typescript-eslint/no-shadow\n        const size = getSize(value);\n        return (size === 0 ||\n            `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``);\n    });\n}\nexports.empty = empty;\n/**\n * Get the size of a string, array, map, or set.\n *\n * @param value - The value to measure.\n * @returns The size of the value.\n */\nfunction getSize(value) {\n    if (value instanceof Map || value instanceof Set) {\n        return value.size;\n    }\n    return value.length;\n}\n/**\n * Ensure that a number or date is below a threshold.\n *\n * @param struct - The struct to augment.\n * @param threshold - The maximum value that the input can be.\n * @param options - An optional options object.\n * @param options.exclusive - When `true`, the input must be strictly less than\n * the threshold. When `false`, the input must be less than or equal to the\n * threshold.\n * @returns A new struct that will only accept values below the threshold.\n */\nfunction max(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'max', (value) => {\n        return exclusive\n            ? value < threshold\n            : value <= threshold ||\n                `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '\n                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                }${threshold} but received \\`${value}\\``;\n    });\n}\nexports.max = max;\n/**\n * Ensure that a number or date is above a threshold.\n *\n * @param struct - The struct to augment.\n * @param threshold - The minimum value that the input can be.\n * @param options - An optional options object.\n * @param options.exclusive - When `true`, the input must be strictly greater\n * than the threshold. When `false`, the input must be greater than or equal to\n * the threshold.\n * @returns A new struct that will only accept values above the threshold.\n */\nfunction min(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'min', (value) => {\n        return exclusive\n            ? value > threshold\n            : value >= threshold ||\n                `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '\n                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                }${threshold} but received \\`${value}\\``;\n    });\n}\nexports.min = min;\n/**\n * Ensure that a string, array, map or set is not empty.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will only accept non-empty values.\n */\nfunction nonempty(struct) {\n    return refine(struct, 'nonempty', (value) => {\n        // eslint-disable-next-line @typescript-eslint/no-shadow\n        const size = getSize(value);\n        return (size > 0 || `Expected a nonempty ${struct.type} but received an empty one`);\n    });\n}\nexports.nonempty = nonempty;\n/**\n * Ensure that a string matches a regular expression.\n *\n * @param struct - The struct to augment.\n * @param regexp - The regular expression to match against.\n * @returns A new struct that will only accept strings matching the regular\n * expression.\n */\nfunction pattern(struct, regexp) {\n    return refine(struct, 'pattern', (value) => {\n        return (regexp.test(value) ||\n            `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`);\n    });\n}\nexports.pattern = pattern;\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length,\n * or time) between `min` and `max`.\n *\n * @param struct - The struct to augment.\n * @param minimum - The minimum size that the input can be.\n * @param maximum - The maximum size that the input can be.\n * @returns A new struct that will only accept values within the given size\n * range.\n */\nfunction size(struct, minimum, maximum = minimum) {\n    const expected = `Expected a ${struct.type}`;\n    const of = minimum === maximum\n        ? `of \\`${minimum}\\``\n        : `between \\`${minimum}\\` and \\`${maximum}\\``;\n    return refine(struct, 'size', (value) => {\n        if (typeof value === 'number' || value instanceof Date) {\n            return ((minimum <= value && value <= maximum) ||\n                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                `${expected} ${of} but received \\`${value}\\``);\n        }\n        else if (value instanceof Map || value instanceof Set) {\n            // eslint-disable-next-line @typescript-eslint/no-shadow\n            const { size } = value;\n            return ((minimum <= size && size <= maximum) ||\n                `${expected} with a size ${of} but received one with a size of \\`${size}\\``);\n        }\n        const { length } = value;\n        return ((minimum <= length && length <= maximum) ||\n            `${expected} with a length ${of} but received one with a length of \\`${length}\\``);\n    });\n}\nexports.size = size;\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n *\n * @param struct - The struct to augment.\n * @param name - The name of the refinement.\n * @param refiner - The refiner function.\n * @returns A new struct that will run the refiner function after the existing\n * validation.\n */\nfunction refine(struct, name, refiner) {\n    return new struct_js_1.Struct({\n        ...struct,\n        *refiner(value, ctx) {\n            yield* struct.refiner(value, ctx);\n            const result = refiner(value, ctx);\n            const failures = (0, utils_js_1.toFailures)(result, ctx, struct, value);\n            for (const failure of failures) {\n                yield { ...failure, refinement: name };\n            }\n        },\n    });\n}\nexports.refine = refine;\n//# sourceMappingURL=refinements.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zdXBlcnN0cnVjdC9kaXN0L3N0cnVjdHMvcmVmaW5lbWVudHMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxZQUFZLEdBQUcsZUFBZSxHQUFHLGdCQUFnQixHQUFHLFdBQVcsR0FBRyxXQUFXLEdBQUcsYUFBYTtBQUM5RyxvQkFBb0IsbUJBQU8sQ0FBQyxxRkFBZTtBQUMzQyxtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGFBQWEsb0NBQW9DLEtBQUs7QUFDdkYsS0FBSztBQUNMO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGFBQWEsWUFBWTtBQUN2RDtBQUNBLGlCQUFpQixFQUFFLFdBQVcsaUJBQWlCLE1BQU07QUFDckQsS0FBSztBQUNMO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGFBQWEsZUFBZTtBQUMxRDtBQUNBLGlCQUFpQixFQUFFLFdBQVcsaUJBQWlCLE1BQU07QUFDckQsS0FBSztBQUNMO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGFBQWE7QUFDaEUsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsYUFBYSxjQUFjLGNBQWMsb0JBQW9CLE1BQU07QUFDN0YsS0FBSztBQUNMO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBLGtCQUFrQixRQUFRO0FBQzFCLHVCQUF1QixRQUFRLFdBQVcsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVLEVBQUUsSUFBSSxpQkFBaUIsTUFBTTtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLG1CQUFtQixVQUFVLGNBQWMsSUFBSSxvQ0FBb0MsS0FBSztBQUN4RjtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0EsZUFBZSxVQUFVLGdCQUFnQixJQUFJLHNDQUFzQyxPQUFPO0FBQzFGLEtBQUs7QUFDTDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc3VwZXJzdHJ1Y3QvZGlzdC9zdHJ1Y3RzL3JlZmluZW1lbnRzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVmaW5lID0gZXhwb3J0cy5zaXplID0gZXhwb3J0cy5wYXR0ZXJuID0gZXhwb3J0cy5ub25lbXB0eSA9IGV4cG9ydHMubWluID0gZXhwb3J0cy5tYXggPSBleHBvcnRzLmVtcHR5ID0gdm9pZCAwO1xuY29uc3Qgc3RydWN0X2pzXzEgPSByZXF1aXJlKFwiLi4vc3RydWN0LmNqc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMuY2pzXCIpO1xuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHN0cmluZywgYXJyYXksIG1hcCwgb3Igc2V0IGlzIGVtcHR5LlxuICpcbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RydWN0IHRvIGF1Z21lbnQuXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IGVtcHR5IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZW1wdHkoc3RydWN0KSB7XG4gICAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdlbXB0eScsICh2YWx1ZSkgPT4ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xuICAgICAgICBjb25zdCBzaXplID0gZ2V0U2l6ZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiAoc2l6ZSA9PT0gMCB8fFxuICAgICAgICAgICAgYEV4cGVjdGVkIGFuIGVtcHR5ICR7c3RydWN0LnR5cGV9IGJ1dCByZWNlaXZlZCBvbmUgd2l0aCBhIHNpemUgb2YgXFxgJHtzaXplfVxcYGApO1xuICAgIH0pO1xufVxuZXhwb3J0cy5lbXB0eSA9IGVtcHR5O1xuLyoqXG4gKiBHZXQgdGhlIHNpemUgb2YgYSBzdHJpbmcsIGFycmF5LCBtYXAsIG9yIHNldC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gbWVhc3VyZS5cbiAqIEByZXR1cm5zIFRoZSBzaXplIG9mIHRoZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0U2l6ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCB8fCB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICByZXR1cm4gdmFsdWUuc2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLmxlbmd0aDtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBudW1iZXIgb3IgZGF0ZSBpcyBiZWxvdyBhIHRocmVzaG9sZC5cbiAqXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byBhdWdtZW50LlxuICogQHBhcmFtIHRocmVzaG9sZCAtIFRoZSBtYXhpbXVtIHZhbHVlIHRoYXQgdGhlIGlucHV0IGNhbiBiZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0gb3B0aW9ucy5leGNsdXNpdmUgLSBXaGVuIGB0cnVlYCwgdGhlIGlucHV0IG11c3QgYmUgc3RyaWN0bHkgbGVzcyB0aGFuXG4gKiB0aGUgdGhyZXNob2xkLiBXaGVuIGBmYWxzZWAsIHRoZSBpbnB1dCBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGVcbiAqIHRocmVzaG9sZC5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgdmFsdWVzIGJlbG93IHRoZSB0aHJlc2hvbGQuXG4gKi9cbmZ1bmN0aW9uIG1heChzdHJ1Y3QsIHRocmVzaG9sZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBleGNsdXNpdmUgfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdtYXgnLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIGV4Y2x1c2l2ZVxuICAgICAgICAgICAgPyB2YWx1ZSA8IHRocmVzaG9sZFxuICAgICAgICAgICAgOiB2YWx1ZSA8PSB0aHJlc2hvbGQgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYSAke3N0cnVjdC50eXBlfSBsZXNzIHRoYW4gJHtleGNsdXNpdmUgPyAnJyA6ICdvciBlcXVhbCB0byAnXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9uc1xuICAgICAgICAgICAgICAgIH0ke3RocmVzaG9sZH0gYnV0IHJlY2VpdmVkIFxcYCR7dmFsdWV9XFxgYDtcbiAgICB9KTtcbn1cbmV4cG9ydHMubWF4ID0gbWF4O1xuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIG51bWJlciBvciBkYXRlIGlzIGFib3ZlIGEgdGhyZXNob2xkLlxuICpcbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RydWN0IHRvIGF1Z21lbnQuXG4gKiBAcGFyYW0gdGhyZXNob2xkIC0gVGhlIG1pbmltdW0gdmFsdWUgdGhhdCB0aGUgaW5wdXQgY2FuIGJlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSBvcHRpb25zLmV4Y2x1c2l2ZSAtIFdoZW4gYHRydWVgLCB0aGUgaW5wdXQgbXVzdCBiZSBzdHJpY3RseSBncmVhdGVyXG4gKiB0aGFuIHRoZSB0aHJlc2hvbGQuIFdoZW4gYGZhbHNlYCwgdGhlIGlucHV0IG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvXG4gKiB0aGUgdGhyZXNob2xkLlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHRoYXQgd2lsbCBvbmx5IGFjY2VwdCB2YWx1ZXMgYWJvdmUgdGhlIHRocmVzaG9sZC5cbiAqL1xuZnVuY3Rpb24gbWluKHN0cnVjdCwgdGhyZXNob2xkLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGV4Y2x1c2l2ZSB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ21pbicsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gZXhjbHVzaXZlXG4gICAgICAgICAgICA/IHZhbHVlID4gdGhyZXNob2xkXG4gICAgICAgICAgICA6IHZhbHVlID49IHRocmVzaG9sZCB8fFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhICR7c3RydWN0LnR5cGV9IGdyZWF0ZXIgdGhhbiAke2V4Y2x1c2l2ZSA/ICcnIDogJ29yIGVxdWFsIHRvICdcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXRlbXBsYXRlLWV4cHJlc3Npb25zXG4gICAgICAgICAgICAgICAgfSR7dGhyZXNob2xkfSBidXQgcmVjZWl2ZWQgXFxgJHt2YWx1ZX1cXGBgO1xuICAgIH0pO1xufVxuZXhwb3J0cy5taW4gPSBtaW47XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nLCBhcnJheSwgbWFwIG9yIHNldCBpcyBub3QgZW1wdHkuXG4gKlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgdG8gYXVnbWVudC5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgbm9uLWVtcHR5IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gbm9uZW1wdHkoc3RydWN0KSB7XG4gICAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdub25lbXB0eScsICh2YWx1ZSkgPT4ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xuICAgICAgICBjb25zdCBzaXplID0gZ2V0U2l6ZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiAoc2l6ZSA+IDAgfHwgYEV4cGVjdGVkIGEgbm9uZW1wdHkgJHtzdHJ1Y3QudHlwZX0gYnV0IHJlY2VpdmVkIGFuIGVtcHR5IG9uZWApO1xuICAgIH0pO1xufVxuZXhwb3J0cy5ub25lbXB0eSA9IG5vbmVtcHR5O1xuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHN0cmluZyBtYXRjaGVzIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RydWN0IHRvIGF1Z21lbnQuXG4gKiBAcGFyYW0gcmVnZXhwIC0gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCBhZ2FpbnN0LlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHRoYXQgd2lsbCBvbmx5IGFjY2VwdCBzdHJpbmdzIG1hdGNoaW5nIHRoZSByZWd1bGFyXG4gKiBleHByZXNzaW9uLlxuICovXG5mdW5jdGlvbiBwYXR0ZXJuKHN0cnVjdCwgcmVnZXhwKSB7XG4gICAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdwYXR0ZXJuJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiAocmVnZXhwLnRlc3QodmFsdWUpIHx8XG4gICAgICAgICAgICBgRXhwZWN0ZWQgYSAke3N0cnVjdC50eXBlfSBtYXRjaGluZyBcXGAvJHtyZWdleHAuc291cmNlfS9cXGAgYnV0IHJlY2VpdmVkIFwiJHt2YWx1ZX1cImApO1xuICAgIH0pO1xufVxuZXhwb3J0cy5wYXR0ZXJuID0gcGF0dGVybjtcbi8qKlxuICogRW5zdXJlIHRoYXQgYSBzdHJpbmcsIGFycmF5LCBudW1iZXIsIGRhdGUsIG1hcCwgb3Igc2V0IGhhcyBhIHNpemUgKG9yIGxlbmd0aCxcbiAqIG9yIHRpbWUpIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgLlxuICpcbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RydWN0IHRvIGF1Z21lbnQuXG4gKiBAcGFyYW0gbWluaW11bSAtIFRoZSBtaW5pbXVtIHNpemUgdGhhdCB0aGUgaW5wdXQgY2FuIGJlLlxuICogQHBhcmFtIG1heGltdW0gLSBUaGUgbWF4aW11bSBzaXplIHRoYXQgdGhlIGlucHV0IGNhbiBiZS5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgdmFsdWVzIHdpdGhpbiB0aGUgZ2l2ZW4gc2l6ZVxuICogcmFuZ2UuXG4gKi9cbmZ1bmN0aW9uIHNpemUoc3RydWN0LCBtaW5pbXVtLCBtYXhpbXVtID0gbWluaW11bSkge1xuICAgIGNvbnN0IGV4cGVjdGVkID0gYEV4cGVjdGVkIGEgJHtzdHJ1Y3QudHlwZX1gO1xuICAgIGNvbnN0IG9mID0gbWluaW11bSA9PT0gbWF4aW11bVxuICAgICAgICA/IGBvZiBcXGAke21pbmltdW19XFxgYFxuICAgICAgICA6IGBiZXR3ZWVuIFxcYCR7bWluaW11bX1cXGAgYW5kIFxcYCR7bWF4aW11bX1cXGBgO1xuICAgIHJldHVybiByZWZpbmUoc3RydWN0LCAnc2l6ZScsICh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiAoKG1pbmltdW0gPD0gdmFsdWUgJiYgdmFsdWUgPD0gbWF4aW11bSkgfHxcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXRlbXBsYXRlLWV4cHJlc3Npb25zXG4gICAgICAgICAgICAgICAgYCR7ZXhwZWN0ZWR9ICR7b2Z9IGJ1dCByZWNlaXZlZCBcXGAke3ZhbHVlfVxcYGApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xuICAgICAgICAgICAgY29uc3QgeyBzaXplIH0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiAoKG1pbmltdW0gPD0gc2l6ZSAmJiBzaXplIDw9IG1heGltdW0pIHx8XG4gICAgICAgICAgICAgICAgYCR7ZXhwZWN0ZWR9IHdpdGggYSBzaXplICR7b2Z9IGJ1dCByZWNlaXZlZCBvbmUgd2l0aCBhIHNpemUgb2YgXFxgJHtzaXplfVxcYGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuICgobWluaW11bSA8PSBsZW5ndGggJiYgbGVuZ3RoIDw9IG1heGltdW0pIHx8XG4gICAgICAgICAgICBgJHtleHBlY3RlZH0gd2l0aCBhIGxlbmd0aCAke29mfSBidXQgcmVjZWl2ZWQgb25lIHdpdGggYSBsZW5ndGggb2YgXFxgJHtsZW5ndGh9XFxgYCk7XG4gICAgfSk7XG59XG5leHBvcnRzLnNpemUgPSBzaXplO1xuLyoqXG4gKiBBdWdtZW50IGEgYFN0cnVjdGAgdG8gYWRkIGFuIGFkZGl0aW9uYWwgcmVmaW5lbWVudCB0byB0aGUgdmFsaWRhdGlvbi5cbiAqXG4gKiBUaGUgcmVmaW5lciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJlY2VpdmUgYSB2YWx1ZSBvZiB0aGUgc3RydWN0J3MgdHlwZSxcbiAqIGJlY2F1c2UgdGhlIHN0cnVjdCdzIGV4aXN0aW5nIHZhbGlkYXRpb24gd2lsbCBhbHJlYWR5IGhhdmUgcGFzc2VkLiBUaGlzXG4gKiBhbGxvd3MgeW91IHRvIGxheWVyIGFkZGl0aW9uYWwgdmFsaWRhdGlvbiBvbiB0b3Agb2YgZXhpc3Rpbmcgc3RydWN0cy5cbiAqXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byBhdWdtZW50LlxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcmVmaW5lbWVudC5cbiAqIEBwYXJhbSByZWZpbmVyIC0gVGhlIHJlZmluZXIgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIHJ1biB0aGUgcmVmaW5lciBmdW5jdGlvbiBhZnRlciB0aGUgZXhpc3RpbmdcbiAqIHZhbGlkYXRpb24uXG4gKi9cbmZ1bmN0aW9uIHJlZmluZShzdHJ1Y3QsIG5hbWUsIHJlZmluZXIpIHtcbiAgICByZXR1cm4gbmV3IHN0cnVjdF9qc18xLlN0cnVjdCh7XG4gICAgICAgIC4uLnN0cnVjdCxcbiAgICAgICAgKnJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgeWllbGQqIHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gKDAsIHV0aWxzX2pzXzEudG9GYWlsdXJlcykocmVzdWx0LCBjdHgsIHN0cnVjdCwgdmFsdWUpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmYWlsdXJlIG9mIGZhaWx1cmVzKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgeyAuLi5mYWlsdXJlLCByZWZpbmVtZW50OiBuYW1lIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnRzLnJlZmluZSA9IHJlZmluZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZmluZW1lbnRzLmNqcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/superstruct/dist/structs/refinements.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/superstruct/dist/structs/types.cjs":
/*!***********************************************************************!*\
  !*** ../../node_modules/@metamask/superstruct/dist/structs/types.cjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unknown = exports.union = exports.type = exports.tuple = exports.string = exports.set = exports.regexp = exports.record = exports.exactOptional = exports.optional = exports.object = exports.number = exports.nullable = exports.never = exports.map = exports.literal = exports.intersection = exports.integer = exports.instance = exports.func = exports.enums = exports.date = exports.boolean = exports.bigint = exports.array = exports.any = void 0;\nconst struct_js_1 = __webpack_require__(/*! ../struct.cjs */ \"(rsc)/../../node_modules/@metamask/superstruct/dist/struct.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ../utils.cjs */ \"(rsc)/../../node_modules/@metamask/superstruct/dist/utils.cjs\");\nconst utilities_js_1 = __webpack_require__(/*! ./utilities.cjs */ \"(rsc)/../../node_modules/@metamask/superstruct/dist/structs/utilities.cjs\");\n/**\n * Ensure that any value passes validation.\n *\n * @returns A struct that will always pass validation.\n */\nfunction any() {\n    return (0, utilities_js_1.define)('any', () => true);\n}\nexports.any = any;\n/**\n * Ensure that a value is an array and that its elements are of a specific type.\n *\n * Note: If you omit the element struct, the arrays elements will not be\n * iterated at all. This can be helpful for cases where performance is critical,\n * and it is preferred to using `array(any())`.\n *\n * @param Element - The struct to validate each element in the array against.\n * @returns A new struct that will only accept arrays of the given type.\n */\nfunction array(Element) {\n    return new struct_js_1.Struct({\n        type: 'array',\n        schema: Element,\n        *entries(value) {\n            if (Element && Array.isArray(value)) {\n                for (const [index, arrayValue] of value.entries()) {\n                    yield [index, arrayValue, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array value, but received: ${(0, utils_js_1.print)(value)}`);\n        },\n    });\n}\nexports.array = array;\n/**\n * Ensure that a value is a bigint.\n *\n * @returns A new struct that will only accept bigints.\n */\nfunction bigint() {\n    return (0, utilities_js_1.define)('bigint', (value) => {\n        return typeof value === 'bigint';\n    });\n}\nexports.bigint = bigint;\n/**\n * Ensure that a value is a boolean.\n *\n * @returns A new struct that will only accept booleans.\n */\nfunction boolean() {\n    return (0, utilities_js_1.define)('boolean', (value) => {\n        return typeof value === 'boolean';\n    });\n}\nexports.boolean = boolean;\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n *\n * @returns A new struct that will only accept valid `Date` objects.\n */\nfunction date() {\n    return (0, utilities_js_1.define)('date', (value) => {\n        return ((value instanceof Date && !isNaN(value.getTime())) ||\n            `Expected a valid \\`Date\\` object, but received: ${(0, utils_js_1.print)(value)}`);\n    });\n}\nexports.date = date;\n/**\n * Ensure that a value is one of a set of potential values.\n *\n * Note: after creating the struct, you can access the definition of the\n * potential values as `struct.schema`.\n *\n * @param values - The potential values that the input can be.\n * @returns A new struct that will only accept the given values.\n */\nfunction enums(values) {\n    const schema = {};\n    const description = values.map((value) => (0, utils_js_1.print)(value)).join();\n    for (const key of values) {\n        schema[key] = key;\n    }\n    return new struct_js_1.Struct({\n        type: 'enums',\n        schema,\n        validator(value) {\n            return (values.includes(value) ||\n                `Expected one of \\`${description}\\`, but received: ${(0, utils_js_1.print)(value)}`);\n        },\n    });\n}\nexports.enums = enums;\n/**\n * Ensure that a value is a function.\n *\n * @returns A new struct that will only accept functions.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction func() {\n    return (0, utilities_js_1.define)('func', (value) => {\n        return (typeof value === 'function' ||\n            `Expected a function, but received: ${(0, utils_js_1.print)(value)}`);\n    });\n}\nexports.func = func;\n/**\n * Ensure that a value is an instance of a specific class.\n *\n * @param Class - The class that the value must be an instance of.\n * @returns A new struct that will only accept instances of the given class.\n */\nfunction instance(Class) {\n    return (0, utilities_js_1.define)('instance', (value) => {\n        return (value instanceof Class ||\n            `Expected a \\`${Class.name}\\` instance, but received: ${(0, utils_js_1.print)(value)}`);\n    });\n}\nexports.instance = instance;\n/**\n * Ensure that a value is an integer.\n *\n * @returns A new struct that will only accept integers.\n */\nfunction integer() {\n    return (0, utilities_js_1.define)('integer', (value) => {\n        return ((typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||\n            `Expected an integer, but received: ${(0, utils_js_1.print)(value)}`);\n    });\n}\nexports.integer = integer;\n/**\n * Ensure that a value matches all of a set of types.\n *\n * @param Structs - The set of structs that the value must match.\n * @returns A new struct that will only accept values that match all of the\n * given structs.\n */\nfunction intersection(Structs) {\n    return new struct_js_1.Struct({\n        type: 'intersection',\n        schema: null,\n        *entries(value, context) {\n            for (const { entries } of Structs) {\n                yield* entries(value, context);\n            }\n        },\n        *validator(value, context) {\n            for (const { validator } of Structs) {\n                yield* validator(value, context);\n            }\n        },\n        *refiner(value, context) {\n            for (const { refiner } of Structs) {\n                yield* refiner(value, context);\n            }\n        },\n    });\n}\nexports.intersection = intersection;\n/**\n * Ensure that a value is an exact value, using `===` for comparison.\n *\n * @param constant - The exact value that the input must be.\n * @returns A new struct that will only accept the exact given value.\n */\nfunction literal(constant) {\n    const description = (0, utils_js_1.print)(constant);\n    const valueType = typeof constant;\n    return new struct_js_1.Struct({\n        type: 'literal',\n        schema: valueType === 'string' ||\n            valueType === 'number' ||\n            valueType === 'boolean'\n            ? constant\n            : null,\n        validator(value) {\n            return (value === constant ||\n                `Expected the literal \\`${description}\\`, but received: ${(0, utils_js_1.print)(value)}`);\n        },\n    });\n}\nexports.literal = literal;\n/**\n * Ensure that a value is a `Map` object, and that its keys and values are of\n * specific types.\n *\n * @param Key - The struct to validate each key in the map against.\n * @param Value - The struct to validate each value in the map against.\n * @returns A new struct that will only accept `Map` objects.\n */\nfunction map(Key, Value) {\n    return new struct_js_1.Struct({\n        type: 'map',\n        schema: null,\n        *entries(value) {\n            if (Key && Value && value instanceof Map) {\n                for (const [mapKey, mapValue] of value.entries()) {\n                    yield [mapKey, mapKey, Key];\n                    yield [mapKey, mapValue, Value];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Map ? new Map(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Map ||\n                `Expected a \\`Map\\` object, but received: ${(0, utils_js_1.print)(value)}`);\n        },\n    });\n}\nexports.map = map;\n/**\n * Ensure that no value ever passes validation.\n *\n * @returns A new struct that will never pass validation.\n */\nfunction never() {\n    return (0, utilities_js_1.define)('never', () => false);\n}\nexports.never = never;\n/**\n * Augment an existing struct to allow `null` values.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will accept `null` values.\n */\nfunction nullable(struct) {\n    return new struct_js_1.Struct({\n        ...struct,\n        validator: (value, ctx) => value === null || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === null || struct.refiner(value, ctx),\n    });\n}\nexports.nullable = nullable;\n/**\n * Ensure that a value is a number.\n *\n * @returns A new struct that will only accept numbers.\n */\nfunction number() {\n    return (0, utilities_js_1.define)('number', (value) => {\n        return ((typeof value === 'number' && !isNaN(value)) ||\n            `Expected a number, but received: ${(0, utils_js_1.print)(value)}`);\n    });\n}\nexports.number = number;\n/**\n * Ensure that a value is an object, that it has a known set of properties,\n * and that its properties are of specific types.\n *\n * Note: Unrecognized properties will fail validation.\n *\n * @param schema - An object that defines the structure of the object.\n * @returns A new struct that will only accept objects.\n */\nfunction object(schema) {\n    const knowns = schema ? Object.keys(schema) : [];\n    const Never = never();\n    return new struct_js_1.Struct({\n        type: 'object',\n        schema: schema ?? null,\n        *entries(value) {\n            if (schema && (0, utils_js_1.isObject)(value)) {\n                const unknowns = new Set(Object.keys(value));\n                for (const key of knowns) {\n                    unknowns.delete(key);\n                    const propertySchema = schema[key];\n                    if (struct_js_1.ExactOptionalStruct.isExactOptional(propertySchema) &&\n                        !Object.prototype.hasOwnProperty.call(value, key)) {\n                        continue;\n                    }\n                    yield [key, value[key], schema[key]];\n                }\n                for (const key of unknowns) {\n                    yield [key, value[key], Never];\n                }\n            }\n        },\n        validator(value) {\n            return ((0, utils_js_1.isObject)(value) || `Expected an object, but received: ${(0, utils_js_1.print)(value)}`);\n        },\n        coercer(value) {\n            return (0, utils_js_1.isObject)(value) ? { ...value } : value;\n        },\n    });\n}\nexports.object = object;\n/**\n * Augment a struct to allow `undefined` values.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will accept `undefined` values.\n */\nfunction optional(struct) {\n    return new struct_js_1.Struct({\n        ...struct,\n        validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n    });\n}\nexports.optional = optional;\n/**\n * Augment a struct such that, if it is the property of an object, it is exactly optional.\n * In other words, it is either present with the correct type, or not present at all.\n *\n * NOTE: Only intended for use with `object()` structs.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that can be used to create exactly optional properties of `object()`\n * structs.\n */\nfunction exactOptional(struct) {\n    return new struct_js_1.ExactOptionalStruct(struct);\n}\nexports.exactOptional = exactOptional;\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * @param Key - The struct to validate each key in the record against.\n * @param Value - The struct to validate each value in the record against.\n * @returns A new struct that will only accept objects.\n */\nfunction record(Key, Value) {\n    return new struct_js_1.Struct({\n        type: 'record',\n        schema: null,\n        *entries(value) {\n            if ((0, utils_js_1.isObject)(value)) {\n                // eslint-disable-next-line guard-for-in\n                for (const objectKey in value) {\n                    const objectValue = value[objectKey];\n                    yield [objectKey, objectKey, Key];\n                    yield [objectKey, objectValue, Value];\n                }\n            }\n        },\n        validator(value) {\n            return ((0, utils_js_1.isObject)(value) || `Expected an object, but received: ${(0, utils_js_1.print)(value)}`);\n        },\n    });\n}\nexports.record = record;\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n *\n * @returns A new struct that will only accept `RegExp` objects.\n */\nfunction regexp() {\n    return (0, utilities_js_1.define)('regexp', (value) => {\n        return value instanceof RegExp;\n    });\n}\nexports.regexp = regexp;\n/**\n * Ensure that a value is a `Set` object, and that its elements are of a\n * specific type.\n *\n * @param Element - The struct to validate each element in the set against.\n * @returns A new struct that will only accept `Set` objects.\n */\nfunction set(Element) {\n    return new struct_js_1.Struct({\n        type: 'set',\n        schema: null,\n        *entries(value) {\n            if (Element && value instanceof Set) {\n                for (const setValue of value) {\n                    yield [setValue, setValue, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Set ? new Set(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Set ||\n                `Expected a \\`Set\\` object, but received: ${(0, utils_js_1.print)(value)}`);\n        },\n    });\n}\nexports.set = set;\n/**\n * Ensure that a value is a string.\n *\n * @returns A new struct that will only accept strings.\n */\nfunction string() {\n    return (0, utilities_js_1.define)('string', (value) => {\n        return (typeof value === 'string' ||\n            `Expected a string, but received: ${(0, utils_js_1.print)(value)}`);\n    });\n}\nexports.string = string;\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n *\n * @param Structs - The set of structs that the value must match.\n * @returns A new struct that will only accept tuples of the given types.\n */\nfunction tuple(Structs) {\n    const Never = never();\n    return new struct_js_1.Struct({\n        type: 'tuple',\n        schema: null,\n        *entries(value) {\n            if (Array.isArray(value)) {\n                const length = Math.max(Structs.length, value.length);\n                for (let i = 0; i < length; i++) {\n                    yield [i, value[i], Structs[i] || Never];\n                }\n            }\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array, but received: ${(0, utils_js_1.print)(value)}`);\n        },\n    });\n}\nexports.tuple = tuple;\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n *\n * @param schema - An object that defines the structure of the object.\n * @returns A new struct that will only accept objects.\n */\nfunction type(schema) {\n    const keys = Object.keys(schema);\n    return new struct_js_1.Struct({\n        type: 'type',\n        schema,\n        *entries(value) {\n            if ((0, utils_js_1.isObject)(value)) {\n                for (const k of keys) {\n                    yield [k, value[k], schema[k]];\n                }\n            }\n        },\n        validator(value) {\n            return ((0, utils_js_1.isObject)(value) || `Expected an object, but received: ${(0, utils_js_1.print)(value)}`);\n        },\n        coercer(value) {\n            return (0, utils_js_1.isObject)(value) ? { ...value } : value;\n        },\n    });\n}\nexports.type = type;\n/**\n * Ensure that a value matches one of a set of types.\n *\n * @param Structs - The set of structs that the value must match.\n * @returns A new struct that will only accept values that match one of the\n * given structs.\n */\nfunction union(Structs) {\n    const description = Structs.map((struct) => struct.type).join(' | ');\n    return new struct_js_1.Struct({\n        type: 'union',\n        schema: null,\n        coercer(value) {\n            for (const InnerStruct of Structs) {\n                const [error, coerced] = InnerStruct.validate(value, { coerce: true });\n                if (!error) {\n                    return coerced;\n                }\n            }\n            return value;\n        },\n        validator(value, ctx) {\n            const failures = [];\n            for (const InnerStruct of Structs) {\n                const [...tuples] = (0, utils_js_1.run)(value, InnerStruct, ctx);\n                const [first] = tuples;\n                if (!first?.[0]) {\n                    return [];\n                }\n                for (const [failure] of tuples) {\n                    if (failure) {\n                        failures.push(failure);\n                    }\n                }\n            }\n            return [\n                `Expected the value to satisfy a union of \\`${description}\\`, but received: ${(0, utils_js_1.print)(value)}`,\n                ...failures,\n            ];\n        },\n    });\n}\nexports.union = union;\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n *\n * @returns A struct that will always pass validation.\n */\nfunction unknown() {\n    return (0, utilities_js_1.define)('unknown', () => true);\n}\nexports.unknown = unknown;\n//# sourceMappingURL=types.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zdXBlcnN0cnVjdC9kaXN0L3N0cnVjdHMvdHlwZXMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsR0FBRyxhQUFhLEdBQUcsWUFBWSxHQUFHLGFBQWEsR0FBRyxjQUFjLEdBQUcsV0FBVyxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcscUJBQXFCLEdBQUcsZ0JBQWdCLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxnQkFBZ0IsR0FBRyxhQUFhLEdBQUcsV0FBVyxHQUFHLGVBQWUsR0FBRyxvQkFBb0IsR0FBRyxlQUFlLEdBQUcsZ0JBQWdCLEdBQUcsWUFBWSxHQUFHLGFBQWEsR0FBRyxZQUFZLEdBQUcsZUFBZSxHQUFHLGNBQWMsR0FBRyxhQUFhLEdBQUcsV0FBVztBQUMxYixvQkFBb0IsbUJBQU8sQ0FBQyxxRkFBZTtBQUMzQyxtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBYztBQUN6Qyx1QkFBdUIsbUJBQU8sQ0FBQyxrR0FBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDBEQUEwRCw2QkFBNkI7QUFDdkYsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCw2QkFBNkI7QUFDNUYsS0FBSztBQUNMO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsWUFBWSxvQkFBb0IsNkJBQTZCO0FBQ2xHLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDZCQUE2QjtBQUMvRSxLQUFLO0FBQ0w7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFdBQVcsNkJBQTZCLDZCQUE2QjtBQUNqRyxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCw2QkFBNkI7QUFDL0UsS0FBSztBQUNMO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFlBQVksb0JBQW9CLDZCQUE2QjtBQUN2RyxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDREQUE0RCw2QkFBNkI7QUFDekYsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCw2QkFBNkI7QUFDN0UsS0FBSztBQUNMO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNEZBQTRGLDZCQUE2QjtBQUN6SCxTQUFTO0FBQ1Q7QUFDQSx1REFBdUQsV0FBVztBQUNsRSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNEZBQTRGLDZCQUE2QjtBQUN6SCxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw0REFBNEQsNkJBQTZCO0FBQ3pGLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCw2QkFBNkI7QUFDN0UsS0FBSztBQUNMO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxZQUFZO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0RBQW9ELDZCQUE2QjtBQUNqRixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw0RkFBNEYsNkJBQTZCO0FBQ3pILFNBQVM7QUFDVDtBQUNBLHVEQUF1RCxXQUFXO0FBQ2xFLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxjQUFjO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFlBQVksb0JBQW9CLDZCQUE2QjtBQUMzSDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc3VwZXJzdHJ1Y3QvZGlzdC9zdHJ1Y3RzL3R5cGVzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudW5rbm93biA9IGV4cG9ydHMudW5pb24gPSBleHBvcnRzLnR5cGUgPSBleHBvcnRzLnR1cGxlID0gZXhwb3J0cy5zdHJpbmcgPSBleHBvcnRzLnNldCA9IGV4cG9ydHMucmVnZXhwID0gZXhwb3J0cy5yZWNvcmQgPSBleHBvcnRzLmV4YWN0T3B0aW9uYWwgPSBleHBvcnRzLm9wdGlvbmFsID0gZXhwb3J0cy5vYmplY3QgPSBleHBvcnRzLm51bWJlciA9IGV4cG9ydHMubnVsbGFibGUgPSBleHBvcnRzLm5ldmVyID0gZXhwb3J0cy5tYXAgPSBleHBvcnRzLmxpdGVyYWwgPSBleHBvcnRzLmludGVyc2VjdGlvbiA9IGV4cG9ydHMuaW50ZWdlciA9IGV4cG9ydHMuaW5zdGFuY2UgPSBleHBvcnRzLmZ1bmMgPSBleHBvcnRzLmVudW1zID0gZXhwb3J0cy5kYXRlID0gZXhwb3J0cy5ib29sZWFuID0gZXhwb3J0cy5iaWdpbnQgPSBleHBvcnRzLmFycmF5ID0gZXhwb3J0cy5hbnkgPSB2b2lkIDA7XG5jb25zdCBzdHJ1Y3RfanNfMSA9IHJlcXVpcmUoXCIuLi9zdHJ1Y3QuY2pzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy5janNcIik7XG5jb25zdCB1dGlsaXRpZXNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxpdGllcy5janNcIik7XG4vKipcbiAqIEVuc3VyZSB0aGF0IGFueSB2YWx1ZSBwYXNzZXMgdmFsaWRhdGlvbi5cbiAqXG4gKiBAcmV0dXJucyBBIHN0cnVjdCB0aGF0IHdpbGwgYWx3YXlzIHBhc3MgdmFsaWRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gYW55KCkge1xuICAgIHJldHVybiAoMCwgdXRpbGl0aWVzX2pzXzEuZGVmaW5lKSgnYW55JywgKCkgPT4gdHJ1ZSk7XG59XG5leHBvcnRzLmFueSA9IGFueTtcbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhbiBhcnJheSBhbmQgdGhhdCBpdHMgZWxlbWVudHMgYXJlIG9mIGEgc3BlY2lmaWMgdHlwZS5cbiAqXG4gKiBOb3RlOiBJZiB5b3Ugb21pdCB0aGUgZWxlbWVudCBzdHJ1Y3QsIHRoZSBhcnJheXMgZWxlbWVudHMgd2lsbCBub3QgYmVcbiAqIGl0ZXJhdGVkIGF0IGFsbC4gVGhpcyBjYW4gYmUgaGVscGZ1bCBmb3IgY2FzZXMgd2hlcmUgcGVyZm9ybWFuY2UgaXMgY3JpdGljYWwsXG4gKiBhbmQgaXQgaXMgcHJlZmVycmVkIHRvIHVzaW5nIGBhcnJheShhbnkoKSlgLlxuICpcbiAqIEBwYXJhbSBFbGVtZW50IC0gVGhlIHN0cnVjdCB0byB2YWxpZGF0ZSBlYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5IGFnYWluc3QuXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IGFycmF5cyBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqL1xuZnVuY3Rpb24gYXJyYXkoRWxlbWVudCkge1xuICAgIHJldHVybiBuZXcgc3RydWN0X2pzXzEuU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgc2NoZW1hOiBFbGVtZW50LFxuICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKEVsZW1lbnQgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtpbmRleCwgYXJyYXlWYWx1ZV0gb2YgdmFsdWUuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtpbmRleCwgYXJyYXlWYWx1ZSwgRWxlbWVudF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5zbGljZSgpIDogdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhbiBhcnJheSB2YWx1ZSwgYnV0IHJlY2VpdmVkOiAkeygwLCB1dGlsc19qc18xLnByaW50KSh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnRzLmFycmF5ID0gYXJyYXk7XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBiaWdpbnQuXG4gKlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHRoYXQgd2lsbCBvbmx5IGFjY2VwdCBiaWdpbnRzLlxuICovXG5mdW5jdGlvbiBiaWdpbnQoKSB7XG4gICAgcmV0dXJuICgwLCB1dGlsaXRpZXNfanNfMS5kZWZpbmUpKCdiaWdpbnQnLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCc7XG4gICAgfSk7XG59XG5leHBvcnRzLmJpZ2ludCA9IGJpZ2ludDtcbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIGJvb2xlYW4uXG4gKlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHRoYXQgd2lsbCBvbmx5IGFjY2VwdCBib29sZWFucy5cbiAqL1xuZnVuY3Rpb24gYm9vbGVhbigpIHtcbiAgICByZXR1cm4gKDAsIHV0aWxpdGllc19qc18xLmRlZmluZSkoJ2Jvb2xlYW4nLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xuICAgIH0pO1xufVxuZXhwb3J0cy5ib29sZWFuID0gYm9vbGVhbjtcbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIHZhbGlkIGBEYXRlYC5cbiAqXG4gKiBOb3RlOiB0aGlzIGFsc28gZW5zdXJlcyB0aGF0IHRoZSB2YWx1ZSBpcyAqbm90KiBhbiBpbnZhbGlkIGBEYXRlYCBvYmplY3QsXG4gKiB3aGljaCBjYW4gb2NjdXIgd2hlbiBwYXJzaW5nIGEgZGF0ZSBmYWlscyBidXQgc3RpbGwgcmV0dXJucyBhIGBEYXRlYC5cbiAqXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IHZhbGlkIGBEYXRlYCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBkYXRlKCkge1xuICAgIHJldHVybiAoMCwgdXRpbGl0aWVzX2pzXzEuZGVmaW5lKSgnZGF0ZScsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gKCh2YWx1ZSBpbnN0YW5jZW9mIERhdGUgJiYgIWlzTmFOKHZhbHVlLmdldFRpbWUoKSkpIHx8XG4gICAgICAgICAgICBgRXhwZWN0ZWQgYSB2YWxpZCBcXGBEYXRlXFxgIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAkeygwLCB1dGlsc19qc18xLnByaW50KSh2YWx1ZSl9YCk7XG4gICAgfSk7XG59XG5leHBvcnRzLmRhdGUgPSBkYXRlO1xuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIG9uZSBvZiBhIHNldCBvZiBwb3RlbnRpYWwgdmFsdWVzLlxuICpcbiAqIE5vdGU6IGFmdGVyIGNyZWF0aW5nIHRoZSBzdHJ1Y3QsIHlvdSBjYW4gYWNjZXNzIHRoZSBkZWZpbml0aW9uIG9mIHRoZVxuICogcG90ZW50aWFsIHZhbHVlcyBhcyBgc3RydWN0LnNjaGVtYWAuXG4gKlxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSBwb3RlbnRpYWwgdmFsdWVzIHRoYXQgdGhlIGlucHV0IGNhbiBiZS5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgdGhlIGdpdmVuIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZW51bXModmFsdWVzKSB7XG4gICAgY29uc3Qgc2NoZW1hID0ge307XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB2YWx1ZXMubWFwKCh2YWx1ZSkgPT4gKDAsIHV0aWxzX2pzXzEucHJpbnQpKHZhbHVlKSkuam9pbigpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHZhbHVlcykge1xuICAgICAgICBzY2hlbWFba2V5XSA9IGtleTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBzdHJ1Y3RfanNfMS5TdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAnZW51bXMnLFxuICAgICAgICBzY2hlbWEsXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZXMuaW5jbHVkZXModmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIG9uZSBvZiBcXGAke2Rlc2NyaXB0aW9ufVxcYCwgYnV0IHJlY2VpdmVkOiAkeygwLCB1dGlsc19qc18xLnByaW50KSh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnRzLmVudW1zID0gZW51bXM7XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBmdW5jdGlvbi5cbiAqXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IGZ1bmN0aW9ucy5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbmZ1bmN0aW9uIGZ1bmMoKSB7XG4gICAgcmV0dXJuICgwLCB1dGlsaXRpZXNfanNfMS5kZWZpbmUpKCdmdW5jJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICBgRXhwZWN0ZWQgYSBmdW5jdGlvbiwgYnV0IHJlY2VpdmVkOiAkeygwLCB1dGlsc19qc18xLnByaW50KSh2YWx1ZSl9YCk7XG4gICAgfSk7XG59XG5leHBvcnRzLmZ1bmMgPSBmdW5jO1xuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIGluc3RhbmNlIG9mIGEgc3BlY2lmaWMgY2xhc3MuXG4gKlxuICogQHBhcmFtIENsYXNzIC0gVGhlIGNsYXNzIHRoYXQgdGhlIHZhbHVlIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YuXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IGluc3RhbmNlcyBvZiB0aGUgZ2l2ZW4gY2xhc3MuXG4gKi9cbmZ1bmN0aW9uIGluc3RhbmNlKENsYXNzKSB7XG4gICAgcmV0dXJuICgwLCB1dGlsaXRpZXNfanNfMS5kZWZpbmUpKCdpbnN0YW5jZScsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gKHZhbHVlIGluc3RhbmNlb2YgQ2xhc3MgfHxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBhIFxcYCR7Q2xhc3MubmFtZX1cXGAgaW5zdGFuY2UsIGJ1dCByZWNlaXZlZDogJHsoMCwgdXRpbHNfanNfMS5wcmludCkodmFsdWUpfWApO1xuICAgIH0pO1xufVxuZXhwb3J0cy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIGludGVnZXIuXG4gKlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHRoYXQgd2lsbCBvbmx5IGFjY2VwdCBpbnRlZ2Vycy5cbiAqL1xuZnVuY3Rpb24gaW50ZWdlcigpIHtcbiAgICByZXR1cm4gKDAsIHV0aWxpdGllc19qc18xLmRlZmluZSkoJ2ludGVnZXInLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuICgodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpICYmIE51bWJlci5pc0ludGVnZXIodmFsdWUpKSB8fFxuICAgICAgICAgICAgYEV4cGVjdGVkIGFuIGludGVnZXIsIGJ1dCByZWNlaXZlZDogJHsoMCwgdXRpbHNfanNfMS5wcmludCkodmFsdWUpfWApO1xuICAgIH0pO1xufVxuZXhwb3J0cy5pbnRlZ2VyID0gaW50ZWdlcjtcbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBtYXRjaGVzIGFsbCBvZiBhIHNldCBvZiB0eXBlcy5cbiAqXG4gKiBAcGFyYW0gU3RydWN0cyAtIFRoZSBzZXQgb2Ygc3RydWN0cyB0aGF0IHRoZSB2YWx1ZSBtdXN0IG1hdGNoLlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHRoYXQgd2lsbCBvbmx5IGFjY2VwdCB2YWx1ZXMgdGhhdCBtYXRjaCBhbGwgb2YgdGhlXG4gKiBnaXZlbiBzdHJ1Y3RzLlxuICovXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb24oU3RydWN0cykge1xuICAgIHJldHVybiBuZXcgc3RydWN0X2pzXzEuU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ2ludGVyc2VjdGlvbicsXG4gICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgKmVudHJpZXModmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBlbnRyaWVzIH0gb2YgU3RydWN0cykge1xuICAgICAgICAgICAgICAgIHlpZWxkKiBlbnRyaWVzKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgKnZhbGlkYXRvcih2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB7IHZhbGlkYXRvciB9IG9mIFN0cnVjdHMpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogdmFsaWRhdG9yKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgKnJlZmluZXIodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyByZWZpbmVyIH0gb2YgU3RydWN0cykge1xuICAgICAgICAgICAgICAgIHlpZWxkKiByZWZpbmVyKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbmV4cG9ydHMuaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIGV4YWN0IHZhbHVlLCB1c2luZyBgPT09YCBmb3IgY29tcGFyaXNvbi5cbiAqXG4gKiBAcGFyYW0gY29uc3RhbnQgLSBUaGUgZXhhY3QgdmFsdWUgdGhhdCB0aGUgaW5wdXQgbXVzdCBiZS5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgdGhlIGV4YWN0IGdpdmVuIHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXRlcmFsKGNvbnN0YW50KSB7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSAoMCwgdXRpbHNfanNfMS5wcmludCkoY29uc3RhbnQpO1xuICAgIGNvbnN0IHZhbHVlVHlwZSA9IHR5cGVvZiBjb25zdGFudDtcbiAgICByZXR1cm4gbmV3IHN0cnVjdF9qc18xLlN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdsaXRlcmFsJyxcbiAgICAgICAgc2NoZW1hOiB2YWx1ZVR5cGUgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICB2YWx1ZVR5cGUgPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICB2YWx1ZVR5cGUgPT09ICdib29sZWFuJ1xuICAgICAgICAgICAgPyBjb25zdGFudFxuICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUgPT09IGNvbnN0YW50IHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIHRoZSBsaXRlcmFsIFxcYCR7ZGVzY3JpcHRpb259XFxgLCBidXQgcmVjZWl2ZWQ6ICR7KDAsIHV0aWxzX2pzXzEucHJpbnQpKHZhbHVlKX1gKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbmV4cG9ydHMubGl0ZXJhbCA9IGxpdGVyYWw7XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBgTWFwYCBvYmplY3QsIGFuZCB0aGF0IGl0cyBrZXlzIGFuZCB2YWx1ZXMgYXJlIG9mXG4gKiBzcGVjaWZpYyB0eXBlcy5cbiAqXG4gKiBAcGFyYW0gS2V5IC0gVGhlIHN0cnVjdCB0byB2YWxpZGF0ZSBlYWNoIGtleSBpbiB0aGUgbWFwIGFnYWluc3QuXG4gKiBAcGFyYW0gVmFsdWUgLSBUaGUgc3RydWN0IHRvIHZhbGlkYXRlIGVhY2ggdmFsdWUgaW4gdGhlIG1hcCBhZ2FpbnN0LlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHRoYXQgd2lsbCBvbmx5IGFjY2VwdCBgTWFwYCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBtYXAoS2V5LCBWYWx1ZSkge1xuICAgIHJldHVybiBuZXcgc3RydWN0X2pzXzEuU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ21hcCcsXG4gICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChLZXkgJiYgVmFsdWUgJiYgdmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFttYXBLZXksIG1hcFZhbHVlXSBvZiB2YWx1ZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW21hcEtleSwgbWFwS2V5LCBLZXldO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBbbWFwS2V5LCBtYXBWYWx1ZSwgVmFsdWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTWFwID8gbmV3IE1hcCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIGEgXFxgTWFwXFxgIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAkeygwLCB1dGlsc19qc18xLnByaW50KSh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnRzLm1hcCA9IG1hcDtcbi8qKlxuICogRW5zdXJlIHRoYXQgbm8gdmFsdWUgZXZlciBwYXNzZXMgdmFsaWRhdGlvbi5cbiAqXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG5ldmVyIHBhc3MgdmFsaWRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gbmV2ZXIoKSB7XG4gICAgcmV0dXJuICgwLCB1dGlsaXRpZXNfanNfMS5kZWZpbmUpKCduZXZlcicsICgpID0+IGZhbHNlKTtcbn1cbmV4cG9ydHMubmV2ZXIgPSBuZXZlcjtcbi8qKlxuICogQXVnbWVudCBhbiBleGlzdGluZyBzdHJ1Y3QgdG8gYWxsb3cgYG51bGxgIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byBhdWdtZW50LlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHRoYXQgd2lsbCBhY2NlcHQgYG51bGxgIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gbnVsbGFibGUoc3RydWN0KSB7XG4gICAgcmV0dXJuIG5ldyBzdHJ1Y3RfanNfMS5TdHJ1Y3Qoe1xuICAgICAgICAuLi5zdHJ1Y3QsXG4gICAgICAgIHZhbGlkYXRvcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSBudWxsIHx8IHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCksXG4gICAgICAgIHJlZmluZXI6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KSxcbiAgICB9KTtcbn1cbmV4cG9ydHMubnVsbGFibGUgPSBudWxsYWJsZTtcbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIG51bWJlci5cbiAqXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IG51bWJlcnMuXG4gKi9cbmZ1bmN0aW9uIG51bWJlcigpIHtcbiAgICByZXR1cm4gKDAsIHV0aWxpdGllc19qc18xLmRlZmluZSkoJ251bWJlcicsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gKCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSkpIHx8XG4gICAgICAgICAgICBgRXhwZWN0ZWQgYSBudW1iZXIsIGJ1dCByZWNlaXZlZDogJHsoMCwgdXRpbHNfanNfMS5wcmludCkodmFsdWUpfWApO1xuICAgIH0pO1xufVxuZXhwb3J0cy5udW1iZXIgPSBudW1iZXI7XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYW4gb2JqZWN0LCB0aGF0IGl0IGhhcyBhIGtub3duIHNldCBvZiBwcm9wZXJ0aWVzLFxuICogYW5kIHRoYXQgaXRzIHByb3BlcnRpZXMgYXJlIG9mIHNwZWNpZmljIHR5cGVzLlxuICpcbiAqIE5vdGU6IFVucmVjb2duaXplZCBwcm9wZXJ0aWVzIHdpbGwgZmFpbCB2YWxpZGF0aW9uLlxuICpcbiAqIEBwYXJhbSBzY2hlbWEgLSBBbiBvYmplY3QgdGhhdCBkZWZpbmVzIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIG9iamVjdC5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0KHNjaGVtYSkge1xuICAgIGNvbnN0IGtub3ducyA9IHNjaGVtYSA/IE9iamVjdC5rZXlzKHNjaGVtYSkgOiBbXTtcbiAgICBjb25zdCBOZXZlciA9IG5ldmVyKCk7XG4gICAgcmV0dXJuIG5ldyBzdHJ1Y3RfanNfMS5TdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWEgPz8gbnVsbCxcbiAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWEgJiYgKDAsIHV0aWxzX2pzXzEuaXNPYmplY3QpKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVua25vd25zID0gbmV3IFNldChPYmplY3Qua2V5cyh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtub3ducykge1xuICAgICAgICAgICAgICAgICAgICB1bmtub3ducy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHlTY2hlbWEgPSBzY2hlbWFba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cnVjdF9qc18xLkV4YWN0T3B0aW9uYWxTdHJ1Y3QuaXNFeGFjdE9wdGlvbmFsKHByb3BlcnR5U2NoZW1hKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW2tleSwgdmFsdWVba2V5XSwgc2NoZW1hW2tleV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1bmtub3ducykge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBba2V5LCB2YWx1ZVtrZXldLCBOZXZlcl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoKDAsIHV0aWxzX2pzXzEuaXNPYmplY3QpKHZhbHVlKSB8fCBgRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7KDAsIHV0aWxzX2pzXzEucHJpbnQpKHZhbHVlKX1gKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc19qc18xLmlzT2JqZWN0KSh2YWx1ZSkgPyB7IC4uLnZhbHVlIH0gOiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbmV4cG9ydHMub2JqZWN0ID0gb2JqZWN0O1xuLyoqXG4gKiBBdWdtZW50IGEgc3RydWN0IHRvIGFsbG93IGB1bmRlZmluZWRgIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byBhdWdtZW50LlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHRoYXQgd2lsbCBhY2NlcHQgYHVuZGVmaW5lZGAgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBvcHRpb25hbChzdHJ1Y3QpIHtcbiAgICByZXR1cm4gbmV3IHN0cnVjdF9qc18xLlN0cnVjdCh7XG4gICAgICAgIC4uLnN0cnVjdCxcbiAgICAgICAgdmFsaWRhdG9yOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpLFxuICAgICAgICByZWZpbmVyOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KSxcbiAgICB9KTtcbn1cbmV4cG9ydHMub3B0aW9uYWwgPSBvcHRpb25hbDtcbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCBzdWNoIHRoYXQsIGlmIGl0IGlzIHRoZSBwcm9wZXJ0eSBvZiBhbiBvYmplY3QsIGl0IGlzIGV4YWN0bHkgb3B0aW9uYWwuXG4gKiBJbiBvdGhlciB3b3JkcywgaXQgaXMgZWl0aGVyIHByZXNlbnQgd2l0aCB0aGUgY29ycmVjdCB0eXBlLCBvciBub3QgcHJlc2VudCBhdCBhbGwuXG4gKlxuICogTk9URTogT25seSBpbnRlbmRlZCBmb3IgdXNlIHdpdGggYG9iamVjdCgpYCBzdHJ1Y3RzLlxuICpcbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RydWN0IHRvIGF1Z21lbnQuXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgZXhhY3RseSBvcHRpb25hbCBwcm9wZXJ0aWVzIG9mIGBvYmplY3QoKWBcbiAqIHN0cnVjdHMuXG4gKi9cbmZ1bmN0aW9uIGV4YWN0T3B0aW9uYWwoc3RydWN0KSB7XG4gICAgcmV0dXJuIG5ldyBzdHJ1Y3RfanNfMS5FeGFjdE9wdGlvbmFsU3RydWN0KHN0cnVjdCk7XG59XG5leHBvcnRzLmV4YWN0T3B0aW9uYWwgPSBleGFjdE9wdGlvbmFsO1xuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGtleXMgYW5kIHZhbHVlcyBvZiBzcGVjaWZpYyB0eXBlcywgYnV0XG4gKiB3aXRob3V0IGVuc3VyaW5nIGFueSBzcGVjaWZpYyBzaGFwZSBvZiBwcm9wZXJ0aWVzLlxuICpcbiAqIExpa2UgVHlwZVNjcmlwdCdzIGBSZWNvcmRgIHV0aWxpdHkuXG4gKi9cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBrZXlzIGFuZCB2YWx1ZXMgb2Ygc3BlY2lmaWMgdHlwZXMsIGJ1dFxuICogd2l0aG91dCBlbnN1cmluZyBhbnkgc3BlY2lmaWMgc2hhcGUgb2YgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0gS2V5IC0gVGhlIHN0cnVjdCB0byB2YWxpZGF0ZSBlYWNoIGtleSBpbiB0aGUgcmVjb3JkIGFnYWluc3QuXG4gKiBAcGFyYW0gVmFsdWUgLSBUaGUgc3RydWN0IHRvIHZhbGlkYXRlIGVhY2ggdmFsdWUgaW4gdGhlIHJlY29yZCBhZ2FpbnN0LlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHRoYXQgd2lsbCBvbmx5IGFjY2VwdCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiByZWNvcmQoS2V5LCBWYWx1ZSkge1xuICAgIHJldHVybiBuZXcgc3RydWN0X2pzXzEuU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ3JlY29yZCcsXG4gICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfanNfMS5pc09iamVjdCkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgb2JqZWN0S2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9iamVjdFZhbHVlID0gdmFsdWVbb2JqZWN0S2V5XTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW29iamVjdEtleSwgb2JqZWN0S2V5LCBLZXldO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBbb2JqZWN0S2V5LCBvYmplY3RWYWx1ZSwgVmFsdWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKCgwLCB1dGlsc19qc18xLmlzT2JqZWN0KSh2YWx1ZSkgfHwgYEV4cGVjdGVkIGFuIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAkeygwLCB1dGlsc19qc18xLnByaW50KSh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnRzLnJlY29yZCA9IHJlY29yZDtcbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIGBSZWdFeHBgLlxuICpcbiAqIE5vdGU6IHRoaXMgZG9lcyBub3QgdGVzdCB0aGUgdmFsdWUgYWdhaW5zdCB0aGUgcmVndWxhciBleHByZXNzaW9uISBGb3IgdGhhdFxuICogeW91IG5lZWQgdG8gdXNlIHRoZSBgcGF0dGVybigpYCByZWZpbmVtZW50LlxuICpcbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgYFJlZ0V4cGAgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gcmVnZXhwKCkge1xuICAgIHJldHVybiAoMCwgdXRpbGl0aWVzX2pzXzEuZGVmaW5lKSgncmVnZXhwJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cDtcbiAgICB9KTtcbn1cbmV4cG9ydHMucmVnZXhwID0gcmVnZXhwO1xuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYFNldGAgb2JqZWN0LCBhbmQgdGhhdCBpdHMgZWxlbWVudHMgYXJlIG9mIGFcbiAqIHNwZWNpZmljIHR5cGUuXG4gKlxuICogQHBhcmFtIEVsZW1lbnQgLSBUaGUgc3RydWN0IHRvIHZhbGlkYXRlIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0IGFnYWluc3QuXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IGBTZXRgIG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIHNldChFbGVtZW50KSB7XG4gICAgcmV0dXJuIG5ldyBzdHJ1Y3RfanNfMS5TdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAnc2V0JyxcbiAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKEVsZW1lbnQgJiYgdmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNldFZhbHVlIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtzZXRWYWx1ZSwgc2V0VmFsdWUsIEVsZW1lbnRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgU2V0ID8gbmV3IFNldCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlIGluc3RhbmNlb2YgU2V0IHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIGEgXFxgU2V0XFxgIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAkeygwLCB1dGlsc19qc18xLnByaW50KSh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnRzLnNldCA9IHNldDtcbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IHN0cmluZ3MuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZygpIHtcbiAgICByZXR1cm4gKDAsIHV0aWxpdGllc19qc18xLmRlZmluZSkoJ3N0cmluZycsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBhIHN0cmluZywgYnV0IHJlY2VpdmVkOiAkeygwLCB1dGlsc19qc18xLnByaW50KSh2YWx1ZSl9YCk7XG4gICAgfSk7XG59XG5leHBvcnRzLnN0cmluZyA9IHN0cmluZztcbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIHR1cGxlIG9mIGEgc3BlY2lmaWMgbGVuZ3RoLCBhbmQgdGhhdCBlYWNoIG9mIGl0c1xuICogZWxlbWVudHMgaXMgb2YgYSBzcGVjaWZpYyB0eXBlLlxuICpcbiAqIEBwYXJhbSBTdHJ1Y3RzIC0gVGhlIHNldCBvZiBzdHJ1Y3RzIHRoYXQgdGhlIHZhbHVlIG11c3QgbWF0Y2guXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IHR1cGxlcyBvZiB0aGUgZ2l2ZW4gdHlwZXMuXG4gKi9cbmZ1bmN0aW9uIHR1cGxlKFN0cnVjdHMpIHtcbiAgICBjb25zdCBOZXZlciA9IG5ldmVyKCk7XG4gICAgcmV0dXJuIG5ldyBzdHJ1Y3RfanNfMS5TdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAndHVwbGUnLFxuICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChTdHJ1Y3RzLmxlbmd0aCwgdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtpLCB2YWx1ZVtpXSwgU3RydWN0c1tpXSB8fCBOZXZlcl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYW4gYXJyYXksIGJ1dCByZWNlaXZlZDogJHsoMCwgdXRpbHNfanNfMS5wcmludCkodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuZXhwb3J0cy50dXBsZSA9IHR1cGxlO1xuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGhhcyBhIHNldCBvZiBrbm93biBwcm9wZXJ0aWVzIG9mIHNwZWNpZmljIHR5cGVzLlxuICpcbiAqIE5vdGU6IFVucmVjb2duaXplZCBwcm9wZXJ0aWVzIGFyZSBhbGxvd2VkIGFuZCB1bnRvdWNoZWQuIFRoaXMgaXMgc2ltaWxhciB0b1xuICogaG93IFR5cGVTY3JpcHQncyBzdHJ1Y3R1cmFsIHR5cGluZyB3b3Jrcy5cbiAqXG4gKiBAcGFyYW0gc2NoZW1hIC0gQW4gb2JqZWN0IHRoYXQgZGVmaW5lcyB0aGUgc3RydWN0dXJlIG9mIHRoZSBvYmplY3QuXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIHR5cGUoc2NoZW1hKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNjaGVtYSk7XG4gICAgcmV0dXJuIG5ldyBzdHJ1Y3RfanNfMS5TdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAndHlwZScsXG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfanNfMS5pc09iamVjdCkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIGtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW2ssIHZhbHVlW2tdLCBzY2hlbWFba11dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKCgwLCB1dGlsc19qc18xLmlzT2JqZWN0KSh2YWx1ZSkgfHwgYEV4cGVjdGVkIGFuIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAkeygwLCB1dGlsc19qc18xLnByaW50KSh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfanNfMS5pc09iamVjdCkodmFsdWUpID8geyAuLi52YWx1ZSB9IDogdmFsdWU7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnRzLnR5cGUgPSB0eXBlO1xuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIG1hdGNoZXMgb25lIG9mIGEgc2V0IG9mIHR5cGVzLlxuICpcbiAqIEBwYXJhbSBTdHJ1Y3RzIC0gVGhlIHNldCBvZiBzdHJ1Y3RzIHRoYXQgdGhlIHZhbHVlIG11c3QgbWF0Y2guXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IHZhbHVlcyB0aGF0IG1hdGNoIG9uZSBvZiB0aGVcbiAqIGdpdmVuIHN0cnVjdHMuXG4gKi9cbmZ1bmN0aW9uIHVuaW9uKFN0cnVjdHMpIHtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IFN0cnVjdHMubWFwKChzdHJ1Y3QpID0+IHN0cnVjdC50eXBlKS5qb2luKCcgfCAnKTtcbiAgICByZXR1cm4gbmV3IHN0cnVjdF9qc18xLlN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICd1bmlvbicsXG4gICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBJbm5lclN0cnVjdCBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2Vycm9yLCBjb2VyY2VkXSA9IElubmVyU3RydWN0LnZhbGlkYXRlKHZhbHVlLCB7IGNvZXJjZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2VyY2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IElubmVyU3RydWN0IG9mIFN0cnVjdHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbLi4udHVwbGVzXSA9ICgwLCB1dGlsc19qc18xLnJ1bikodmFsdWUsIElubmVyU3RydWN0LCBjdHgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFtmaXJzdF0gPSB0dXBsZXM7XG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdD8uWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbZmFpbHVyZV0gb2YgdHVwbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlcy5wdXNoKGZhaWx1cmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgdGhlIHZhbHVlIHRvIHNhdGlzZnkgYSB1bmlvbiBvZiBcXGAke2Rlc2NyaXB0aW9ufVxcYCwgYnV0IHJlY2VpdmVkOiAkeygwLCB1dGlsc19qc18xLnByaW50KSh2YWx1ZSl9YCxcbiAgICAgICAgICAgICAgICAuLi5mYWlsdXJlcyxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnRzLnVuaW9uID0gdW5pb247XG4vKipcbiAqIEVuc3VyZSB0aGF0IGFueSB2YWx1ZSBwYXNzZXMgdmFsaWRhdGlvbiwgd2l0aG91dCB3aWRlbmluZyBpdHMgdHlwZSB0byBgYW55YC5cbiAqXG4gKiBAcmV0dXJucyBBIHN0cnVjdCB0aGF0IHdpbGwgYWx3YXlzIHBhc3MgdmFsaWRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gdW5rbm93bigpIHtcbiAgICByZXR1cm4gKDAsIHV0aWxpdGllc19qc18xLmRlZmluZSkoJ3Vua25vd24nLCAoKSA9PiB0cnVlKTtcbn1cbmV4cG9ydHMudW5rbm93biA9IHVua25vd247XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5janMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/superstruct/dist/structs/types.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/superstruct/dist/structs/utilities.cjs":
/*!***************************************************************************!*\
  !*** ../../node_modules/@metamask/superstruct/dist/structs/utilities.cjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pick = exports.partial = exports.omit = exports.lazy = exports.dynamic = exports.deprecated = exports.define = exports.assign = void 0;\nconst struct_js_1 = __webpack_require__(/*! ../struct.cjs */ \"(rsc)/../../node_modules/@metamask/superstruct/dist/struct.cjs\");\nconst types_js_1 = __webpack_require__(/*! ./types.cjs */ \"(rsc)/../../node_modules/@metamask/superstruct/dist/structs/types.cjs\");\n/**\n * Create a new struct that combines the properties from multiple object or type\n * structs. Its return type will match the first parameter's type.\n *\n * @param Structs - The structs to combine.\n * @returns A new struct that combines the properties of the input structs.\n */\nfunction assign(...Structs) {\n    const isType = Structs[0]?.type === 'type';\n    const schemas = Structs.map(({ schema }) => schema);\n    const schema = Object.assign({}, ...schemas);\n    return isType ? (0, types_js_1.type)(schema) : (0, types_js_1.object)(schema);\n}\nexports.assign = assign;\n/**\n * Define a new struct type with a custom validation function.\n *\n * @param name - The name of the struct type.\n * @param validator - The validation function.\n * @returns A new struct type.\n */\nfunction define(name, validator) {\n    return new struct_js_1.Struct({ type: name, schema: null, validator });\n}\nexports.define = define;\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n *\n * @param struct - The struct to augment.\n * @param log - The function to call when the value is not `undefined`.\n * @returns A new struct that will only accept `undefined` or values that pass\n * the input struct.\n */\nfunction deprecated(struct, log) {\n    return new struct_js_1.Struct({\n        ...struct,\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n        validator(value, ctx) {\n            if (value === undefined) {\n                return true;\n            }\n            log(value, ctx);\n            return struct.validator(value, ctx);\n        },\n    });\n}\nexports.deprecated = deprecated;\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n *\n * @param fn - The callback to create the struct.\n * @returns A new struct with dynamic validation logic.\n */\nfunction dynamic(fn) {\n    return new struct_js_1.Struct({\n        type: 'dynamic',\n        schema: null,\n        *entries(value, ctx) {\n            const struct = fn(value, ctx);\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.refiner(value, ctx);\n        },\n    });\n}\nexports.dynamic = dynamic;\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n *\n * @param fn - The callback to create the struct.\n * @returns A new struct with lazily evaluated validation logic.\n */\nfunction lazy(fn) {\n    let struct;\n    return new struct_js_1.Struct({\n        type: 'lazy',\n        schema: null,\n        *entries(value, ctx) {\n            struct ?? (struct = fn());\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.refiner(value, ctx);\n        },\n    });\n}\nexports.lazy = lazy;\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n *\n * @param struct - The struct to augment.\n * @param keys - The keys to omit.\n * @returns A new struct that will not accept the input keys.\n */\nfunction omit(struct, keys) {\n    const { schema } = struct;\n    const subschema = { ...schema };\n    for (const key of keys) {\n        delete subschema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return (0, types_js_1.type)(subschema);\n        default:\n            return (0, types_js_1.object)(subschema);\n    }\n}\nexports.omit = omit;\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will accept the input keys as `undefined`.\n */\nfunction partial(struct) {\n    const isStruct = struct instanceof struct_js_1.Struct;\n    const schema = isStruct ? { ...struct.schema } : { ...struct };\n    // eslint-disable-next-line guard-for-in\n    for (const key in schema) {\n        schema[key] = (0, types_js_1.optional)(schema[key]);\n    }\n    if (isStruct && struct.type === 'type') {\n        return (0, types_js_1.type)(schema);\n    }\n    return (0, types_js_1.object)(schema);\n}\nexports.partial = partial;\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n *\n * @param struct - The struct to augment.\n * @param keys - The keys to pick.\n * @returns A new struct that will only accept the input keys.\n */\nfunction pick(struct, keys) {\n    const { schema } = struct;\n    const subschema = {};\n    for (const key of keys) {\n        subschema[key] = schema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return (0, types_js_1.type)(subschema);\n        default:\n            return (0, types_js_1.object)(subschema);\n    }\n}\nexports.pick = pick;\n//# sourceMappingURL=utilities.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zdXBlcnN0cnVjdC9kaXN0L3N0cnVjdHMvdXRpbGl0aWVzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZLEdBQUcsZUFBZSxHQUFHLFlBQVksR0FBRyxZQUFZLEdBQUcsZUFBZSxHQUFHLGtCQUFrQixHQUFHLGNBQWMsR0FBRyxjQUFjO0FBQ3JJLG9CQUFvQixtQkFBTyxDQUFDLHFGQUFlO0FBQzNDLG1CQUFtQixtQkFBTyxDQUFDLDBGQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MscUNBQXFDO0FBQ3pFO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxtQkFBbUIsSUFBSTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc3VwZXJzdHJ1Y3QvZGlzdC9zdHJ1Y3RzL3V0aWxpdGllcy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBpY2sgPSBleHBvcnRzLnBhcnRpYWwgPSBleHBvcnRzLm9taXQgPSBleHBvcnRzLmxhenkgPSBleHBvcnRzLmR5bmFtaWMgPSBleHBvcnRzLmRlcHJlY2F0ZWQgPSBleHBvcnRzLmRlZmluZSA9IGV4cG9ydHMuYXNzaWduID0gdm9pZCAwO1xuY29uc3Qgc3RydWN0X2pzXzEgPSByZXF1aXJlKFwiLi4vc3RydWN0LmNqc1wiKTtcbmNvbnN0IHR5cGVzX2pzXzEgPSByZXF1aXJlKFwiLi90eXBlcy5janNcIik7XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdHJ1Y3QgdGhhdCBjb21iaW5lcyB0aGUgcHJvcGVydGllcyBmcm9tIG11bHRpcGxlIG9iamVjdCBvciB0eXBlXG4gKiBzdHJ1Y3RzLiBJdHMgcmV0dXJuIHR5cGUgd2lsbCBtYXRjaCB0aGUgZmlyc3QgcGFyYW1ldGVyJ3MgdHlwZS5cbiAqXG4gKiBAcGFyYW0gU3RydWN0cyAtIFRoZSBzdHJ1Y3RzIHRvIGNvbWJpbmUuXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCBjb21iaW5lcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgaW5wdXQgc3RydWN0cy5cbiAqL1xuZnVuY3Rpb24gYXNzaWduKC4uLlN0cnVjdHMpIHtcbiAgICBjb25zdCBpc1R5cGUgPSBTdHJ1Y3RzWzBdPy50eXBlID09PSAndHlwZSc7XG4gICAgY29uc3Qgc2NoZW1hcyA9IFN0cnVjdHMubWFwKCh7IHNjaGVtYSB9KSA9PiBzY2hlbWEpO1xuICAgIGNvbnN0IHNjaGVtYSA9IE9iamVjdC5hc3NpZ24oe30sIC4uLnNjaGVtYXMpO1xuICAgIHJldHVybiBpc1R5cGUgPyAoMCwgdHlwZXNfanNfMS50eXBlKShzY2hlbWEpIDogKDAsIHR5cGVzX2pzXzEub2JqZWN0KShzY2hlbWEpO1xufVxuZXhwb3J0cy5hc3NpZ24gPSBhc3NpZ247XG4vKipcbiAqIERlZmluZSBhIG5ldyBzdHJ1Y3QgdHlwZSB3aXRoIGEgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgc3RydWN0IHR5cGUuXG4gKiBAcGFyYW0gdmFsaWRhdG9yIC0gVGhlIHZhbGlkYXRpb24gZnVuY3Rpb24uXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdHlwZS5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lKG5hbWUsIHZhbGlkYXRvcikge1xuICAgIHJldHVybiBuZXcgc3RydWN0X2pzXzEuU3RydWN0KHsgdHlwZTogbmFtZSwgc2NoZW1hOiBudWxsLCB2YWxpZGF0b3IgfSk7XG59XG5leHBvcnRzLmRlZmluZSA9IGRlZmluZTtcbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBzdHJ1Y3QsIGJ1dCB0aGUgdmFsdWUgaXMgYWxsb3dlZCB0b1xuICogYmUgYHVuZGVmaW5lZGAuIGBsb2dgIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSB2YWx1ZSBpcyBub3QgYHVuZGVmaW5lZGAuXG4gKlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgdG8gYXVnbWVudC5cbiAqIEBwYXJhbSBsb2cgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSB2YWx1ZSBpcyBub3QgYHVuZGVmaW5lZGAuXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IGB1bmRlZmluZWRgIG9yIHZhbHVlcyB0aGF0IHBhc3NcbiAqIHRoZSBpbnB1dCBzdHJ1Y3QuXG4gKi9cbmZ1bmN0aW9uIGRlcHJlY2F0ZWQoc3RydWN0LCBsb2cpIHtcbiAgICByZXR1cm4gbmV3IHN0cnVjdF9qc18xLlN0cnVjdCh7XG4gICAgICAgIC4uLnN0cnVjdCxcbiAgICAgICAgcmVmaW5lcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSB1bmRlZmluZWQgfHwgc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCksXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnRzLmRlcHJlY2F0ZWQgPSBkZXByZWNhdGVkO1xuLyoqXG4gKiBDcmVhdGUgYSBzdHJ1Y3Qgd2l0aCBkeW5hbWljIHZhbGlkYXRpb24gbG9naWMuXG4gKlxuICogVGhlIGNhbGxiYWNrIHdpbGwgcmVjZWl2ZSB0aGUgdmFsdWUgY3VycmVudGx5IGJlaW5nIHZhbGlkYXRlZCwgYW5kIG11c3RcbiAqIHJldHVybiBhIHN0cnVjdCBvYmplY3QgdG8gdmFsaWRhdGUgaXQgd2l0aC4gVGhpcyBjYW4gYmUgdXNlZnVsIHRvIG1vZGVsXG4gKiB2YWxpZGF0aW9uIGxvZ2ljIHRoYXQgY2hhbmdlcyBiYXNlZCBvbiBpdHMgaW5wdXQuXG4gKlxuICogQHBhcmFtIGZuIC0gVGhlIGNhbGxiYWNrIHRvIGNyZWF0ZSB0aGUgc3RydWN0LlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHdpdGggZHluYW1pYyB2YWxpZGF0aW9uIGxvZ2ljLlxuICovXG5mdW5jdGlvbiBkeW5hbWljKGZuKSB7XG4gICAgcmV0dXJuIG5ldyBzdHJ1Y3RfanNfMS5TdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAnZHluYW1pYycsXG4gICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgKmVudHJpZXModmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgY29uc3Qgc3RydWN0ID0gZm4odmFsdWUsIGN0eCk7XG4gICAgICAgICAgICB5aWVsZCogc3RydWN0LmVudHJpZXModmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBjb25zdCBzdHJ1Y3QgPSBmbih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdC5jb2VyY2VyKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgICAgICByZWZpbmVyKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuZXhwb3J0cy5keW5hbWljID0gZHluYW1pYztcbi8qKlxuICogQ3JlYXRlIGEgc3RydWN0IHdpdGggbGF6aWx5IGV2YWx1YXRlZCB2YWxpZGF0aW9uIGxvZ2ljLlxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHZhbGlkYXRpb24gaXMgcnVuIHdpdGggdGhlIHN0cnVjdCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkXG4gKiBhbmQgbXVzdCByZXR1cm4gYSBzdHJ1Y3Qgb2JqZWN0IHRvIHVzZS4gVGhpcyBpcyB1c2VmdWwgZm9yIGNhc2VzIHdoZXJlIHlvdVxuICogd2FudCB0byBoYXZlIHNlbGYtcmVmZXJlbnRpYWwgc3RydWN0cyBmb3IgbmVzdGVkIGRhdGEgc3RydWN0dXJlcyB0byBhdm9pZCBhXG4gKiBjaXJjdWxhciBkZWZpbml0aW9uIHByb2JsZW0uXG4gKlxuICogQHBhcmFtIGZuIC0gVGhlIGNhbGxiYWNrIHRvIGNyZWF0ZSB0aGUgc3RydWN0LlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHdpdGggbGF6aWx5IGV2YWx1YXRlZCB2YWxpZGF0aW9uIGxvZ2ljLlxuICovXG5mdW5jdGlvbiBsYXp5KGZuKSB7XG4gICAgbGV0IHN0cnVjdDtcbiAgICByZXR1cm4gbmV3IHN0cnVjdF9qc18xLlN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdsYXp5JyxcbiAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBzdHJ1Y3QgPz8gKHN0cnVjdCA9IGZuKCkpO1xuICAgICAgICAgICAgeWllbGQqIHN0cnVjdC5lbnRyaWVzKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgc3RydWN0ID8/IChzdHJ1Y3QgPSBmbigpKTtcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIHN0cnVjdCA/PyAoc3RydWN0ID0gZm4oKSk7XG4gICAgICAgICAgICByZXR1cm4gc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgc3RydWN0ID8/IChzdHJ1Y3QgPSBmbigpKTtcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbmV4cG9ydHMubGF6eSA9IGxhenk7XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdHJ1Y3QgYmFzZWQgb24gYW4gZXhpc3Rpbmcgb2JqZWN0IHN0cnVjdCwgYnV0IGV4Y2x1ZGluZ1xuICogc3BlY2lmaWMgcHJvcGVydGllcy5cbiAqXG4gKiBMaWtlIFR5cGVTY3JpcHQncyBgT21pdGAgdXRpbGl0eS5cbiAqXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byBhdWdtZW50LlxuICogQHBhcmFtIGtleXMgLSBUaGUga2V5cyB0byBvbWl0LlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHRoYXQgd2lsbCBub3QgYWNjZXB0IHRoZSBpbnB1dCBrZXlzLlxuICovXG5mdW5jdGlvbiBvbWl0KHN0cnVjdCwga2V5cykge1xuICAgIGNvbnN0IHsgc2NoZW1hIH0gPSBzdHJ1Y3Q7XG4gICAgY29uc3Qgc3Vic2NoZW1hID0geyAuLi5zY2hlbWEgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGRlbGV0ZSBzdWJzY2hlbWFba2V5XTtcbiAgICB9XG4gICAgc3dpdGNoIChzdHJ1Y3QudHlwZSkge1xuICAgICAgICBjYXNlICd0eXBlJzpcbiAgICAgICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS50eXBlKShzdWJzY2hlbWEpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICgwLCB0eXBlc19qc18xLm9iamVjdCkoc3Vic2NoZW1hKTtcbiAgICB9XG59XG5leHBvcnRzLm9taXQgPSBvbWl0O1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc3RydWN0IGJhc2VkIG9uIGFuIGV4aXN0aW5nIG9iamVjdCBzdHJ1Y3QsIGJ1dCB3aXRoIGFsbCBvZiBpdHNcbiAqIHByb3BlcnRpZXMgYWxsb3dlZCB0byBiZSBgdW5kZWZpbmVkYC5cbiAqXG4gKiBMaWtlIFR5cGVTY3JpcHQncyBgUGFydGlhbGAgdXRpbGl0eS5cbiAqXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byBhdWdtZW50LlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHRoYXQgd2lsbCBhY2NlcHQgdGhlIGlucHV0IGtleXMgYXMgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIHBhcnRpYWwoc3RydWN0KSB7XG4gICAgY29uc3QgaXNTdHJ1Y3QgPSBzdHJ1Y3QgaW5zdGFuY2VvZiBzdHJ1Y3RfanNfMS5TdHJ1Y3Q7XG4gICAgY29uc3Qgc2NoZW1hID0gaXNTdHJ1Y3QgPyB7IC4uLnN0cnVjdC5zY2hlbWEgfSA6IHsgLi4uc3RydWN0IH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICBzY2hlbWFba2V5XSA9ICgwLCB0eXBlc19qc18xLm9wdGlvbmFsKShzY2hlbWFba2V5XSk7XG4gICAgfVxuICAgIGlmIChpc1N0cnVjdCAmJiBzdHJ1Y3QudHlwZSA9PT0gJ3R5cGUnKSB7XG4gICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS50eXBlKShzY2hlbWEpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIHR5cGVzX2pzXzEub2JqZWN0KShzY2hlbWEpO1xufVxuZXhwb3J0cy5wYXJ0aWFsID0gcGFydGlhbDtcbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgb25seSBpbmNsdWRpbmdcbiAqIHNwZWNpZmljIHByb3BlcnRpZXMuXG4gKlxuICogTGlrZSBUeXBlU2NyaXB0J3MgYFBpY2tgIHV0aWxpdHkuXG4gKlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgdG8gYXVnbWVudC5cbiAqIEBwYXJhbSBrZXlzIC0gVGhlIGtleXMgdG8gcGljay5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgdGhlIGlucHV0IGtleXMuXG4gKi9cbmZ1bmN0aW9uIHBpY2soc3RydWN0LCBrZXlzKSB7XG4gICAgY29uc3QgeyBzY2hlbWEgfSA9IHN0cnVjdDtcbiAgICBjb25zdCBzdWJzY2hlbWEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIHN1YnNjaGVtYVtrZXldID0gc2NoZW1hW2tleV07XG4gICAgfVxuICAgIHN3aXRjaCAoc3RydWN0LnR5cGUpIHtcbiAgICAgICAgY2FzZSAndHlwZSc6XG4gICAgICAgICAgICByZXR1cm4gKDAsIHR5cGVzX2pzXzEudHlwZSkoc3Vic2NoZW1hKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS5vYmplY3QpKHN1YnNjaGVtYSk7XG4gICAgfVxufVxuZXhwb3J0cy5waWNrID0gcGljaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxpdGllcy5janMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/superstruct/dist/structs/utilities.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/superstruct/dist/utils.cjs":
/*!***************************************************************!*\
  !*** ../../node_modules/@metamask/superstruct/dist/utils.cjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.run = exports.toFailures = exports.toFailure = exports.shiftIterator = exports.print = exports.isPlainObject = exports.isObject = void 0;\n/**\n * Check if a value is an iterator.\n *\n * @param value - The value to check.\n * @returns Whether the value is an iterator.\n */\nfunction isIterable(value) {\n    return isObject(value) && typeof value[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a plain object.\n */\nfunction isObject(value) {\n    return typeof value === 'object' && value !== null;\n}\nexports.isObject = isObject;\n/**\n * Check if a value is a plain object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a plain object.\n */\nfunction isPlainObject(value) {\n    if (Object.prototype.toString.call(value) !== '[object Object]') {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(value);\n    return prototype === null || prototype === Object.prototype;\n}\nexports.isPlainObject = isPlainObject;\n/**\n * Return a value as a printable string.\n *\n * @param value - The value to print.\n * @returns The value as a string.\n */\nfunction print(value) {\n    if (typeof value === 'symbol') {\n        return value.toString();\n    }\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    return typeof value === 'string' ? JSON.stringify(value) : `${value}`;\n}\nexports.print = print;\n/**\n * Shift (remove and return) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n *\n * @param input - The iterator to shift.\n * @returns The first value of the iterator, or `undefined` if the iterator is\n * empty.\n */\nfunction shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? undefined : value;\n}\nexports.shiftIterator = shiftIterator;\n/**\n * Convert a single validation result to a failure.\n *\n * @param result - The result to convert.\n * @param context - The context of the validation.\n * @param struct - The struct being validated.\n * @param value - The value being validated.\n * @returns A failure if the result is a failure, or `undefined` if the result\n * is a success.\n */\nfunction toFailure(result, context, struct, value) {\n    if (result === true) {\n        return undefined;\n    }\n    else if (result === false) {\n        // eslint-disable-next-line no-param-reassign\n        result = {};\n    }\n    else if (typeof result === 'string') {\n        // eslint-disable-next-line no-param-reassign\n        result = { message: result };\n    }\n    const { path, branch } = context;\n    const { type } = struct;\n    const { refinement, message = `Expected a value of type \\`${type}\\`${refinement ? ` with refinement \\`${refinement}\\`` : ''}, but received: \\`${print(value)}\\``, } = result;\n    return {\n        value,\n        type,\n        refinement,\n        key: path[path.length - 1],\n        path,\n        branch,\n        ...result,\n        message,\n    };\n}\nexports.toFailure = toFailure;\n/**\n * Convert a validation result to an iterable of failures.\n *\n * @param result - The result to convert.\n * @param context - The context of the validation.\n * @param struct - The struct being validated.\n * @param value - The value being validated.\n * @yields The failures.\n * @returns An iterable of failures.\n */\nfunction* toFailures(result, context, struct, value) {\n    if (!isIterable(result)) {\n        // eslint-disable-next-line no-param-reassign\n        result = [result];\n    }\n    for (const validationResult of result) {\n        const failure = toFailure(validationResult, context, struct, value);\n        if (failure) {\n            yield failure;\n        }\n    }\n}\nexports.toFailures = toFailures;\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n *\n * @param value - The value to check.\n * @param struct - The struct to check against.\n * @param options - Optional settings.\n * @param options.path - The path to the value in the input data.\n * @param options.branch - The branch of the value in the input data.\n * @param options.coerce - Whether to coerce the value before validating it.\n * @param options.mask - Whether to mask the value before validating it.\n * @param options.message - An optional message to include in the error.\n * @yields An iterator of failures or success.\n * @returns An iterator of failures or success.\n */\nfunction* run(value, struct, options = {}) {\n    const { path = [], branch = [value], coerce = false, mask = false } = options;\n    const context = { path, branch };\n    if (coerce) {\n        // eslint-disable-next-line no-param-reassign\n        value = struct.coercer(value, context);\n        if (mask &&\n            struct.type !== 'type' &&\n            isObject(struct.schema) &&\n            isObject(value) &&\n            !Array.isArray(value)) {\n            for (const key in value) {\n                if (struct.schema[key] === undefined) {\n                    delete value[key];\n                }\n            }\n        }\n    }\n    let status = 'valid';\n    for (const failure of struct.validator(value, context)) {\n        failure.explanation = options.message;\n        status = 'not_valid';\n        yield [failure, undefined];\n    }\n    // eslint-disable-next-line prefer-const\n    for (let [innerKey, innerValue, innerStruct] of struct.entries(value, context)) {\n        const iterable = run(innerValue, innerStruct, {\n            path: innerKey === undefined ? path : [...path, innerKey],\n            branch: innerKey === undefined ? branch : [...branch, innerValue],\n            coerce,\n            mask,\n            message: options.message,\n        });\n        for (const result of iterable) {\n            if (result[0]) {\n                status =\n                    result[0].refinement === null || result[0].refinement === undefined\n                        ? 'not_valid'\n                        : 'not_refined';\n                yield [result[0], undefined];\n            }\n            else if (coerce) {\n                innerValue = result[1];\n                if (innerKey === undefined) {\n                    // eslint-disable-next-line no-param-reassign\n                    value = innerValue;\n                }\n                else if (value instanceof Map) {\n                    value.set(innerKey, innerValue);\n                }\n                else if (value instanceof Set) {\n                    value.add(innerValue);\n                }\n                else if (isObject(value)) {\n                    if (innerValue !== undefined || innerKey in value) {\n                        value[innerKey] = innerValue;\n                    }\n                }\n            }\n        }\n    }\n    if (status !== 'not_valid') {\n        for (const failure of struct.refiner(value, context)) {\n            failure.explanation = options.message;\n            status = 'not_refined';\n            yield [failure, undefined];\n        }\n    }\n    if (status === 'valid') {\n        yield [undefined, value];\n    }\n}\nexports.run = run;\n//# sourceMappingURL=utils.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zdXBlcnN0cnVjdC9kaXN0L3V0aWxzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxXQUFXLEdBQUcsa0JBQWtCLEdBQUcsaUJBQWlCLEdBQUcscUJBQXFCLEdBQUcsYUFBYSxHQUFHLHFCQUFxQixHQUFHLGdCQUFnQjtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxNQUFNO0FBQ3hFO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxZQUFZLGVBQWU7QUFDM0IsWUFBWSxPQUFPO0FBQ25CLFlBQVksb0RBQW9ELEtBQUssSUFBSSxtQ0FBbUMsV0FBVyxTQUFTLG9CQUFvQixhQUFhLE9BQU87QUFDeEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsWUFBWSw0REFBNEQ7QUFDeEUsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc3VwZXJzdHJ1Y3QvZGlzdC91dGlscy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJ1biA9IGV4cG9ydHMudG9GYWlsdXJlcyA9IGV4cG9ydHMudG9GYWlsdXJlID0gZXhwb3J0cy5zaGlmdEl0ZXJhdG9yID0gZXhwb3J0cy5wcmludCA9IGV4cG9ydHMuaXNQbGFpbk9iamVjdCA9IGV4cG9ydHMuaXNPYmplY3QgPSB2b2lkIDA7XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW4gaXRlcmF0b3IuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYW4gaXRlcmF0b3IuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIHR5cGVvZiB2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgICByZXR1cm4gcHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcbn1cbmV4cG9ydHMuaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG4vKipcbiAqIFJldHVybiBhIHZhbHVlIGFzIGEgcHJpbnRhYmxlIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gcHJpbnQuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgYXMgYSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHByaW50KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnNcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKSA6IGAke3ZhbHVlfWA7XG59XG5leHBvcnRzLnByaW50ID0gcHJpbnQ7XG4vKipcbiAqIFNoaWZ0IChyZW1vdmUgYW5kIHJldHVybikgdGhlIGZpcnN0IHZhbHVlIGZyb20gdGhlIGBpbnB1dGAgaXRlcmF0b3IuXG4gKiBMaWtlIGBBcnJheS5wcm90b3R5cGUuc2hpZnQoKWAgYnV0IGZvciBhbiBgSXRlcmF0b3JgLlxuICpcbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSBpdGVyYXRvciB0byBzaGlmdC5cbiAqIEByZXR1cm5zIFRoZSBmaXJzdCB2YWx1ZSBvZiB0aGUgaXRlcmF0b3IsIG9yIGB1bmRlZmluZWRgIGlmIHRoZSBpdGVyYXRvciBpc1xuICogZW1wdHkuXG4gKi9cbmZ1bmN0aW9uIHNoaWZ0SXRlcmF0b3IoaW5wdXQpIHtcbiAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBpbnB1dC5uZXh0KCk7XG4gICAgcmV0dXJuIGRvbmUgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbn1cbmV4cG9ydHMuc2hpZnRJdGVyYXRvciA9IHNoaWZ0SXRlcmF0b3I7XG4vKipcbiAqIENvbnZlcnQgYSBzaW5nbGUgdmFsaWRhdGlvbiByZXN1bHQgdG8gYSBmYWlsdXJlLlxuICpcbiAqIEBwYXJhbSByZXN1bHQgLSBUaGUgcmVzdWx0IHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IG9mIHRoZSB2YWxpZGF0aW9uLlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgYmVpbmcgdmFsaWRhdGVkLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIGJlaW5nIHZhbGlkYXRlZC5cbiAqIEByZXR1cm5zIEEgZmFpbHVyZSBpZiB0aGUgcmVzdWx0IGlzIGEgZmFpbHVyZSwgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIHJlc3VsdFxuICogaXMgYSBzdWNjZXNzLlxuICovXG5mdW5jdGlvbiB0b0ZhaWx1cmUocmVzdWx0LCBjb250ZXh0LCBzdHJ1Y3QsIHZhbHVlKSB7XG4gICAgaWYgKHJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICByZXN1bHQgPSB7fTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHJlc3VsdCA9IHsgbWVzc2FnZTogcmVzdWx0IH07XG4gICAgfVxuICAgIGNvbnN0IHsgcGF0aCwgYnJhbmNoIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHsgdHlwZSB9ID0gc3RydWN0O1xuICAgIGNvbnN0IHsgcmVmaW5lbWVudCwgbWVzc2FnZSA9IGBFeHBlY3RlZCBhIHZhbHVlIG9mIHR5cGUgXFxgJHt0eXBlfVxcYCR7cmVmaW5lbWVudCA/IGAgd2l0aCByZWZpbmVtZW50IFxcYCR7cmVmaW5lbWVudH1cXGBgIDogJyd9LCBidXQgcmVjZWl2ZWQ6IFxcYCR7cHJpbnQodmFsdWUpfVxcYGAsIH0gPSByZXN1bHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHJlZmluZW1lbnQsXG4gICAgICAgIGtleTogcGF0aFtwYXRoLmxlbmd0aCAtIDFdLFxuICAgICAgICBwYXRoLFxuICAgICAgICBicmFuY2gsXG4gICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgbWVzc2FnZSxcbiAgICB9O1xufVxuZXhwb3J0cy50b0ZhaWx1cmUgPSB0b0ZhaWx1cmU7XG4vKipcbiAqIENvbnZlcnQgYSB2YWxpZGF0aW9uIHJlc3VsdCB0byBhbiBpdGVyYWJsZSBvZiBmYWlsdXJlcy5cbiAqXG4gKiBAcGFyYW0gcmVzdWx0IC0gVGhlIHJlc3VsdCB0byBjb252ZXJ0LlxuICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCBvZiB0aGUgdmFsaWRhdGlvbi5cbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RydWN0IGJlaW5nIHZhbGlkYXRlZC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBiZWluZyB2YWxpZGF0ZWQuXG4gKiBAeWllbGRzIFRoZSBmYWlsdXJlcy5cbiAqIEByZXR1cm5zIEFuIGl0ZXJhYmxlIG9mIGZhaWx1cmVzLlxuICovXG5mdW5jdGlvbiogdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpIHtcbiAgICBpZiAoIWlzSXRlcmFibGUocmVzdWx0KSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgcmVzdWx0ID0gW3Jlc3VsdF07XG4gICAgfVxuICAgIGZvciAoY29uc3QgdmFsaWRhdGlvblJlc3VsdCBvZiByZXN1bHQpIHtcbiAgICAgICAgY29uc3QgZmFpbHVyZSA9IHRvRmFpbHVyZSh2YWxpZGF0aW9uUmVzdWx0LCBjb250ZXh0LCBzdHJ1Y3QsIHZhbHVlKTtcbiAgICAgICAgaWYgKGZhaWx1cmUpIHtcbiAgICAgICAgICAgIHlpZWxkIGZhaWx1cmU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnRvRmFpbHVyZXMgPSB0b0ZhaWx1cmVzO1xuLyoqXG4gKiBDaGVjayBhIHZhbHVlIGFnYWluc3QgYSBzdHJ1Y3QsIHRyYXZlcnNpbmcgZGVlcGx5IGludG8gbmVzdGVkIHZhbHVlcywgYW5kXG4gKiByZXR1cm5pbmcgYW4gaXRlcmF0b3Igb2YgZmFpbHVyZXMgb3Igc3VjY2Vzcy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byBjaGVjayBhZ2FpbnN0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBzZXR0aW5ncy5cbiAqIEBwYXJhbSBvcHRpb25zLnBhdGggLSBUaGUgcGF0aCB0byB0aGUgdmFsdWUgaW4gdGhlIGlucHV0IGRhdGEuXG4gKiBAcGFyYW0gb3B0aW9ucy5icmFuY2ggLSBUaGUgYnJhbmNoIG9mIHRoZSB2YWx1ZSBpbiB0aGUgaW5wdXQgZGF0YS5cbiAqIEBwYXJhbSBvcHRpb25zLmNvZXJjZSAtIFdoZXRoZXIgdG8gY29lcmNlIHRoZSB2YWx1ZSBiZWZvcmUgdmFsaWRhdGluZyBpdC5cbiAqIEBwYXJhbSBvcHRpb25zLm1hc2sgLSBXaGV0aGVyIHRvIG1hc2sgdGhlIHZhbHVlIGJlZm9yZSB2YWxpZGF0aW5nIGl0LlxuICogQHBhcmFtIG9wdGlvbnMubWVzc2FnZSAtIEFuIG9wdGlvbmFsIG1lc3NhZ2UgdG8gaW5jbHVkZSBpbiB0aGUgZXJyb3IuXG4gKiBAeWllbGRzIEFuIGl0ZXJhdG9yIG9mIGZhaWx1cmVzIG9yIHN1Y2Nlc3MuXG4gKiBAcmV0dXJucyBBbiBpdGVyYXRvciBvZiBmYWlsdXJlcyBvciBzdWNjZXNzLlxuICovXG5mdW5jdGlvbiogcnVuKHZhbHVlLCBzdHJ1Y3QsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcGF0aCA9IFtdLCBicmFuY2ggPSBbdmFsdWVdLCBjb2VyY2UgPSBmYWxzZSwgbWFzayA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGNvbnRleHQgPSB7IHBhdGgsIGJyYW5jaCB9O1xuICAgIGlmIChjb2VyY2UpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHZhbHVlID0gc3RydWN0LmNvZXJjZXIodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICBpZiAobWFzayAmJlxuICAgICAgICAgICAgc3RydWN0LnR5cGUgIT09ICd0eXBlJyAmJlxuICAgICAgICAgICAgaXNPYmplY3Qoc3RydWN0LnNjaGVtYSkgJiZcbiAgICAgICAgICAgIGlzT2JqZWN0KHZhbHVlKSAmJlxuICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdHJ1Y3Quc2NoZW1hW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHN0YXR1cyA9ICd2YWxpZCc7XG4gICAgZm9yIChjb25zdCBmYWlsdXJlIG9mIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGNvbnRleHQpKSB7XG4gICAgICAgIGZhaWx1cmUuZXhwbGFuYXRpb24gPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgICAgIHN0YXR1cyA9ICdub3RfdmFsaWQnO1xuICAgICAgICB5aWVsZCBbZmFpbHVyZSwgdW5kZWZpbmVkXTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgIGZvciAobGV0IFtpbm5lcktleSwgaW5uZXJWYWx1ZSwgaW5uZXJTdHJ1Y3RdIG9mIHN0cnVjdC5lbnRyaWVzKHZhbHVlLCBjb250ZXh0KSkge1xuICAgICAgICBjb25zdCBpdGVyYWJsZSA9IHJ1bihpbm5lclZhbHVlLCBpbm5lclN0cnVjdCwge1xuICAgICAgICAgICAgcGF0aDogaW5uZXJLZXkgPT09IHVuZGVmaW5lZCA/IHBhdGggOiBbLi4ucGF0aCwgaW5uZXJLZXldLFxuICAgICAgICAgICAgYnJhbmNoOiBpbm5lcktleSA9PT0gdW5kZWZpbmVkID8gYnJhbmNoIDogWy4uLmJyYW5jaCwgaW5uZXJWYWx1ZV0sXG4gICAgICAgICAgICBjb2VyY2UsXG4gICAgICAgICAgICBtYXNrLFxuICAgICAgICAgICAgbWVzc2FnZTogb3B0aW9ucy5tZXNzYWdlLFxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHRbMF0pIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbMF0ucmVmaW5lbWVudCA9PT0gbnVsbCB8fCByZXN1bHRbMF0ucmVmaW5lbWVudCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICdub3RfdmFsaWQnXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICdub3RfcmVmaW5lZCc7XG4gICAgICAgICAgICAgICAgeWllbGQgW3Jlc3VsdFswXSwgdW5kZWZpbmVkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvZXJjZSkge1xuICAgICAgICAgICAgICAgIGlubmVyVmFsdWUgPSByZXN1bHRbMV07XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaW5uZXJWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2V0KGlubmVyS2V5LCBpbm5lclZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuYWRkKGlubmVyVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyVmFsdWUgIT09IHVuZGVmaW5lZCB8fCBpbm5lcktleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbaW5uZXJLZXldID0gaW5uZXJWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhdHVzICE9PSAnbm90X3ZhbGlkJykge1xuICAgICAgICBmb3IgKGNvbnN0IGZhaWx1cmUgb2Ygc3RydWN0LnJlZmluZXIodmFsdWUsIGNvbnRleHQpKSB7XG4gICAgICAgICAgICBmYWlsdXJlLmV4cGxhbmF0aW9uID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgICAgICAgICAgc3RhdHVzID0gJ25vdF9yZWZpbmVkJztcbiAgICAgICAgICAgIHlpZWxkIFtmYWlsdXJlLCB1bmRlZmluZWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09ICd2YWxpZCcpIHtcbiAgICAgICAgeWllbGQgW3VuZGVmaW5lZCwgdmFsdWVdO1xuICAgIH1cbn1cbmV4cG9ydHMucnVuID0gcnVuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuY2pzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/superstruct/dist/utils.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/dist/assert.cjs":
/*!**********************************************************!*\
  !*** ../../node_modules/@metamask/utils/dist/assert.cjs ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.assertExhaustive = exports.assertStruct = exports.assert = exports.AssertionError = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(rsc)/../../node_modules/@metamask/superstruct/dist/index.cjs\");\nconst errors_1 = __webpack_require__(/*! ./errors.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/errors.cjs\");\n/**\n * Check if a value is a constructor, i.e., a function that can be called with\n * the `new` keyword.\n *\n * @param fn - The value to check.\n * @returns `true` if the value is a constructor, or `false` otherwise.\n */\nfunction isConstructable(fn) {\n    /* istanbul ignore next */\n    return Boolean(typeof fn?.prototype?.constructor?.name === 'string');\n}\n/**\n * Attempts to obtain the message from a possible error object. If it is\n * possible to do so, any trailing period will be removed from the message;\n * otherwise an empty string is returned.\n *\n * @param error - The error object to get the message from.\n * @returns The message without any trailing period if `error` is an object\n * with a `message` property; the string version of `error` without any trailing\n * period if it is not `undefined` or `null`; otherwise an empty string.\n */\nfunction getErrorMessageWithoutTrailingPeriod(error) {\n    // We'll add our own period.\n    return (0, errors_1.getErrorMessage)(error).replace(/\\.$/u, '');\n}\n/**\n * Initialise an {@link AssertionErrorConstructor} error.\n *\n * @param ErrorWrapper - The error class to use.\n * @param message - The error message.\n * @returns The error object.\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction getError(ErrorWrapper, message) {\n    if (isConstructable(ErrorWrapper)) {\n        return new ErrorWrapper({\n            message,\n        });\n    }\n    return ErrorWrapper({\n        message,\n    });\n}\n/**\n * The default error class that is thrown if an assertion fails.\n */\nclass AssertionError extends Error {\n    constructor(options) {\n        super(options.message);\n        this.code = 'ERR_ASSERTION';\n    }\n}\nexports.AssertionError = AssertionError;\n/**\n * Same as Node.js assert.\n * If the value is falsy, throws an error, does nothing otherwise.\n *\n * @throws {@link AssertionError} If value is falsy.\n * @param value - The test that should be truthy to pass.\n * @param message - Message to be passed to {@link AssertionError} or an\n * {@link Error} instance to throw.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}. If a custom error class is provided for\n * the `message` argument, this argument is ignored.\n */\nfunction assert(value, message = 'Assertion failed.', \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper = AssertionError) {\n    if (!value) {\n        if (message instanceof Error) {\n            throw message;\n        }\n        throw getError(ErrorWrapper, message);\n    }\n}\nexports.assert = assert;\n/**\n * Assert a value against a Superstruct struct.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param errorPrefix - A prefix to add to the error message. Defaults to\n * \"Assertion failed\".\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the value is not valid.\n */\nfunction assertStruct(value, struct, errorPrefix = 'Assertion failed', \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper = AssertionError) {\n    try {\n        (0, superstruct_1.assert)(value, struct);\n    }\n    catch (error) {\n        throw getError(ErrorWrapper, `${errorPrefix}: ${getErrorMessageWithoutTrailingPeriod(error)}.`);\n    }\n}\nexports.assertStruct = assertStruct;\n/**\n * Use in the default case of a switch that you want to be fully exhaustive.\n * Using this function forces the compiler to enforce exhaustivity during\n * compile-time.\n *\n * @example\n * ```\n * const number = 1;\n * switch (number) {\n *   case 0:\n *     ...\n *   case 1:\n *     ...\n *   default:\n *     assertExhaustive(snapPrefix);\n * }\n * ```\n * @param _object - The object on which the switch is being operated.\n */\nfunction assertExhaustive(_object) {\n    throw new Error('Invalid branch reached. Should be detected during compilation.');\n}\nexports.assertExhaustive = assertExhaustive;\n//# sourceMappingURL=assert.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2Fzc2VydC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsb0JBQW9CLEdBQUcsY0FBYyxHQUFHLHNCQUFzQjtBQUN6RixzQkFBc0IsbUJBQU8sQ0FBQyw0RkFBdUI7QUFDckQsaUJBQWlCLG1CQUFPLENBQUMsOEVBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUNBQWlDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0EsNkNBQTZDLHNCQUFzQjtBQUNuRSxJQUFJLGFBQWE7QUFDakI7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBWSxJQUFJLDRDQUE0QztBQUNwRztBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9hc3NlcnQuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hc3NlcnRFeGhhdXN0aXZlID0gZXhwb3J0cy5hc3NlcnRTdHJ1Y3QgPSBleHBvcnRzLmFzc2VydCA9IGV4cG9ydHMuQXNzZXJ0aW9uRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcIkBtZXRhbWFzay9zdXBlcnN0cnVjdFwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzLmNqc1wiKTtcbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGNvbnN0cnVjdG9yLCBpLmUuLCBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGNhbGxlZCB3aXRoXG4gKiB0aGUgYG5ld2Aga2V5d29yZC5cbiAqXG4gKiBAcGFyYW0gZm4gLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEgY29uc3RydWN0b3IsIG9yIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0NvbnN0cnVjdGFibGUoZm4pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiBCb29sZWFuKHR5cGVvZiBmbj8ucHJvdG90eXBlPy5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gJ3N0cmluZycpO1xufVxuLyoqXG4gKiBBdHRlbXB0cyB0byBvYnRhaW4gdGhlIG1lc3NhZ2UgZnJvbSBhIHBvc3NpYmxlIGVycm9yIG9iamVjdC4gSWYgaXQgaXNcbiAqIHBvc3NpYmxlIHRvIGRvIHNvLCBhbnkgdHJhaWxpbmcgcGVyaW9kIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBtZXNzYWdlO1xuICogb3RoZXJ3aXNlIGFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3Igb2JqZWN0IHRvIGdldCB0aGUgbWVzc2FnZSBmcm9tLlxuICogQHJldHVybnMgVGhlIG1lc3NhZ2Ugd2l0aG91dCBhbnkgdHJhaWxpbmcgcGVyaW9kIGlmIGBlcnJvcmAgaXMgYW4gb2JqZWN0XG4gKiB3aXRoIGEgYG1lc3NhZ2VgIHByb3BlcnR5OyB0aGUgc3RyaW5nIHZlcnNpb24gb2YgYGVycm9yYCB3aXRob3V0IGFueSB0cmFpbGluZ1xuICogcGVyaW9kIGlmIGl0IGlzIG5vdCBgdW5kZWZpbmVkYCBvciBgbnVsbGA7IG90aGVyd2lzZSBhbiBlbXB0eSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZVdpdGhvdXRUcmFpbGluZ1BlcmlvZChlcnJvcikge1xuICAgIC8vIFdlJ2xsIGFkZCBvdXIgb3duIHBlcmlvZC5cbiAgICByZXR1cm4gKDAsIGVycm9yc18xLmdldEVycm9yTWVzc2FnZSkoZXJyb3IpLnJlcGxhY2UoL1xcLiQvdSwgJycpO1xufVxuLyoqXG4gKiBJbml0aWFsaXNlIGFuIHtAbGluayBBc3NlcnRpb25FcnJvckNvbnN0cnVjdG9yfSBlcnJvci5cbiAqXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHVzZS5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyBUaGUgZXJyb3Igb2JqZWN0LlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5mdW5jdGlvbiBnZXRFcnJvcihFcnJvcldyYXBwZXIsIG1lc3NhZ2UpIHtcbiAgICBpZiAoaXNDb25zdHJ1Y3RhYmxlKEVycm9yV3JhcHBlcikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcldyYXBwZXIoe1xuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBFcnJvcldyYXBwZXIoe1xuICAgICAgICBtZXNzYWdlLFxuICAgIH0pO1xufVxuLyoqXG4gKiBUaGUgZGVmYXVsdCBlcnJvciBjbGFzcyB0aGF0IGlzIHRocm93biBpZiBhbiBhc3NlcnRpb24gZmFpbHMuXG4gKi9cbmNsYXNzIEFzc2VydGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucy5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gJ0VSUl9BU1NFUlRJT04nO1xuICAgIH1cbn1cbmV4cG9ydHMuQXNzZXJ0aW9uRXJyb3IgPSBBc3NlcnRpb25FcnJvcjtcbi8qKlxuICogU2FtZSBhcyBOb2RlLmpzIGFzc2VydC5cbiAqIElmIHRoZSB2YWx1ZSBpcyBmYWxzeSwgdGhyb3dzIGFuIGVycm9yLCBkb2VzIG5vdGhpbmcgb3RoZXJ3aXNlLlxuICpcbiAqIEB0aHJvd3Mge0BsaW5rIEFzc2VydGlvbkVycm9yfSBJZiB2YWx1ZSBpcyBmYWxzeS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB0ZXN0IHRoYXQgc2hvdWxkIGJlIHRydXRoeSB0byBwYXNzLlxuICogQHBhcmFtIG1lc3NhZ2UgLSBNZXNzYWdlIHRvIGJlIHBhc3NlZCB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9IG9yIGFuXG4gKiB7QGxpbmsgRXJyb3J9IGluc3RhbmNlIHRvIHRocm93LlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS4gSWYgYSBjdXN0b20gZXJyb3IgY2xhc3MgaXMgcHJvdmlkZWQgZm9yXG4gKiB0aGUgYG1lc3NhZ2VgIGFyZ3VtZW50LCB0aGlzIGFyZ3VtZW50IGlzIGlnbm9yZWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydCh2YWx1ZSwgbWVzc2FnZSA9ICdBc3NlcnRpb24gZmFpbGVkLicsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyID0gQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZ2V0RXJyb3IoRXJyb3JXcmFwcGVyLCBtZXNzYWdlKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcbi8qKlxuICogQXNzZXJ0IGEgdmFsdWUgYWdhaW5zdCBhIFN1cGVyc3RydWN0IHN0cnVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdmFsaWRhdGUuXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byB2YWxpZGF0ZSBhZ2FpbnN0LlxuICogQHBhcmFtIGVycm9yUHJlZml4IC0gQSBwcmVmaXggdG8gYWRkIHRvIHRoZSBlcnJvciBtZXNzYWdlLiBEZWZhdWx0cyB0b1xuICogXCJBc3NlcnRpb24gZmFpbGVkXCIuXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRTdHJ1Y3QodmFsdWUsIHN0cnVjdCwgZXJyb3JQcmVmaXggPSAnQXNzZXJ0aW9uIGZhaWxlZCcsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyID0gQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICB0cnkge1xuICAgICAgICAoMCwgc3VwZXJzdHJ1Y3RfMS5hc3NlcnQpKHZhbHVlLCBzdHJ1Y3QpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZ2V0RXJyb3IoRXJyb3JXcmFwcGVyLCBgJHtlcnJvclByZWZpeH06ICR7Z2V0RXJyb3JNZXNzYWdlV2l0aG91dFRyYWlsaW5nUGVyaW9kKGVycm9yKX0uYCk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnRTdHJ1Y3QgPSBhc3NlcnRTdHJ1Y3Q7XG4vKipcbiAqIFVzZSBpbiB0aGUgZGVmYXVsdCBjYXNlIG9mIGEgc3dpdGNoIHRoYXQgeW91IHdhbnQgdG8gYmUgZnVsbHkgZXhoYXVzdGl2ZS5cbiAqIFVzaW5nIHRoaXMgZnVuY3Rpb24gZm9yY2VzIHRoZSBjb21waWxlciB0byBlbmZvcmNlIGV4aGF1c3Rpdml0eSBkdXJpbmdcbiAqIGNvbXBpbGUtdGltZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBjb25zdCBudW1iZXIgPSAxO1xuICogc3dpdGNoIChudW1iZXIpIHtcbiAqICAgY2FzZSAwOlxuICogICAgIC4uLlxuICogICBjYXNlIDE6XG4gKiAgICAgLi4uXG4gKiAgIGRlZmF1bHQ6XG4gKiAgICAgYXNzZXJ0RXhoYXVzdGl2ZShzbmFwUHJlZml4KTtcbiAqIH1cbiAqIGBgYFxuICogQHBhcmFtIF9vYmplY3QgLSBUaGUgb2JqZWN0IG9uIHdoaWNoIHRoZSBzd2l0Y2ggaXMgYmVpbmcgb3BlcmF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydEV4aGF1c3RpdmUoX29iamVjdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBicmFuY2ggcmVhY2hlZC4gU2hvdWxkIGJlIGRldGVjdGVkIGR1cmluZyBjb21waWxhdGlvbi4nKTtcbn1cbmV4cG9ydHMuYXNzZXJ0RXhoYXVzdGl2ZSA9IGFzc2VydEV4aGF1c3RpdmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NlcnQuY2pzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/dist/assert.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/dist/base64.cjs":
/*!**********************************************************!*\
  !*** ../../node_modules/@metamask/utils/dist/base64.cjs ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.base64 = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(rsc)/../../node_modules/@metamask/superstruct/dist/index.cjs\");\nconst assert_1 = __webpack_require__(/*! ./assert.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/assert.cjs\");\n/**\n * Ensure that a provided string-based struct is valid base64.\n *\n * @param struct - The string based struct.\n * @param options - Optional options to specialize base64 validation. See {@link Base64Options} documentation.\n * @returns A superstruct validating base64.\n */\nconst base64 = (struct, options = {}) => {\n    const paddingRequired = options.paddingRequired ?? false;\n    const characterSet = options.characterSet ?? 'base64';\n    let letters;\n    if (characterSet === 'base64') {\n        letters = String.raw `[A-Za-z0-9+\\/]`;\n    }\n    else {\n        (0, assert_1.assert)(characterSet === 'base64url');\n        letters = String.raw `[-_A-Za-z0-9]`;\n    }\n    let re;\n    if (paddingRequired) {\n        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{3}=|${letters}{2}==)?$`, 'u');\n    }\n    else {\n        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{2,3}|${letters}{3}=|${letters}{2}==)?$`, 'u');\n    }\n    return (0, superstruct_1.pattern)(struct, re);\n};\nexports.base64 = base64;\n//# sourceMappingURL=base64.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2Jhc2U2NC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLHNCQUFzQixtQkFBTyxDQUFDLDRGQUF1QjtBQUNyRCxpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxxQkFBcUI7QUFDaEc7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsU0FBUyxFQUFFLE9BQU8sU0FBUyxFQUFFLElBQUksU0FBUyxFQUFFO0FBQzNFO0FBQ0E7QUFDQSwrQkFBK0IsU0FBUyxFQUFFLE9BQU8sU0FBUyxJQUFJLEdBQUcsU0FBUyxFQUFFLElBQUksU0FBUyxFQUFFO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYmFzZTY0LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmFzZTY0ID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svc3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydC5janNcIik7XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgcHJvdmlkZWQgc3RyaW5nLWJhc2VkIHN0cnVjdCBpcyB2YWxpZCBiYXNlNjQuXG4gKlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJpbmcgYmFzZWQgc3RydWN0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBvcHRpb25zIHRvIHNwZWNpYWxpemUgYmFzZTY0IHZhbGlkYXRpb24uIFNlZSB7QGxpbmsgQmFzZTY0T3B0aW9uc30gZG9jdW1lbnRhdGlvbi5cbiAqIEByZXR1cm5zIEEgc3VwZXJzdHJ1Y3QgdmFsaWRhdGluZyBiYXNlNjQuXG4gKi9cbmNvbnN0IGJhc2U2NCA9IChzdHJ1Y3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IHBhZGRpbmdSZXF1aXJlZCA9IG9wdGlvbnMucGFkZGluZ1JlcXVpcmVkID8/IGZhbHNlO1xuICAgIGNvbnN0IGNoYXJhY3RlclNldCA9IG9wdGlvbnMuY2hhcmFjdGVyU2V0ID8/ICdiYXNlNjQnO1xuICAgIGxldCBsZXR0ZXJzO1xuICAgIGlmIChjaGFyYWN0ZXJTZXQgPT09ICdiYXNlNjQnKSB7XG4gICAgICAgIGxldHRlcnMgPSBTdHJpbmcucmF3IGBbQS1aYS16MC05K1xcL11gO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgKDAsIGFzc2VydF8xLmFzc2VydCkoY2hhcmFjdGVyU2V0ID09PSAnYmFzZTY0dXJsJyk7XG4gICAgICAgIGxldHRlcnMgPSBTdHJpbmcucmF3IGBbLV9BLVphLXowLTldYDtcbiAgICB9XG4gICAgbGV0IHJlO1xuICAgIGlmIChwYWRkaW5nUmVxdWlyZWQpIHtcbiAgICAgICAgcmUgPSBuZXcgUmVnRXhwKGBeKD86JHtsZXR0ZXJzfXs0fSkqKD86JHtsZXR0ZXJzfXszfT18JHtsZXR0ZXJzfXsyfT09KT8kYCwgJ3UnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlID0gbmV3IFJlZ0V4cChgXig/OiR7bGV0dGVyc317NH0pKig/OiR7bGV0dGVyc317MiwzfXwke2xldHRlcnN9ezN9PXwke2xldHRlcnN9ezJ9PT0pPyRgLCAndScpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEucGF0dGVybikoc3RydWN0LCByZSk7XG59O1xuZXhwb3J0cy5iYXNlNjQgPSBiYXNlNjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjQuY2pzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/dist/base64.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/dist/bytes.cjs":
/*!*********************************************************!*\
  !*** ../../node_modules/@metamask/utils/dist/bytes.cjs ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.areUint8ArraysEqual = exports.createDataView = exports.concatBytes = exports.valueToBytes = exports.base64ToBytes = exports.stringToBytes = exports.numberToBytes = exports.signedBigIntToBytes = exports.bigIntToBytes = exports.hexToBytes = exports.bytesToBase64 = exports.bytesToString = exports.bytesToNumber = exports.bytesToSignedBigInt = exports.bytesToBigInt = exports.bytesToHex = exports.assertIsBytes = exports.isBytes = void 0;\nconst base_1 = __webpack_require__(/*! @scure/base */ \"(rsc)/../../node_modules/@scure/base/lib/index.js\");\nconst assert_1 = __webpack_require__(/*! ./assert.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/assert.cjs\");\nconst hex_1 = __webpack_require__(/*! ./hex.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/hex.cjs\");\n// '0'.charCodeAt(0) === 48\nconst HEX_MINIMUM_NUMBER_CHARACTER = 48;\n// '9'.charCodeAt(0) === 57\nconst HEX_MAXIMUM_NUMBER_CHARACTER = 58;\nconst HEX_CHARACTER_OFFSET = 87;\n/**\n * Memoized function that returns an array to be used as a lookup table for\n * converting bytes to hexadecimal values.\n *\n * The array is created lazily and then cached for future use. The benefit of\n * this approach is that the performance of converting bytes to hex is much\n * better than if we were to call `toString(16)` on each byte.\n *\n * The downside is that the array is created once and then never garbage\n * collected. This is not a problem in practice because the array is only 256\n * elements long.\n *\n * @returns A function that returns the lookup table.\n */\nfunction getPrecomputedHexValuesBuilder() {\n    // To avoid issues with tree shaking, we need to use a function to return the\n    // array. This is because the array is only used in the `bytesToHex` function\n    // and if we were to use a global variable, the array might be removed by the\n    // tree shaker.\n    const lookupTable = [];\n    return () => {\n        if (lookupTable.length === 0) {\n            for (let i = 0; i < 256; i++) {\n                lookupTable.push(i.toString(16).padStart(2, '0'));\n            }\n        }\n        return lookupTable;\n    };\n}\n/**\n * Function implementation of the {@link getPrecomputedHexValuesBuilder}\n * function.\n */\nconst getPrecomputedHexValues = getPrecomputedHexValuesBuilder();\n/**\n * Check if a value is a `Uint8Array`.\n *\n * @param value - The value to check.\n * @returns Whether the value is a `Uint8Array`.\n */\nfunction isBytes(value) {\n    return value instanceof Uint8Array;\n}\nexports.isBytes = isBytes;\n/**\n * Assert that a value is a `Uint8Array`.\n *\n * @param value - The value to check.\n * @throws If the value is not a `Uint8Array`.\n */\nfunction assertIsBytes(value) {\n    (0, assert_1.assert)(isBytes(value), 'Value must be a Uint8Array.');\n}\nexports.assertIsBytes = assertIsBytes;\n/**\n * Convert a `Uint8Array` to a hexadecimal string.\n *\n * @param bytes - The bytes to convert to a hexadecimal string.\n * @returns The hexadecimal string.\n */\nfunction bytesToHex(bytes) {\n    assertIsBytes(bytes);\n    if (bytes.length === 0) {\n        return '0x';\n    }\n    const lookupTable = getPrecomputedHexValues();\n    const hexadecimal = new Array(bytes.length);\n    for (let i = 0; i < bytes.length; i++) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        hexadecimal[i] = lookupTable[bytes[i]];\n    }\n    return (0, hex_1.add0x)(hexadecimal.join(''));\n}\nexports.bytesToHex = bytesToHex;\n/**\n * Convert a `Uint8Array` to a `bigint`.\n *\n * To convert a `Uint8Array` to a `number` instead, use {@link bytesToNumber}.\n * To convert a two's complement encoded `Uint8Array` to a `bigint`, use\n * {@link bytesToSignedBigInt}.\n *\n * @param bytes - The bytes to convert to a `bigint`.\n * @returns The `bigint`.\n */\nfunction bytesToBigInt(bytes) {\n    assertIsBytes(bytes);\n    const hexadecimal = bytesToHex(bytes);\n    return BigInt(hexadecimal);\n}\nexports.bytesToBigInt = bytesToBigInt;\n/**\n * Convert a `Uint8Array` to a signed `bigint`. This assumes that the bytes are\n * encoded in two's complement.\n *\n * To convert a `Uint8Array` to an unsigned `bigint` instead, use\n * {@link bytesToBigInt}.\n *\n * @see https://en.wikipedia.org/wiki/Two%27s_complement\n * @param bytes - The bytes to convert to a signed `bigint`.\n * @returns The signed `bigint`.\n */\nfunction bytesToSignedBigInt(bytes) {\n    assertIsBytes(bytes);\n    let value = BigInt(0);\n    for (const byte of bytes) {\n        // eslint-disable-next-line no-bitwise\n        value = (value << BigInt(8)) + BigInt(byte);\n    }\n    return BigInt.asIntN(bytes.length * 8, value);\n}\nexports.bytesToSignedBigInt = bytesToSignedBigInt;\n/**\n * Convert a `Uint8Array` to a `number`.\n *\n * To convert a `Uint8Array` to a `bigint` instead, use {@link bytesToBigInt}.\n *\n * @param bytes - The bytes to convert to a number.\n * @returns The number.\n * @throws If the resulting number is not a safe integer.\n */\nfunction bytesToNumber(bytes) {\n    assertIsBytes(bytes);\n    const bigint = bytesToBigInt(bytes);\n    (0, assert_1.assert)(bigint <= BigInt(Number.MAX_SAFE_INTEGER), 'Number is not a safe integer. Use `bytesToBigInt` instead.');\n    return Number(bigint);\n}\nexports.bytesToNumber = bytesToNumber;\n/**\n * Convert a UTF-8 encoded `Uint8Array` to a `string`.\n *\n * @param bytes - The bytes to convert to a string.\n * @returns The string.\n */\nfunction bytesToString(bytes) {\n    assertIsBytes(bytes);\n    return new TextDecoder().decode(bytes);\n}\nexports.bytesToString = bytesToString;\n/**\n * Convert a `Uint8Array` to a base64 encoded string.\n *\n * @param bytes - The bytes to convert to a base64 encoded string.\n * @returns The base64 encoded string.\n */\nfunction bytesToBase64(bytes) {\n    assertIsBytes(bytes);\n    return base_1.base64.encode(bytes);\n}\nexports.bytesToBase64 = bytesToBase64;\n/**\n * Convert a hexadecimal string to a `Uint8Array`. The string can optionally be\n * prefixed with `0x`. It accepts even and odd length strings.\n *\n * If the value is \"0x\", an empty `Uint8Array` is returned.\n *\n * @param value - The hexadecimal string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nfunction hexToBytes(value) {\n    // \"0x\" is often used as empty byte array.\n    if (value?.toLowerCase?.() === '0x') {\n        return new Uint8Array();\n    }\n    (0, hex_1.assertIsHexString)(value);\n    // Remove the `0x` prefix if it exists, and pad the string to have an even\n    // number of characters.\n    const strippedValue = (0, hex_1.remove0x)(value).toLowerCase();\n    const normalizedValue = strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;\n    const bytes = new Uint8Array(normalizedValue.length / 2);\n    for (let i = 0; i < bytes.length; i++) {\n        // While this is not the prettiest way to convert a hexadecimal string to a\n        // `Uint8Array`, it is a lot faster than using `parseInt` to convert each\n        // character.\n        const c1 = normalizedValue.charCodeAt(i * 2);\n        const c2 = normalizedValue.charCodeAt(i * 2 + 1);\n        const n1 = c1 -\n            (c1 < HEX_MAXIMUM_NUMBER_CHARACTER\n                ? HEX_MINIMUM_NUMBER_CHARACTER\n                : HEX_CHARACTER_OFFSET);\n        const n2 = c2 -\n            (c2 < HEX_MAXIMUM_NUMBER_CHARACTER\n                ? HEX_MINIMUM_NUMBER_CHARACTER\n                : HEX_CHARACTER_OFFSET);\n        bytes[i] = n1 * 16 + n2;\n    }\n    return bytes;\n}\nexports.hexToBytes = hexToBytes;\n/**\n * Convert a `bigint` to a `Uint8Array`.\n *\n * This assumes that the `bigint` is an unsigned integer. To convert a signed\n * `bigint` instead, use {@link signedBigIntToBytes}.\n *\n * @param value - The bigint to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nfunction bigIntToBytes(value) {\n    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');\n    (0, assert_1.assert)(value >= BigInt(0), 'Value must be a non-negative bigint.');\n    const hexadecimal = value.toString(16);\n    return hexToBytes(hexadecimal);\n}\nexports.bigIntToBytes = bigIntToBytes;\n/**\n * Check if a `bigint` fits in a certain number of bytes.\n *\n * @param value - The `bigint` to check.\n * @param bytes - The number of bytes.\n * @returns Whether the `bigint` fits in the number of bytes.\n */\nfunction bigIntFits(value, bytes) {\n    (0, assert_1.assert)(bytes > 0);\n    /* eslint-disable no-bitwise */\n    const mask = value >> BigInt(31);\n    return !(((~value & mask) + (value & ~mask)) >> BigInt(bytes * 8 + ~0));\n    /* eslint-enable no-bitwise */\n}\n/**\n * Convert a signed `bigint` to a `Uint8Array`. This uses two's complement\n * encoding to represent negative numbers.\n *\n * To convert an unsigned `bigint` to a `Uint8Array` instead, use\n * {@link bigIntToBytes}.\n *\n * @see https://en.wikipedia.org/wiki/Two%27s_complement\n * @param value - The number to convert to bytes.\n * @param byteLength - The length of the resulting `Uint8Array`. If the number\n * is larger than the maximum value that can be represented by the given length,\n * an error is thrown.\n * @returns The bytes as `Uint8Array`.\n */\nfunction signedBigIntToBytes(value, byteLength) {\n    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');\n    (0, assert_1.assert)(typeof byteLength === 'number', 'Byte length must be a number.');\n    (0, assert_1.assert)(byteLength > 0, 'Byte length must be greater than 0.');\n    (0, assert_1.assert)(bigIntFits(value, byteLength), 'Byte length is too small to represent the given value.');\n    // ESLint doesn't like mutating function parameters, so to avoid having to\n    // disable the rule, we create a new variable.\n    let numberValue = value;\n    const bytes = new Uint8Array(byteLength);\n    for (let i = 0; i < bytes.length; i++) {\n        bytes[i] = Number(BigInt.asUintN(8, numberValue));\n        // eslint-disable-next-line no-bitwise\n        numberValue >>= BigInt(8);\n    }\n    return bytes.reverse();\n}\nexports.signedBigIntToBytes = signedBigIntToBytes;\n/**\n * Convert a `number` to a `Uint8Array`.\n *\n * @param value - The number to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n * @throws If the number is not a safe integer.\n */\nfunction numberToBytes(value) {\n    (0, assert_1.assert)(typeof value === 'number', 'Value must be a number.');\n    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative number.');\n    (0, assert_1.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToBytes` instead.');\n    const hexadecimal = value.toString(16);\n    return hexToBytes(hexadecimal);\n}\nexports.numberToBytes = numberToBytes;\n/**\n * Convert a `string` to a UTF-8 encoded `Uint8Array`.\n *\n * @param value - The string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nfunction stringToBytes(value) {\n    (0, assert_1.assert)(typeof value === 'string', 'Value must be a string.');\n    return new TextEncoder().encode(value);\n}\nexports.stringToBytes = stringToBytes;\n/**\n * Convert a base64 encoded string to a `Uint8Array`.\n *\n * @param value - The base64 encoded string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nfunction base64ToBytes(value) {\n    (0, assert_1.assert)(typeof value === 'string', 'Value must be a string.');\n    return base_1.base64.decode(value);\n}\nexports.base64ToBytes = base64ToBytes;\n/**\n * Convert a byte-like value to a `Uint8Array`. The value can be a `Uint8Array`,\n * a `bigint`, a `number`, or a `string`.\n *\n * This will attempt to guess the type of the value based on its type and\n * contents. For more control over the conversion, use the more specific\n * conversion functions, such as {@link hexToBytes} or {@link stringToBytes}.\n *\n * If the value is a `string`, and it is prefixed with `0x`, it will be\n * interpreted as a hexadecimal string. Otherwise, it will be interpreted as a\n * UTF-8 string. To convert a hexadecimal string to bytes without interpreting\n * it as a UTF-8 string, use {@link hexToBytes} instead.\n *\n * If the value is a `bigint`, it is assumed to be unsigned. To convert a signed\n * `bigint` to bytes, use {@link signedBigIntToBytes} instead.\n *\n * If the value is a `Uint8Array`, it will be returned as-is.\n *\n * @param value - The value to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nfunction valueToBytes(value) {\n    if (typeof value === 'bigint') {\n        return bigIntToBytes(value);\n    }\n    if (typeof value === 'number') {\n        return numberToBytes(value);\n    }\n    if (typeof value === 'string') {\n        if (value.startsWith('0x')) {\n            return hexToBytes(value);\n        }\n        return stringToBytes(value);\n    }\n    if (isBytes(value)) {\n        return value;\n    }\n    throw new TypeError(`Unsupported value type: \"${typeof value}\".`);\n}\nexports.valueToBytes = valueToBytes;\n/**\n * Concatenate multiple byte-like values into a single `Uint8Array`. The values\n * can be `Uint8Array`, `bigint`, `number`, or `string`. This uses\n * {@link valueToBytes} under the hood to convert each value to bytes. Refer to\n * the documentation of that function for more information.\n *\n * @param values - The values to concatenate.\n * @returns The concatenated bytes as `Uint8Array`.\n */\nfunction concatBytes(values) {\n    const normalizedValues = new Array(values.length);\n    let byteLength = 0;\n    for (let i = 0; i < values.length; i++) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const value = valueToBytes(values[i]);\n        normalizedValues[i] = value;\n        byteLength += value.length;\n    }\n    const bytes = new Uint8Array(byteLength);\n    for (let i = 0, offset = 0; i < normalizedValues.length; i++) {\n        // While we could simply spread the values into an array and use\n        // `Uint8Array.from`, that is a lot slower than using `Uint8Array.set`.\n        bytes.set(normalizedValues[i], offset);\n        offset += normalizedValues[i].length;\n    }\n    return bytes;\n}\nexports.concatBytes = concatBytes;\n/**\n * Create a {@link DataView} from a {@link Uint8Array}. This is a convenience\n * function that avoids having to create a {@link DataView} manually, which\n * requires passing the `byteOffset` and `byteLength` parameters every time.\n *\n * Not passing the `byteOffset` and `byteLength` parameters can result in\n * unexpected behavior when the {@link Uint8Array} is a view of a larger\n * {@link ArrayBuffer}, e.g., when using {@link Uint8Array.subarray}.\n *\n * This function also supports Node.js {@link Buffer}s.\n *\n * @example\n * ```typescript\n * const bytes = new Uint8Array([1, 2, 3]);\n *\n * // This is equivalent to:\n * // const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n * const dataView = createDataView(bytes);\n * ```\n * @param bytes - The bytes to create the {@link DataView} from.\n * @returns The {@link DataView}.\n */\nfunction createDataView(bytes) {\n    // To maintain compatibility with Node.js, we need to check if the bytes are\n    // a Buffer. If so, we need to slice the buffer to get the underlying\n    // ArrayBuffer.\n    // eslint-disable-next-line no-restricted-globals\n    if (typeof Buffer !== 'undefined' && bytes instanceof Buffer) {\n        const buffer = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);\n        return new DataView(buffer);\n    }\n    return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n}\nexports.createDataView = createDataView;\n/**\n * Compare two Uint8Arrays using a constant-time style loop to reduce timing\n * side-channels when comparing sensitive data (e.g., mnemonic bytes, keys,\n * authentication tags). Does not early-return on the first difference:\n * work done depends only on the input lengths, so byte content does not affect timing.\n *\n * When to use:\n * - Use for secret or security-sensitive byte comparisons to avoid content-based timing leaks.\n * - Prefer when inputs are fixed-length (or validated to equal length) at the API boundary.\n *\n * @param a - The first Uint8Array to compare.\n * @param b - The second Uint8Array to compare.\n * @returns Whether the Uint8Arrays are equal.\n */\nfunction areUint8ArraysEqual(a, b) {\n    // eslint-disable-next-line no-bitwise\n    let diff = a.byteLength ^ b.byteLength;\n    const len = Math.max(a.byteLength, b.byteLength);\n    for (let i = 0; i < len; i++) {\n        const aByte = a[i] ?? 0;\n        const bByte = b[i] ?? 0;\n        // eslint-disable-next-line no-bitwise\n        diff |= aByte ^ bByte;\n    }\n    return diff === 0;\n}\nexports.areUint8ArraysEqual = areUint8ArraysEqual;\n//# sourceMappingURL=bytes.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2J5dGVzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRyxzQkFBc0IsR0FBRyxtQkFBbUIsR0FBRyxvQkFBb0IsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRywyQkFBMkIsR0FBRyxxQkFBcUIsR0FBRyxrQkFBa0IsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRywyQkFBMkIsR0FBRyxxQkFBcUIsR0FBRyxrQkFBa0IsR0FBRyxxQkFBcUIsR0FBRyxlQUFlO0FBQ2piLGVBQWUsbUJBQU8sQ0FBQyxzRUFBYTtBQUNwQyxpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBYztBQUN2QyxjQUFjLG1CQUFPLENBQUMsd0VBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsb0JBQW9CO0FBQzdFO0FBQ0EsSUFBSSwwQkFBMEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG9CQUFvQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxvQkFBb0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsY0FBYztBQUMvRjtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQkFBMEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG9CQUFvQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msa0JBQWtCLElBQUksb0JBQW9CO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtCQUFrQjtBQUNoRDtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxhQUFhO0FBQ2pFO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLElBQUksb0JBQW9CO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw2QkFBNkI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxhQUFhLGdCQUFnQixRQUFRLGlCQUFpQjtBQUN0RCw0Q0FBNEMsZ0JBQWdCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQsSUFBSSxrQkFBa0Isb0JBQW9CLDBCQUEwQjtBQUNwRTtBQUNBLHdDQUF3QyxhQUFhO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQkFBZ0I7QUFDM0QsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9ieXRlcy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFyZVVpbnQ4QXJyYXlzRXF1YWwgPSBleHBvcnRzLmNyZWF0ZURhdGFWaWV3ID0gZXhwb3J0cy5jb25jYXRCeXRlcyA9IGV4cG9ydHMudmFsdWVUb0J5dGVzID0gZXhwb3J0cy5iYXNlNjRUb0J5dGVzID0gZXhwb3J0cy5zdHJpbmdUb0J5dGVzID0gZXhwb3J0cy5udW1iZXJUb0J5dGVzID0gZXhwb3J0cy5zaWduZWRCaWdJbnRUb0J5dGVzID0gZXhwb3J0cy5iaWdJbnRUb0J5dGVzID0gZXhwb3J0cy5oZXhUb0J5dGVzID0gZXhwb3J0cy5ieXRlc1RvQmFzZTY0ID0gZXhwb3J0cy5ieXRlc1RvU3RyaW5nID0gZXhwb3J0cy5ieXRlc1RvTnVtYmVyID0gZXhwb3J0cy5ieXRlc1RvU2lnbmVkQmlnSW50ID0gZXhwb3J0cy5ieXRlc1RvQmlnSW50ID0gZXhwb3J0cy5ieXRlc1RvSGV4ID0gZXhwb3J0cy5hc3NlcnRJc0J5dGVzID0gZXhwb3J0cy5pc0J5dGVzID0gdm9pZCAwO1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIkBzY3VyZS9iYXNlXCIpO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnQuY2pzXCIpO1xuY29uc3QgaGV4XzEgPSByZXF1aXJlKFwiLi9oZXguY2pzXCIpO1xuLy8gJzAnLmNoYXJDb2RlQXQoMCkgPT09IDQ4XG5jb25zdCBIRVhfTUlOSU1VTV9OVU1CRVJfQ0hBUkFDVEVSID0gNDg7XG4vLyAnOScuY2hhckNvZGVBdCgwKSA9PT0gNTdcbmNvbnN0IEhFWF9NQVhJTVVNX05VTUJFUl9DSEFSQUNURVIgPSA1ODtcbmNvbnN0IEhFWF9DSEFSQUNURVJfT0ZGU0VUID0gODc7XG4vKipcbiAqIE1lbW9pemVkIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBhcnJheSB0byBiZSB1c2VkIGFzIGEgbG9va3VwIHRhYmxlIGZvclxuICogY29udmVydGluZyBieXRlcyB0byBoZXhhZGVjaW1hbCB2YWx1ZXMuXG4gKlxuICogVGhlIGFycmF5IGlzIGNyZWF0ZWQgbGF6aWx5IGFuZCB0aGVuIGNhY2hlZCBmb3IgZnV0dXJlIHVzZS4gVGhlIGJlbmVmaXQgb2ZcbiAqIHRoaXMgYXBwcm9hY2ggaXMgdGhhdCB0aGUgcGVyZm9ybWFuY2Ugb2YgY29udmVydGluZyBieXRlcyB0byBoZXggaXMgbXVjaFxuICogYmV0dGVyIHRoYW4gaWYgd2Ugd2VyZSB0byBjYWxsIGB0b1N0cmluZygxNilgIG9uIGVhY2ggYnl0ZS5cbiAqXG4gKiBUaGUgZG93bnNpZGUgaXMgdGhhdCB0aGUgYXJyYXkgaXMgY3JlYXRlZCBvbmNlIGFuZCB0aGVuIG5ldmVyIGdhcmJhZ2VcbiAqIGNvbGxlY3RlZC4gVGhpcyBpcyBub3QgYSBwcm9ibGVtIGluIHByYWN0aWNlIGJlY2F1c2UgdGhlIGFycmF5IGlzIG9ubHkgMjU2XG4gKiBlbGVtZW50cyBsb25nLlxuICpcbiAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBsb29rdXAgdGFibGUuXG4gKi9cbmZ1bmN0aW9uIGdldFByZWNvbXB1dGVkSGV4VmFsdWVzQnVpbGRlcigpIHtcbiAgICAvLyBUbyBhdm9pZCBpc3N1ZXMgd2l0aCB0cmVlIHNoYWtpbmcsIHdlIG5lZWQgdG8gdXNlIGEgZnVuY3Rpb24gdG8gcmV0dXJuIHRoZVxuICAgIC8vIGFycmF5LiBUaGlzIGlzIGJlY2F1c2UgdGhlIGFycmF5IGlzIG9ubHkgdXNlZCBpbiB0aGUgYGJ5dGVzVG9IZXhgIGZ1bmN0aW9uXG4gICAgLy8gYW5kIGlmIHdlIHdlcmUgdG8gdXNlIGEgZ2xvYmFsIHZhcmlhYmxlLCB0aGUgYXJyYXkgbWlnaHQgYmUgcmVtb3ZlZCBieSB0aGVcbiAgICAvLyB0cmVlIHNoYWtlci5cbiAgICBjb25zdCBsb29rdXBUYWJsZSA9IFtdO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChsb29rdXBUYWJsZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsb29rdXBUYWJsZS5wdXNoKGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb29rdXBUYWJsZTtcbiAgICB9O1xufVxuLyoqXG4gKiBGdW5jdGlvbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUge0BsaW5rIGdldFByZWNvbXB1dGVkSGV4VmFsdWVzQnVpbGRlcn1cbiAqIGZ1bmN0aW9uLlxuICovXG5jb25zdCBnZXRQcmVjb21wdXRlZEhleFZhbHVlcyA9IGdldFByZWNvbXB1dGVkSGV4VmFsdWVzQnVpbGRlcigpO1xuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBpc0J5dGVzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheTtcbn1cbmV4cG9ydHMuaXNCeXRlcyA9IGlzQnl0ZXM7XG4vKipcbiAqIEFzc2VydCB0aGF0IGEgdmFsdWUgaXMgYSBgVWludDhBcnJheWAuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0J5dGVzKHZhbHVlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoaXNCeXRlcyh2YWx1ZSksICdWYWx1ZSBtdXN0IGJlIGEgVWludDhBcnJheS4nKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNCeXRlcyA9IGFzc2VydElzQnl0ZXM7XG4vKipcbiAqIENvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJzB4JztcbiAgICB9XG4gICAgY29uc3QgbG9va3VwVGFibGUgPSBnZXRQcmVjb21wdXRlZEhleFZhbHVlcygpO1xuICAgIGNvbnN0IGhleGFkZWNpbWFsID0gbmV3IEFycmF5KGJ5dGVzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBoZXhhZGVjaW1hbFtpXSA9IGxvb2t1cFRhYmxlW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBoZXhfMS5hZGQweCkoaGV4YWRlY2ltYWwuam9pbignJykpO1xufVxuZXhwb3J0cy5ieXRlc1RvSGV4ID0gYnl0ZXNUb0hleDtcbi8qKlxuICogQ29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIGBiaWdpbnRgLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBgbnVtYmVyYCBpbnN0ZWFkLCB1c2Uge0BsaW5rIGJ5dGVzVG9OdW1iZXJ9LlxuICogVG8gY29udmVydCBhIHR3bydzIGNvbXBsZW1lbnQgZW5jb2RlZCBgVWludDhBcnJheWAgdG8gYSBgYmlnaW50YCwgdXNlXG4gKiB7QGxpbmsgYnl0ZXNUb1NpZ25lZEJpZ0ludH0uXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBgYmlnaW50YC5cbiAqIEByZXR1cm5zIFRoZSBgYmlnaW50YC5cbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0JpZ0ludChieXRlcykge1xuICAgIGFzc2VydElzQnl0ZXMoYnl0ZXMpO1xuICAgIGNvbnN0IGhleGFkZWNpbWFsID0gYnl0ZXNUb0hleChieXRlcyk7XG4gICAgcmV0dXJuIEJpZ0ludChoZXhhZGVjaW1hbCk7XG59XG5leHBvcnRzLmJ5dGVzVG9CaWdJbnQgPSBieXRlc1RvQmlnSW50O1xuLyoqXG4gKiBDb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgc2lnbmVkIGBiaWdpbnRgLiBUaGlzIGFzc3VtZXMgdGhhdCB0aGUgYnl0ZXMgYXJlXG4gKiBlbmNvZGVkIGluIHR3bydzIGNvbXBsZW1lbnQuXG4gKlxuICogVG8gY29udmVydCBhIGBVaW50OEFycmF5YCB0byBhbiB1bnNpZ25lZCBgYmlnaW50YCBpbnN0ZWFkLCB1c2VcbiAqIHtAbGluayBieXRlc1RvQmlnSW50fS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1R3byUyN3NfY29tcGxlbWVudFxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBzaWduZWQgYGJpZ2ludGAuXG4gKiBAcmV0dXJucyBUaGUgc2lnbmVkIGBiaWdpbnRgLlxuICovXG5mdW5jdGlvbiBieXRlc1RvU2lnbmVkQmlnSW50KGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgbGV0IHZhbHVlID0gQmlnSW50KDApO1xuICAgIGZvciAoY29uc3QgYnl0ZSBvZiBieXRlcykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSA8PCBCaWdJbnQoOCkpICsgQmlnSW50KGJ5dGUpO1xuICAgIH1cbiAgICByZXR1cm4gQmlnSW50LmFzSW50TihieXRlcy5sZW5ndGggKiA4LCB2YWx1ZSk7XG59XG5leHBvcnRzLmJ5dGVzVG9TaWduZWRCaWdJbnQgPSBieXRlc1RvU2lnbmVkQmlnSW50O1xuLyoqXG4gKiBDb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgYG51bWJlcmAuXG4gKlxuICogVG8gY29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIGBiaWdpbnRgIGluc3RlYWQsIHVzZSB7QGxpbmsgYnl0ZXNUb0JpZ0ludH0uXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBudW1iZXIuXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyLlxuICogQHRocm93cyBJZiB0aGUgcmVzdWx0aW5nIG51bWJlciBpcyBub3QgYSBzYWZlIGludGVnZXIuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXIoYnl0ZXMpIHtcbiAgICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgICBjb25zdCBiaWdpbnQgPSBieXRlc1RvQmlnSW50KGJ5dGVzKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShiaWdpbnQgPD0gQmlnSW50KE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSwgJ051bWJlciBpcyBub3QgYSBzYWZlIGludGVnZXIuIFVzZSBgYnl0ZXNUb0JpZ0ludGAgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gTnVtYmVyKGJpZ2ludCk7XG59XG5leHBvcnRzLmJ5dGVzVG9OdW1iZXIgPSBieXRlc1RvTnVtYmVyO1xuLyoqXG4gKiBDb252ZXJ0IGEgVVRGLTggZW5jb2RlZCBgVWludDhBcnJheWAgdG8gYSBgc3RyaW5nYC5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY29udmVydCB0byBhIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9TdHJpbmcoYnl0ZXMpIHtcbiAgICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ5dGVzKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb1N0cmluZyA9IGJ5dGVzVG9TdHJpbmc7XG4vKipcbiAqIENvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBieXRlc1RvQmFzZTY0KGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgcmV0dXJuIGJhc2VfMS5iYXNlNjQuZW5jb2RlKGJ5dGVzKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb0Jhc2U2NCA9IGJ5dGVzVG9CYXNlNjQ7XG4vKipcbiAqIENvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBgVWludDhBcnJheWAuIFRoZSBzdHJpbmcgY2FuIG9wdGlvbmFsbHkgYmVcbiAqIHByZWZpeGVkIHdpdGggYDB4YC4gSXQgYWNjZXB0cyBldmVuIGFuZCBvZGQgbGVuZ3RoIHN0cmluZ3MuXG4gKlxuICogSWYgdGhlIHZhbHVlIGlzIFwiMHhcIiwgYW4gZW1wdHkgYFVpbnQ4QXJyYXlgIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGhleFRvQnl0ZXModmFsdWUpIHtcbiAgICAvLyBcIjB4XCIgaXMgb2Z0ZW4gdXNlZCBhcyBlbXB0eSBieXRlIGFycmF5LlxuICAgIGlmICh2YWx1ZT8udG9Mb3dlckNhc2U/LigpID09PSAnMHgnKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgpO1xuICAgIH1cbiAgICAoMCwgaGV4XzEuYXNzZXJ0SXNIZXhTdHJpbmcpKHZhbHVlKTtcbiAgICAvLyBSZW1vdmUgdGhlIGAweGAgcHJlZml4IGlmIGl0IGV4aXN0cywgYW5kIHBhZCB0aGUgc3RyaW5nIHRvIGhhdmUgYW4gZXZlblxuICAgIC8vIG51bWJlciBvZiBjaGFyYWN0ZXJzLlxuICAgIGNvbnN0IHN0cmlwcGVkVmFsdWUgPSAoMCwgaGV4XzEucmVtb3ZlMHgpKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZSA9IHN0cmlwcGVkVmFsdWUubGVuZ3RoICUgMiA9PT0gMCA/IHN0cmlwcGVkVmFsdWUgOiBgMCR7c3RyaXBwZWRWYWx1ZX1gO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobm9ybWFsaXplZFZhbHVlLmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gV2hpbGUgdGhpcyBpcyBub3QgdGhlIHByZXR0aWVzdCB3YXkgdG8gY29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBhXG4gICAgICAgIC8vIGBVaW50OEFycmF5YCwgaXQgaXMgYSBsb3QgZmFzdGVyIHRoYW4gdXNpbmcgYHBhcnNlSW50YCB0byBjb252ZXJ0IGVhY2hcbiAgICAgICAgLy8gY2hhcmFjdGVyLlxuICAgICAgICBjb25zdCBjMSA9IG5vcm1hbGl6ZWRWYWx1ZS5jaGFyQ29kZUF0KGkgKiAyKTtcbiAgICAgICAgY29uc3QgYzIgPSBub3JtYWxpemVkVmFsdWUuY2hhckNvZGVBdChpICogMiArIDEpO1xuICAgICAgICBjb25zdCBuMSA9IGMxIC1cbiAgICAgICAgICAgIChjMSA8IEhFWF9NQVhJTVVNX05VTUJFUl9DSEFSQUNURVJcbiAgICAgICAgICAgICAgICA/IEhFWF9NSU5JTVVNX05VTUJFUl9DSEFSQUNURVJcbiAgICAgICAgICAgICAgICA6IEhFWF9DSEFSQUNURVJfT0ZGU0VUKTtcbiAgICAgICAgY29uc3QgbjIgPSBjMiAtXG4gICAgICAgICAgICAoYzIgPCBIRVhfTUFYSU1VTV9OVU1CRVJfQ0hBUkFDVEVSXG4gICAgICAgICAgICAgICAgPyBIRVhfTUlOSU1VTV9OVU1CRVJfQ0hBUkFDVEVSXG4gICAgICAgICAgICAgICAgOiBIRVhfQ0hBUkFDVEVSX09GRlNFVCk7XG4gICAgICAgIGJ5dGVzW2ldID0gbjEgKiAxNiArIG4yO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5leHBvcnRzLmhleFRvQnl0ZXMgPSBoZXhUb0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYGJpZ2ludGAgdG8gYSBgVWludDhBcnJheWAuXG4gKlxuICogVGhpcyBhc3N1bWVzIHRoYXQgdGhlIGBiaWdpbnRgIGlzIGFuIHVuc2lnbmVkIGludGVnZXIuIFRvIGNvbnZlcnQgYSBzaWduZWRcbiAqIGBiaWdpbnRgIGluc3RlYWQsIHVzZSB7QGxpbmsgc2lnbmVkQmlnSW50VG9CeXRlc30uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGJpZ2ludCB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICogQHJldHVybnMgVGhlIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYmlnSW50VG9CeXRlcyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcsICdWYWx1ZSBtdXN0IGJlIGEgYmlnaW50LicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHZhbHVlID49IEJpZ0ludCgwKSwgJ1ZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgYmlnaW50LicpO1xuICAgIGNvbnN0IGhleGFkZWNpbWFsID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXhUb0J5dGVzKGhleGFkZWNpbWFsKTtcbn1cbmV4cG9ydHMuYmlnSW50VG9CeXRlcyA9IGJpZ0ludFRvQnl0ZXM7XG4vKipcbiAqIENoZWNrIGlmIGEgYGJpZ2ludGAgZml0cyBpbiBhIGNlcnRhaW4gbnVtYmVyIG9mIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBgYmlnaW50YCB0byBjaGVjay5cbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBudW1iZXIgb2YgYnl0ZXMuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBgYmlnaW50YCBmaXRzIGluIHRoZSBudW1iZXIgb2YgYnl0ZXMuXG4gKi9cbmZ1bmN0aW9uIGJpZ0ludEZpdHModmFsdWUsIGJ5dGVzKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoYnl0ZXMgPiAwKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG4gICAgY29uc3QgbWFzayA9IHZhbHVlID4+IEJpZ0ludCgzMSk7XG4gICAgcmV0dXJuICEoKCh+dmFsdWUgJiBtYXNrKSArICh2YWx1ZSAmIH5tYXNrKSkgPj4gQmlnSW50KGJ5dGVzICogOCArIH4wKSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1iaXR3aXNlICovXG59XG4vKipcbiAqIENvbnZlcnQgYSBzaWduZWQgYGJpZ2ludGAgdG8gYSBgVWludDhBcnJheWAuIFRoaXMgdXNlcyB0d28ncyBjb21wbGVtZW50XG4gKiBlbmNvZGluZyB0byByZXByZXNlbnQgbmVnYXRpdmUgbnVtYmVycy5cbiAqXG4gKiBUbyBjb252ZXJ0IGFuIHVuc2lnbmVkIGBiaWdpbnRgIHRvIGEgYFVpbnQ4QXJyYXlgIGluc3RlYWQsIHVzZVxuICoge0BsaW5rIGJpZ0ludFRvQnl0ZXN9LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHdvJTI3c19jb21wbGVtZW50XG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcGFyYW0gYnl0ZUxlbmd0aCAtIFRoZSBsZW5ndGggb2YgdGhlIHJlc3VsdGluZyBgVWludDhBcnJheWAuIElmIHRoZSBudW1iZXJcbiAqIGlzIGxhcmdlciB0aGFuIHRoZSBtYXhpbXVtIHZhbHVlIHRoYXQgY2FuIGJlIHJlcHJlc2VudGVkIGJ5IHRoZSBnaXZlbiBsZW5ndGgsXG4gKiBhbiBlcnJvciBpcyB0aHJvd24uXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBzaWduZWRCaWdJbnRUb0J5dGVzKHZhbHVlLCBieXRlTGVuZ3RoKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JywgJ1ZhbHVlIG11c3QgYmUgYSBiaWdpbnQuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIGJ5dGVMZW5ndGggPT09ICdudW1iZXInLCAnQnl0ZSBsZW5ndGggbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShieXRlTGVuZ3RoID4gMCwgJ0J5dGUgbGVuZ3RoIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoYmlnSW50Rml0cyh2YWx1ZSwgYnl0ZUxlbmd0aCksICdCeXRlIGxlbmd0aCBpcyB0b28gc21hbGwgdG8gcmVwcmVzZW50IHRoZSBnaXZlbiB2YWx1ZS4nKTtcbiAgICAvLyBFU0xpbnQgZG9lc24ndCBsaWtlIG11dGF0aW5nIGZ1bmN0aW9uIHBhcmFtZXRlcnMsIHNvIHRvIGF2b2lkIGhhdmluZyB0b1xuICAgIC8vIGRpc2FibGUgdGhlIHJ1bGUsIHdlIGNyZWF0ZSBhIG5ldyB2YXJpYWJsZS5cbiAgICBsZXQgbnVtYmVyVmFsdWUgPSB2YWx1ZTtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVMZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYnl0ZXNbaV0gPSBOdW1iZXIoQmlnSW50LmFzVWludE4oOCwgbnVtYmVyVmFsdWUpKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgbnVtYmVyVmFsdWUgPj49IEJpZ0ludCg4KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzLnJldmVyc2UoKTtcbn1cbmV4cG9ydHMuc2lnbmVkQmlnSW50VG9CeXRlcyA9IHNpZ25lZEJpZ0ludFRvQnl0ZXM7XG4vKipcbiAqIENvbnZlcnQgYSBgbnVtYmVyYCB0byBhIGBVaW50OEFycmF5YC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICogQHRocm93cyBJZiB0aGUgbnVtYmVyIGlzIG5vdCBhIHNhZmUgaW50ZWdlci5cbiAqL1xuZnVuY3Rpb24gbnVtYmVyVG9CeXRlcyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdWYWx1ZSBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHZhbHVlID49IDAsICdWYWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSksICdWYWx1ZSBpcyBub3QgYSBzYWZlIGludGVnZXIuIFVzZSBgYmlnSW50VG9CeXRlc2AgaW5zdGVhZC4nKTtcbiAgICBjb25zdCBoZXhhZGVjaW1hbCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhoZXhhZGVjaW1hbCk7XG59XG5leHBvcnRzLm51bWJlclRvQnl0ZXMgPSBudW1iZXJUb0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYHN0cmluZ2AgdG8gYSBVVEYtOCBlbmNvZGVkIGBVaW50OEFycmF5YC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHZhbHVlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJywgJ1ZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSk7XG59XG5leHBvcnRzLnN0cmluZ1RvQnl0ZXMgPSBzdHJpbmdUb0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIGEgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXModmFsdWUpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnLCAnVmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICByZXR1cm4gYmFzZV8xLmJhc2U2NC5kZWNvZGUodmFsdWUpO1xufVxuZXhwb3J0cy5iYXNlNjRUb0J5dGVzID0gYmFzZTY0VG9CeXRlcztcbi8qKlxuICogQ29udmVydCBhIGJ5dGUtbGlrZSB2YWx1ZSB0byBhIGBVaW50OEFycmF5YC4gVGhlIHZhbHVlIGNhbiBiZSBhIGBVaW50OEFycmF5YCxcbiAqIGEgYGJpZ2ludGAsIGEgYG51bWJlcmAsIG9yIGEgYHN0cmluZ2AuXG4gKlxuICogVGhpcyB3aWxsIGF0dGVtcHQgdG8gZ3Vlc3MgdGhlIHR5cGUgb2YgdGhlIHZhbHVlIGJhc2VkIG9uIGl0cyB0eXBlIGFuZFxuICogY29udGVudHMuIEZvciBtb3JlIGNvbnRyb2wgb3ZlciB0aGUgY29udmVyc2lvbiwgdXNlIHRoZSBtb3JlIHNwZWNpZmljXG4gKiBjb252ZXJzaW9uIGZ1bmN0aW9ucywgc3VjaCBhcyB7QGxpbmsgaGV4VG9CeXRlc30gb3Ige0BsaW5rIHN0cmluZ1RvQnl0ZXN9LlxuICpcbiAqIElmIHRoZSB2YWx1ZSBpcyBhIGBzdHJpbmdgLCBhbmQgaXQgaXMgcHJlZml4ZWQgd2l0aCBgMHhgLCBpdCB3aWxsIGJlXG4gKiBpbnRlcnByZXRlZCBhcyBhIGhleGFkZWNpbWFsIHN0cmluZy4gT3RoZXJ3aXNlLCBpdCB3aWxsIGJlIGludGVycHJldGVkIGFzIGFcbiAqIFVURi04IHN0cmluZy4gVG8gY29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBieXRlcyB3aXRob3V0IGludGVycHJldGluZ1xuICogaXQgYXMgYSBVVEYtOCBzdHJpbmcsIHVzZSB7QGxpbmsgaGV4VG9CeXRlc30gaW5zdGVhZC5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgaXMgYSBgYmlnaW50YCwgaXQgaXMgYXNzdW1lZCB0byBiZSB1bnNpZ25lZC4gVG8gY29udmVydCBhIHNpZ25lZFxuICogYGJpZ2ludGAgdG8gYnl0ZXMsIHVzZSB7QGxpbmsgc2lnbmVkQmlnSW50VG9CeXRlc30gaW5zdGVhZC5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgaXMgYSBgVWludDhBcnJheWAsIGl0IHdpbGwgYmUgcmV0dXJuZWQgYXMtaXMuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiB2YWx1ZVRvQnl0ZXModmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgICAgICByZXR1cm4gYmlnSW50VG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBudW1iZXJUb0J5dGVzKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgICAgIHJldHVybiBoZXhUb0J5dGVzKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5nVG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChpc0J5dGVzKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHZhbHVlIHR5cGU6IFwiJHt0eXBlb2YgdmFsdWV9XCIuYCk7XG59XG5leHBvcnRzLnZhbHVlVG9CeXRlcyA9IHZhbHVlVG9CeXRlcztcbi8qKlxuICogQ29uY2F0ZW5hdGUgbXVsdGlwbGUgYnl0ZS1saWtlIHZhbHVlcyBpbnRvIGEgc2luZ2xlIGBVaW50OEFycmF5YC4gVGhlIHZhbHVlc1xuICogY2FuIGJlIGBVaW50OEFycmF5YCwgYGJpZ2ludGAsIGBudW1iZXJgLCBvciBgc3RyaW5nYC4gVGhpcyB1c2VzXG4gKiB7QGxpbmsgdmFsdWVUb0J5dGVzfSB1bmRlciB0aGUgaG9vZCB0byBjb252ZXJ0IGVhY2ggdmFsdWUgdG8gYnl0ZXMuIFJlZmVyIHRvXG4gKiB0aGUgZG9jdW1lbnRhdGlvbiBvZiB0aGF0IGZ1bmN0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIGNvbmNhdGVuYXRlLlxuICogQHJldHVybnMgVGhlIGNvbmNhdGVuYXRlZCBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKHZhbHVlcykge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZXMgPSBuZXcgQXJyYXkodmFsdWVzLmxlbmd0aCk7XG4gICAgbGV0IGJ5dGVMZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVUb0J5dGVzKHZhbHVlc1tpXSk7XG4gICAgICAgIG5vcm1hbGl6ZWRWYWx1ZXNbaV0gPSB2YWx1ZTtcbiAgICAgICAgYnl0ZUxlbmd0aCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZUxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIG9mZnNldCA9IDA7IGkgPCBub3JtYWxpemVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIFdoaWxlIHdlIGNvdWxkIHNpbXBseSBzcHJlYWQgdGhlIHZhbHVlcyBpbnRvIGFuIGFycmF5IGFuZCB1c2VcbiAgICAgICAgLy8gYFVpbnQ4QXJyYXkuZnJvbWAsIHRoYXQgaXMgYSBsb3Qgc2xvd2VyIHRoYW4gdXNpbmcgYFVpbnQ4QXJyYXkuc2V0YC5cbiAgICAgICAgYnl0ZXMuc2V0KG5vcm1hbGl6ZWRWYWx1ZXNbaV0sIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBub3JtYWxpemVkVmFsdWVzW2ldLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuZXhwb3J0cy5jb25jYXRCeXRlcyA9IGNvbmNhdEJ5dGVzO1xuLyoqXG4gKiBDcmVhdGUgYSB7QGxpbmsgRGF0YVZpZXd9IGZyb20gYSB7QGxpbmsgVWludDhBcnJheX0uIFRoaXMgaXMgYSBjb252ZW5pZW5jZVxuICogZnVuY3Rpb24gdGhhdCBhdm9pZHMgaGF2aW5nIHRvIGNyZWF0ZSBhIHtAbGluayBEYXRhVmlld30gbWFudWFsbHksIHdoaWNoXG4gKiByZXF1aXJlcyBwYXNzaW5nIHRoZSBgYnl0ZU9mZnNldGAgYW5kIGBieXRlTGVuZ3RoYCBwYXJhbWV0ZXJzIGV2ZXJ5IHRpbWUuXG4gKlxuICogTm90IHBhc3NpbmcgdGhlIGBieXRlT2Zmc2V0YCBhbmQgYGJ5dGVMZW5ndGhgIHBhcmFtZXRlcnMgY2FuIHJlc3VsdCBpblxuICogdW5leHBlY3RlZCBiZWhhdmlvciB3aGVuIHRoZSB7QGxpbmsgVWludDhBcnJheX0gaXMgYSB2aWV3IG9mIGEgbGFyZ2VyXG4gKiB7QGxpbmsgQXJyYXlCdWZmZXJ9LCBlLmcuLCB3aGVuIHVzaW5nIHtAbGluayBVaW50OEFycmF5LnN1YmFycmF5fS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGFsc28gc3VwcG9ydHMgTm9kZS5qcyB7QGxpbmsgQnVmZmVyfXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoWzEsIDIsIDNdKTtcbiAqXG4gKiAvLyBUaGlzIGlzIGVxdWl2YWxlbnQgdG86XG4gKiAvLyBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVMZW5ndGgpO1xuICogY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVEYXRhVmlldyhieXRlcyk7XG4gKiBgYGBcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBjcmVhdGUgdGhlIHtAbGluayBEYXRhVmlld30gZnJvbS5cbiAqIEByZXR1cm5zIFRoZSB7QGxpbmsgRGF0YVZpZXd9LlxuICovXG5mdW5jdGlvbiBjcmVhdGVEYXRhVmlldyhieXRlcykge1xuICAgIC8vIFRvIG1haW50YWluIGNvbXBhdGliaWxpdHkgd2l0aCBOb2RlLmpzLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBieXRlcyBhcmVcbiAgICAvLyBhIEJ1ZmZlci4gSWYgc28sIHdlIG5lZWQgdG8gc2xpY2UgdGhlIGJ1ZmZlciB0byBnZXQgdGhlIHVuZGVybHlpbmdcbiAgICAvLyBBcnJheUJ1ZmZlci5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGJ5dGVzIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGJ5dGVzLmJ1ZmZlci5zbGljZShieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlT2Zmc2V0ICsgYnl0ZXMuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVMZW5ndGgpO1xufVxuZXhwb3J0cy5jcmVhdGVEYXRhVmlldyA9IGNyZWF0ZURhdGFWaWV3O1xuLyoqXG4gKiBDb21wYXJlIHR3byBVaW50OEFycmF5cyB1c2luZyBhIGNvbnN0YW50LXRpbWUgc3R5bGUgbG9vcCB0byByZWR1Y2UgdGltaW5nXG4gKiBzaWRlLWNoYW5uZWxzIHdoZW4gY29tcGFyaW5nIHNlbnNpdGl2ZSBkYXRhIChlLmcuLCBtbmVtb25pYyBieXRlcywga2V5cyxcbiAqIGF1dGhlbnRpY2F0aW9uIHRhZ3MpLiBEb2VzIG5vdCBlYXJseS1yZXR1cm4gb24gdGhlIGZpcnN0IGRpZmZlcmVuY2U6XG4gKiB3b3JrIGRvbmUgZGVwZW5kcyBvbmx5IG9uIHRoZSBpbnB1dCBsZW5ndGhzLCBzbyBieXRlIGNvbnRlbnQgZG9lcyBub3QgYWZmZWN0IHRpbWluZy5cbiAqXG4gKiBXaGVuIHRvIHVzZTpcbiAqIC0gVXNlIGZvciBzZWNyZXQgb3Igc2VjdXJpdHktc2Vuc2l0aXZlIGJ5dGUgY29tcGFyaXNvbnMgdG8gYXZvaWQgY29udGVudC1iYXNlZCB0aW1pbmcgbGVha3MuXG4gKiAtIFByZWZlciB3aGVuIGlucHV0cyBhcmUgZml4ZWQtbGVuZ3RoIChvciB2YWxpZGF0ZWQgdG8gZXF1YWwgbGVuZ3RoKSBhdCB0aGUgQVBJIGJvdW5kYXJ5LlxuICpcbiAqIEBwYXJhbSBhIC0gVGhlIGZpcnN0IFVpbnQ4QXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSBiIC0gVGhlIHNlY29uZCBVaW50OEFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBVaW50OEFycmF5cyBhcmUgZXF1YWwuXG4gKi9cbmZ1bmN0aW9uIGFyZVVpbnQ4QXJyYXlzRXF1YWwoYSwgYikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgbGV0IGRpZmYgPSBhLmJ5dGVMZW5ndGggXiBiLmJ5dGVMZW5ndGg7XG4gICAgY29uc3QgbGVuID0gTWF0aC5tYXgoYS5ieXRlTGVuZ3RoLCBiLmJ5dGVMZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgYUJ5dGUgPSBhW2ldID8/IDA7XG4gICAgICAgIGNvbnN0IGJCeXRlID0gYltpXSA/PyAwO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICBkaWZmIHw9IGFCeXRlIF4gYkJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBkaWZmID09PSAwO1xufVxuZXhwb3J0cy5hcmVVaW50OEFycmF5c0VxdWFsID0gYXJlVWludDhBcnJheXNFcXVhbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ5dGVzLmNqcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/dist/bytes.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/dist/caip-types.cjs":
/*!**************************************************************!*\
  !*** ../../node_modules/@metamask/utils/dist/caip-types.cjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toCaipAssetId = exports.toCaipAssetType = exports.toCaipAccountId = exports.toCaipChainId = exports.parseCaipAssetId = exports.parseCaipAssetType = exports.parseCaipAccountId = exports.parseCaipChainId = exports.isCaipAssetId = exports.isCaipAssetType = exports.isCaipTokenId = exports.isCaipAssetReference = exports.isCaipAssetNamespace = exports.isCaipAccountAddress = exports.isCaipAccountId = exports.isCaipReference = exports.isCaipNamespace = exports.isCaipChainId = exports.KnownCaipNamespace = exports.CaipAssetTypeOrIdStruct = exports.CaipAssetIdStruct = exports.CaipAssetTypeStruct = exports.CaipTokenIdStruct = exports.CaipAssetReferenceStruct = exports.CaipAssetNamespaceStruct = exports.CaipAccountAddressStruct = exports.CaipAccountIdStruct = exports.CaipReferenceStruct = exports.CaipNamespaceStruct = exports.CaipChainIdStruct = exports.CAIP_ASSET_ID_REGEX = exports.CAIP_ASSET_TYPE_REGEX = exports.CAIP_TOKEN_ID_REGEX = exports.CAIP_ASSET_REFERENCE_REGEX = exports.CAIP_ASSET_NAMESPACE_REGEX = exports.CAIP_ACCOUNT_ADDRESS_REGEX = exports.CAIP_ACCOUNT_ID_REGEX = exports.CAIP_REFERENCE_REGEX = exports.CAIP_NAMESPACE_REGEX = exports.CAIP_CHAIN_ID_REGEX = void 0;\nconst superstruct_1 = __webpack_require__(/*! ./superstruct.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/superstruct.cjs\");\nexports.CAIP_CHAIN_ID_REGEX = /^(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32})$/u;\nexports.CAIP_NAMESPACE_REGEX = /^[-a-z0-9]{3,8}$/u;\nexports.CAIP_REFERENCE_REGEX = /^[-_a-zA-Z0-9]{1,32}$/u;\nexports.CAIP_ACCOUNT_ID_REGEX = /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32})):(?<accountAddress>[-.%a-zA-Z0-9]{1,128})$/u;\nexports.CAIP_ACCOUNT_ADDRESS_REGEX = /^[-.%a-zA-Z0-9]{1,128}$/u;\nexports.CAIP_ASSET_NAMESPACE_REGEX = /^[-a-z0-9]{3,8}$/u;\nexports.CAIP_ASSET_REFERENCE_REGEX = /^[-.%a-zA-Z0-9]{1,128}$/u;\nexports.CAIP_TOKEN_ID_REGEX = /^[-.%a-zA-Z0-9]{1,78}$/u;\nexports.CAIP_ASSET_TYPE_REGEX = /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32}))\\/(?<assetNamespace>[-a-z0-9]{3,8}):(?<assetReference>[-.%a-zA-Z0-9]{1,128})$/u;\nexports.CAIP_ASSET_ID_REGEX = /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32}))\\/(?<assetNamespace>[-a-z0-9]{3,8}):(?<assetReference>[-.%a-zA-Z0-9]{1,128})\\/(?<tokenId>[-.%a-zA-Z0-9]{1,78})$/u;\nconst CAIP_ASSET_TYPE_OR_ID_REGEX = /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32}))\\/(?<assetNamespace>[-a-z0-9]{3,8}):(?<assetReference>[-.%a-zA-Z0-9]{1,128})(\\/(?<tokenId>[-.%a-zA-Z0-9]{1,78}))?$/u;\n/**\n * A CAIP-2 chain ID, i.e., a human-readable namespace and reference.\n */\nexports.CaipChainIdStruct = (0, superstruct_1.definePattern)('CaipChainId', exports.CAIP_CHAIN_ID_REGEX);\n/**\n * A CAIP-2 namespace, i.e., the first part of a CAIP chain ID.\n */\nexports.CaipNamespaceStruct = (0, superstruct_1.definePattern)('CaipNamespace', exports.CAIP_NAMESPACE_REGEX);\n/**\n * A CAIP-2 reference, i.e., the second part of a CAIP chain ID.\n */\nexports.CaipReferenceStruct = (0, superstruct_1.definePattern)('CaipReference', exports.CAIP_REFERENCE_REGEX);\n/**\n * A CAIP-10 account ID, i.e., a human-readable namespace, reference, and account address.\n */\nexports.CaipAccountIdStruct = (0, superstruct_1.definePattern)('CaipAccountId', exports.CAIP_ACCOUNT_ID_REGEX);\n/**\n * A CAIP-10 account address, i.e., the third part of the CAIP account ID.\n */\nexports.CaipAccountAddressStruct = (0, superstruct_1.definePattern)('CaipAccountAddress', exports.CAIP_ACCOUNT_ADDRESS_REGEX);\n/**\n * A CAIP-19 asset namespace, i.e., a namespace domain of an asset.\n */\nexports.CaipAssetNamespaceStruct = (0, superstruct_1.definePattern)('CaipAssetNamespace', exports.CAIP_ASSET_NAMESPACE_REGEX);\n/**\n * A CAIP-19 asset reference, i.e., an identifier for an asset within a given namespace.\n */\nexports.CaipAssetReferenceStruct = (0, superstruct_1.definePattern)('CaipAssetReference', exports.CAIP_ASSET_REFERENCE_REGEX);\n/**\n * A CAIP-19 asset token ID, i.e., a unique identifier for an addressable asset of a given type\n */\nexports.CaipTokenIdStruct = (0, superstruct_1.definePattern)('CaipTokenId', exports.CAIP_TOKEN_ID_REGEX);\n/**\n * A CAIP-19 asset type identifier, i.e., a human-readable type of asset identifier.\n */\nexports.CaipAssetTypeStruct = (0, superstruct_1.definePattern)('CaipAssetType', exports.CAIP_ASSET_TYPE_REGEX);\n/**\n * A CAIP-19 asset ID identifier, i.e., a human-readable type of asset ID.\n */\nexports.CaipAssetIdStruct = (0, superstruct_1.definePattern)('CaipAssetId', exports.CAIP_ASSET_ID_REGEX);\n/**\n * A CAIP-19 asset type or asset ID identifier, i.e., a human-readable type of asset identifier.\n */\nexports.CaipAssetTypeOrIdStruct = (0, superstruct_1.definePattern)('CaipAssetTypeOrId', CAIP_ASSET_TYPE_OR_ID_REGEX);\n/** Known CAIP namespaces. */\nvar KnownCaipNamespace;\n(function (KnownCaipNamespace) {\n    /** BIP-122 (Bitcoin) compatible chains. */\n    KnownCaipNamespace[\"Bip122\"] = \"bip122\";\n    /** Solana compatible chains */\n    KnownCaipNamespace[\"Solana\"] = \"solana\";\n    /** Tron compatible chains */\n    KnownCaipNamespace[\"Tron\"] = \"tron\";\n    /** EIP-155 compatible chains. */\n    KnownCaipNamespace[\"Eip155\"] = \"eip155\";\n    KnownCaipNamespace[\"Wallet\"] = \"wallet\";\n})(KnownCaipNamespace = exports.KnownCaipNamespace || (exports.KnownCaipNamespace = {}));\n/**\n * Check if the given value is a {@link CaipChainId}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipChainId}.\n */\nfunction isCaipChainId(value) {\n    return typeof value === 'string' && exports.CAIP_CHAIN_ID_REGEX.test(value);\n}\nexports.isCaipChainId = isCaipChainId;\n/**\n * Check if the given value is a {@link CaipNamespace}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipNamespace}.\n */\nfunction isCaipNamespace(value) {\n    return typeof value === 'string' && exports.CAIP_NAMESPACE_REGEX.test(value);\n}\nexports.isCaipNamespace = isCaipNamespace;\n/**\n * Check if the given value is a {@link CaipReference}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipReference}.\n */\nfunction isCaipReference(value) {\n    return typeof value === 'string' && exports.CAIP_REFERENCE_REGEX.test(value);\n}\nexports.isCaipReference = isCaipReference;\n/**\n * Check if the given value is a {@link CaipAccountId}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipAccountId}.\n */\nfunction isCaipAccountId(value) {\n    return typeof value === 'string' && exports.CAIP_ACCOUNT_ID_REGEX.test(value);\n}\nexports.isCaipAccountId = isCaipAccountId;\n/**\n * Check if a value is a {@link CaipAccountAddress}.\n *\n * @param value - The value to validate.\n * @returns True if the value is a valid {@link CaipAccountAddress}.\n */\nfunction isCaipAccountAddress(value) {\n    return typeof value === 'string' && exports.CAIP_ACCOUNT_ADDRESS_REGEX.test(value);\n}\nexports.isCaipAccountAddress = isCaipAccountAddress;\n/**\n * Check if the given value is a {@link CaipAssetNamespace}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipAssetNamespace}.\n */\nfunction isCaipAssetNamespace(value) {\n    return typeof value === 'string' && exports.CAIP_ASSET_NAMESPACE_REGEX.test(value);\n}\nexports.isCaipAssetNamespace = isCaipAssetNamespace;\n/**\n * Check if the given value is a {@link CaipAssetReference}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipAssetReference}.\n */\nfunction isCaipAssetReference(value) {\n    return typeof value === 'string' && exports.CAIP_ASSET_REFERENCE_REGEX.test(value);\n}\nexports.isCaipAssetReference = isCaipAssetReference;\n/**\n * Check if the given value is a {@link CaipTokenId}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipTokenId}.\n */\nfunction isCaipTokenId(value) {\n    return typeof value === 'string' && exports.CAIP_TOKEN_ID_REGEX.test(value);\n}\nexports.isCaipTokenId = isCaipTokenId;\n/**\n * Check if the given value is a {@link CaipAssetType}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipAssetType}.\n */\nfunction isCaipAssetType(value) {\n    return typeof value === 'string' && exports.CAIP_ASSET_TYPE_REGEX.test(value);\n}\nexports.isCaipAssetType = isCaipAssetType;\n/**\n * Check if the given value is a {@link CaipAssetId}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipAssetId}.\n */\nfunction isCaipAssetId(value) {\n    return typeof value === 'string' && exports.CAIP_ASSET_ID_REGEX.test(value);\n}\nexports.isCaipAssetId = isCaipAssetId;\n/**\n * Parse a CAIP-2 chain ID to an object containing the namespace and reference.\n * This validates the CAIP-2 chain ID before parsing it.\n *\n * @param caipChainId - The CAIP-2 chain ID to validate and parse.\n * @returns The parsed CAIP-2 chain ID.\n */\nfunction parseCaipChainId(caipChainId) {\n    const match = exports.CAIP_CHAIN_ID_REGEX.exec(caipChainId);\n    if (!match?.groups) {\n        throw new Error('Invalid CAIP chain ID.');\n    }\n    return {\n        namespace: match.groups.namespace,\n        reference: match.groups.reference,\n    };\n}\nexports.parseCaipChainId = parseCaipChainId;\n/**\n * Parse an CAIP-10 account ID to an object containing the chain ID, parsed chain ID, and account address.\n * This validates the CAIP-10 account ID before parsing it.\n *\n * @param caipAccountId - The CAIP-10 account ID to validate and parse.\n * @returns The parsed CAIP-10 account ID.\n */\nfunction parseCaipAccountId(caipAccountId) {\n    const match = exports.CAIP_ACCOUNT_ID_REGEX.exec(caipAccountId);\n    if (!match?.groups) {\n        throw new Error('Invalid CAIP account ID.');\n    }\n    return {\n        address: match.groups.accountAddress,\n        chainId: match.groups.chainId,\n        chain: {\n            namespace: match.groups.namespace,\n            reference: match.groups.reference,\n        },\n    };\n}\nexports.parseCaipAccountId = parseCaipAccountId;\n/**\n * Parse a CAIP-19 asset type to an object containing the chain ID, parsed chain ID,\n * asset namespace, and asset reference\n *\n * This validates the CAIP-19 asset type before parsing it.\n *\n * @param caipAssetType - The CAIP-19 asset type to validate and parse.\n * @returns The parsed CAIP-19 asset type.\n */\nfunction parseCaipAssetType(caipAssetType) {\n    const match = exports.CAIP_ASSET_TYPE_REGEX.exec(caipAssetType);\n    if (!match?.groups) {\n        throw new Error('Invalid CAIP asset type.');\n    }\n    return {\n        assetNamespace: match.groups.assetNamespace,\n        assetReference: match.groups.assetReference,\n        chainId: match.groups.chainId,\n        chain: {\n            namespace: match.groups.namespace,\n            reference: match.groups.reference,\n        },\n    };\n}\nexports.parseCaipAssetType = parseCaipAssetType;\n/**\n * Parse a CAIP-19 asset ID to an object containing the chain ID, parsed chain ID,\n * asset namespace, asset reference, and token ID.\n *\n * This validates the CAIP-19 asset ID before parsing it.\n *\n * @param caipAssetId - The CAIP-19 asset ID to validate and parse.\n * @returns The parsed CAIP-19 asset ID.\n */\nfunction parseCaipAssetId(caipAssetId) {\n    const match = exports.CAIP_ASSET_ID_REGEX.exec(caipAssetId);\n    if (!match?.groups) {\n        throw new Error('Invalid CAIP asset ID.');\n    }\n    return {\n        assetNamespace: match.groups.assetNamespace,\n        assetReference: match.groups.assetReference,\n        tokenId: match.groups.tokenId,\n        chainId: match.groups.chainId,\n        chain: {\n            namespace: match.groups.namespace,\n            reference: match.groups.reference,\n        },\n    };\n}\nexports.parseCaipAssetId = parseCaipAssetId;\n/**\n * Chain ID as defined per the CAIP-2\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-2.md}.\n *\n * It defines a way to uniquely identify any blockchain in a human-readable\n * way.\n *\n * @param namespace - The standard (ecosystem) of similar blockchains.\n * @param reference - Identify of a blockchain within a given namespace.\n * @throws {@link Error}\n * This exception is thrown if the inputs does not comply with the CAIP-2\n * syntax specification\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-2.md#syntax}.\n * @returns A CAIP chain ID.\n */\nfunction toCaipChainId(namespace, reference) {\n    if (!isCaipNamespace(namespace)) {\n        throw new Error(`Invalid \"namespace\", must match: ${exports.CAIP_NAMESPACE_REGEX.toString()}`);\n    }\n    if (!isCaipReference(reference)) {\n        throw new Error(`Invalid \"reference\", must match: ${exports.CAIP_REFERENCE_REGEX.toString()}`);\n    }\n    return `${namespace}:${reference}`;\n}\nexports.toCaipChainId = toCaipChainId;\n/**\n * Account ID as defined per the CAIP-10\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-10.md}.\n *\n * It defines a way to uniquely identify any blockchain account in a human-readable\n * way.\n *\n * @param namespace - The standard (ecosystem) of similar blockchains.\n * @param reference - Identity of a blockchain within a given namespace.\n * @param accountAddress - The address of the blockchain account.\n * @throws {@link Error}\n * This exception is thrown if the inputs do not comply with the CAIP-10\n * syntax specification\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-10.md#syntax}.\n * @returns A CAIP account ID.\n */\nfunction toCaipAccountId(namespace, reference, accountAddress) {\n    if (!isCaipNamespace(namespace)) {\n        throw new Error(`Invalid \"namespace\", must match: ${exports.CAIP_NAMESPACE_REGEX.toString()}`);\n    }\n    if (!isCaipReference(reference)) {\n        throw new Error(`Invalid \"reference\", must match: ${exports.CAIP_REFERENCE_REGEX.toString()}`);\n    }\n    if (!isCaipAccountAddress(accountAddress)) {\n        throw new Error(`Invalid \"accountAddress\", must match: ${exports.CAIP_ACCOUNT_ADDRESS_REGEX.toString()}`);\n    }\n    return `${namespace}:${reference}:${accountAddress}`;\n}\nexports.toCaipAccountId = toCaipAccountId;\n/**\n * Asset Type as defined per the CAIP-19\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-19.md}.\n *\n * It defines a way to uniquely identify any blockchain asset in a human-readable\n * way.\n *\n * @param namespace - The standard (ecosystem) of similar blockchains.\n * @param reference - Identity of a blockchain within a given namespace.\n * @param assetNamespace - The namespace domain of an asset.\n * @param assetReference - The identity of an asset within a given namespace.\n * @throws {@link Error}\n * This exception is thrown if the inputs do not comply with the CAIP-19\n * syntax specification\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-19.md#syntax}.\n * @returns A CAIP asset type.\n */\nfunction toCaipAssetType(namespace, reference, assetNamespace, assetReference) {\n    if (!isCaipNamespace(namespace)) {\n        throw new Error(`Invalid \"namespace\", must match: ${exports.CAIP_NAMESPACE_REGEX.toString()}`);\n    }\n    if (!isCaipReference(reference)) {\n        throw new Error(`Invalid \"reference\", must match: ${exports.CAIP_REFERENCE_REGEX.toString()}`);\n    }\n    if (!isCaipAssetNamespace(assetNamespace)) {\n        throw new Error(`Invalid \"assetNamespace\", must match: ${exports.CAIP_ASSET_NAMESPACE_REGEX.toString()}`);\n    }\n    if (!isCaipAssetReference(assetReference)) {\n        throw new Error(`Invalid \"assetReference\", must match: ${exports.CAIP_ASSET_REFERENCE_REGEX.toString()}`);\n    }\n    return `${namespace}:${reference}/${assetNamespace}:${assetReference}`;\n}\nexports.toCaipAssetType = toCaipAssetType;\n/**\n * Asset ID as defined per the CAIP-19\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-19.md}.\n *\n * It defines a way to uniquely identify any blockchain asset in a human-readable\n * way.\n *\n * @param namespace - The standard (ecosystem) of similar blockchains.\n * @param reference - Identity of a blockchain within a given namespace.\n * @param assetNamespace - The namespace domain of an asset.\n * @param assetReference - The identity of an asset within a given namespace.\n * @param tokenId - The unique identifier for an addressable asset of a given type.\n * @throws {@link Error}\n * This exception is thrown if the inputs do not comply with the CAIP-19\n * syntax specification\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-19.md#syntax}.\n * @returns A CAIP asset ID.\n */\nfunction toCaipAssetId(namespace, reference, assetNamespace, assetReference, tokenId) {\n    if (!isCaipNamespace(namespace)) {\n        throw new Error(`Invalid \"namespace\", must match: ${exports.CAIP_NAMESPACE_REGEX.toString()}`);\n    }\n    if (!isCaipReference(reference)) {\n        throw new Error(`Invalid \"reference\", must match: ${exports.CAIP_REFERENCE_REGEX.toString()}`);\n    }\n    if (!isCaipAssetNamespace(assetNamespace)) {\n        throw new Error(`Invalid \"assetNamespace\", must match: ${exports.CAIP_ASSET_NAMESPACE_REGEX.toString()}`);\n    }\n    if (!isCaipAssetReference(assetReference)) {\n        throw new Error(`Invalid \"assetReference\", must match: ${exports.CAIP_ASSET_REFERENCE_REGEX.toString()}`);\n    }\n    if (!isCaipTokenId(tokenId)) {\n        throw new Error(`Invalid \"tokenId\", must match: ${exports.CAIP_TOKEN_ID_REGEX.toString()}`);\n    }\n    return `${namespace}:${reference}/${assetNamespace}:${assetReference}/${tokenId}`;\n}\nexports.toCaipAssetId = toCaipAssetId;\n//# sourceMappingURL=caip-types.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NhaXAtdHlwZXMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixHQUFHLHVCQUF1QixHQUFHLHVCQUF1QixHQUFHLHFCQUFxQixHQUFHLHdCQUF3QixHQUFHLDBCQUEwQixHQUFHLDBCQUEwQixHQUFHLHdCQUF3QixHQUFHLHFCQUFxQixHQUFHLHVCQUF1QixHQUFHLHFCQUFxQixHQUFHLDRCQUE0QixHQUFHLDRCQUE0QixHQUFHLDRCQUE0QixHQUFHLHVCQUF1QixHQUFHLHVCQUF1QixHQUFHLHVCQUF1QixHQUFHLHFCQUFxQixHQUFHLDBCQUEwQixHQUFHLCtCQUErQixHQUFHLHlCQUF5QixHQUFHLDJCQUEyQixHQUFHLHlCQUF5QixHQUFHLGdDQUFnQyxHQUFHLGdDQUFnQyxHQUFHLGdDQUFnQyxHQUFHLDJCQUEyQixHQUFHLDJCQUEyQixHQUFHLDJCQUEyQixHQUFHLHlCQUF5QixHQUFHLDJCQUEyQixHQUFHLDZCQUE2QixHQUFHLDJCQUEyQixHQUFHLGtDQUFrQyxHQUFHLGtDQUFrQyxHQUFHLGtDQUFrQyxHQUFHLDZCQUE2QixHQUFHLDRCQUE0QixHQUFHLDRCQUE0QixHQUFHLDJCQUEyQjtBQUN6cEMsc0JBQXNCLG1CQUFPLENBQUMsd0ZBQW1CO0FBQ2pELDJCQUEyQiw0QkFBNEIsSUFBSSw2QkFBNkIsS0FBSztBQUM3Riw0QkFBNEIsZUFBZSxJQUFJO0FBQy9DLDRCQUE0QixtQkFBbUIsS0FBSztBQUNwRCw2QkFBNkIsdUNBQXVDLElBQUksNkJBQTZCLEtBQUssb0NBQW9DLE1BQU07QUFDcEosa0NBQWtDLG9CQUFvQixNQUFNO0FBQzVELGtDQUFrQyxlQUFlLElBQUk7QUFDckQsa0NBQWtDLG9CQUFvQixNQUFNO0FBQzVELDJCQUEyQixvQkFBb0IsS0FBSztBQUNwRCw2QkFBNkIsdUNBQXVDLElBQUksNkJBQTZCLEtBQUssZ0NBQWdDLElBQUksbUNBQW1DLE1BQU07QUFDdkwsMkJBQTJCLHVDQUF1QyxJQUFJLDZCQUE2QixLQUFLLGdDQUFnQyxJQUFJLG1DQUFtQyxNQUFNLDZCQUE2QixLQUFLO0FBQ3ZOLHdFQUF3RSxJQUFJLDZCQUE2QixLQUFLLGdDQUFnQyxJQUFJLG1DQUFtQyxNQUFNLDhCQUE4QixLQUFLO0FBQzlOO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzREFBc0QsMEJBQTBCLEtBQUs7QUFDdEY7QUFDQSxrQ0FBa0Msa0JBQWtCO0FBQ3BEO0FBQ0E7QUFDQSxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0Esa0NBQWtDLG9CQUFvQjtBQUN0RDtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLGtDQUFrQyxvQkFBb0I7QUFDdEQ7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxrQ0FBa0Msb0JBQW9CO0FBQ3REO0FBQ0E7QUFDQSxvQ0FBb0Msb0JBQW9CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FBQ0EsMENBQTBDLHlCQUF5QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLGtDQUFrQyx5QkFBeUI7QUFDM0Q7QUFDQTtBQUNBLG9DQUFvQyx5QkFBeUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxrQ0FBa0MseUJBQXlCO0FBQzNEO0FBQ0E7QUFDQSxvQ0FBb0MseUJBQXlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0Esa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0Esb0NBQW9DLGtCQUFrQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGtDQUFrQyxvQkFBb0I7QUFDdEQ7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxrQ0FBa0Msa0JBQWtCO0FBQ3BEO0FBQ0E7QUFDQSxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsSUFBSSx1RUFBdUU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxJQUFJLDhFQUE4RTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCx3Q0FBd0M7QUFDcEc7QUFDQTtBQUNBLDREQUE0RCx3Q0FBd0M7QUFDcEc7QUFDQSxjQUFjLFVBQVUsR0FBRyxVQUFVO0FBQ3JDO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxJQUFJLHdFQUF3RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsSUFBSSwrRUFBK0U7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsd0NBQXdDO0FBQ3BHO0FBQ0E7QUFDQSw0REFBNEQsd0NBQXdDO0FBQ3BHO0FBQ0E7QUFDQSxpRUFBaUUsOENBQThDO0FBQy9HO0FBQ0EsY0FBYyxVQUFVLEdBQUcsVUFBVSxHQUFHLGVBQWU7QUFDdkQ7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLElBQUksd0VBQXdFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLElBQUksK0VBQStFO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELHdDQUF3QztBQUNwRztBQUNBO0FBQ0EsNERBQTRELHdDQUF3QztBQUNwRztBQUNBO0FBQ0EsaUVBQWlFLDhDQUE4QztBQUMvRztBQUNBO0FBQ0EsaUVBQWlFLDhDQUE4QztBQUMvRztBQUNBLGNBQWMsVUFBVSxHQUFHLFVBQVUsR0FBRyxlQUFlLEdBQUcsZUFBZTtBQUN6RTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsSUFBSSx3RUFBd0U7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxJQUFJLCtFQUErRTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCx3Q0FBd0M7QUFDcEc7QUFDQTtBQUNBLDREQUE0RCx3Q0FBd0M7QUFDcEc7QUFDQTtBQUNBLGlFQUFpRSw4Q0FBOEM7QUFDL0c7QUFDQTtBQUNBLGlFQUFpRSw4Q0FBOEM7QUFDL0c7QUFDQTtBQUNBLDBEQUEwRCx1Q0FBdUM7QUFDakc7QUFDQSxjQUFjLFVBQVUsR0FBRyxVQUFVLEdBQUcsZUFBZSxHQUFHLGVBQWUsR0FBRyxRQUFRO0FBQ3BGO0FBQ0EscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9jYWlwLXR5cGVzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudG9DYWlwQXNzZXRJZCA9IGV4cG9ydHMudG9DYWlwQXNzZXRUeXBlID0gZXhwb3J0cy50b0NhaXBBY2NvdW50SWQgPSBleHBvcnRzLnRvQ2FpcENoYWluSWQgPSBleHBvcnRzLnBhcnNlQ2FpcEFzc2V0SWQgPSBleHBvcnRzLnBhcnNlQ2FpcEFzc2V0VHlwZSA9IGV4cG9ydHMucGFyc2VDYWlwQWNjb3VudElkID0gZXhwb3J0cy5wYXJzZUNhaXBDaGFpbklkID0gZXhwb3J0cy5pc0NhaXBBc3NldElkID0gZXhwb3J0cy5pc0NhaXBBc3NldFR5cGUgPSBleHBvcnRzLmlzQ2FpcFRva2VuSWQgPSBleHBvcnRzLmlzQ2FpcEFzc2V0UmVmZXJlbmNlID0gZXhwb3J0cy5pc0NhaXBBc3NldE5hbWVzcGFjZSA9IGV4cG9ydHMuaXNDYWlwQWNjb3VudEFkZHJlc3MgPSBleHBvcnRzLmlzQ2FpcEFjY291bnRJZCA9IGV4cG9ydHMuaXNDYWlwUmVmZXJlbmNlID0gZXhwb3J0cy5pc0NhaXBOYW1lc3BhY2UgPSBleHBvcnRzLmlzQ2FpcENoYWluSWQgPSBleHBvcnRzLktub3duQ2FpcE5hbWVzcGFjZSA9IGV4cG9ydHMuQ2FpcEFzc2V0VHlwZU9ySWRTdHJ1Y3QgPSBleHBvcnRzLkNhaXBBc3NldElkU3RydWN0ID0gZXhwb3J0cy5DYWlwQXNzZXRUeXBlU3RydWN0ID0gZXhwb3J0cy5DYWlwVG9rZW5JZFN0cnVjdCA9IGV4cG9ydHMuQ2FpcEFzc2V0UmVmZXJlbmNlU3RydWN0ID0gZXhwb3J0cy5DYWlwQXNzZXROYW1lc3BhY2VTdHJ1Y3QgPSBleHBvcnRzLkNhaXBBY2NvdW50QWRkcmVzc1N0cnVjdCA9IGV4cG9ydHMuQ2FpcEFjY291bnRJZFN0cnVjdCA9IGV4cG9ydHMuQ2FpcFJlZmVyZW5jZVN0cnVjdCA9IGV4cG9ydHMuQ2FpcE5hbWVzcGFjZVN0cnVjdCA9IGV4cG9ydHMuQ2FpcENoYWluSWRTdHJ1Y3QgPSBleHBvcnRzLkNBSVBfQVNTRVRfSURfUkVHRVggPSBleHBvcnRzLkNBSVBfQVNTRVRfVFlQRV9SRUdFWCA9IGV4cG9ydHMuQ0FJUF9UT0tFTl9JRF9SRUdFWCA9IGV4cG9ydHMuQ0FJUF9BU1NFVF9SRUZFUkVOQ0VfUkVHRVggPSBleHBvcnRzLkNBSVBfQVNTRVRfTkFNRVNQQUNFX1JFR0VYID0gZXhwb3J0cy5DQUlQX0FDQ09VTlRfQUREUkVTU19SRUdFWCA9IGV4cG9ydHMuQ0FJUF9BQ0NPVU5UX0lEX1JFR0VYID0gZXhwb3J0cy5DQUlQX1JFRkVSRU5DRV9SRUdFWCA9IGV4cG9ydHMuQ0FJUF9OQU1FU1BBQ0VfUkVHRVggPSBleHBvcnRzLkNBSVBfQ0hBSU5fSURfUkVHRVggPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcIi4vc3VwZXJzdHJ1Y3QuY2pzXCIpO1xuZXhwb3J0cy5DQUlQX0NIQUlOX0lEX1JFR0VYID0gL14oPzxuYW1lc3BhY2U+Wy1hLXowLTldezMsOH0pOig/PHJlZmVyZW5jZT5bLV9hLXpBLVowLTldezEsMzJ9KSQvdTtcbmV4cG9ydHMuQ0FJUF9OQU1FU1BBQ0VfUkVHRVggPSAvXlstYS16MC05XXszLDh9JC91O1xuZXhwb3J0cy5DQUlQX1JFRkVSRU5DRV9SRUdFWCA9IC9eWy1fYS16QS1aMC05XXsxLDMyfSQvdTtcbmV4cG9ydHMuQ0FJUF9BQ0NPVU5UX0lEX1JFR0VYID0gL14oPzxjaGFpbklkPig/PG5hbWVzcGFjZT5bLWEtejAtOV17Myw4fSk6KD88cmVmZXJlbmNlPlstX2EtekEtWjAtOV17MSwzMn0pKTooPzxhY2NvdW50QWRkcmVzcz5bLS4lYS16QS1aMC05XXsxLDEyOH0pJC91O1xuZXhwb3J0cy5DQUlQX0FDQ09VTlRfQUREUkVTU19SRUdFWCA9IC9eWy0uJWEtekEtWjAtOV17MSwxMjh9JC91O1xuZXhwb3J0cy5DQUlQX0FTU0VUX05BTUVTUEFDRV9SRUdFWCA9IC9eWy1hLXowLTldezMsOH0kL3U7XG5leHBvcnRzLkNBSVBfQVNTRVRfUkVGRVJFTkNFX1JFR0VYID0gL15bLS4lYS16QS1aMC05XXsxLDEyOH0kL3U7XG5leHBvcnRzLkNBSVBfVE9LRU5fSURfUkVHRVggPSAvXlstLiVhLXpBLVowLTldezEsNzh9JC91O1xuZXhwb3J0cy5DQUlQX0FTU0VUX1RZUEVfUkVHRVggPSAvXig/PGNoYWluSWQ+KD88bmFtZXNwYWNlPlstYS16MC05XXszLDh9KTooPzxyZWZlcmVuY2U+Wy1fYS16QS1aMC05XXsxLDMyfSkpXFwvKD88YXNzZXROYW1lc3BhY2U+Wy1hLXowLTldezMsOH0pOig/PGFzc2V0UmVmZXJlbmNlPlstLiVhLXpBLVowLTldezEsMTI4fSkkL3U7XG5leHBvcnRzLkNBSVBfQVNTRVRfSURfUkVHRVggPSAvXig/PGNoYWluSWQ+KD88bmFtZXNwYWNlPlstYS16MC05XXszLDh9KTooPzxyZWZlcmVuY2U+Wy1fYS16QS1aMC05XXsxLDMyfSkpXFwvKD88YXNzZXROYW1lc3BhY2U+Wy1hLXowLTldezMsOH0pOig/PGFzc2V0UmVmZXJlbmNlPlstLiVhLXpBLVowLTldezEsMTI4fSlcXC8oPzx0b2tlbklkPlstLiVhLXpBLVowLTldezEsNzh9KSQvdTtcbmNvbnN0IENBSVBfQVNTRVRfVFlQRV9PUl9JRF9SRUdFWCA9IC9eKD88Y2hhaW5JZD4oPzxuYW1lc3BhY2U+Wy1hLXowLTldezMsOH0pOig/PHJlZmVyZW5jZT5bLV9hLXpBLVowLTldezEsMzJ9KSlcXC8oPzxhc3NldE5hbWVzcGFjZT5bLWEtejAtOV17Myw4fSk6KD88YXNzZXRSZWZlcmVuY2U+Wy0uJWEtekEtWjAtOV17MSwxMjh9KShcXC8oPzx0b2tlbklkPlstLiVhLXpBLVowLTldezEsNzh9KSk/JC91O1xuLyoqXG4gKiBBIENBSVAtMiBjaGFpbiBJRCwgaS5lLiwgYSBodW1hbi1yZWFkYWJsZSBuYW1lc3BhY2UgYW5kIHJlZmVyZW5jZS5cbiAqL1xuZXhwb3J0cy5DYWlwQ2hhaW5JZFN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLmRlZmluZVBhdHRlcm4pKCdDYWlwQ2hhaW5JZCcsIGV4cG9ydHMuQ0FJUF9DSEFJTl9JRF9SRUdFWCk7XG4vKipcbiAqIEEgQ0FJUC0yIG5hbWVzcGFjZSwgaS5lLiwgdGhlIGZpcnN0IHBhcnQgb2YgYSBDQUlQIGNoYWluIElELlxuICovXG5leHBvcnRzLkNhaXBOYW1lc3BhY2VTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5kZWZpbmVQYXR0ZXJuKSgnQ2FpcE5hbWVzcGFjZScsIGV4cG9ydHMuQ0FJUF9OQU1FU1BBQ0VfUkVHRVgpO1xuLyoqXG4gKiBBIENBSVAtMiByZWZlcmVuY2UsIGkuZS4sIHRoZSBzZWNvbmQgcGFydCBvZiBhIENBSVAgY2hhaW4gSUQuXG4gKi9cbmV4cG9ydHMuQ2FpcFJlZmVyZW5jZVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLmRlZmluZVBhdHRlcm4pKCdDYWlwUmVmZXJlbmNlJywgZXhwb3J0cy5DQUlQX1JFRkVSRU5DRV9SRUdFWCk7XG4vKipcbiAqIEEgQ0FJUC0xMCBhY2NvdW50IElELCBpLmUuLCBhIGh1bWFuLXJlYWRhYmxlIG5hbWVzcGFjZSwgcmVmZXJlbmNlLCBhbmQgYWNjb3VudCBhZGRyZXNzLlxuICovXG5leHBvcnRzLkNhaXBBY2NvdW50SWRTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5kZWZpbmVQYXR0ZXJuKSgnQ2FpcEFjY291bnRJZCcsIGV4cG9ydHMuQ0FJUF9BQ0NPVU5UX0lEX1JFR0VYKTtcbi8qKlxuICogQSBDQUlQLTEwIGFjY291bnQgYWRkcmVzcywgaS5lLiwgdGhlIHRoaXJkIHBhcnQgb2YgdGhlIENBSVAgYWNjb3VudCBJRC5cbiAqL1xuZXhwb3J0cy5DYWlwQWNjb3VudEFkZHJlc3NTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5kZWZpbmVQYXR0ZXJuKSgnQ2FpcEFjY291bnRBZGRyZXNzJywgZXhwb3J0cy5DQUlQX0FDQ09VTlRfQUREUkVTU19SRUdFWCk7XG4vKipcbiAqIEEgQ0FJUC0xOSBhc3NldCBuYW1lc3BhY2UsIGkuZS4sIGEgbmFtZXNwYWNlIGRvbWFpbiBvZiBhbiBhc3NldC5cbiAqL1xuZXhwb3J0cy5DYWlwQXNzZXROYW1lc3BhY2VTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5kZWZpbmVQYXR0ZXJuKSgnQ2FpcEFzc2V0TmFtZXNwYWNlJywgZXhwb3J0cy5DQUlQX0FTU0VUX05BTUVTUEFDRV9SRUdFWCk7XG4vKipcbiAqIEEgQ0FJUC0xOSBhc3NldCByZWZlcmVuY2UsIGkuZS4sIGFuIGlkZW50aWZpZXIgZm9yIGFuIGFzc2V0IHdpdGhpbiBhIGdpdmVuIG5hbWVzcGFjZS5cbiAqL1xuZXhwb3J0cy5DYWlwQXNzZXRSZWZlcmVuY2VTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5kZWZpbmVQYXR0ZXJuKSgnQ2FpcEFzc2V0UmVmZXJlbmNlJywgZXhwb3J0cy5DQUlQX0FTU0VUX1JFRkVSRU5DRV9SRUdFWCk7XG4vKipcbiAqIEEgQ0FJUC0xOSBhc3NldCB0b2tlbiBJRCwgaS5lLiwgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgYW4gYWRkcmVzc2FibGUgYXNzZXQgb2YgYSBnaXZlbiB0eXBlXG4gKi9cbmV4cG9ydHMuQ2FpcFRva2VuSWRTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5kZWZpbmVQYXR0ZXJuKSgnQ2FpcFRva2VuSWQnLCBleHBvcnRzLkNBSVBfVE9LRU5fSURfUkVHRVgpO1xuLyoqXG4gKiBBIENBSVAtMTkgYXNzZXQgdHlwZSBpZGVudGlmaWVyLCBpLmUuLCBhIGh1bWFuLXJlYWRhYmxlIHR5cGUgb2YgYXNzZXQgaWRlbnRpZmllci5cbiAqL1xuZXhwb3J0cy5DYWlwQXNzZXRUeXBlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEuZGVmaW5lUGF0dGVybikoJ0NhaXBBc3NldFR5cGUnLCBleHBvcnRzLkNBSVBfQVNTRVRfVFlQRV9SRUdFWCk7XG4vKipcbiAqIEEgQ0FJUC0xOSBhc3NldCBJRCBpZGVudGlmaWVyLCBpLmUuLCBhIGh1bWFuLXJlYWRhYmxlIHR5cGUgb2YgYXNzZXQgSUQuXG4gKi9cbmV4cG9ydHMuQ2FpcEFzc2V0SWRTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5kZWZpbmVQYXR0ZXJuKSgnQ2FpcEFzc2V0SWQnLCBleHBvcnRzLkNBSVBfQVNTRVRfSURfUkVHRVgpO1xuLyoqXG4gKiBBIENBSVAtMTkgYXNzZXQgdHlwZSBvciBhc3NldCBJRCBpZGVudGlmaWVyLCBpLmUuLCBhIGh1bWFuLXJlYWRhYmxlIHR5cGUgb2YgYXNzZXQgaWRlbnRpZmllci5cbiAqL1xuZXhwb3J0cy5DYWlwQXNzZXRUeXBlT3JJZFN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLmRlZmluZVBhdHRlcm4pKCdDYWlwQXNzZXRUeXBlT3JJZCcsIENBSVBfQVNTRVRfVFlQRV9PUl9JRF9SRUdFWCk7XG4vKiogS25vd24gQ0FJUCBuYW1lc3BhY2VzLiAqL1xudmFyIEtub3duQ2FpcE5hbWVzcGFjZTtcbihmdW5jdGlvbiAoS25vd25DYWlwTmFtZXNwYWNlKSB7XG4gICAgLyoqIEJJUC0xMjIgKEJpdGNvaW4pIGNvbXBhdGlibGUgY2hhaW5zLiAqL1xuICAgIEtub3duQ2FpcE5hbWVzcGFjZVtcIkJpcDEyMlwiXSA9IFwiYmlwMTIyXCI7XG4gICAgLyoqIFNvbGFuYSBjb21wYXRpYmxlIGNoYWlucyAqL1xuICAgIEtub3duQ2FpcE5hbWVzcGFjZVtcIlNvbGFuYVwiXSA9IFwic29sYW5hXCI7XG4gICAgLyoqIFRyb24gY29tcGF0aWJsZSBjaGFpbnMgKi9cbiAgICBLbm93bkNhaXBOYW1lc3BhY2VbXCJUcm9uXCJdID0gXCJ0cm9uXCI7XG4gICAgLyoqIEVJUC0xNTUgY29tcGF0aWJsZSBjaGFpbnMuICovXG4gICAgS25vd25DYWlwTmFtZXNwYWNlW1wiRWlwMTU1XCJdID0gXCJlaXAxNTVcIjtcbiAgICBLbm93bkNhaXBOYW1lc3BhY2VbXCJXYWxsZXRcIl0gPSBcIndhbGxldFwiO1xufSkoS25vd25DYWlwTmFtZXNwYWNlID0gZXhwb3J0cy5Lbm93bkNhaXBOYW1lc3BhY2UgfHwgKGV4cG9ydHMuS25vd25DYWlwTmFtZXNwYWNlID0ge30pKTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEge0BsaW5rIENhaXBDaGFpbklkfS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHtAbGluayBDYWlwQ2hhaW5JZH0uXG4gKi9cbmZ1bmN0aW9uIGlzQ2FpcENoYWluSWQodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBleHBvcnRzLkNBSVBfQ0hBSU5fSURfUkVHRVgudGVzdCh2YWx1ZSk7XG59XG5leHBvcnRzLmlzQ2FpcENoYWluSWQgPSBpc0NhaXBDaGFpbklkO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB7QGxpbmsgQ2FpcE5hbWVzcGFjZX0uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB7QGxpbmsgQ2FpcE5hbWVzcGFjZX0uXG4gKi9cbmZ1bmN0aW9uIGlzQ2FpcE5hbWVzcGFjZSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIGV4cG9ydHMuQ0FJUF9OQU1FU1BBQ0VfUkVHRVgudGVzdCh2YWx1ZSk7XG59XG5leHBvcnRzLmlzQ2FpcE5hbWVzcGFjZSA9IGlzQ2FpcE5hbWVzcGFjZTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEge0BsaW5rIENhaXBSZWZlcmVuY2V9LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEge0BsaW5rIENhaXBSZWZlcmVuY2V9LlxuICovXG5mdW5jdGlvbiBpc0NhaXBSZWZlcmVuY2UodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBleHBvcnRzLkNBSVBfUkVGRVJFTkNFX1JFR0VYLnRlc3QodmFsdWUpO1xufVxuZXhwb3J0cy5pc0NhaXBSZWZlcmVuY2UgPSBpc0NhaXBSZWZlcmVuY2U7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHtAbGluayBDYWlwQWNjb3VudElkfS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHtAbGluayBDYWlwQWNjb3VudElkfS5cbiAqL1xuZnVuY3Rpb24gaXNDYWlwQWNjb3VudElkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgZXhwb3J0cy5DQUlQX0FDQ09VTlRfSURfUkVHRVgudGVzdCh2YWx1ZSk7XG59XG5leHBvcnRzLmlzQ2FpcEFjY291bnRJZCA9IGlzQ2FpcEFjY291bnRJZDtcbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHtAbGluayBDYWlwQWNjb3VudEFkZHJlc3N9LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB2YWxpZGF0ZS5cbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIENhaXBBY2NvdW50QWRkcmVzc30uXG4gKi9cbmZ1bmN0aW9uIGlzQ2FpcEFjY291bnRBZGRyZXNzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgZXhwb3J0cy5DQUlQX0FDQ09VTlRfQUREUkVTU19SRUdFWC50ZXN0KHZhbHVlKTtcbn1cbmV4cG9ydHMuaXNDYWlwQWNjb3VudEFkZHJlc3MgPSBpc0NhaXBBY2NvdW50QWRkcmVzcztcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEge0BsaW5rIENhaXBBc3NldE5hbWVzcGFjZX0uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB7QGxpbmsgQ2FpcEFzc2V0TmFtZXNwYWNlfS5cbiAqL1xuZnVuY3Rpb24gaXNDYWlwQXNzZXROYW1lc3BhY2UodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBleHBvcnRzLkNBSVBfQVNTRVRfTkFNRVNQQUNFX1JFR0VYLnRlc3QodmFsdWUpO1xufVxuZXhwb3J0cy5pc0NhaXBBc3NldE5hbWVzcGFjZSA9IGlzQ2FpcEFzc2V0TmFtZXNwYWNlO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB7QGxpbmsgQ2FpcEFzc2V0UmVmZXJlbmNlfS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHtAbGluayBDYWlwQXNzZXRSZWZlcmVuY2V9LlxuICovXG5mdW5jdGlvbiBpc0NhaXBBc3NldFJlZmVyZW5jZSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIGV4cG9ydHMuQ0FJUF9BU1NFVF9SRUZFUkVOQ0VfUkVHRVgudGVzdCh2YWx1ZSk7XG59XG5leHBvcnRzLmlzQ2FpcEFzc2V0UmVmZXJlbmNlID0gaXNDYWlwQXNzZXRSZWZlcmVuY2U7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHtAbGluayBDYWlwVG9rZW5JZH0uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB7QGxpbmsgQ2FpcFRva2VuSWR9LlxuICovXG5mdW5jdGlvbiBpc0NhaXBUb2tlbklkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgZXhwb3J0cy5DQUlQX1RPS0VOX0lEX1JFR0VYLnRlc3QodmFsdWUpO1xufVxuZXhwb3J0cy5pc0NhaXBUb2tlbklkID0gaXNDYWlwVG9rZW5JZDtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEge0BsaW5rIENhaXBBc3NldFR5cGV9LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEge0BsaW5rIENhaXBBc3NldFR5cGV9LlxuICovXG5mdW5jdGlvbiBpc0NhaXBBc3NldFR5cGUodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBleHBvcnRzLkNBSVBfQVNTRVRfVFlQRV9SRUdFWC50ZXN0KHZhbHVlKTtcbn1cbmV4cG9ydHMuaXNDYWlwQXNzZXRUeXBlID0gaXNDYWlwQXNzZXRUeXBlO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB7QGxpbmsgQ2FpcEFzc2V0SWR9LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEge0BsaW5rIENhaXBBc3NldElkfS5cbiAqL1xuZnVuY3Rpb24gaXNDYWlwQXNzZXRJZCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIGV4cG9ydHMuQ0FJUF9BU1NFVF9JRF9SRUdFWC50ZXN0KHZhbHVlKTtcbn1cbmV4cG9ydHMuaXNDYWlwQXNzZXRJZCA9IGlzQ2FpcEFzc2V0SWQ7XG4vKipcbiAqIFBhcnNlIGEgQ0FJUC0yIGNoYWluIElEIHRvIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBuYW1lc3BhY2UgYW5kIHJlZmVyZW5jZS5cbiAqIFRoaXMgdmFsaWRhdGVzIHRoZSBDQUlQLTIgY2hhaW4gSUQgYmVmb3JlIHBhcnNpbmcgaXQuXG4gKlxuICogQHBhcmFtIGNhaXBDaGFpbklkIC0gVGhlIENBSVAtMiBjaGFpbiBJRCB0byB2YWxpZGF0ZSBhbmQgcGFyc2UuXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIENBSVAtMiBjaGFpbiBJRC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VDYWlwQ2hhaW5JZChjYWlwQ2hhaW5JZCkge1xuICAgIGNvbnN0IG1hdGNoID0gZXhwb3J0cy5DQUlQX0NIQUlOX0lEX1JFR0VYLmV4ZWMoY2FpcENoYWluSWQpO1xuICAgIGlmICghbWF0Y2g/Lmdyb3Vwcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgQ0FJUCBjaGFpbiBJRC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZXNwYWNlOiBtYXRjaC5ncm91cHMubmFtZXNwYWNlLFxuICAgICAgICByZWZlcmVuY2U6IG1hdGNoLmdyb3Vwcy5yZWZlcmVuY2UsXG4gICAgfTtcbn1cbmV4cG9ydHMucGFyc2VDYWlwQ2hhaW5JZCA9IHBhcnNlQ2FpcENoYWluSWQ7XG4vKipcbiAqIFBhcnNlIGFuIENBSVAtMTAgYWNjb3VudCBJRCB0byBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgY2hhaW4gSUQsIHBhcnNlZCBjaGFpbiBJRCwgYW5kIGFjY291bnQgYWRkcmVzcy5cbiAqIFRoaXMgdmFsaWRhdGVzIHRoZSBDQUlQLTEwIGFjY291bnQgSUQgYmVmb3JlIHBhcnNpbmcgaXQuXG4gKlxuICogQHBhcmFtIGNhaXBBY2NvdW50SWQgLSBUaGUgQ0FJUC0xMCBhY2NvdW50IElEIHRvIHZhbGlkYXRlIGFuZCBwYXJzZS5cbiAqIEByZXR1cm5zIFRoZSBwYXJzZWQgQ0FJUC0xMCBhY2NvdW50IElELlxuICovXG5mdW5jdGlvbiBwYXJzZUNhaXBBY2NvdW50SWQoY2FpcEFjY291bnRJZCkge1xuICAgIGNvbnN0IG1hdGNoID0gZXhwb3J0cy5DQUlQX0FDQ09VTlRfSURfUkVHRVguZXhlYyhjYWlwQWNjb3VudElkKTtcbiAgICBpZiAoIW1hdGNoPy5ncm91cHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENBSVAgYWNjb3VudCBJRC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogbWF0Y2guZ3JvdXBzLmFjY291bnRBZGRyZXNzLFxuICAgICAgICBjaGFpbklkOiBtYXRjaC5ncm91cHMuY2hhaW5JZCxcbiAgICAgICAgY2hhaW46IHtcbiAgICAgICAgICAgIG5hbWVzcGFjZTogbWF0Y2guZ3JvdXBzLm5hbWVzcGFjZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZTogbWF0Y2guZ3JvdXBzLnJlZmVyZW5jZSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0cy5wYXJzZUNhaXBBY2NvdW50SWQgPSBwYXJzZUNhaXBBY2NvdW50SWQ7XG4vKipcbiAqIFBhcnNlIGEgQ0FJUC0xOSBhc3NldCB0eXBlIHRvIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBjaGFpbiBJRCwgcGFyc2VkIGNoYWluIElELFxuICogYXNzZXQgbmFtZXNwYWNlLCBhbmQgYXNzZXQgcmVmZXJlbmNlXG4gKlxuICogVGhpcyB2YWxpZGF0ZXMgdGhlIENBSVAtMTkgYXNzZXQgdHlwZSBiZWZvcmUgcGFyc2luZyBpdC5cbiAqXG4gKiBAcGFyYW0gY2FpcEFzc2V0VHlwZSAtIFRoZSBDQUlQLTE5IGFzc2V0IHR5cGUgdG8gdmFsaWRhdGUgYW5kIHBhcnNlLlxuICogQHJldHVybnMgVGhlIHBhcnNlZCBDQUlQLTE5IGFzc2V0IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQ2FpcEFzc2V0VHlwZShjYWlwQXNzZXRUeXBlKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBleHBvcnRzLkNBSVBfQVNTRVRfVFlQRV9SRUdFWC5leGVjKGNhaXBBc3NldFR5cGUpO1xuICAgIGlmICghbWF0Y2g/Lmdyb3Vwcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgQ0FJUCBhc3NldCB0eXBlLicpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBhc3NldE5hbWVzcGFjZTogbWF0Y2guZ3JvdXBzLmFzc2V0TmFtZXNwYWNlLFxuICAgICAgICBhc3NldFJlZmVyZW5jZTogbWF0Y2guZ3JvdXBzLmFzc2V0UmVmZXJlbmNlLFxuICAgICAgICBjaGFpbklkOiBtYXRjaC5ncm91cHMuY2hhaW5JZCxcbiAgICAgICAgY2hhaW46IHtcbiAgICAgICAgICAgIG5hbWVzcGFjZTogbWF0Y2guZ3JvdXBzLm5hbWVzcGFjZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZTogbWF0Y2guZ3JvdXBzLnJlZmVyZW5jZSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0cy5wYXJzZUNhaXBBc3NldFR5cGUgPSBwYXJzZUNhaXBBc3NldFR5cGU7XG4vKipcbiAqIFBhcnNlIGEgQ0FJUC0xOSBhc3NldCBJRCB0byBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgY2hhaW4gSUQsIHBhcnNlZCBjaGFpbiBJRCxcbiAqIGFzc2V0IG5hbWVzcGFjZSwgYXNzZXQgcmVmZXJlbmNlLCBhbmQgdG9rZW4gSUQuXG4gKlxuICogVGhpcyB2YWxpZGF0ZXMgdGhlIENBSVAtMTkgYXNzZXQgSUQgYmVmb3JlIHBhcnNpbmcgaXQuXG4gKlxuICogQHBhcmFtIGNhaXBBc3NldElkIC0gVGhlIENBSVAtMTkgYXNzZXQgSUQgdG8gdmFsaWRhdGUgYW5kIHBhcnNlLlxuICogQHJldHVybnMgVGhlIHBhcnNlZCBDQUlQLTE5IGFzc2V0IElELlxuICovXG5mdW5jdGlvbiBwYXJzZUNhaXBBc3NldElkKGNhaXBBc3NldElkKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBleHBvcnRzLkNBSVBfQVNTRVRfSURfUkVHRVguZXhlYyhjYWlwQXNzZXRJZCk7XG4gICAgaWYgKCFtYXRjaD8uZ3JvdXBzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBDQUlQIGFzc2V0IElELicpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBhc3NldE5hbWVzcGFjZTogbWF0Y2guZ3JvdXBzLmFzc2V0TmFtZXNwYWNlLFxuICAgICAgICBhc3NldFJlZmVyZW5jZTogbWF0Y2guZ3JvdXBzLmFzc2V0UmVmZXJlbmNlLFxuICAgICAgICB0b2tlbklkOiBtYXRjaC5ncm91cHMudG9rZW5JZCxcbiAgICAgICAgY2hhaW5JZDogbWF0Y2guZ3JvdXBzLmNoYWluSWQsXG4gICAgICAgIGNoYWluOiB7XG4gICAgICAgICAgICBuYW1lc3BhY2U6IG1hdGNoLmdyb3Vwcy5uYW1lc3BhY2UsXG4gICAgICAgICAgICByZWZlcmVuY2U6IG1hdGNoLmdyb3Vwcy5yZWZlcmVuY2UsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydHMucGFyc2VDYWlwQXNzZXRJZCA9IHBhcnNlQ2FpcEFzc2V0SWQ7XG4vKipcbiAqIENoYWluIElEIGFzIGRlZmluZWQgcGVyIHRoZSBDQUlQLTJcbiAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vQ2hhaW5BZ25vc3RpYy9DQUlQcy9ibG9iL21haW4vQ0FJUHMvY2FpcC0yLm1kfS5cbiAqXG4gKiBJdCBkZWZpbmVzIGEgd2F5IHRvIHVuaXF1ZWx5IGlkZW50aWZ5IGFueSBibG9ja2NoYWluIGluIGEgaHVtYW4tcmVhZGFibGVcbiAqIHdheS5cbiAqXG4gKiBAcGFyYW0gbmFtZXNwYWNlIC0gVGhlIHN0YW5kYXJkIChlY29zeXN0ZW0pIG9mIHNpbWlsYXIgYmxvY2tjaGFpbnMuXG4gKiBAcGFyYW0gcmVmZXJlbmNlIC0gSWRlbnRpZnkgb2YgYSBibG9ja2NoYWluIHdpdGhpbiBhIGdpdmVuIG5hbWVzcGFjZS5cbiAqIEB0aHJvd3Mge0BsaW5rIEVycm9yfVxuICogVGhpcyBleGNlcHRpb24gaXMgdGhyb3duIGlmIHRoZSBpbnB1dHMgZG9lcyBub3QgY29tcGx5IHdpdGggdGhlIENBSVAtMlxuICogc3ludGF4IHNwZWNpZmljYXRpb25cbiAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vQ2hhaW5BZ25vc3RpYy9DQUlQcy9ibG9iL21haW4vQ0FJUHMvY2FpcC0yLm1kI3N5bnRheH0uXG4gKiBAcmV0dXJucyBBIENBSVAgY2hhaW4gSUQuXG4gKi9cbmZ1bmN0aW9uIHRvQ2FpcENoYWluSWQobmFtZXNwYWNlLCByZWZlcmVuY2UpIHtcbiAgICBpZiAoIWlzQ2FpcE5hbWVzcGFjZShuYW1lc3BhY2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBcIm5hbWVzcGFjZVwiLCBtdXN0IG1hdGNoOiAke2V4cG9ydHMuQ0FJUF9OQU1FU1BBQ0VfUkVHRVgudG9TdHJpbmcoKX1gKTtcbiAgICB9XG4gICAgaWYgKCFpc0NhaXBSZWZlcmVuY2UocmVmZXJlbmNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgXCJyZWZlcmVuY2VcIiwgbXVzdCBtYXRjaDogJHtleHBvcnRzLkNBSVBfUkVGRVJFTkNFX1JFR0VYLnRvU3RyaW5nKCl9YCk7XG4gICAgfVxuICAgIHJldHVybiBgJHtuYW1lc3BhY2V9OiR7cmVmZXJlbmNlfWA7XG59XG5leHBvcnRzLnRvQ2FpcENoYWluSWQgPSB0b0NhaXBDaGFpbklkO1xuLyoqXG4gKiBBY2NvdW50IElEIGFzIGRlZmluZWQgcGVyIHRoZSBDQUlQLTEwXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0NoYWluQWdub3N0aWMvQ0FJUHMvYmxvYi9tYWluL0NBSVBzL2NhaXAtMTAubWR9LlxuICpcbiAqIEl0IGRlZmluZXMgYSB3YXkgdG8gdW5pcXVlbHkgaWRlbnRpZnkgYW55IGJsb2NrY2hhaW4gYWNjb3VudCBpbiBhIGh1bWFuLXJlYWRhYmxlXG4gKiB3YXkuXG4gKlxuICogQHBhcmFtIG5hbWVzcGFjZSAtIFRoZSBzdGFuZGFyZCAoZWNvc3lzdGVtKSBvZiBzaW1pbGFyIGJsb2NrY2hhaW5zLlxuICogQHBhcmFtIHJlZmVyZW5jZSAtIElkZW50aXR5IG9mIGEgYmxvY2tjaGFpbiB3aXRoaW4gYSBnaXZlbiBuYW1lc3BhY2UuXG4gKiBAcGFyYW0gYWNjb3VudEFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgYmxvY2tjaGFpbiBhY2NvdW50LlxuICogQHRocm93cyB7QGxpbmsgRXJyb3J9XG4gKiBUaGlzIGV4Y2VwdGlvbiBpcyB0aHJvd24gaWYgdGhlIGlucHV0cyBkbyBub3QgY29tcGx5IHdpdGggdGhlIENBSVAtMTBcbiAqIHN5bnRheCBzcGVjaWZpY2F0aW9uXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0NoYWluQWdub3N0aWMvQ0FJUHMvYmxvYi9tYWluL0NBSVBzL2NhaXAtMTAubWQjc3ludGF4fS5cbiAqIEByZXR1cm5zIEEgQ0FJUCBhY2NvdW50IElELlxuICovXG5mdW5jdGlvbiB0b0NhaXBBY2NvdW50SWQobmFtZXNwYWNlLCByZWZlcmVuY2UsIGFjY291bnRBZGRyZXNzKSB7XG4gICAgaWYgKCFpc0NhaXBOYW1lc3BhY2UobmFtZXNwYWNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgXCJuYW1lc3BhY2VcIiwgbXVzdCBtYXRjaDogJHtleHBvcnRzLkNBSVBfTkFNRVNQQUNFX1JFR0VYLnRvU3RyaW5nKCl9YCk7XG4gICAgfVxuICAgIGlmICghaXNDYWlwUmVmZXJlbmNlKHJlZmVyZW5jZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFwicmVmZXJlbmNlXCIsIG11c3QgbWF0Y2g6ICR7ZXhwb3J0cy5DQUlQX1JFRkVSRU5DRV9SRUdFWC50b1N0cmluZygpfWApO1xuICAgIH1cbiAgICBpZiAoIWlzQ2FpcEFjY291bnRBZGRyZXNzKGFjY291bnRBZGRyZXNzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgXCJhY2NvdW50QWRkcmVzc1wiLCBtdXN0IG1hdGNoOiAke2V4cG9ydHMuQ0FJUF9BQ0NPVU5UX0FERFJFU1NfUkVHRVgudG9TdHJpbmcoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGAke25hbWVzcGFjZX06JHtyZWZlcmVuY2V9OiR7YWNjb3VudEFkZHJlc3N9YDtcbn1cbmV4cG9ydHMudG9DYWlwQWNjb3VudElkID0gdG9DYWlwQWNjb3VudElkO1xuLyoqXG4gKiBBc3NldCBUeXBlIGFzIGRlZmluZWQgcGVyIHRoZSBDQUlQLTE5XG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0NoYWluQWdub3N0aWMvQ0FJUHMvYmxvYi9tYWluL0NBSVBzL2NhaXAtMTkubWR9LlxuICpcbiAqIEl0IGRlZmluZXMgYSB3YXkgdG8gdW5pcXVlbHkgaWRlbnRpZnkgYW55IGJsb2NrY2hhaW4gYXNzZXQgaW4gYSBodW1hbi1yZWFkYWJsZVxuICogd2F5LlxuICpcbiAqIEBwYXJhbSBuYW1lc3BhY2UgLSBUaGUgc3RhbmRhcmQgKGVjb3N5c3RlbSkgb2Ygc2ltaWxhciBibG9ja2NoYWlucy5cbiAqIEBwYXJhbSByZWZlcmVuY2UgLSBJZGVudGl0eSBvZiBhIGJsb2NrY2hhaW4gd2l0aGluIGEgZ2l2ZW4gbmFtZXNwYWNlLlxuICogQHBhcmFtIGFzc2V0TmFtZXNwYWNlIC0gVGhlIG5hbWVzcGFjZSBkb21haW4gb2YgYW4gYXNzZXQuXG4gKiBAcGFyYW0gYXNzZXRSZWZlcmVuY2UgLSBUaGUgaWRlbnRpdHkgb2YgYW4gYXNzZXQgd2l0aGluIGEgZ2l2ZW4gbmFtZXNwYWNlLlxuICogQHRocm93cyB7QGxpbmsgRXJyb3J9XG4gKiBUaGlzIGV4Y2VwdGlvbiBpcyB0aHJvd24gaWYgdGhlIGlucHV0cyBkbyBub3QgY29tcGx5IHdpdGggdGhlIENBSVAtMTlcbiAqIHN5bnRheCBzcGVjaWZpY2F0aW9uXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0NoYWluQWdub3N0aWMvQ0FJUHMvYmxvYi9tYWluL0NBSVBzL2NhaXAtMTkubWQjc3ludGF4fS5cbiAqIEByZXR1cm5zIEEgQ0FJUCBhc3NldCB0eXBlLlxuICovXG5mdW5jdGlvbiB0b0NhaXBBc3NldFR5cGUobmFtZXNwYWNlLCByZWZlcmVuY2UsIGFzc2V0TmFtZXNwYWNlLCBhc3NldFJlZmVyZW5jZSkge1xuICAgIGlmICghaXNDYWlwTmFtZXNwYWNlKG5hbWVzcGFjZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFwibmFtZXNwYWNlXCIsIG11c3QgbWF0Y2g6ICR7ZXhwb3J0cy5DQUlQX05BTUVTUEFDRV9SRUdFWC50b1N0cmluZygpfWApO1xuICAgIH1cbiAgICBpZiAoIWlzQ2FpcFJlZmVyZW5jZShyZWZlcmVuY2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBcInJlZmVyZW5jZVwiLCBtdXN0IG1hdGNoOiAke2V4cG9ydHMuQ0FJUF9SRUZFUkVOQ0VfUkVHRVgudG9TdHJpbmcoKX1gKTtcbiAgICB9XG4gICAgaWYgKCFpc0NhaXBBc3NldE5hbWVzcGFjZShhc3NldE5hbWVzcGFjZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFwiYXNzZXROYW1lc3BhY2VcIiwgbXVzdCBtYXRjaDogJHtleHBvcnRzLkNBSVBfQVNTRVRfTkFNRVNQQUNFX1JFR0VYLnRvU3RyaW5nKCl9YCk7XG4gICAgfVxuICAgIGlmICghaXNDYWlwQXNzZXRSZWZlcmVuY2UoYXNzZXRSZWZlcmVuY2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBcImFzc2V0UmVmZXJlbmNlXCIsIG11c3QgbWF0Y2g6ICR7ZXhwb3J0cy5DQUlQX0FTU0VUX1JFRkVSRU5DRV9SRUdFWC50b1N0cmluZygpfWApO1xuICAgIH1cbiAgICByZXR1cm4gYCR7bmFtZXNwYWNlfToke3JlZmVyZW5jZX0vJHthc3NldE5hbWVzcGFjZX06JHthc3NldFJlZmVyZW5jZX1gO1xufVxuZXhwb3J0cy50b0NhaXBBc3NldFR5cGUgPSB0b0NhaXBBc3NldFR5cGU7XG4vKipcbiAqIEFzc2V0IElEIGFzIGRlZmluZWQgcGVyIHRoZSBDQUlQLTE5XG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0NoYWluQWdub3N0aWMvQ0FJUHMvYmxvYi9tYWluL0NBSVBzL2NhaXAtMTkubWR9LlxuICpcbiAqIEl0IGRlZmluZXMgYSB3YXkgdG8gdW5pcXVlbHkgaWRlbnRpZnkgYW55IGJsb2NrY2hhaW4gYXNzZXQgaW4gYSBodW1hbi1yZWFkYWJsZVxuICogd2F5LlxuICpcbiAqIEBwYXJhbSBuYW1lc3BhY2UgLSBUaGUgc3RhbmRhcmQgKGVjb3N5c3RlbSkgb2Ygc2ltaWxhciBibG9ja2NoYWlucy5cbiAqIEBwYXJhbSByZWZlcmVuY2UgLSBJZGVudGl0eSBvZiBhIGJsb2NrY2hhaW4gd2l0aGluIGEgZ2l2ZW4gbmFtZXNwYWNlLlxuICogQHBhcmFtIGFzc2V0TmFtZXNwYWNlIC0gVGhlIG5hbWVzcGFjZSBkb21haW4gb2YgYW4gYXNzZXQuXG4gKiBAcGFyYW0gYXNzZXRSZWZlcmVuY2UgLSBUaGUgaWRlbnRpdHkgb2YgYW4gYXNzZXQgd2l0aGluIGEgZ2l2ZW4gbmFtZXNwYWNlLlxuICogQHBhcmFtIHRva2VuSWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIGFuIGFkZHJlc3NhYmxlIGFzc2V0IG9mIGEgZ2l2ZW4gdHlwZS5cbiAqIEB0aHJvd3Mge0BsaW5rIEVycm9yfVxuICogVGhpcyBleGNlcHRpb24gaXMgdGhyb3duIGlmIHRoZSBpbnB1dHMgZG8gbm90IGNvbXBseSB3aXRoIHRoZSBDQUlQLTE5XG4gKiBzeW50YXggc3BlY2lmaWNhdGlvblxuICoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9DaGFpbkFnbm9zdGljL0NBSVBzL2Jsb2IvbWFpbi9DQUlQcy9jYWlwLTE5Lm1kI3N5bnRheH0uXG4gKiBAcmV0dXJucyBBIENBSVAgYXNzZXQgSUQuXG4gKi9cbmZ1bmN0aW9uIHRvQ2FpcEFzc2V0SWQobmFtZXNwYWNlLCByZWZlcmVuY2UsIGFzc2V0TmFtZXNwYWNlLCBhc3NldFJlZmVyZW5jZSwgdG9rZW5JZCkge1xuICAgIGlmICghaXNDYWlwTmFtZXNwYWNlKG5hbWVzcGFjZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFwibmFtZXNwYWNlXCIsIG11c3QgbWF0Y2g6ICR7ZXhwb3J0cy5DQUlQX05BTUVTUEFDRV9SRUdFWC50b1N0cmluZygpfWApO1xuICAgIH1cbiAgICBpZiAoIWlzQ2FpcFJlZmVyZW5jZShyZWZlcmVuY2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBcInJlZmVyZW5jZVwiLCBtdXN0IG1hdGNoOiAke2V4cG9ydHMuQ0FJUF9SRUZFUkVOQ0VfUkVHRVgudG9TdHJpbmcoKX1gKTtcbiAgICB9XG4gICAgaWYgKCFpc0NhaXBBc3NldE5hbWVzcGFjZShhc3NldE5hbWVzcGFjZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFwiYXNzZXROYW1lc3BhY2VcIiwgbXVzdCBtYXRjaDogJHtleHBvcnRzLkNBSVBfQVNTRVRfTkFNRVNQQUNFX1JFR0VYLnRvU3RyaW5nKCl9YCk7XG4gICAgfVxuICAgIGlmICghaXNDYWlwQXNzZXRSZWZlcmVuY2UoYXNzZXRSZWZlcmVuY2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBcImFzc2V0UmVmZXJlbmNlXCIsIG11c3QgbWF0Y2g6ICR7ZXhwb3J0cy5DQUlQX0FTU0VUX1JFRkVSRU5DRV9SRUdFWC50b1N0cmluZygpfWApO1xuICAgIH1cbiAgICBpZiAoIWlzQ2FpcFRva2VuSWQodG9rZW5JZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFwidG9rZW5JZFwiLCBtdXN0IG1hdGNoOiAke2V4cG9ydHMuQ0FJUF9UT0tFTl9JRF9SRUdFWC50b1N0cmluZygpfWApO1xuICAgIH1cbiAgICByZXR1cm4gYCR7bmFtZXNwYWNlfToke3JlZmVyZW5jZX0vJHthc3NldE5hbWVzcGFjZX06JHthc3NldFJlZmVyZW5jZX0vJHt0b2tlbklkfWA7XG59XG5leHBvcnRzLnRvQ2FpcEFzc2V0SWQgPSB0b0NhaXBBc3NldElkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FpcC10eXBlcy5janMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/dist/caip-types.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/dist/checksum.cjs":
/*!************************************************************!*\
  !*** ../../node_modules/@metamask/utils/dist/checksum.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChecksumStruct = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(rsc)/../../node_modules/@metamask/superstruct/dist/index.cjs\");\nconst base64_1 = __webpack_require__(/*! ./base64.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/base64.cjs\");\nexports.ChecksumStruct = (0, superstruct_1.size)((0, base64_1.base64)((0, superstruct_1.string)(), { paddingRequired: true }), 44, 44);\n//# sourceMappingURL=checksum.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NoZWNrc3VtLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEIsc0JBQXNCLG1CQUFPLENBQUMsNEZBQXVCO0FBQ3JELGlCQUFpQixtQkFBTyxDQUFDLDhFQUFjO0FBQ3ZDLHNCQUFzQiwrRUFBK0UsdUJBQXVCO0FBQzVIIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9jaGVja3N1bS5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNoZWNrc3VtU3RydWN0ID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svc3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBiYXNlNjRfMSA9IHJlcXVpcmUoXCIuL2Jhc2U2NC5janNcIik7XG5leHBvcnRzLkNoZWNrc3VtU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEuc2l6ZSkoKDAsIGJhc2U2NF8xLmJhc2U2NCkoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCB7IHBhZGRpbmdSZXF1aXJlZDogdHJ1ZSB9KSwgNDQsIDQ0KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrc3VtLmNqcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/dist/checksum.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/dist/coercers.cjs":
/*!************************************************************!*\
  !*** ../../node_modules/@metamask/utils/dist/coercers.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createHex = exports.createBytes = exports.createBigInt = exports.createNumber = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(rsc)/../../node_modules/@metamask/superstruct/dist/index.cjs\");\nconst assert_1 = __webpack_require__(/*! ./assert.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/assert.cjs\");\nconst bytes_1 = __webpack_require__(/*! ./bytes.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/bytes.cjs\");\nconst hex_1 = __webpack_require__(/*! ./hex.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/hex.cjs\");\nconst NumberLikeStruct = (0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.bigint)(), (0, superstruct_1.string)(), hex_1.StrictHexStruct]);\nconst NumberCoercer = (0, superstruct_1.coerce)((0, superstruct_1.number)(), NumberLikeStruct, Number);\nconst BigIntCoercer = (0, superstruct_1.coerce)((0, superstruct_1.bigint)(), NumberLikeStruct, BigInt);\nconst BytesLikeStruct = (0, superstruct_1.union)([hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array)]);\nconst BytesCoercer = (0, superstruct_1.coerce)((0, superstruct_1.instance)(Uint8Array), (0, superstruct_1.union)([hex_1.StrictHexStruct]), bytes_1.hexToBytes);\nconst HexCoercer = (0, superstruct_1.coerce)(hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array), bytes_1.bytesToHex);\n/**\n * Create a number from a number-like value.\n *\n * - If the value is a number, it is returned as-is.\n * - If the value is a `bigint`, it is converted to a number.\n * - If the value is a string, it is interpreted as a decimal number.\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is\n * interpreted as a hexadecimal number.\n *\n * This validates that the value is a number-like value, and that the resulting\n * number is not `NaN` or `Infinity`.\n *\n * @example\n * ```typescript\n * const value = createNumber('0x010203');\n * console.log(value); // 66051\n *\n * const otherValue = createNumber(123n);\n * console.log(otherValue); // 123\n * ```\n * @param value - The value to create the number from.\n * @returns The created number.\n * @throws If the value is not a number-like value, or if the resulting number\n * is `NaN` or `Infinity`.\n */\nfunction createNumber(value) {\n    try {\n        const result = (0, superstruct_1.create)(value, NumberCoercer);\n        (0, assert_1.assert)(Number.isFinite(result), `Expected a number-like value, got \"${value}\".`);\n        return result;\n    }\n    catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a number-like value, got \"${value}\".`);\n        }\n        /* istanbul ignore next */\n        throw error;\n    }\n}\nexports.createNumber = createNumber;\n/**\n * Create a `bigint` from a number-like value.\n *\n * - If the value is a number, it is converted to a `bigint`.\n * - If the value is a `bigint`, it is returned as-is.\n * - If the value is a string, it is interpreted as a decimal number and\n * converted to a `bigint`.\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is\n * interpreted as a hexadecimal number and converted to a `bigint`.\n *\n * @example\n * ```typescript\n * const value = createBigInt('0x010203');\n * console.log(value); // 16909060n\n *\n * const otherValue = createBigInt(123);\n * console.log(otherValue); // 123n\n * ```\n * @param value - The value to create the bigint from.\n * @returns The created bigint.\n * @throws If the value is not a number-like value.\n */\nfunction createBigInt(value) {\n    try {\n        // The `BigInt` constructor throws if the value is not a number-like value.\n        // There is no need to validate the value manually.\n        return (0, superstruct_1.create)(value, BigIntCoercer);\n    }\n    catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a number-like value, got \"${String(error.value)}\".`);\n        }\n        /* istanbul ignore next */\n        throw error;\n    }\n}\nexports.createBigInt = createBigInt;\n/**\n * Create a byte array from a bytes-like value.\n *\n * - If the value is a byte array, it is returned as-is.\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is interpreted\n * as a hexadecimal number and converted to a byte array.\n *\n * @example\n * ```typescript\n * const value = createBytes('0x010203');\n * console.log(value); // Uint8Array [ 1, 2, 3 ]\n *\n * const otherValue = createBytes('0x010203');\n * console.log(otherValue); // Uint8Array [ 1, 2, 3 ]\n * ```\n * @param value - The value to create the byte array from.\n * @returns The created byte array.\n * @throws If the value is not a bytes-like value.\n */\nfunction createBytes(value) {\n    if (typeof value === 'string' && value.toLowerCase() === '0x') {\n        return new Uint8Array();\n    }\n    try {\n        return (0, superstruct_1.create)(value, BytesCoercer);\n    }\n    catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a bytes-like value, got \"${String(error.value)}\".`);\n        }\n        /* istanbul ignore next */\n        throw error;\n    }\n}\nexports.createBytes = createBytes;\n/**\n * Create a hexadecimal string from a bytes-like value.\n *\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is returned\n * as-is.\n * - If the value is a `Uint8Array`, it is converted to a hex string.\n *\n * @example\n * ```typescript\n * const value = createHex(new Uint8Array([1, 2, 3]));\n * console.log(value); // '0x010203'\n *\n * const otherValue = createHex('0x010203');\n * console.log(otherValue); // '0x010203'\n * ```\n * @param value - The value to create the hex string from.\n * @returns The created hex string.\n * @throws If the value is not a bytes-like value.\n */\nfunction createHex(value) {\n    if ((value instanceof Uint8Array && value.length === 0) ||\n        (typeof value === 'string' && value.toLowerCase() === '0x')) {\n        return '0x';\n    }\n    try {\n        return (0, superstruct_1.create)(value, HexCoercer);\n    }\n    catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a bytes-like value, got \"${String(error.value)}\".`);\n        }\n        /* istanbul ignore next */\n        throw error;\n    }\n}\nexports.createHex = createHex;\n//# sourceMappingURL=coercers.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NvZXJjZXJzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyxtQkFBbUIsR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0I7QUFDckYsc0JBQXNCLG1CQUFPLENBQUMsNEZBQXVCO0FBQ3JELGlCQUFpQixtQkFBTyxDQUFDLDhFQUFjO0FBQ3ZDLGdCQUFnQixtQkFBTyxDQUFDLDRFQUFhO0FBQ3JDLGNBQWMsbUJBQU8sQ0FBQyx3RUFBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsTUFBTTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxNQUFNO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxvQkFBb0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsb0JBQW9CO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsb0JBQW9CO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NvZXJjZXJzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlSGV4ID0gZXhwb3J0cy5jcmVhdGVCeXRlcyA9IGV4cG9ydHMuY3JlYXRlQmlnSW50ID0gZXhwb3J0cy5jcmVhdGVOdW1iZXIgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcIkBtZXRhbWFzay9zdXBlcnN0cnVjdFwiKTtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0LmNqc1wiKTtcbmNvbnN0IGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlcy5janNcIik7XG5jb25zdCBoZXhfMSA9IHJlcXVpcmUoXCIuL2hleC5janNcIik7XG5jb25zdCBOdW1iZXJMaWtlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFsoMCwgc3VwZXJzdHJ1Y3RfMS5udW1iZXIpKCksICgwLCBzdXBlcnN0cnVjdF8xLmJpZ2ludCkoKSwgKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCBoZXhfMS5TdHJpY3RIZXhTdHJ1Y3RdKTtcbmNvbnN0IE51bWJlckNvZXJjZXIgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jb2VyY2UpKCgwLCBzdXBlcnN0cnVjdF8xLm51bWJlcikoKSwgTnVtYmVyTGlrZVN0cnVjdCwgTnVtYmVyKTtcbmNvbnN0IEJpZ0ludENvZXJjZXIgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jb2VyY2UpKCgwLCBzdXBlcnN0cnVjdF8xLmJpZ2ludCkoKSwgTnVtYmVyTGlrZVN0cnVjdCwgQmlnSW50KTtcbmNvbnN0IEJ5dGVzTGlrZVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbaGV4XzEuU3RyaWN0SGV4U3RydWN0LCAoMCwgc3VwZXJzdHJ1Y3RfMS5pbnN0YW5jZSkoVWludDhBcnJheSldKTtcbmNvbnN0IEJ5dGVzQ29lcmNlciA9ICgwLCBzdXBlcnN0cnVjdF8xLmNvZXJjZSkoKDAsIHN1cGVyc3RydWN0XzEuaW5zdGFuY2UpKFVpbnQ4QXJyYXkpLCAoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoW2hleF8xLlN0cmljdEhleFN0cnVjdF0pLCBieXRlc18xLmhleFRvQnl0ZXMpO1xuY29uc3QgSGV4Q29lcmNlciA9ICgwLCBzdXBlcnN0cnVjdF8xLmNvZXJjZSkoaGV4XzEuU3RyaWN0SGV4U3RydWN0LCAoMCwgc3VwZXJzdHJ1Y3RfMS5pbnN0YW5jZSkoVWludDhBcnJheSksIGJ5dGVzXzEuYnl0ZXNUb0hleCk7XG4vKipcbiAqIENyZWF0ZSBhIG51bWJlciBmcm9tIGEgbnVtYmVyLWxpa2UgdmFsdWUuXG4gKlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBudW1iZXIsIGl0IGlzIHJldHVybmVkIGFzLWlzLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBgYmlnaW50YCwgaXQgaXMgY29udmVydGVkIHRvIGEgbnVtYmVyLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcsIGl0IGlzIGludGVycHJldGVkIGFzIGEgZGVjaW1hbCBudW1iZXIuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGhleCBzdHJpbmcgKGkuZS4sIGl0IHN0YXJ0cyB3aXRoIFwiMHhcIiksIGl0IGlzXG4gKiBpbnRlcnByZXRlZCBhcyBhIGhleGFkZWNpbWFsIG51bWJlci5cbiAqXG4gKiBUaGlzIHZhbGlkYXRlcyB0aGF0IHRoZSB2YWx1ZSBpcyBhIG51bWJlci1saWtlIHZhbHVlLCBhbmQgdGhhdCB0aGUgcmVzdWx0aW5nXG4gKiBudW1iZXIgaXMgbm90IGBOYU5gIG9yIGBJbmZpbml0eWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHZhbHVlID0gY3JlYXRlTnVtYmVyKCcweDAxMDIwMycpO1xuICogY29uc29sZS5sb2codmFsdWUpOyAvLyA2NjA1MVxuICpcbiAqIGNvbnN0IG90aGVyVmFsdWUgPSBjcmVhdGVOdW1iZXIoMTIzbik7XG4gKiBjb25zb2xlLmxvZyhvdGhlclZhbHVlKTsgLy8gMTIzXG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjcmVhdGUgdGhlIG51bWJlciBmcm9tLlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgbnVtYmVyLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgbnVtYmVyLWxpa2UgdmFsdWUsIG9yIGlmIHRoZSByZXN1bHRpbmcgbnVtYmVyXG4gKiBpcyBgTmFOYCBvciBgSW5maW5pdHlgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVOdW1iZXIodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jcmVhdGUpKHZhbHVlLCBOdW1iZXJDb2VyY2VyKTtcbiAgICAgICAgKDAsIGFzc2VydF8xLmFzc2VydCkoTnVtYmVyLmlzRmluaXRlKHJlc3VsdCksIGBFeHBlY3RlZCBhIG51bWJlci1saWtlIHZhbHVlLCBnb3QgXCIke3ZhbHVlfVwiLmApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2Ygc3VwZXJzdHJ1Y3RfMS5TdHJ1Y3RFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIG51bWJlci1saWtlIHZhbHVlLCBnb3QgXCIke3ZhbHVlfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlTnVtYmVyID0gY3JlYXRlTnVtYmVyO1xuLyoqXG4gKiBDcmVhdGUgYSBgYmlnaW50YCBmcm9tIGEgbnVtYmVyLWxpa2UgdmFsdWUuXG4gKlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBudW1iZXIsIGl0IGlzIGNvbnZlcnRlZCB0byBhIGBiaWdpbnRgLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBgYmlnaW50YCwgaXQgaXMgcmV0dXJuZWQgYXMtaXMuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgaXQgaXMgaW50ZXJwcmV0ZWQgYXMgYSBkZWNpbWFsIG51bWJlciBhbmRcbiAqIGNvbnZlcnRlZCB0byBhIGBiaWdpbnRgLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBoZXggc3RyaW5nIChpLmUuLCBpdCBzdGFydHMgd2l0aCBcIjB4XCIpLCBpdCBpc1xuICogaW50ZXJwcmV0ZWQgYXMgYSBoZXhhZGVjaW1hbCBudW1iZXIgYW5kIGNvbnZlcnRlZCB0byBhIGBiaWdpbnRgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCB2YWx1ZSA9IGNyZWF0ZUJpZ0ludCgnMHgwMTAyMDMnKTtcbiAqIGNvbnNvbGUubG9nKHZhbHVlKTsgLy8gMTY5MDkwNjBuXG4gKlxuICogY29uc3Qgb3RoZXJWYWx1ZSA9IGNyZWF0ZUJpZ0ludCgxMjMpO1xuICogY29uc29sZS5sb2cob3RoZXJWYWx1ZSk7IC8vIDEyM25cbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNyZWF0ZSB0aGUgYmlnaW50IGZyb20uXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBiaWdpbnQuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBudW1iZXItbGlrZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmlnSW50KHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gVGhlIGBCaWdJbnRgIGNvbnN0cnVjdG9yIHRocm93cyBpZiB0aGUgdmFsdWUgaXMgbm90IGEgbnVtYmVyLWxpa2UgdmFsdWUuXG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIG5lZWQgdG8gdmFsaWRhdGUgdGhlIHZhbHVlIG1hbnVhbGx5LlxuICAgICAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuY3JlYXRlKSh2YWx1ZSwgQmlnSW50Q29lcmNlcik7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBzdXBlcnN0cnVjdF8xLlN0cnVjdEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgbnVtYmVyLWxpa2UgdmFsdWUsIGdvdCBcIiR7U3RyaW5nKGVycm9yLnZhbHVlKX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZUJpZ0ludCA9IGNyZWF0ZUJpZ0ludDtcbi8qKlxuICogQ3JlYXRlIGEgYnl0ZSBhcnJheSBmcm9tIGEgYnl0ZXMtbGlrZSB2YWx1ZS5cbiAqXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGJ5dGUgYXJyYXksIGl0IGlzIHJldHVybmVkIGFzLWlzLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBoZXggc3RyaW5nIChpLmUuLCBpdCBzdGFydHMgd2l0aCBcIjB4XCIpLCBpdCBpcyBpbnRlcnByZXRlZFxuICogYXMgYSBoZXhhZGVjaW1hbCBudW1iZXIgYW5kIGNvbnZlcnRlZCB0byBhIGJ5dGUgYXJyYXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHZhbHVlID0gY3JlYXRlQnl0ZXMoJzB4MDEwMjAzJyk7XG4gKiBjb25zb2xlLmxvZyh2YWx1ZSk7IC8vIFVpbnQ4QXJyYXkgWyAxLCAyLCAzIF1cbiAqXG4gKiBjb25zdCBvdGhlclZhbHVlID0gY3JlYXRlQnl0ZXMoJzB4MDEwMjAzJyk7XG4gKiBjb25zb2xlLmxvZyhvdGhlclZhbHVlKTsgLy8gVWludDhBcnJheSBbIDEsIDIsIDMgXVxuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY3JlYXRlIHRoZSBieXRlIGFycmF5IGZyb20uXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBieXRlIGFycmF5LlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgYnl0ZXMtbGlrZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnl0ZXModmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAnMHgnKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuY3JlYXRlKSh2YWx1ZSwgQnl0ZXNDb2VyY2VyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHN1cGVyc3RydWN0XzEuU3RydWN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBieXRlcy1saWtlIHZhbHVlLCBnb3QgXCIke1N0cmluZyhlcnJvci52YWx1ZSl9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVCeXRlcyA9IGNyZWF0ZUJ5dGVzO1xuLyoqXG4gKiBDcmVhdGUgYSBoZXhhZGVjaW1hbCBzdHJpbmcgZnJvbSBhIGJ5dGVzLWxpa2UgdmFsdWUuXG4gKlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBoZXggc3RyaW5nIChpLmUuLCBpdCBzdGFydHMgd2l0aCBcIjB4XCIpLCBpdCBpcyByZXR1cm5lZFxuICogYXMtaXMuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGBVaW50OEFycmF5YCwgaXQgaXMgY29udmVydGVkIHRvIGEgaGV4IHN0cmluZy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgdmFsdWUgPSBjcmVhdGVIZXgobmV3IFVpbnQ4QXJyYXkoWzEsIDIsIDNdKSk7XG4gKiBjb25zb2xlLmxvZyh2YWx1ZSk7IC8vICcweDAxMDIwMydcbiAqXG4gKiBjb25zdCBvdGhlclZhbHVlID0gY3JlYXRlSGV4KCcweDAxMDIwMycpO1xuICogY29uc29sZS5sb2cob3RoZXJWYWx1ZSk7IC8vICcweDAxMDIwMydcbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNyZWF0ZSB0aGUgaGV4IHN0cmluZyBmcm9tLlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgaGV4IHN0cmluZy5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIGJ5dGVzLWxpa2UgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUhleCh2YWx1ZSkge1xuICAgIGlmICgodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJzB4JykpIHtcbiAgICAgICAgcmV0dXJuICcweCc7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5jcmVhdGUpKHZhbHVlLCBIZXhDb2VyY2VyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHN1cGVyc3RydWN0XzEuU3RydWN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBieXRlcy1saWtlIHZhbHVlLCBnb3QgXCIke1N0cmluZyhlcnJvci52YWx1ZSl9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVIZXggPSBjcmVhdGVIZXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2VyY2Vycy5janMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/dist/coercers.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/dist/collections.cjs":
/*!***************************************************************!*\
  !*** ../../node_modules/@metamask/utils/dist/collections.cjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _FrozenMap_map, _FrozenSet_set;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FrozenSet = exports.FrozenMap = void 0;\n/**\n * A {@link ReadonlyMap} that cannot be modified after instantiation.\n * The implementation uses an inner map hidden via a private field, and the\n * immutability guarantee relies on it being impossible to get a reference\n * to this map.\n */\nclass FrozenMap {\n    get size() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").size;\n    }\n    [(_FrozenMap_map = new WeakMap(), Symbol.iterator)]() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\")[Symbol.iterator]();\n    }\n    constructor(entries) {\n        _FrozenMap_map.set(this, void 0);\n        __classPrivateFieldSet(this, _FrozenMap_map, new Map(entries), \"f\");\n        Object.freeze(this);\n    }\n    entries() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").entries();\n    }\n    forEach(callbackfn, thisArg) {\n        // We have to wrap the specified callback in order to prevent it from\n        // receiving a reference to the inner map.\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").forEach((value, key, _map) => callbackfn.call(thisArg, value, key, this));\n    }\n    get(key) {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").get(key);\n    }\n    has(key) {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").has(key);\n    }\n    keys() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").keys();\n    }\n    values() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").values();\n    }\n    toString() {\n        return `FrozenMap(${this.size}) {${this.size > 0\n            ? ` ${[...this.entries()]\n                .map(([key, value]) => `${String(key)} => ${String(value)}`)\n                .join(', ')} `\n            : ''}}`;\n    }\n}\nexports.FrozenMap = FrozenMap;\n/**\n * A {@link ReadonlySet} that cannot be modified after instantiation.\n * The implementation uses an inner set hidden via a private field, and the\n * immutability guarantee relies on it being impossible to get a reference\n * to this set.\n */\nclass FrozenSet {\n    get size() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").size;\n    }\n    [(_FrozenSet_set = new WeakMap(), Symbol.iterator)]() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\")[Symbol.iterator]();\n    }\n    constructor(values) {\n        _FrozenSet_set.set(this, void 0);\n        __classPrivateFieldSet(this, _FrozenSet_set, new Set(values), \"f\");\n        Object.freeze(this);\n    }\n    entries() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").entries();\n    }\n    forEach(callbackfn, thisArg) {\n        // We have to wrap the specified callback in order to prevent it from\n        // receiving a reference to the inner set.\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").forEach((value, value2, _set) => callbackfn.call(thisArg, value, value2, this));\n    }\n    has(value) {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").has(value);\n    }\n    keys() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").keys();\n    }\n    values() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").values();\n    }\n    toString() {\n        return `FrozenSet(${this.size}) {${this.size > 0\n            ? ` ${[...this.values()].map((member) => String(member)).join(', ')} `\n            : ''}}`;\n    }\n}\nexports.FrozenSet = FrozenSet;\nObject.freeze(FrozenMap);\nObject.freeze(FrozenMap.prototype);\nObject.freeze(FrozenSet);\nObject.freeze(FrozenSet.prototype);\n//# sourceMappingURL=collections.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NvbGxlY3Rpb25zLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyxpQkFBaUI7QUFDckM7QUFDQSxNQUFNLG1CQUFtQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVLEdBQUcsRUFBRTtBQUMzQyxrQkFBa0I7QUFDbEIsMENBQTBDLGFBQWEsS0FBSyxjQUFjO0FBQzFFLDZCQUE2QjtBQUM3QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLE1BQU0sbUJBQW1CO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVUsR0FBRyxFQUFFO0FBQzNDLGtCQUFrQiwrREFBK0Q7QUFDakYsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY29sbGVjdGlvbnMuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9Gcm96ZW5NYXBfbWFwLCBfRnJvemVuU2V0X3NldDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRnJvemVuU2V0ID0gZXhwb3J0cy5Gcm96ZW5NYXAgPSB2b2lkIDA7XG4vKipcbiAqIEEge0BsaW5rIFJlYWRvbmx5TWFwfSB0aGF0IGNhbm5vdCBiZSBtb2RpZmllZCBhZnRlciBpbnN0YW50aWF0aW9uLlxuICogVGhlIGltcGxlbWVudGF0aW9uIHVzZXMgYW4gaW5uZXIgbWFwIGhpZGRlbiB2aWEgYSBwcml2YXRlIGZpZWxkLCBhbmQgdGhlXG4gKiBpbW11dGFiaWxpdHkgZ3VhcmFudGVlIHJlbGllcyBvbiBpdCBiZWluZyBpbXBvc3NpYmxlIHRvIGdldCBhIHJlZmVyZW5jZVxuICogdG8gdGhpcyBtYXAuXG4gKi9cbmNsYXNzIEZyb3plbk1hcCB7XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuc2l6ZTtcbiAgICB9XG4gICAgWyhfRnJvemVuTWFwX21hcCA9IG5ldyBXZWFrTWFwKCksIFN5bWJvbC5pdGVyYXRvcildKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZW50cmllcykge1xuICAgICAgICBfRnJvemVuTWFwX21hcC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgbmV3IE1hcChlbnRyaWVzKSwgXCJmXCIpO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICBlbnRyaWVzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpLmVudHJpZXMoKTtcbiAgICB9XG4gICAgZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgdG8gd3JhcCB0aGUgc3BlY2lmaWVkIGNhbGxiYWNrIGluIG9yZGVyIHRvIHByZXZlbnQgaXQgZnJvbVxuICAgICAgICAvLyByZWNlaXZpbmcgYSByZWZlcmVuY2UgdG8gdGhlIGlubmVyIG1hcC5cbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS5mb3JFYWNoKCh2YWx1ZSwga2V5LCBfbWFwKSA9PiBjYWxsYmFja2ZuLmNhbGwodGhpc0FyZywgdmFsdWUsIGtleSwgdGhpcykpO1xuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuZ2V0KGtleSk7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS5oYXMoa2V5KTtcbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS5rZXlzKCk7XG4gICAgfVxuICAgIHZhbHVlcygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS52YWx1ZXMoKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgRnJvemVuTWFwKCR7dGhpcy5zaXplfSkgeyR7dGhpcy5zaXplID4gMFxuICAgICAgICAgICAgPyBgICR7Wy4uLnRoaXMuZW50cmllcygpXVxuICAgICAgICAgICAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCR7U3RyaW5nKGtleSl9ID0+ICR7U3RyaW5nKHZhbHVlKX1gKVxuICAgICAgICAgICAgICAgIC5qb2luKCcsICcpfSBgXG4gICAgICAgICAgICA6ICcnfX1gO1xuICAgIH1cbn1cbmV4cG9ydHMuRnJvemVuTWFwID0gRnJvemVuTWFwO1xuLyoqXG4gKiBBIHtAbGluayBSZWFkb25seVNldH0gdGhhdCBjYW5ub3QgYmUgbW9kaWZpZWQgYWZ0ZXIgaW5zdGFudGlhdGlvbi5cbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiB1c2VzIGFuIGlubmVyIHNldCBoaWRkZW4gdmlhIGEgcHJpdmF0ZSBmaWVsZCwgYW5kIHRoZVxuICogaW1tdXRhYmlsaXR5IGd1YXJhbnRlZSByZWxpZXMgb24gaXQgYmVpbmcgaW1wb3NzaWJsZSB0byBnZXQgYSByZWZlcmVuY2VcbiAqIHRvIHRoaXMgc2V0LlxuICovXG5jbGFzcyBGcm96ZW5TZXQge1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLnNpemU7XG4gICAgfVxuICAgIFsoX0Zyb3plblNldF9zZXQgPSBuZXcgV2Vha01hcCgpLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHZhbHVlcykge1xuICAgICAgICBfRnJvemVuU2V0X3NldC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgbmV3IFNldCh2YWx1ZXMpLCBcImZcIik7XG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgfVxuICAgIGVudHJpZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIikuZW50cmllcygpO1xuICAgIH1cbiAgICBmb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSB0byB3cmFwIHRoZSBzcGVjaWZpZWQgY2FsbGJhY2sgaW4gb3JkZXIgdG8gcHJldmVudCBpdCBmcm9tXG4gICAgICAgIC8vIHJlY2VpdmluZyBhIHJlZmVyZW5jZSB0byB0aGUgaW5uZXIgc2V0LlxuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLmZvckVhY2goKHZhbHVlLCB2YWx1ZTIsIF9zZXQpID0+IGNhbGxiYWNrZm4uY2FsbCh0aGlzQXJnLCB2YWx1ZSwgdmFsdWUyLCB0aGlzKSk7XG4gICAgfVxuICAgIGhhcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLmhhcyh2YWx1ZSk7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIikua2V5cygpO1xuICAgIH1cbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIikudmFsdWVzKCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYEZyb3plblNldCgke3RoaXMuc2l6ZX0pIHske3RoaXMuc2l6ZSA+IDBcbiAgICAgICAgICAgID8gYCAke1suLi50aGlzLnZhbHVlcygpXS5tYXAoKG1lbWJlcikgPT4gU3RyaW5nKG1lbWJlcikpLmpvaW4oJywgJyl9IGBcbiAgICAgICAgICAgIDogJyd9fWA7XG4gICAgfVxufVxuZXhwb3J0cy5Gcm96ZW5TZXQgPSBGcm96ZW5TZXQ7XG5PYmplY3QuZnJlZXplKEZyb3plbk1hcCk7XG5PYmplY3QuZnJlZXplKEZyb3plbk1hcC5wcm90b3R5cGUpO1xuT2JqZWN0LmZyZWV6ZShGcm96ZW5TZXQpO1xuT2JqZWN0LmZyZWV6ZShGcm96ZW5TZXQucHJvdG90eXBlKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbGxlY3Rpb25zLmNqcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/dist/collections.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/dist/encryption-types.cjs":
/*!********************************************************************!*\
  !*** ../../node_modules/@metamask/utils/dist/encryption-types.cjs ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=encryption-types.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2VuY3J5cHRpb24tdHlwZXMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9lbmNyeXB0aW9uLXR5cGVzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVuY3J5cHRpb24tdHlwZXMuY2pzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/dist/encryption-types.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/dist/errors.cjs":
/*!**********************************************************!*\
  !*** ../../node_modules/@metamask/utils/dist/errors.cjs ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.wrapError = exports.getErrorMessage = exports.isErrorWithStack = exports.isErrorWithMessage = exports.isErrorWithCode = void 0;\nconst pony_cause_1 = __webpack_require__(/*! pony-cause */ \"(rsc)/../../node_modules/pony-cause/index.js\");\nconst misc_1 = __webpack_require__(/*! ./misc.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/misc.cjs\");\n/**\n * Type guard for determining whether the given value is an instance of Error.\n * For errors generated via `fs.promises`, `error instanceof Error` won't work,\n * so we have to come up with another way of testing.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nfunction isError(error) {\n    return (error instanceof Error ||\n        ((0, misc_1.isObject)(error) && error.constructor.name === 'Error'));\n}\n/**\n * Type guard for determining whether the given value is an error object with a\n * `code` property such as the type of error that Node throws for filesystem\n * operations, etc.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nfunction isErrorWithCode(error) {\n    return typeof error === 'object' && error !== null && 'code' in error;\n}\nexports.isErrorWithCode = isErrorWithCode;\n/**\n * Type guard for determining whether the given value is an error object with a\n * `message` property, such as an instance of Error.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nfunction isErrorWithMessage(error) {\n    return typeof error === 'object' && error !== null && 'message' in error;\n}\nexports.isErrorWithMessage = isErrorWithMessage;\n/**\n * Type guard for determining whether the given value is an error object with a\n * `stack` property, such as an instance of Error.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nfunction isErrorWithStack(error) {\n    return typeof error === 'object' && error !== null && 'stack' in error;\n}\nexports.isErrorWithStack = isErrorWithStack;\n/**\n * Attempts to obtain the message from a possible error object, defaulting to an\n * empty string if it is impossible to do so.\n *\n * @param error - The possible error to get the message from.\n * @returns The message if `error` is an object with a `message` property;\n * the string version of `error` if it is not `undefined` or `null`; otherwise\n * an empty string.\n */\nfunction getErrorMessage(error) {\n    if (isErrorWithMessage(error) && typeof error.message === 'string') {\n        return error.message;\n    }\n    if ((0, misc_1.isNullOrUndefined)(error)) {\n        return '';\n    }\n    return String(error);\n}\nexports.getErrorMessage = getErrorMessage;\n/**\n * Builds a new error object, linking it to the original error via the `cause`\n * property if it is an Error.\n *\n * This function is useful to reframe error messages in general, but is\n * _critical_ when interacting with any of Node's filesystem functions as\n * provided via `fs.promises`, because these do not produce stack traces in the\n * case of an I/O error (see <https://github.com/nodejs/node/issues/30944>).\n *\n * @param originalError - The error to be wrapped (something throwable).\n * @param message - The desired message of the new error.\n * @returns A new error object.\n */\nfunction wrapError(originalError, message) {\n    if (isError(originalError)) {\n        let error;\n        if (Error.length === 2) {\n            // for some reason `tsserver` is not complaining that the\n            // Error constructor doesn't support a second argument in the editor,\n            // but `tsc` does. Error causes are not supported by our current tsc target (ES2020, we need ES2022 to make this work)\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            error = new Error(message, { cause: originalError });\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            error = new pony_cause_1.ErrorWithCause(message, { cause: originalError });\n        }\n        if (isErrorWithCode(originalError)) {\n            error.code = originalError.code;\n        }\n        return error;\n    }\n    if (message.length > 0) {\n        return new Error(`${String(originalError)}: ${message}`);\n    }\n    return new Error(String(originalError));\n}\nexports.wrapError = wrapError;\n//# sourceMappingURL=errors.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2Vycm9ycy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsdUJBQXVCLEdBQUcsd0JBQXdCLEdBQUcsMEJBQTBCLEdBQUcsdUJBQXVCO0FBQzdILHFCQUFxQixtQkFBTyxDQUFDLGdFQUFZO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQywwRUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHNCQUFzQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxzQkFBc0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCLElBQUksUUFBUTtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2Vycm9ycy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndyYXBFcnJvciA9IGV4cG9ydHMuZ2V0RXJyb3JNZXNzYWdlID0gZXhwb3J0cy5pc0Vycm9yV2l0aFN0YWNrID0gZXhwb3J0cy5pc0Vycm9yV2l0aE1lc3NhZ2UgPSBleHBvcnRzLmlzRXJyb3JXaXRoQ29kZSA9IHZvaWQgMDtcbmNvbnN0IHBvbnlfY2F1c2VfMSA9IHJlcXVpcmUoXCJwb255LWNhdXNlXCIpO1xuY29uc3QgbWlzY18xID0gcmVxdWlyZShcIi4vbWlzYy5janNcIik7XG4vKipcbiAqIFR5cGUgZ3VhcmQgZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIGluc3RhbmNlIG9mIEVycm9yLlxuICogRm9yIGVycm9ycyBnZW5lcmF0ZWQgdmlhIGBmcy5wcm9taXNlc2AsIGBlcnJvciBpbnN0YW5jZW9mIEVycm9yYCB3b24ndCB3b3JrLFxuICogc28gd2UgaGF2ZSB0byBjb21lIHVwIHdpdGggYW5vdGhlciB3YXkgb2YgdGVzdGluZy5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybnMgQSBib29sZWFuLlxuICovXG5mdW5jdGlvbiBpc0Vycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIChlcnJvciBpbnN0YW5jZW9mIEVycm9yIHx8XG4gICAgICAgICgoMCwgbWlzY18xLmlzT2JqZWN0KShlcnJvcikgJiYgZXJyb3IuY29uc3RydWN0b3IubmFtZSA9PT0gJ0Vycm9yJykpO1xufVxuLyoqXG4gKiBUeXBlIGd1YXJkIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBlcnJvciBvYmplY3Qgd2l0aCBhXG4gKiBgY29kZWAgcHJvcGVydHkgc3VjaCBhcyB0aGUgdHlwZSBvZiBlcnJvciB0aGF0IE5vZGUgdGhyb3dzIGZvciBmaWxlc3lzdGVtXG4gKiBvcGVyYXRpb25zLCBldGMuXG4gKlxuICogQHBhcmFtIGVycm9yIC0gVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm5zIEEgYm9vbGVhbi5cbiAqL1xuZnVuY3Rpb24gaXNFcnJvcldpdGhDb2RlKGVycm9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ2NvZGUnIGluIGVycm9yO1xufVxuZXhwb3J0cy5pc0Vycm9yV2l0aENvZGUgPSBpc0Vycm9yV2l0aENvZGU7XG4vKipcbiAqIFR5cGUgZ3VhcmQgZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIGVycm9yIG9iamVjdCB3aXRoIGFcbiAqIGBtZXNzYWdlYCBwcm9wZXJ0eSwgc3VjaCBhcyBhbiBpbnN0YW5jZSBvZiBFcnJvci5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybnMgQSBib29sZWFuLlxuICovXG5mdW5jdGlvbiBpc0Vycm9yV2l0aE1lc3NhZ2UoZXJyb3IpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBlcnJvciAhPT0gbnVsbCAmJiAnbWVzc2FnZScgaW4gZXJyb3I7XG59XG5leHBvcnRzLmlzRXJyb3JXaXRoTWVzc2FnZSA9IGlzRXJyb3JXaXRoTWVzc2FnZTtcbi8qKlxuICogVHlwZSBndWFyZCBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gZXJyb3Igb2JqZWN0IHdpdGggYVxuICogYHN0YWNrYCBwcm9wZXJ0eSwgc3VjaCBhcyBhbiBpbnN0YW5jZSBvZiBFcnJvci5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybnMgQSBib29sZWFuLlxuICovXG5mdW5jdGlvbiBpc0Vycm9yV2l0aFN0YWNrKGVycm9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ3N0YWNrJyBpbiBlcnJvcjtcbn1cbmV4cG9ydHMuaXNFcnJvcldpdGhTdGFjayA9IGlzRXJyb3JXaXRoU3RhY2s7XG4vKipcbiAqIEF0dGVtcHRzIHRvIG9idGFpbiB0aGUgbWVzc2FnZSBmcm9tIGEgcG9zc2libGUgZXJyb3Igb2JqZWN0LCBkZWZhdWx0aW5nIHRvIGFuXG4gKiBlbXB0eSBzdHJpbmcgaWYgaXQgaXMgaW1wb3NzaWJsZSB0byBkbyBzby5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgcG9zc2libGUgZXJyb3IgdG8gZ2V0IHRoZSBtZXNzYWdlIGZyb20uXG4gKiBAcmV0dXJucyBUaGUgbWVzc2FnZSBpZiBgZXJyb3JgIGlzIGFuIG9iamVjdCB3aXRoIGEgYG1lc3NhZ2VgIHByb3BlcnR5O1xuICogdGhlIHN0cmluZyB2ZXJzaW9uIG9mIGBlcnJvcmAgaWYgaXQgaXMgbm90IGB1bmRlZmluZWRgIG9yIGBudWxsYDsgb3RoZXJ3aXNlXG4gKiBhbiBlbXB0eSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShlcnJvcikge1xuICAgIGlmIChpc0Vycm9yV2l0aE1lc3NhZ2UoZXJyb3IpICYmIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgICB9XG4gICAgaWYgKCgwLCBtaXNjXzEuaXNOdWxsT3JVbmRlZmluZWQpKGVycm9yKSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcoZXJyb3IpO1xufVxuZXhwb3J0cy5nZXRFcnJvck1lc3NhZ2UgPSBnZXRFcnJvck1lc3NhZ2U7XG4vKipcbiAqIEJ1aWxkcyBhIG5ldyBlcnJvciBvYmplY3QsIGxpbmtpbmcgaXQgdG8gdGhlIG9yaWdpbmFsIGVycm9yIHZpYSB0aGUgYGNhdXNlYFxuICogcHJvcGVydHkgaWYgaXQgaXMgYW4gRXJyb3IuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VmdWwgdG8gcmVmcmFtZSBlcnJvciBtZXNzYWdlcyBpbiBnZW5lcmFsLCBidXQgaXNcbiAqIF9jcml0aWNhbF8gd2hlbiBpbnRlcmFjdGluZyB3aXRoIGFueSBvZiBOb2RlJ3MgZmlsZXN5c3RlbSBmdW5jdGlvbnMgYXNcbiAqIHByb3ZpZGVkIHZpYSBgZnMucHJvbWlzZXNgLCBiZWNhdXNlIHRoZXNlIGRvIG5vdCBwcm9kdWNlIHN0YWNrIHRyYWNlcyBpbiB0aGVcbiAqIGNhc2Ugb2YgYW4gSS9PIGVycm9yIChzZWUgPGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMzA5NDQ+KS5cbiAqXG4gKiBAcGFyYW0gb3JpZ2luYWxFcnJvciAtIFRoZSBlcnJvciB0byBiZSB3cmFwcGVkIChzb21ldGhpbmcgdGhyb3dhYmxlKS5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIGRlc2lyZWQgbWVzc2FnZSBvZiB0aGUgbmV3IGVycm9yLlxuICogQHJldHVybnMgQSBuZXcgZXJyb3Igb2JqZWN0LlxuICovXG5mdW5jdGlvbiB3cmFwRXJyb3Iob3JpZ2luYWxFcnJvciwgbWVzc2FnZSkge1xuICAgIGlmIChpc0Vycm9yKG9yaWdpbmFsRXJyb3IpKSB7XG4gICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgaWYgKEVycm9yLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgLy8gZm9yIHNvbWUgcmVhc29uIGB0c3NlcnZlcmAgaXMgbm90IGNvbXBsYWluaW5nIHRoYXQgdGhlXG4gICAgICAgICAgICAvLyBFcnJvciBjb25zdHJ1Y3RvciBkb2Vzbid0IHN1cHBvcnQgYSBzZWNvbmQgYXJndW1lbnQgaW4gdGhlIGVkaXRvcixcbiAgICAgICAgICAgIC8vIGJ1dCBgdHNjYCBkb2VzLiBFcnJvciBjYXVzZXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgb3VyIGN1cnJlbnQgdHNjIHRhcmdldCAoRVMyMDIwLCB3ZSBuZWVkIEVTMjAyMiB0byBtYWtlIHRoaXMgd29yaylcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UsIHsgY2F1c2U6IG9yaWdpbmFsRXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBlcnJvciA9IG5ldyBwb255X2NhdXNlXzEuRXJyb3JXaXRoQ2F1c2UobWVzc2FnZSwgeyBjYXVzZTogb3JpZ2luYWxFcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNFcnJvcldpdGhDb2RlKG9yaWdpbmFsRXJyb3IpKSB7XG4gICAgICAgICAgICBlcnJvci5jb2RlID0gb3JpZ2luYWxFcnJvci5jb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKGAke1N0cmluZyhvcmlnaW5hbEVycm9yKX06ICR7bWVzc2FnZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFcnJvcihTdHJpbmcob3JpZ2luYWxFcnJvcikpO1xufVxuZXhwb3J0cy53cmFwRXJyb3IgPSB3cmFwRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuY2pzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/dist/errors.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/dist/hex.cjs":
/*!*******************************************************!*\
  !*** ../../node_modules/@metamask/utils/dist/hex.cjs ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.remove0x = exports.add0x = exports.isValidHexAddress = exports.isValidHexAddressUnmemoized = exports.isValidChecksumAddress = exports.isValidChecksumAddressUnmemoized = exports.getChecksumAddress = exports.getChecksumAddressUnmemoized = exports.assertIsStrictHexString = exports.assertIsHexString = exports.isHexChecksumAddress = exports.isHexAddress = exports.isStrictHexString = exports.isHexString = exports.HexChecksumAddressStruct = exports.HexAddressStruct = exports.StrictHexStruct = exports.HexStruct = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(rsc)/../../node_modules/@metamask/superstruct/dist/index.cjs\");\nconst sha3_1 = __webpack_require__(/*! @noble/hashes/sha3 */ \"(rsc)/../../node_modules/@noble/hashes/sha3.js\");\nconst lodash_1 = __webpack_require__(/*! lodash */ \"(rsc)/../../node_modules/lodash/lodash.js\");\nconst assert_1 = __webpack_require__(/*! ./assert.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/assert.cjs\");\n// Use native regexes instead of superstruct for maximum performance.\n// Pre-compiled regex for maximum performance - avoids recompilation on each call\nconst HEX_REGEX = /^(?:0x)?[0-9a-f]+$/iu;\nconst STRICT_HEX_REGEX = /^0x[0-9a-f]+$/iu;\nconst HEX_ADDRESS_REGEX = /^0x[0-9a-f]{40}$/u;\nconst HEX_CHECKSUM_ADDRESS_REGEX = /^0x[0-9a-fA-F]{40}$/u;\nexports.HexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), HEX_REGEX);\nexports.StrictHexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), STRICT_HEX_REGEX);\nexports.HexAddressStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), HEX_ADDRESS_REGEX);\nexports.HexChecksumAddressStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), HEX_CHECKSUM_ADDRESS_REGEX);\nconst isString = (value) => typeof value === 'string';\n/**\n * Check if a string is a valid hex string.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */\nfunction isHexString(value) {\n    return isString(value) && HEX_REGEX.test(value);\n}\nexports.isHexString = isHexString;\n/**\n * Strictly check if a string is a valid hex string. A valid hex string must\n * start with the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */\nfunction isStrictHexString(value) {\n    return isString(value) && STRICT_HEX_REGEX.test(value);\n}\nexports.isStrictHexString = isStrictHexString;\n/**\n * Check if a string is a valid hex address.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex address.\n */\nfunction isHexAddress(value) {\n    return isString(value) && HEX_ADDRESS_REGEX.test(value);\n}\nexports.isHexAddress = isHexAddress;\n/**\n * Check if a string is a valid hex checksum address.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex checksum address.\n */\nfunction isHexChecksumAddress(value) {\n    return isString(value) && HEX_CHECKSUM_ADDRESS_REGEX.test(value);\n}\nexports.isHexChecksumAddress = isHexChecksumAddress;\n/**\n * Assert that a value is a valid hex string.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */\nfunction assertIsHexString(value) {\n    (0, assert_1.assert)(isHexString(value), 'Value must be a hexadecimal string.');\n}\nexports.assertIsHexString = assertIsHexString;\n/**\n * Assert that a value is a valid hex string. A valid hex string must start with\n * the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */\nfunction assertIsStrictHexString(value) {\n    (0, assert_1.assert)(isStrictHexString(value), 'Value must be a hexadecimal string, starting with \"0x\".');\n}\nexports.assertIsStrictHexString = assertIsStrictHexString;\n/**\n * Encode a passed hex string as an ERC-55 mixed-case checksum address.\n * This is the unmemoized version, primarily used for testing.\n *\n * @param hexAddress - The hex address to encode.\n * @returns The address encoded according to ERC-55.\n * @see https://eips.ethereum.org/EIPS/eip-55\n */\nfunction getChecksumAddressUnmemoized(hexAddress) {\n    (0, assert_1.assert)(isHexChecksumAddress(hexAddress), 'Invalid hex address.');\n    const address = remove0x(hexAddress).toLowerCase();\n    const hashBytes = (0, sha3_1.keccak_256)(address);\n    const { length } = address;\n    const result = new Array(length); // Pre-allocate array\n    for (let i = 0; i < length; i++) {\n        /* eslint-disable no-bitwise */\n        const byteIndex = i >> 1; // Faster than Math.floor(i / 2)\n        const nibbleIndex = i & 1; // Faster than i % 2\n        const byte = hashBytes[byteIndex];\n        const nibble = nibbleIndex === 0 ? byte >> 4 : byte & 0x0f;\n        /* eslint-enable no-bitwise */\n        result[i] = nibble >= 8 ? address[i].toUpperCase() : address[i];\n    }\n    return `0x${result.join('')}`;\n}\nexports.getChecksumAddressUnmemoized = getChecksumAddressUnmemoized;\n/**\n * Encode a passed hex string as an ERC-55 mixed-case checksum address.\n * This function is memoized for performance.\n *\n * @param hexAddress - The hex address to encode.\n * @returns The address encoded according to ERC-55.\n * @see https://eips.ethereum.org/EIPS/eip-55\n */\nexports.getChecksumAddress = (0, lodash_1.memoize)(getChecksumAddressUnmemoized);\n/**\n * Validate that the passed hex string is a valid ERC-55 mixed-case\n * checksum address.\n *\n * @param possibleChecksum - The hex address to check.\n * @returns True if the address is a checksum address.\n */\nfunction isValidChecksumAddressUnmemoized(possibleChecksum) {\n    if (!isHexChecksumAddress(possibleChecksum)) {\n        return false;\n    }\n    return (0, exports.getChecksumAddress)(possibleChecksum) === possibleChecksum;\n}\nexports.isValidChecksumAddressUnmemoized = isValidChecksumAddressUnmemoized;\n/**\n * Validate that the passed hex string is a valid ERC-55 mixed-case\n * checksum address.\n *\n * @param possibleChecksum - The hex address to check.\n * @returns True if the address is a checksum address.\n */\nexports.isValidChecksumAddress = (0, lodash_1.memoize)(isValidChecksumAddressUnmemoized);\n/**\n * Validate that the passed prefixed hex string is an all-lowercase\n * hex address, or a valid mixed-case checksum address.\n *\n * @param possibleAddress - Input parameter to check against.\n * @returns Whether or not the input is a valid hex address.\n */\nfunction isValidHexAddressUnmemoized(possibleAddress) {\n    return (isHexAddress(possibleAddress) || (0, exports.isValidChecksumAddress)(possibleAddress));\n}\nexports.isValidHexAddressUnmemoized = isValidHexAddressUnmemoized;\n/**\n * Validate that the passed prefixed hex string is an all-lowercase\n * hex address, or a valid mixed-case checksum address.\n *\n * @param possibleAddress - Input parameter to check against.\n * @returns Whether or not the input is a valid hex address.\n */\nexports.isValidHexAddress = (0, lodash_1.memoize)(isValidHexAddressUnmemoized);\n/**\n * Add the `0x`-prefix to a hexadecimal string. If the string already has the\n * prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to add the prefix to.\n * @returns The prefixed hexadecimal string.\n */\nfunction add0x(hexadecimal) {\n    if (hexadecimal.startsWith('0x')) {\n        return hexadecimal;\n    }\n    if (hexadecimal.startsWith('0X')) {\n        return `0x${hexadecimal.substring(2)}`;\n    }\n    return `0x${hexadecimal}`;\n}\nexports.add0x = add0x;\n/**\n * Remove the `0x`-prefix from a hexadecimal string. If the string doesn't have\n * the prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to remove the prefix from.\n * @returns The un-prefixed hexadecimal string.\n */\nfunction remove0x(hexadecimal) {\n    if (hexadecimal.startsWith('0x') || hexadecimal.startsWith('0X')) {\n        return hexadecimal.substring(2);\n    }\n    return hexadecimal;\n}\nexports.remove0x = remove0x;\n//# sourceMappingURL=hex.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2hleC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLEdBQUcsYUFBYSxHQUFHLHlCQUF5QixHQUFHLG1DQUFtQyxHQUFHLDhCQUE4QixHQUFHLHdDQUF3QyxHQUFHLDBCQUEwQixHQUFHLG9DQUFvQyxHQUFHLCtCQUErQixHQUFHLHlCQUF5QixHQUFHLDRCQUE0QixHQUFHLG9CQUFvQixHQUFHLHlCQUF5QixHQUFHLG1CQUFtQixHQUFHLGdDQUFnQyxHQUFHLHdCQUF3QixHQUFHLHVCQUF1QixHQUFHLGlCQUFpQjtBQUNwZ0Isc0JBQXNCLG1CQUFPLENBQUMsNEZBQXVCO0FBQ3JELGVBQWUsbUJBQU8sQ0FBQywwRUFBb0I7QUFDM0MsaUJBQWlCLG1CQUFPLENBQUMseURBQVE7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMsOEVBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsR0FBRztBQUMxQyxtREFBbUQsR0FBRztBQUN0RCxpQkFBaUI7QUFDakIsdUJBQXVCO0FBQ3ZCLHdCQUF3QjtBQUN4QixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLHNDQUFzQztBQUN0QyxvQkFBb0IsWUFBWTtBQUNoQztBQUNBLGtDQUFrQztBQUNsQyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2hleC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlbW92ZTB4ID0gZXhwb3J0cy5hZGQweCA9IGV4cG9ydHMuaXNWYWxpZEhleEFkZHJlc3MgPSBleHBvcnRzLmlzVmFsaWRIZXhBZGRyZXNzVW5tZW1vaXplZCA9IGV4cG9ydHMuaXNWYWxpZENoZWNrc3VtQWRkcmVzcyA9IGV4cG9ydHMuaXNWYWxpZENoZWNrc3VtQWRkcmVzc1VubWVtb2l6ZWQgPSBleHBvcnRzLmdldENoZWNrc3VtQWRkcmVzcyA9IGV4cG9ydHMuZ2V0Q2hlY2tzdW1BZGRyZXNzVW5tZW1vaXplZCA9IGV4cG9ydHMuYXNzZXJ0SXNTdHJpY3RIZXhTdHJpbmcgPSBleHBvcnRzLmFzc2VydElzSGV4U3RyaW5nID0gZXhwb3J0cy5pc0hleENoZWNrc3VtQWRkcmVzcyA9IGV4cG9ydHMuaXNIZXhBZGRyZXNzID0gZXhwb3J0cy5pc1N0cmljdEhleFN0cmluZyA9IGV4cG9ydHMuaXNIZXhTdHJpbmcgPSBleHBvcnRzLkhleENoZWNrc3VtQWRkcmVzc1N0cnVjdCA9IGV4cG9ydHMuSGV4QWRkcmVzc1N0cnVjdCA9IGV4cG9ydHMuU3RyaWN0SGV4U3RydWN0ID0gZXhwb3J0cy5IZXhTdHJ1Y3QgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcIkBtZXRhbWFzay9zdXBlcnN0cnVjdFwiKTtcbmNvbnN0IHNoYTNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3NoYTNcIik7XG5jb25zdCBsb2Rhc2hfMSA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydC5janNcIik7XG4vLyBVc2UgbmF0aXZlIHJlZ2V4ZXMgaW5zdGVhZCBvZiBzdXBlcnN0cnVjdCBmb3IgbWF4aW11bSBwZXJmb3JtYW5jZS5cbi8vIFByZS1jb21waWxlZCByZWdleCBmb3IgbWF4aW11bSBwZXJmb3JtYW5jZSAtIGF2b2lkcyByZWNvbXBpbGF0aW9uIG9uIGVhY2ggY2FsbFxuY29uc3QgSEVYX1JFR0VYID0gL14oPzoweCk/WzAtOWEtZl0rJC9pdTtcbmNvbnN0IFNUUklDVF9IRVhfUkVHRVggPSAvXjB4WzAtOWEtZl0rJC9pdTtcbmNvbnN0IEhFWF9BRERSRVNTX1JFR0VYID0gL14weFswLTlhLWZdezQwfSQvdTtcbmNvbnN0IEhFWF9DSEVDS1NVTV9BRERSRVNTX1JFR0VYID0gL14weFswLTlhLWZBLUZdezQwfSQvdTtcbmV4cG9ydHMuSGV4U3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEucGF0dGVybikoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCBIRVhfUkVHRVgpO1xuZXhwb3J0cy5TdHJpY3RIZXhTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5wYXR0ZXJuKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIFNUUklDVF9IRVhfUkVHRVgpO1xuZXhwb3J0cy5IZXhBZGRyZXNzU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEucGF0dGVybikoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCBIRVhfQUREUkVTU19SRUdFWCk7XG5leHBvcnRzLkhleENoZWNrc3VtQWRkcmVzc1N0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnBhdHRlcm4pKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgSEVYX0NIRUNLU1VNX0FERFJFU1NfUkVHRVgpO1xuY29uc3QgaXNTdHJpbmcgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIGlzIGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHZhbGlkIGhleCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nKHZhbHVlKSAmJiBIRVhfUkVHRVgudGVzdCh2YWx1ZSk7XG59XG5leHBvcnRzLmlzSGV4U3RyaW5nID0gaXNIZXhTdHJpbmc7XG4vKipcbiAqIFN0cmljdGx5IGNoZWNrIGlmIGEgc3RyaW5nIGlzIGEgdmFsaWQgaGV4IHN0cmluZy4gQSB2YWxpZCBoZXggc3RyaW5nIG11c3RcbiAqIHN0YXJ0IHdpdGggdGhlIFwiMHhcIi1wcmVmaXguXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB2YWxpZCBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdEhleFN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiBpc1N0cmluZyh2YWx1ZSkgJiYgU1RSSUNUX0hFWF9SRUdFWC50ZXN0KHZhbHVlKTtcbn1cbmV4cG9ydHMuaXNTdHJpY3RIZXhTdHJpbmcgPSBpc1N0cmljdEhleFN0cmluZztcbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgaXMgYSB2YWxpZCBoZXggYWRkcmVzcy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHZhbGlkIGhleCBhZGRyZXNzLlxuICovXG5mdW5jdGlvbiBpc0hleEFkZHJlc3ModmFsdWUpIHtcbiAgICByZXR1cm4gaXNTdHJpbmcodmFsdWUpICYmIEhFWF9BRERSRVNTX1JFR0VYLnRlc3QodmFsdWUpO1xufVxuZXhwb3J0cy5pc0hleEFkZHJlc3MgPSBpc0hleEFkZHJlc3M7XG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIGlzIGEgdmFsaWQgaGV4IGNoZWNrc3VtIGFkZHJlc3MuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB2YWxpZCBoZXggY2hlY2tzdW0gYWRkcmVzcy5cbiAqL1xuZnVuY3Rpb24gaXNIZXhDaGVja3N1bUFkZHJlc3ModmFsdWUpIHtcbiAgICByZXR1cm4gaXNTdHJpbmcodmFsdWUpICYmIEhFWF9DSEVDS1NVTV9BRERSRVNTX1JFR0VYLnRlc3QodmFsdWUpO1xufVxuZXhwb3J0cy5pc0hleENoZWNrc3VtQWRkcmVzcyA9IGlzSGV4Q2hlY2tzdW1BZGRyZXNzO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0hleFN0cmluZyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGlzSGV4U3RyaW5nKHZhbHVlKSwgJ1ZhbHVlIG11c3QgYmUgYSBoZXhhZGVjaW1hbCBzdHJpbmcuJyk7XG59XG5leHBvcnRzLmFzc2VydElzSGV4U3RyaW5nID0gYXNzZXJ0SXNIZXhTdHJpbmc7XG4vKipcbiAqIEFzc2VydCB0aGF0IGEgdmFsdWUgaXMgYSB2YWxpZCBoZXggc3RyaW5nLiBBIHZhbGlkIGhleCBzdHJpbmcgbXVzdCBzdGFydCB3aXRoXG4gKiB0aGUgXCIweFwiLXByZWZpeC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc1N0cmljdEhleFN0cmluZyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGlzU3RyaWN0SGV4U3RyaW5nKHZhbHVlKSwgJ1ZhbHVlIG11c3QgYmUgYSBoZXhhZGVjaW1hbCBzdHJpbmcsIHN0YXJ0aW5nIHdpdGggXCIweFwiLicpO1xufVxuZXhwb3J0cy5hc3NlcnRJc1N0cmljdEhleFN0cmluZyA9IGFzc2VydElzU3RyaWN0SGV4U3RyaW5nO1xuLyoqXG4gKiBFbmNvZGUgYSBwYXNzZWQgaGV4IHN0cmluZyBhcyBhbiBFUkMtNTUgbWl4ZWQtY2FzZSBjaGVja3N1bSBhZGRyZXNzLlxuICogVGhpcyBpcyB0aGUgdW5tZW1vaXplZCB2ZXJzaW9uLCBwcmltYXJpbHkgdXNlZCBmb3IgdGVzdGluZy5cbiAqXG4gKiBAcGFyYW0gaGV4QWRkcmVzcyAtIFRoZSBoZXggYWRkcmVzcyB0byBlbmNvZGUuXG4gKiBAcmV0dXJucyBUaGUgYWRkcmVzcyBlbmNvZGVkIGFjY29yZGluZyB0byBFUkMtNTUuXG4gKiBAc2VlIGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNTVcbiAqL1xuZnVuY3Rpb24gZ2V0Q2hlY2tzdW1BZGRyZXNzVW5tZW1vaXplZChoZXhBZGRyZXNzKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoaXNIZXhDaGVja3N1bUFkZHJlc3MoaGV4QWRkcmVzcyksICdJbnZhbGlkIGhleCBhZGRyZXNzLicpO1xuICAgIGNvbnN0IGFkZHJlc3MgPSByZW1vdmUweChoZXhBZGRyZXNzKS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGhhc2hCeXRlcyA9ICgwLCBzaGEzXzEua2VjY2FrXzI1NikoYWRkcmVzcyk7XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IGFkZHJlc3M7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KGxlbmd0aCk7IC8vIFByZS1hbGxvY2F0ZSBhcnJheVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuICAgICAgICBjb25zdCBieXRlSW5kZXggPSBpID4+IDE7IC8vIEZhc3RlciB0aGFuIE1hdGguZmxvb3IoaSAvIDIpXG4gICAgICAgIGNvbnN0IG5pYmJsZUluZGV4ID0gaSAmIDE7IC8vIEZhc3RlciB0aGFuIGkgJSAyXG4gICAgICAgIGNvbnN0IGJ5dGUgPSBoYXNoQnl0ZXNbYnl0ZUluZGV4XTtcbiAgICAgICAgY29uc3QgbmliYmxlID0gbmliYmxlSW5kZXggPT09IDAgPyBieXRlID4+IDQgOiBieXRlICYgMHgwZjtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1iaXR3aXNlICovXG4gICAgICAgIHJlc3VsdFtpXSA9IG5pYmJsZSA+PSA4ID8gYWRkcmVzc1tpXS50b1VwcGVyQ2FzZSgpIDogYWRkcmVzc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGAweCR7cmVzdWx0LmpvaW4oJycpfWA7XG59XG5leHBvcnRzLmdldENoZWNrc3VtQWRkcmVzc1VubWVtb2l6ZWQgPSBnZXRDaGVja3N1bUFkZHJlc3NVbm1lbW9pemVkO1xuLyoqXG4gKiBFbmNvZGUgYSBwYXNzZWQgaGV4IHN0cmluZyBhcyBhbiBFUkMtNTUgbWl4ZWQtY2FzZSBjaGVja3N1bSBhZGRyZXNzLlxuICogVGhpcyBmdW5jdGlvbiBpcyBtZW1vaXplZCBmb3IgcGVyZm9ybWFuY2UuXG4gKlxuICogQHBhcmFtIGhleEFkZHJlc3MgLSBUaGUgaGV4IGFkZHJlc3MgdG8gZW5jb2RlLlxuICogQHJldHVybnMgVGhlIGFkZHJlc3MgZW5jb2RlZCBhY2NvcmRpbmcgdG8gRVJDLTU1LlxuICogQHNlZSBodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTU1XG4gKi9cbmV4cG9ydHMuZ2V0Q2hlY2tzdW1BZGRyZXNzID0gKDAsIGxvZGFzaF8xLm1lbW9pemUpKGdldENoZWNrc3VtQWRkcmVzc1VubWVtb2l6ZWQpO1xuLyoqXG4gKiBWYWxpZGF0ZSB0aGF0IHRoZSBwYXNzZWQgaGV4IHN0cmluZyBpcyBhIHZhbGlkIEVSQy01NSBtaXhlZC1jYXNlXG4gKiBjaGVja3N1bSBhZGRyZXNzLlxuICpcbiAqIEBwYXJhbSBwb3NzaWJsZUNoZWNrc3VtIC0gVGhlIGhleCBhZGRyZXNzIHRvIGNoZWNrLlxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgYWRkcmVzcyBpcyBhIGNoZWNrc3VtIGFkZHJlc3MuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRDaGVja3N1bUFkZHJlc3NVbm1lbW9pemVkKHBvc3NpYmxlQ2hlY2tzdW0pIHtcbiAgICBpZiAoIWlzSGV4Q2hlY2tzdW1BZGRyZXNzKHBvc3NpYmxlQ2hlY2tzdW0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLmdldENoZWNrc3VtQWRkcmVzcykocG9zc2libGVDaGVja3N1bSkgPT09IHBvc3NpYmxlQ2hlY2tzdW07XG59XG5leHBvcnRzLmlzVmFsaWRDaGVja3N1bUFkZHJlc3NVbm1lbW9pemVkID0gaXNWYWxpZENoZWNrc3VtQWRkcmVzc1VubWVtb2l6ZWQ7XG4vKipcbiAqIFZhbGlkYXRlIHRoYXQgdGhlIHBhc3NlZCBoZXggc3RyaW5nIGlzIGEgdmFsaWQgRVJDLTU1IG1peGVkLWNhc2VcbiAqIGNoZWNrc3VtIGFkZHJlc3MuXG4gKlxuICogQHBhcmFtIHBvc3NpYmxlQ2hlY2tzdW0gLSBUaGUgaGV4IGFkZHJlc3MgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBhZGRyZXNzIGlzIGEgY2hlY2tzdW0gYWRkcmVzcy5cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzID0gKDAsIGxvZGFzaF8xLm1lbW9pemUpKGlzVmFsaWRDaGVja3N1bUFkZHJlc3NVbm1lbW9pemVkKTtcbi8qKlxuICogVmFsaWRhdGUgdGhhdCB0aGUgcGFzc2VkIHByZWZpeGVkIGhleCBzdHJpbmcgaXMgYW4gYWxsLWxvd2VyY2FzZVxuICogaGV4IGFkZHJlc3MsIG9yIGEgdmFsaWQgbWl4ZWQtY2FzZSBjaGVja3N1bSBhZGRyZXNzLlxuICpcbiAqIEBwYXJhbSBwb3NzaWJsZUFkZHJlc3MgLSBJbnB1dCBwYXJhbWV0ZXIgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIFdoZXRoZXIgb3Igbm90IHRoZSBpbnB1dCBpcyBhIHZhbGlkIGhleCBhZGRyZXNzLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkSGV4QWRkcmVzc1VubWVtb2l6ZWQocG9zc2libGVBZGRyZXNzKSB7XG4gICAgcmV0dXJuIChpc0hleEFkZHJlc3MocG9zc2libGVBZGRyZXNzKSB8fCAoMCwgZXhwb3J0cy5pc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzKShwb3NzaWJsZUFkZHJlc3MpKTtcbn1cbmV4cG9ydHMuaXNWYWxpZEhleEFkZHJlc3NVbm1lbW9pemVkID0gaXNWYWxpZEhleEFkZHJlc3NVbm1lbW9pemVkO1xuLyoqXG4gKiBWYWxpZGF0ZSB0aGF0IHRoZSBwYXNzZWQgcHJlZml4ZWQgaGV4IHN0cmluZyBpcyBhbiBhbGwtbG93ZXJjYXNlXG4gKiBoZXggYWRkcmVzcywgb3IgYSB2YWxpZCBtaXhlZC1jYXNlIGNoZWNrc3VtIGFkZHJlc3MuXG4gKlxuICogQHBhcmFtIHBvc3NpYmxlQWRkcmVzcyAtIElucHV0IHBhcmFtZXRlciB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMgV2hldGhlciBvciBub3QgdGhlIGlucHV0IGlzIGEgdmFsaWQgaGV4IGFkZHJlc3MuXG4gKi9cbmV4cG9ydHMuaXNWYWxpZEhleEFkZHJlc3MgPSAoMCwgbG9kYXNoXzEubWVtb2l6ZSkoaXNWYWxpZEhleEFkZHJlc3NVbm1lbW9pemVkKTtcbi8qKlxuICogQWRkIHRoZSBgMHhgLXByZWZpeCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy4gSWYgdGhlIHN0cmluZyBhbHJlYWR5IGhhcyB0aGVcbiAqIHByZWZpeCwgaXQgaXMgcmV0dXJuZWQgYXMtaXMuXG4gKlxuICogQHBhcmFtIGhleGFkZWNpbWFsIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBhZGQgdGhlIHByZWZpeCB0by5cbiAqIEByZXR1cm5zIFRoZSBwcmVmaXhlZCBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGFkZDB4KGhleGFkZWNpbWFsKSB7XG4gICAgaWYgKGhleGFkZWNpbWFsLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgcmV0dXJuIGhleGFkZWNpbWFsO1xuICAgIH1cbiAgICBpZiAoaGV4YWRlY2ltYWwuc3RhcnRzV2l0aCgnMFgnKSkge1xuICAgICAgICByZXR1cm4gYDB4JHtoZXhhZGVjaW1hbC5zdWJzdHJpbmcoMil9YDtcbiAgICB9XG4gICAgcmV0dXJuIGAweCR7aGV4YWRlY2ltYWx9YDtcbn1cbmV4cG9ydHMuYWRkMHggPSBhZGQweDtcbi8qKlxuICogUmVtb3ZlIHRoZSBgMHhgLXByZWZpeCBmcm9tIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBJZiB0aGUgc3RyaW5nIGRvZXNuJ3QgaGF2ZVxuICogdGhlIHByZWZpeCwgaXQgaXMgcmV0dXJuZWQgYXMtaXMuXG4gKlxuICogQHBhcmFtIGhleGFkZWNpbWFsIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byByZW1vdmUgdGhlIHByZWZpeCBmcm9tLlxuICogQHJldHVybnMgVGhlIHVuLXByZWZpeGVkIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlMHgoaGV4YWRlY2ltYWwpIHtcbiAgICBpZiAoaGV4YWRlY2ltYWwuc3RhcnRzV2l0aCgnMHgnKSB8fCBoZXhhZGVjaW1hbC5zdGFydHNXaXRoKCcwWCcpKSB7XG4gICAgICAgIHJldHVybiBoZXhhZGVjaW1hbC5zdWJzdHJpbmcoMik7XG4gICAgfVxuICAgIHJldHVybiBoZXhhZGVjaW1hbDtcbn1cbmV4cG9ydHMucmVtb3ZlMHggPSByZW1vdmUweDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhleC5janMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/dist/hex.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/dist/index.cjs":
/*!*********************************************************!*\
  !*** ../../node_modules/@metamask/utils/dist/index.cjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unitMap = exports.getValueOfUnit = exports.numberToString = exports.fromWei = exports.toWei = exports.remove0x = exports.add0x = exports.isValidChecksumAddress = exports.getChecksumAddress = exports.isValidHexAddress = exports.assertIsStrictHexString = exports.assertIsHexString = exports.isHexChecksumAddress = exports.isHexAddress = exports.isStrictHexString = exports.isHexString = exports.HexChecksumAddressStruct = exports.HexAddressStruct = exports.StrictHexStruct = exports.HexStruct = void 0;\n__exportStar(__webpack_require__(/*! ./assert.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/assert.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./base64.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/base64.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./bytes.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/bytes.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./caip-types.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/caip-types.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./checksum.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/checksum.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./coercers.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/coercers.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./collections.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/collections.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./encryption-types.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/encryption-types.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./errors.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/errors.cjs\"), exports);\nvar hex_1 = __webpack_require__(/*! ./hex.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/hex.cjs\");\nObject.defineProperty(exports, \"HexStruct\", ({ enumerable: true, get: function () { return hex_1.HexStruct; } }));\nObject.defineProperty(exports, \"StrictHexStruct\", ({ enumerable: true, get: function () { return hex_1.StrictHexStruct; } }));\nObject.defineProperty(exports, \"HexAddressStruct\", ({ enumerable: true, get: function () { return hex_1.HexAddressStruct; } }));\nObject.defineProperty(exports, \"HexChecksumAddressStruct\", ({ enumerable: true, get: function () { return hex_1.HexChecksumAddressStruct; } }));\nObject.defineProperty(exports, \"isHexString\", ({ enumerable: true, get: function () { return hex_1.isHexString; } }));\nObject.defineProperty(exports, \"isStrictHexString\", ({ enumerable: true, get: function () { return hex_1.isStrictHexString; } }));\nObject.defineProperty(exports, \"isHexAddress\", ({ enumerable: true, get: function () { return hex_1.isHexAddress; } }));\nObject.defineProperty(exports, \"isHexChecksumAddress\", ({ enumerable: true, get: function () { return hex_1.isHexChecksumAddress; } }));\nObject.defineProperty(exports, \"assertIsHexString\", ({ enumerable: true, get: function () { return hex_1.assertIsHexString; } }));\nObject.defineProperty(exports, \"assertIsStrictHexString\", ({ enumerable: true, get: function () { return hex_1.assertIsStrictHexString; } }));\nObject.defineProperty(exports, \"isValidHexAddress\", ({ enumerable: true, get: function () { return hex_1.isValidHexAddress; } }));\nObject.defineProperty(exports, \"getChecksumAddress\", ({ enumerable: true, get: function () { return hex_1.getChecksumAddress; } }));\nObject.defineProperty(exports, \"isValidChecksumAddress\", ({ enumerable: true, get: function () { return hex_1.isValidChecksumAddress; } }));\nObject.defineProperty(exports, \"add0x\", ({ enumerable: true, get: function () { return hex_1.add0x; } }));\nObject.defineProperty(exports, \"remove0x\", ({ enumerable: true, get: function () { return hex_1.remove0x; } }));\n__exportStar(__webpack_require__(/*! ./json.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/json.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./keyring.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/keyring.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./logging.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/logging.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./misc.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/misc.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./number.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/number.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./opaque.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/opaque.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./promise.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/promise.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./superstruct.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/superstruct.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./time.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/time.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./transaction-types.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/transaction-types.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./versions.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/versions.cjs\"), exports);\nvar unitsConversion_1 = __webpack_require__(/*! ./unitsConversion.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/unitsConversion.cjs\");\nObject.defineProperty(exports, \"toWei\", ({ enumerable: true, get: function () { return unitsConversion_1.toWei; } }));\nObject.defineProperty(exports, \"fromWei\", ({ enumerable: true, get: function () { return unitsConversion_1.fromWei; } }));\nObject.defineProperty(exports, \"numberToString\", ({ enumerable: true, get: function () { return unitsConversion_1.numberToString; } }));\nObject.defineProperty(exports, \"getValueOfUnit\", ({ enumerable: true, get: function () { return unitsConversion_1.getValueOfUnit; } }));\nObject.defineProperty(exports, \"unitMap\", ({ enumerable: true, get: function () { return unitsConversion_1.unitMap; } }));\n//# sourceMappingURL=index.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLEdBQUcsc0JBQXNCLEdBQUcsc0JBQXNCLEdBQUcsZUFBZSxHQUFHLGFBQWEsR0FBRyxnQkFBZ0IsR0FBRyxhQUFhLEdBQUcsOEJBQThCLEdBQUcsMEJBQTBCLEdBQUcseUJBQXlCLEdBQUcsK0JBQStCLEdBQUcseUJBQXlCLEdBQUcsNEJBQTRCLEdBQUcsb0JBQW9CLEdBQUcseUJBQXlCLEdBQUcsbUJBQW1CLEdBQUcsZ0NBQWdDLEdBQUcsd0JBQXdCLEdBQUcsdUJBQXVCLEdBQUcsaUJBQWlCO0FBQ2xmLGFBQWEsbUJBQU8sQ0FBQyw4RUFBYztBQUNuQyxhQUFhLG1CQUFPLENBQUMsOEVBQWM7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLDRFQUFhO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyxzRkFBa0I7QUFDdkMsYUFBYSxtQkFBTyxDQUFDLGtGQUFnQjtBQUNyQyxhQUFhLG1CQUFPLENBQUMsa0ZBQWdCO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLGtHQUF3QjtBQUM3QyxhQUFhLG1CQUFPLENBQUMsOEVBQWM7QUFDbkMsWUFBWSxtQkFBTyxDQUFDLHdFQUFXO0FBQy9CLDZDQUE0QyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUMvRyxtREFBa0QsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDM0gsb0RBQW1ELEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQzdILDREQUEyRCxFQUFFLHFDQUFxQywwQ0FBMEMsRUFBQztBQUM3SSwrQ0FBOEMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDbkgscURBQW9ELEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQy9ILGdEQUErQyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNySCx3REFBdUQsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDckkscURBQW9ELEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQy9ILDJEQUEwRCxFQUFFLHFDQUFxQyx5Q0FBeUMsRUFBQztBQUMzSSxxREFBb0QsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDL0gsc0RBQXFELEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQ2pJLDBEQUF5RCxFQUFFLHFDQUFxQyx3Q0FBd0MsRUFBQztBQUN6SSx5Q0FBd0MsRUFBRSxxQ0FBcUMsdUJBQXVCLEVBQUM7QUFDdkcsNENBQTJDLEVBQUUscUNBQXFDLDBCQUEwQixFQUFDO0FBQzdHLGFBQWEsbUJBQU8sQ0FBQywwRUFBWTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsZ0ZBQWU7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLGdGQUFlO0FBQ3BDLGFBQWEsbUJBQU8sQ0FBQywwRUFBWTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsOEVBQWM7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLDhFQUFjO0FBQ25DLGFBQWEsbUJBQU8sQ0FBQyxnRkFBZTtBQUNwQyxhQUFhLG1CQUFPLENBQUMsd0ZBQW1CO0FBQ3hDLGFBQWEsbUJBQU8sQ0FBQywwRUFBWTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsb0dBQXlCO0FBQzlDLGFBQWEsbUJBQU8sQ0FBQyxrRkFBZ0I7QUFDckMsd0JBQXdCLG1CQUFPLENBQUMsZ0dBQXVCO0FBQ3ZELHlDQUF3QyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUNuSCwyQ0FBMEMsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDdkgsa0RBQWlELEVBQUUscUNBQXFDLDRDQUE0QyxFQUFDO0FBQ3JJLGtEQUFpRCxFQUFFLHFDQUFxQyw0Q0FBNEMsRUFBQztBQUNySSwyQ0FBMEMsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDdkgiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2luZGV4LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51bml0TWFwID0gZXhwb3J0cy5nZXRWYWx1ZU9mVW5pdCA9IGV4cG9ydHMubnVtYmVyVG9TdHJpbmcgPSBleHBvcnRzLmZyb21XZWkgPSBleHBvcnRzLnRvV2VpID0gZXhwb3J0cy5yZW1vdmUweCA9IGV4cG9ydHMuYWRkMHggPSBleHBvcnRzLmlzVmFsaWRDaGVja3N1bUFkZHJlc3MgPSBleHBvcnRzLmdldENoZWNrc3VtQWRkcmVzcyA9IGV4cG9ydHMuaXNWYWxpZEhleEFkZHJlc3MgPSBleHBvcnRzLmFzc2VydElzU3RyaWN0SGV4U3RyaW5nID0gZXhwb3J0cy5hc3NlcnRJc0hleFN0cmluZyA9IGV4cG9ydHMuaXNIZXhDaGVja3N1bUFkZHJlc3MgPSBleHBvcnRzLmlzSGV4QWRkcmVzcyA9IGV4cG9ydHMuaXNTdHJpY3RIZXhTdHJpbmcgPSBleHBvcnRzLmlzSGV4U3RyaW5nID0gZXhwb3J0cy5IZXhDaGVja3N1bUFkZHJlc3NTdHJ1Y3QgPSBleHBvcnRzLkhleEFkZHJlc3NTdHJ1Y3QgPSBleHBvcnRzLlN0cmljdEhleFN0cnVjdCA9IGV4cG9ydHMuSGV4U3RydWN0ID0gdm9pZCAwO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc2VydC5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2U2NC5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2J5dGVzLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY2FpcC10eXBlcy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NoZWNrc3VtLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29lcmNlcnMuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2xsZWN0aW9ucy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2VuY3J5cHRpb24tdHlwZXMuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lcnJvcnMuY2pzXCIpLCBleHBvcnRzKTtcbnZhciBoZXhfMSA9IHJlcXVpcmUoXCIuL2hleC5janNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJIZXhTdHJ1Y3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhleF8xLkhleFN0cnVjdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN0cmljdEhleFN0cnVjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGV4XzEuU3RyaWN0SGV4U3RydWN0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSGV4QWRkcmVzc1N0cnVjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGV4XzEuSGV4QWRkcmVzc1N0cnVjdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkhleENoZWNrc3VtQWRkcmVzc1N0cnVjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGV4XzEuSGV4Q2hlY2tzdW1BZGRyZXNzU3RydWN0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNIZXhTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhleF8xLmlzSGV4U3RyaW5nOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNTdHJpY3RIZXhTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhleF8xLmlzU3RyaWN0SGV4U3RyaW5nOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNIZXhBZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoZXhfMS5pc0hleEFkZHJlc3M7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0hleENoZWNrc3VtQWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGV4XzEuaXNIZXhDaGVja3N1bUFkZHJlc3M7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhc3NlcnRJc0hleFN0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGV4XzEuYXNzZXJ0SXNIZXhTdHJpbmc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhc3NlcnRJc1N0cmljdEhleFN0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGV4XzEuYXNzZXJ0SXNTdHJpY3RIZXhTdHJpbmc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1ZhbGlkSGV4QWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGV4XzEuaXNWYWxpZEhleEFkZHJlc3M7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRDaGVja3N1bUFkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhleF8xLmdldENoZWNrc3VtQWRkcmVzczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzVmFsaWRDaGVja3N1bUFkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhleF8xLmlzVmFsaWRDaGVja3N1bUFkZHJlc3M7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhZGQweFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGV4XzEuYWRkMHg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZW1vdmUweFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGV4XzEucmVtb3ZlMHg7IH0gfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vanNvbi5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2tleXJpbmcuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9sb2dnaW5nLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbWlzYy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL251bWJlci5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL29wYXF1ZS5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Byb21pc2UuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zdXBlcnN0cnVjdC5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3RpbWUuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90cmFuc2FjdGlvbi10eXBlcy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZlcnNpb25zLmNqc1wiKSwgZXhwb3J0cyk7XG52YXIgdW5pdHNDb252ZXJzaW9uXzEgPSByZXF1aXJlKFwiLi91bml0c0NvbnZlcnNpb24uY2pzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9XZWlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaXRzQ29udmVyc2lvbl8xLnRvV2VpOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZnJvbVdlaVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pdHNDb252ZXJzaW9uXzEuZnJvbVdlaTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm51bWJlclRvU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bml0c0NvbnZlcnNpb25fMS5udW1iZXJUb1N0cmluZzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFZhbHVlT2ZVbml0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bml0c0NvbnZlcnNpb25fMS5nZXRWYWx1ZU9mVW5pdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVuaXRNYXBcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaXRzQ29udmVyc2lvbl8xLnVuaXRNYXA7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5janMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/dist/index.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/dist/json.cjs":
/*!********************************************************!*\
  !*** ../../node_modules/@metamask/utils/dist/json.cjs ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getJsonRpcIdValidator = exports.assertIsJsonRpcError = exports.isJsonRpcError = exports.assertIsJsonRpcFailure = exports.isJsonRpcFailure = exports.assertIsJsonRpcSuccess = exports.isJsonRpcSuccess = exports.assertIsJsonRpcResponse = exports.isJsonRpcResponse = exports.assertIsPendingJsonRpcResponse = exports.isPendingJsonRpcResponse = exports.JsonRpcResponseStruct = exports.JsonRpcFailureStruct = exports.JsonRpcSuccessStruct = exports.PendingJsonRpcResponseStruct = exports.assertIsJsonRpcRequest = exports.isJsonRpcRequest = exports.assertIsJsonRpcNotification = exports.isJsonRpcNotification = exports.JsonRpcNotificationStruct = exports.JsonRpcRequestStruct = exports.JsonRpcParamsStruct = exports.JsonRpcErrorStruct = exports.JsonRpcIdStruct = exports.JsonRpcVersionStruct = exports.jsonrpc2 = exports.getJsonSize = exports.getSafeJson = exports.isValidJson = exports.JsonStruct = exports.UnsafeJsonStruct = exports.exactOptional = exports.object = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(rsc)/../../node_modules/@metamask/superstruct/dist/index.cjs\");\nconst assert_1 = __webpack_require__(/*! ./assert.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/assert.cjs\");\nconst misc_1 = __webpack_require__(/*! ./misc.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/misc.cjs\");\n/**\n * A struct to check if the given value is a valid object, with support for\n * {@link exactOptional} types.\n *\n * @deprecated Use `exactOptional` and `object` from `@metamask/superstruct@>=3.2.0` instead.\n * @param schema - The schema of the object.\n * @returns A struct to check if the given value is an object.\n */\nconst object = (schema) => \n// The type is slightly different from a regular object struct, because we\n// want to make properties with `undefined` in their type optional, but not\n// `undefined` itself. This means that we need a type cast.\n(0, superstruct_1.object)(schema);\nexports.object = object;\n/**\n * Check the last field of a path is present.\n *\n * @param context - The context to check.\n * @param context.path - The path to check.\n * @param context.branch - The branch to check.\n * @returns Whether the last field of a path is present.\n */\nfunction hasOptional({ path, branch }) {\n    const field = path[path.length - 1];\n    return (0, misc_1.hasProperty)(branch[branch.length - 2], field);\n}\n/**\n * A struct which allows the property of an object to be absent, or to be present\n * as long as it's valid and not set to `undefined`.\n *\n * This struct should be used in conjunction with the {@link object} from this\n * library, to get proper type inference.\n *\n * @deprecated Use `exactOptional` and `object` from `@metamask/superstruct@>=3.2.0` instead.\n * @param struct - The struct to check the value against, if present.\n * @returns A struct to check if the given value is valid, or not present.\n * @example\n * ```ts\n * const struct = object({\n *   foo: exactOptional(string()),\n *   bar: exactOptional(number()),\n *   baz: optional(boolean()),\n *   qux: unknown(),\n * });\n *\n * type Type = Infer<typeof struct>;\n * // Type is equivalent to:\n * // {\n * //   foo?: string;\n * //   bar?: number;\n * //   baz?: boolean | undefined;\n * //   qux: unknown;\n * // }\n * ```\n */\nfunction exactOptional(struct) {\n    return new superstruct_1.Struct({\n        ...struct,\n        type: `optional ${struct.type}`,\n        validator: (value, context) => !hasOptional(context) || struct.validator(value, context),\n        refiner: (value, context) => !hasOptional(context) || struct.refiner(value, context),\n    });\n}\nexports.exactOptional = exactOptional;\n/**\n * Validate an unknown input to be valid JSON.\n *\n * Useful for constructing JSON structs.\n *\n * @param json - An unknown value.\n * @returns True if the value is valid JSON, otherwise false.\n */\nfunction validateJson(json) {\n    if (json === null || typeof json === 'boolean' || typeof json === 'string') {\n        return true;\n    }\n    if (typeof json === 'number' && Number.isFinite(json)) {\n        return true;\n    }\n    if (typeof json === 'object') {\n        let every = true;\n        if (Array.isArray(json)) {\n            // Ignoring linting error since for-of is significantly slower than a normal for-loop\n            // and performance is important in this specific function.\n            // eslint-disable-next-line @typescript-eslint/prefer-for-of\n            for (let i = 0; i < json.length; i++) {\n                if (!validateJson(json[i])) {\n                    every = false;\n                    break;\n                }\n            }\n            return every;\n        }\n        const entries = Object.entries(json);\n        // Ignoring linting errors since for-of is significantly slower than a normal for-loop\n        // and performance is important in this specific function.\n        // eslint-disable-next-line @typescript-eslint/prefer-for-of\n        for (let i = 0; i < entries.length; i++) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            if (typeof entries[i][0] !== 'string' || !validateJson(entries[i][1])) {\n                every = false;\n                break;\n            }\n        }\n        return every;\n    }\n    return false;\n}\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * Note that this struct is unsafe. For safe validation, use {@link JsonStruct}.\n */\nexports.UnsafeJsonStruct = (0, superstruct_1.define)('JSON', (json) => validateJson(json));\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * This struct sanitizes the value before validating it, so that it is safe to\n * use with untrusted input.\n */\nexports.JsonStruct = (0, superstruct_1.coerce)(exports.UnsafeJsonStruct, (0, superstruct_1.refine)((0, superstruct_1.any)(), 'JSON', (value) => (0, superstruct_1.is)(value, exports.UnsafeJsonStruct)), (value) => JSON.parse(JSON.stringify(value, (propKey, propValue) => {\n    // Strip __proto__ and constructor properties to prevent prototype pollution.\n    if (propKey === '__proto__' || propKey === 'constructor') {\n        return undefined;\n    }\n    return propValue;\n})));\n/**\n * Check if the given value is a valid {@link Json} value, i.e., a value that is\n * serializable to JSON.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link Json} value.\n */\nfunction isValidJson(value) {\n    try {\n        getSafeJson(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nexports.isValidJson = isValidJson;\n/**\n * Validate and return sanitized JSON.\n *\n * Note:\n * This function uses sanitized JsonStruct for validation\n * that applies stringify and then parse of a value provided\n * to ensure that there are no getters which can have side effects\n * that can cause security issues.\n *\n * @param value - JSON structure to be processed.\n * @returns Sanitized JSON structure.\n */\nfunction getSafeJson(value) {\n    return (0, superstruct_1.create)(value, exports.JsonStruct);\n}\nexports.getSafeJson = getSafeJson;\n/**\n * Get the size of a JSON value in bytes. This also validates the value.\n *\n * @param value - The JSON value to get the size of.\n * @returns The size of the JSON value in bytes.\n */\nfunction getJsonSize(value) {\n    (0, assert_1.assertStruct)(value, exports.JsonStruct, 'Invalid JSON value');\n    const json = JSON.stringify(value);\n    return new TextEncoder().encode(json).byteLength;\n}\nexports.getJsonSize = getJsonSize;\n/**\n * The string '2.0'.\n */\nexports.jsonrpc2 = '2.0';\nexports.JsonRpcVersionStruct = (0, superstruct_1.literal)(exports.jsonrpc2);\nexports.JsonRpcIdStruct = (0, superstruct_1.nullable)((0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.string)()]));\nexports.JsonRpcErrorStruct = (0, exports.object)({\n    code: (0, superstruct_1.integer)(),\n    message: (0, superstruct_1.string)(),\n    data: exactOptional(exports.JsonStruct),\n    stack: exactOptional((0, superstruct_1.string)()),\n});\nexports.JsonRpcParamsStruct = (0, superstruct_1.union)([(0, superstruct_1.record)((0, superstruct_1.string)(), exports.JsonStruct), (0, superstruct_1.array)(exports.JsonStruct)]);\nexports.JsonRpcRequestStruct = (0, exports.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    method: (0, superstruct_1.string)(),\n    params: exactOptional(exports.JsonRpcParamsStruct),\n});\nexports.JsonRpcNotificationStruct = (0, exports.object)({\n    jsonrpc: exports.JsonRpcVersionStruct,\n    method: (0, superstruct_1.string)(),\n    params: exactOptional(exports.JsonRpcParamsStruct),\n});\n/**\n * Check if the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcNotification}\n * object.\n */\nfunction isJsonRpcNotification(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcNotificationStruct);\n}\nexports.isJsonRpcNotification = isJsonRpcNotification;\n/**\n * Assert that the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcNotification} object.\n */\nfunction assertIsJsonRpcNotification(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcNotificationStruct, 'Invalid JSON-RPC notification', ErrorWrapper);\n}\nexports.assertIsJsonRpcNotification = assertIsJsonRpcNotification;\n/**\n * Check if the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcRequest} object.\n */\nfunction isJsonRpcRequest(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcRequestStruct);\n}\nexports.isJsonRpcRequest = isJsonRpcRequest;\n/**\n * Assert that the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The JSON-RPC request or notification to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcRequest} object.\n */\nfunction assertIsJsonRpcRequest(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcRequestStruct, 'Invalid JSON-RPC request', ErrorWrapper);\n}\nexports.assertIsJsonRpcRequest = assertIsJsonRpcRequest;\nexports.PendingJsonRpcResponseStruct = (0, superstruct_1.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    result: (0, superstruct_1.optional)((0, superstruct_1.unknown)()),\n    error: (0, superstruct_1.optional)(exports.JsonRpcErrorStruct),\n});\nexports.JsonRpcSuccessStruct = (0, exports.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    result: exports.JsonStruct,\n});\nexports.JsonRpcFailureStruct = (0, exports.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    error: exports.JsonRpcErrorStruct,\n});\nexports.JsonRpcResponseStruct = (0, superstruct_1.union)([\n    exports.JsonRpcSuccessStruct,\n    exports.JsonRpcFailureStruct,\n]);\n/**\n * Type guard to check whether specified JSON-RPC response is a\n * {@link PendingJsonRpcResponse}.\n *\n * @param response - The JSON-RPC response to check.\n * @returns Whether the specified JSON-RPC response is pending.\n */\nfunction isPendingJsonRpcResponse(response) {\n    return (0, superstruct_1.is)(response, exports.PendingJsonRpcResponseStruct);\n}\nexports.isPendingJsonRpcResponse = isPendingJsonRpcResponse;\n/**\n * Assert that the given value is a valid {@link PendingJsonRpcResponse} object.\n *\n * @param response - The JSON-RPC response to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link PendingJsonRpcResponse}\n * object.\n */\nfunction assertIsPendingJsonRpcResponse(response, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(response, exports.PendingJsonRpcResponseStruct, 'Invalid pending JSON-RPC response', ErrorWrapper);\n}\nexports.assertIsPendingJsonRpcResponse = assertIsPendingJsonRpcResponse;\n/**\n * Type guard to check if a value is a {@link JsonRpcResponse}.\n *\n * @param response - The object to check.\n * @returns Whether the object is a JsonRpcResponse.\n */\nfunction isJsonRpcResponse(response) {\n    return (0, superstruct_1.is)(response, exports.JsonRpcResponseStruct);\n}\nexports.isJsonRpcResponse = isJsonRpcResponse;\n/**\n * Assert that the given value is a valid {@link JsonRpcResponse} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcResponse} object.\n */\nfunction assertIsJsonRpcResponse(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcResponseStruct, 'Invalid JSON-RPC response', ErrorWrapper);\n}\nexports.assertIsJsonRpcResponse = assertIsJsonRpcResponse;\n/**\n * Check if the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcSuccess} object.\n */\nfunction isJsonRpcSuccess(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcSuccessStruct);\n}\nexports.isJsonRpcSuccess = isJsonRpcSuccess;\n/**\n * Assert that the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcSuccess} object.\n */\nfunction assertIsJsonRpcSuccess(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcSuccessStruct, 'Invalid JSON-RPC success response', ErrorWrapper);\n}\nexports.assertIsJsonRpcSuccess = assertIsJsonRpcSuccess;\n/**\n * Check if the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcFailure} object.\n */\nfunction isJsonRpcFailure(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcFailureStruct);\n}\nexports.isJsonRpcFailure = isJsonRpcFailure;\n/**\n * Assert that the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcFailure} object.\n */\nfunction assertIsJsonRpcFailure(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcFailureStruct, 'Invalid JSON-RPC failure response', ErrorWrapper);\n}\nexports.assertIsJsonRpcFailure = assertIsJsonRpcFailure;\n/**\n * Check if the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcError} object.\n */\nfunction isJsonRpcError(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcErrorStruct);\n}\nexports.isJsonRpcError = isJsonRpcError;\n/**\n * Assert that the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcError} object.\n */\nfunction assertIsJsonRpcError(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcErrorStruct, 'Invalid JSON-RPC error', ErrorWrapper);\n}\nexports.assertIsJsonRpcError = assertIsJsonRpcError;\n/**\n * Gets a function for validating JSON-RPC request / response `id` values.\n *\n * By manipulating the options of this factory, you can control the behavior\n * of the resulting validator for some edge cases. This is useful because e.g.\n * `null` should sometimes but not always be permitted.\n *\n * Note that the empty string (`''`) is always permitted by the JSON-RPC\n * specification, but that kind of sucks and you may want to forbid it in some\n * instances anyway.\n *\n * For more details, see the\n * [JSON-RPC Specification](https://www.jsonrpc.org/specification).\n *\n * @param options - An options object.\n * @param options.permitEmptyString - Whether the empty string (i.e. `''`)\n * should be treated as a valid ID. Default: `true`\n * @param options.permitFractions - Whether fractional numbers (e.g. `1.2`)\n * should be treated as valid IDs. Default: `false`\n * @param options.permitNull - Whether `null` should be treated as a valid ID.\n * Default: `true`\n * @returns The JSON-RPC ID validator function.\n */\nfunction getJsonRpcIdValidator(options) {\n    const { permitEmptyString, permitFractions, permitNull } = {\n        permitEmptyString: true,\n        permitFractions: false,\n        permitNull: true,\n        ...options,\n    };\n    /**\n     * Type guard for {@link JsonRpcId}.\n     *\n     * @param id - The JSON-RPC ID value to check.\n     * @returns Whether the given ID is valid per the options given to the\n     * factory.\n     */\n    const isValidJsonRpcId = (id) => {\n        return Boolean((typeof id === 'number' && (permitFractions || Number.isInteger(id))) ||\n            (typeof id === 'string' && (permitEmptyString || id.length > 0)) ||\n            (permitNull && id === null));\n    };\n    return isValidJsonRpcId;\n}\nexports.getJsonRpcIdValidator = getJsonRpcIdValidator;\n//# sourceMappingURL=json.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2pzb24uY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QixHQUFHLDRCQUE0QixHQUFHLHNCQUFzQixHQUFHLDhCQUE4QixHQUFHLHdCQUF3QixHQUFHLDhCQUE4QixHQUFHLHdCQUF3QixHQUFHLCtCQUErQixHQUFHLHlCQUF5QixHQUFHLHNDQUFzQyxHQUFHLGdDQUFnQyxHQUFHLDZCQUE2QixHQUFHLDRCQUE0QixHQUFHLDRCQUE0QixHQUFHLG9DQUFvQyxHQUFHLDhCQUE4QixHQUFHLHdCQUF3QixHQUFHLG1DQUFtQyxHQUFHLDZCQUE2QixHQUFHLGlDQUFpQyxHQUFHLDRCQUE0QixHQUFHLDJCQUEyQixHQUFHLDBCQUEwQixHQUFHLHVCQUF1QixHQUFHLDRCQUE0QixHQUFHLGdCQUFnQixHQUFHLG1CQUFtQixHQUFHLG1CQUFtQixHQUFHLG1CQUFtQixHQUFHLGtCQUFrQixHQUFHLHdCQUF3QixHQUFHLHFCQUFxQixHQUFHLGNBQWM7QUFDbjhCLHNCQUFzQixtQkFBTyxDQUFDLDRGQUF1QjtBQUNyRCxpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBYztBQUN2QyxlQUFlLG1CQUFPLENBQUMsMEVBQVk7QUFDbkM7QUFDQTtBQUNBLElBQUkscUJBQXFCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsY0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGlCQUFpQjtBQUMvRTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxZQUFZO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQiw0QkFBNEI7QUFDNUIsdUJBQXVCO0FBQ3ZCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwyQkFBMkI7QUFDM0IsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx3Q0FBd0MsMkJBQTJCO0FBQ25FO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDJDQUEyQywyQkFBMkI7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQyw4Q0FBOEMsMkJBQTJCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLHdDQUF3QyxzQkFBc0I7QUFDOUQ7QUFDQTtBQUNBLGdEQUFnRCxzQkFBc0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSwyQ0FBMkMsc0JBQXNCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckMsOENBQThDLHNCQUFzQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNkJBQTZCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsMkNBQTJDLDhCQUE4QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLHdDQUF3QyxzQkFBc0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSwyQ0FBMkMsdUJBQXVCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckMsOENBQThDLHVCQUF1QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSx3Q0FBd0Msc0JBQXNCO0FBQzlEO0FBQ0E7QUFDQSxnREFBZ0Qsc0JBQXNCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsMkNBQTJDLHNCQUFzQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDLDhDQUE4QyxzQkFBc0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0Esd0NBQXdDLHNCQUFzQjtBQUM5RDtBQUNBO0FBQ0EsZ0RBQWdELHNCQUFzQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLDJDQUEyQyxzQkFBc0I7QUFDakU7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQyw4Q0FBOEMsc0JBQXNCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLHdDQUF3QyxvQkFBb0I7QUFDNUQ7QUFDQTtBQUNBLGdEQUFnRCxvQkFBb0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSwyQ0FBMkMsb0JBQW9CO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckMsOENBQThDLG9CQUFvQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpREFBaUQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2pzb24uY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRKc29uUnBjSWRWYWxpZGF0b3IgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY0Vycm9yID0gZXhwb3J0cy5pc0pzb25ScGNFcnJvciA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjRmFpbHVyZSA9IGV4cG9ydHMuaXNKc29uUnBjRmFpbHVyZSA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjU3VjY2VzcyA9IGV4cG9ydHMuaXNKc29uUnBjU3VjY2VzcyA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2UgPSBleHBvcnRzLmlzSnNvblJwY1Jlc3BvbnNlID0gZXhwb3J0cy5hc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UgPSBleHBvcnRzLmlzUGVuZGluZ0pzb25ScGNSZXNwb25zZSA9IGV4cG9ydHMuSnNvblJwY1Jlc3BvbnNlU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCA9IGV4cG9ydHMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QgPSBleHBvcnRzLlBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY1JlcXVlc3QgPSBleHBvcnRzLmlzSnNvblJwY1JlcXVlc3QgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuaXNKc29uUnBjTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Kc29uUnBjTm90aWZpY2F0aW9uU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjUmVxdWVzdFN0cnVjdCA9IGV4cG9ydHMuSnNvblJwY1BhcmFtc1N0cnVjdCA9IGV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNWZXJzaW9uU3RydWN0ID0gZXhwb3J0cy5qc29ucnBjMiA9IGV4cG9ydHMuZ2V0SnNvblNpemUgPSBleHBvcnRzLmdldFNhZmVKc29uID0gZXhwb3J0cy5pc1ZhbGlkSnNvbiA9IGV4cG9ydHMuSnNvblN0cnVjdCA9IGV4cG9ydHMuVW5zYWZlSnNvblN0cnVjdCA9IGV4cG9ydHMuZXhhY3RPcHRpb25hbCA9IGV4cG9ydHMub2JqZWN0ID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svc3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydC5janNcIik7XG5jb25zdCBtaXNjXzEgPSByZXF1aXJlKFwiLi9taXNjLmNqc1wiKTtcbi8qKlxuICogQSBzdHJ1Y3QgdG8gY2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQgb2JqZWN0LCB3aXRoIHN1cHBvcnQgZm9yXG4gKiB7QGxpbmsgZXhhY3RPcHRpb25hbH0gdHlwZXMuXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIGBleGFjdE9wdGlvbmFsYCBhbmQgYG9iamVjdGAgZnJvbSBgQG1ldGFtYXNrL3N1cGVyc3RydWN0QD49My4yLjBgIGluc3RlYWQuXG4gKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSBvZiB0aGUgb2JqZWN0LlxuICogQHJldHVybnMgQSBzdHJ1Y3QgdG8gY2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIG9iamVjdC5cbiAqL1xuY29uc3Qgb2JqZWN0ID0gKHNjaGVtYSkgPT4gXG4vLyBUaGUgdHlwZSBpcyBzbGlnaHRseSBkaWZmZXJlbnQgZnJvbSBhIHJlZ3VsYXIgb2JqZWN0IHN0cnVjdCwgYmVjYXVzZSB3ZVxuLy8gd2FudCB0byBtYWtlIHByb3BlcnRpZXMgd2l0aCBgdW5kZWZpbmVkYCBpbiB0aGVpciB0eXBlIG9wdGlvbmFsLCBidXQgbm90XG4vLyBgdW5kZWZpbmVkYCBpdHNlbGYuIFRoaXMgbWVhbnMgdGhhdCB3ZSBuZWVkIGEgdHlwZSBjYXN0LlxuKDAsIHN1cGVyc3RydWN0XzEub2JqZWN0KShzY2hlbWEpO1xuZXhwb3J0cy5vYmplY3QgPSBvYmplY3Q7XG4vKipcbiAqIENoZWNrIHRoZSBsYXN0IGZpZWxkIG9mIGEgcGF0aCBpcyBwcmVzZW50LlxuICpcbiAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdG8gY2hlY2suXG4gKiBAcGFyYW0gY29udGV4dC5wYXRoIC0gVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0gY29udGV4dC5icmFuY2ggLSBUaGUgYnJhbmNoIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgbGFzdCBmaWVsZCBvZiBhIHBhdGggaXMgcHJlc2VudC5cbiAqL1xuZnVuY3Rpb24gaGFzT3B0aW9uYWwoeyBwYXRoLCBicmFuY2ggfSkge1xuICAgIGNvbnN0IGZpZWxkID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiAoMCwgbWlzY18xLmhhc1Byb3BlcnR5KShicmFuY2hbYnJhbmNoLmxlbmd0aCAtIDJdLCBmaWVsZCk7XG59XG4vKipcbiAqIEEgc3RydWN0IHdoaWNoIGFsbG93cyB0aGUgcHJvcGVydHkgb2YgYW4gb2JqZWN0IHRvIGJlIGFic2VudCwgb3IgdG8gYmUgcHJlc2VudFxuICogYXMgbG9uZyBhcyBpdCdzIHZhbGlkIGFuZCBub3Qgc2V0IHRvIGB1bmRlZmluZWRgLlxuICpcbiAqIFRoaXMgc3RydWN0IHNob3VsZCBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIHtAbGluayBvYmplY3R9IGZyb20gdGhpc1xuICogbGlicmFyeSwgdG8gZ2V0IHByb3BlciB0eXBlIGluZmVyZW5jZS5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYGV4YWN0T3B0aW9uYWxgIGFuZCBgb2JqZWN0YCBmcm9tIGBAbWV0YW1hc2svc3VwZXJzdHJ1Y3RAPj0zLjIuMGAgaW5zdGVhZC5cbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RydWN0IHRvIGNoZWNrIHRoZSB2YWx1ZSBhZ2FpbnN0LCBpZiBwcmVzZW50LlxuICogQHJldHVybnMgQSBzdHJ1Y3QgdG8gY2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIHZhbGlkLCBvciBub3QgcHJlc2VudC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3Qgc3RydWN0ID0gb2JqZWN0KHtcbiAqICAgZm9vOiBleGFjdE9wdGlvbmFsKHN0cmluZygpKSxcbiAqICAgYmFyOiBleGFjdE9wdGlvbmFsKG51bWJlcigpKSxcbiAqICAgYmF6OiBvcHRpb25hbChib29sZWFuKCkpLFxuICogICBxdXg6IHVua25vd24oKSxcbiAqIH0pO1xuICpcbiAqIHR5cGUgVHlwZSA9IEluZmVyPHR5cGVvZiBzdHJ1Y3Q+O1xuICogLy8gVHlwZSBpcyBlcXVpdmFsZW50IHRvOlxuICogLy8ge1xuICogLy8gICBmb28/OiBzdHJpbmc7XG4gKiAvLyAgIGJhcj86IG51bWJlcjtcbiAqIC8vICAgYmF6PzogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAqIC8vICAgcXV4OiB1bmtub3duO1xuICogLy8gfVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGV4YWN0T3B0aW9uYWwoc3RydWN0KSB7XG4gICAgcmV0dXJuIG5ldyBzdXBlcnN0cnVjdF8xLlN0cnVjdCh7XG4gICAgICAgIC4uLnN0cnVjdCxcbiAgICAgICAgdHlwZTogYG9wdGlvbmFsICR7c3RydWN0LnR5cGV9YCxcbiAgICAgICAgdmFsaWRhdG9yOiAodmFsdWUsIGNvbnRleHQpID0+ICFoYXNPcHRpb25hbChjb250ZXh0KSB8fCBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjb250ZXh0KSxcbiAgICAgICAgcmVmaW5lcjogKHZhbHVlLCBjb250ZXh0KSA9PiAhaGFzT3B0aW9uYWwoY29udGV4dCkgfHwgc3RydWN0LnJlZmluZXIodmFsdWUsIGNvbnRleHQpLFxuICAgIH0pO1xufVxuZXhwb3J0cy5leGFjdE9wdGlvbmFsID0gZXhhY3RPcHRpb25hbDtcbi8qKlxuICogVmFsaWRhdGUgYW4gdW5rbm93biBpbnB1dCB0byBiZSB2YWxpZCBKU09OLlxuICpcbiAqIFVzZWZ1bCBmb3IgY29uc3RydWN0aW5nIEpTT04gc3RydWN0cy5cbiAqXG4gKiBAcGFyYW0ganNvbiAtIEFuIHVua25vd24gdmFsdWUuXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB2YWxpZCBKU09OLCBvdGhlcndpc2UgZmFsc2UuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlSnNvbihqc29uKSB7XG4gICAgaWYgKGpzb24gPT09IG51bGwgfHwgdHlwZW9mIGpzb24gPT09ICdib29sZWFuJyB8fCB0eXBlb2YganNvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YganNvbiA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzRmluaXRlKGpzb24pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGpzb24gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGxldCBldmVyeSA9IHRydWU7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGpzb24pKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmluZyBsaW50aW5nIGVycm9yIHNpbmNlIGZvci1vZiBpcyBzaWduaWZpY2FudGx5IHNsb3dlciB0aGFuIGEgbm9ybWFsIGZvci1sb29wXG4gICAgICAgICAgICAvLyBhbmQgcGVyZm9ybWFuY2UgaXMgaW1wb3J0YW50IGluIHRoaXMgc3BlY2lmaWMgZnVuY3Rpb24uXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1mb3Itb2ZcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwganNvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghdmFsaWRhdGVKc29uKGpzb25baV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZXJ5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBldmVyeTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoanNvbik7XG4gICAgICAgIC8vIElnbm9yaW5nIGxpbnRpbmcgZXJyb3JzIHNpbmNlIGZvci1vZiBpcyBzaWduaWZpY2FudGx5IHNsb3dlciB0aGFuIGEgbm9ybWFsIGZvci1sb29wXG4gICAgICAgIC8vIGFuZCBwZXJmb3JtYW5jZSBpcyBpbXBvcnRhbnQgaW4gdGhpcyBzcGVjaWZpYyBmdW5jdGlvbi5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItZm9yLW9mXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW50cmllc1tpXVswXSAhPT0gJ3N0cmluZycgfHwgIXZhbGlkYXRlSnNvbihlbnRyaWVzW2ldWzFdKSkge1xuICAgICAgICAgICAgICAgIGV2ZXJ5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZXJ5O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIEEgc3RydWN0IHRvIGNoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIEpTT04tc2VyaWFsaXphYmxlIHZhbHVlLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIHN0cnVjdCBpcyB1bnNhZmUuIEZvciBzYWZlIHZhbGlkYXRpb24sIHVzZSB7QGxpbmsgSnNvblN0cnVjdH0uXG4gKi9cbmV4cG9ydHMuVW5zYWZlSnNvblN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLmRlZmluZSkoJ0pTT04nLCAoanNvbikgPT4gdmFsaWRhdGVKc29uKGpzb24pKTtcbi8qKlxuICogQSBzdHJ1Y3QgdG8gY2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQgSlNPTi1zZXJpYWxpemFibGUgdmFsdWUuXG4gKlxuICogVGhpcyBzdHJ1Y3Qgc2FuaXRpemVzIHRoZSB2YWx1ZSBiZWZvcmUgdmFsaWRhdGluZyBpdCwgc28gdGhhdCBpdCBpcyBzYWZlIHRvXG4gKiB1c2Ugd2l0aCB1bnRydXN0ZWQgaW5wdXQuXG4gKi9cbmV4cG9ydHMuSnNvblN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLmNvZXJjZSkoZXhwb3J0cy5VbnNhZmVKc29uU3RydWN0LCAoMCwgc3VwZXJzdHJ1Y3RfMS5yZWZpbmUpKCgwLCBzdXBlcnN0cnVjdF8xLmFueSkoKSwgJ0pTT04nLCAodmFsdWUpID0+ICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5VbnNhZmVKc29uU3RydWN0KSksICh2YWx1ZSkgPT4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWx1ZSwgKHByb3BLZXksIHByb3BWYWx1ZSkgPT4ge1xuICAgIC8vIFN0cmlwIF9fcHJvdG9fXyBhbmQgY29uc3RydWN0b3IgcHJvcGVydGllcyB0byBwcmV2ZW50IHByb3RvdHlwZSBwb2xsdXRpb24uXG4gICAgaWYgKHByb3BLZXkgPT09ICdfX3Byb3RvX18nIHx8IHByb3BLZXkgPT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZTtcbn0pKSk7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29ufSB2YWx1ZSwgaS5lLiwgYSB2YWx1ZSB0aGF0IGlzXG4gKiBzZXJpYWxpemFibGUgdG8gSlNPTi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29ufSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEpzb24odmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICBnZXRTYWZlSnNvbih2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLmlzVmFsaWRKc29uID0gaXNWYWxpZEpzb247XG4vKipcbiAqIFZhbGlkYXRlIGFuZCByZXR1cm4gc2FuaXRpemVkIEpTT04uXG4gKlxuICogTm90ZTpcbiAqIFRoaXMgZnVuY3Rpb24gdXNlcyBzYW5pdGl6ZWQgSnNvblN0cnVjdCBmb3IgdmFsaWRhdGlvblxuICogdGhhdCBhcHBsaWVzIHN0cmluZ2lmeSBhbmQgdGhlbiBwYXJzZSBvZiBhIHZhbHVlIHByb3ZpZGVkXG4gKiB0byBlbnN1cmUgdGhhdCB0aGVyZSBhcmUgbm8gZ2V0dGVycyB3aGljaCBjYW4gaGF2ZSBzaWRlIGVmZmVjdHNcbiAqIHRoYXQgY2FuIGNhdXNlIHNlY3VyaXR5IGlzc3Vlcy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBKU09OIHN0cnVjdHVyZSB0byBiZSBwcm9jZXNzZWQuXG4gKiBAcmV0dXJucyBTYW5pdGl6ZWQgSlNPTiBzdHJ1Y3R1cmUuXG4gKi9cbmZ1bmN0aW9uIGdldFNhZmVKc29uKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmNyZWF0ZSkodmFsdWUsIGV4cG9ydHMuSnNvblN0cnVjdCk7XG59XG5leHBvcnRzLmdldFNhZmVKc29uID0gZ2V0U2FmZUpzb247XG4vKipcbiAqIEdldCB0aGUgc2l6ZSBvZiBhIEpTT04gdmFsdWUgaW4gYnl0ZXMuIFRoaXMgYWxzbyB2YWxpZGF0ZXMgdGhlIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBKU09OIHZhbHVlIHRvIGdldCB0aGUgc2l6ZSBvZi5cbiAqIEByZXR1cm5zIFRoZSBzaXplIG9mIHRoZSBKU09OIHZhbHVlIGluIGJ5dGVzLlxuICovXG5mdW5jdGlvbiBnZXRKc29uU2l6ZSh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25TdHJ1Y3QsICdJbnZhbGlkIEpTT04gdmFsdWUnKTtcbiAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoanNvbikuYnl0ZUxlbmd0aDtcbn1cbmV4cG9ydHMuZ2V0SnNvblNpemUgPSBnZXRKc29uU2l6ZTtcbi8qKlxuICogVGhlIHN0cmluZyAnMi4wJy5cbiAqL1xuZXhwb3J0cy5qc29ucnBjMiA9ICcyLjAnO1xuZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLmxpdGVyYWwpKGV4cG9ydHMuanNvbnJwYzIpO1xuZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5udWxsYWJsZSkoKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFsoMCwgc3VwZXJzdHJ1Y3RfMS5udW1iZXIpKCksICgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKV0pKTtcbmV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0ID0gKDAsIGV4cG9ydHMub2JqZWN0KSh7XG4gICAgY29kZTogKDAsIHN1cGVyc3RydWN0XzEuaW50ZWdlcikoKSxcbiAgICBtZXNzYWdlOiAoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksXG4gICAgZGF0YTogZXhhY3RPcHRpb25hbChleHBvcnRzLkpzb25TdHJ1Y3QpLFxuICAgIHN0YWNrOiBleGFjdE9wdGlvbmFsKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSksXG59KTtcbmV4cG9ydHMuSnNvblJwY1BhcmFtc1N0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbKDAsIHN1cGVyc3RydWN0XzEucmVjb3JkKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIGV4cG9ydHMuSnNvblN0cnVjdCksICgwLCBzdXBlcnN0cnVjdF8xLmFycmF5KShleHBvcnRzLkpzb25TdHJ1Y3QpXSk7XG5leHBvcnRzLkpzb25ScGNSZXF1ZXN0U3RydWN0ID0gKDAsIGV4cG9ydHMub2JqZWN0KSh7XG4gICAgaWQ6IGV4cG9ydHMuSnNvblJwY0lkU3RydWN0LFxuICAgIGpzb25ycGM6IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gICAgbWV0aG9kOiAoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksXG4gICAgcGFyYW1zOiBleGFjdE9wdGlvbmFsKGV4cG9ydHMuSnNvblJwY1BhcmFtc1N0cnVjdCksXG59KTtcbmV4cG9ydHMuSnNvblJwY05vdGlmaWNhdGlvblN0cnVjdCA9ICgwLCBleHBvcnRzLm9iamVjdCkoe1xuICAgIGpzb25ycGM6IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gICAgbWV0aG9kOiAoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksXG4gICAgcGFyYW1zOiBleGFjdE9wdGlvbmFsKGV4cG9ydHMuSnNvblJwY1BhcmFtc1N0cnVjdCksXG59KTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNOb3RpZmljYXRpb259IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjTm90aWZpY2F0aW9ufVxuICogb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNOb3RpZmljYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNOb3RpZmljYXRpb25TdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNOb3RpZmljYXRpb24gPSBpc0pzb25ScGNOb3RpZmljYXRpb247XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjTm90aWZpY2F0aW9ufSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjTm90aWZpY2F0aW9ufSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY05vdGlmaWNhdGlvbih2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjTm90aWZpY2F0aW9uU3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyBub3RpZmljYXRpb24nLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNOb3RpZmljYXRpb24gPSBhc3NlcnRJc0pzb25ScGNOb3RpZmljYXRpb247XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVxdWVzdH0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNSZXF1ZXN0fSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY1JlcXVlc3QodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNSZXF1ZXN0U3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjUmVxdWVzdCA9IGlzSnNvblJwY1JlcXVlc3Q7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVxdWVzdH0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBKU09OLVJQQyByZXF1ZXN0IG9yIG5vdGlmaWNhdGlvbiB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1JlcXVlc3R9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjUmVxdWVzdCh2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjUmVxdWVzdFN0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgcmVxdWVzdCcsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY1JlcXVlc3QgPSBhc3NlcnRJc0pzb25ScGNSZXF1ZXN0O1xuZXhwb3J0cy5QZW5kaW5nSnNvblJwY1Jlc3BvbnNlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEub2JqZWN0KSh7XG4gICAgaWQ6IGV4cG9ydHMuSnNvblJwY0lkU3RydWN0LFxuICAgIGpzb25ycGM6IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gICAgcmVzdWx0OiAoMCwgc3VwZXJzdHJ1Y3RfMS5vcHRpb25hbCkoKDAsIHN1cGVyc3RydWN0XzEudW5rbm93bikoKSksXG4gICAgZXJyb3I6ICgwLCBzdXBlcnN0cnVjdF8xLm9wdGlvbmFsKShleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCksXG59KTtcbmV4cG9ydHMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QgPSAoMCwgZXhwb3J0cy5vYmplY3QpKHtcbiAgICBpZDogZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QsXG4gICAganNvbnJwYzogZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCxcbiAgICByZXN1bHQ6IGV4cG9ydHMuSnNvblN0cnVjdCxcbn0pO1xuZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCA9ICgwLCBleHBvcnRzLm9iamVjdCkoe1xuICAgIGlkOiBleHBvcnRzLkpzb25ScGNJZFN0cnVjdCxcbiAgICBqc29ucnBjOiBleHBvcnRzLkpzb25ScGNWZXJzaW9uU3RydWN0LFxuICAgIGVycm9yOiBleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCxcbn0pO1xuZXhwb3J0cy5Kc29uUnBjUmVzcG9uc2VTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoW1xuICAgIGV4cG9ydHMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QsXG4gICAgZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCxcbl0pO1xuLyoqXG4gKiBUeXBlIGd1YXJkIHRvIGNoZWNrIHdoZXRoZXIgc3BlY2lmaWVkIEpTT04tUlBDIHJlc3BvbnNlIGlzIGFcbiAqIHtAbGluayBQZW5kaW5nSnNvblJwY1Jlc3BvbnNlfS5cbiAqXG4gKiBAcGFyYW0gcmVzcG9uc2UgLSBUaGUgSlNPTi1SUEMgcmVzcG9uc2UgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzcGVjaWZpZWQgSlNPTi1SUEMgcmVzcG9uc2UgaXMgcGVuZGluZy5cbiAqL1xuZnVuY3Rpb24gaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKShyZXNwb25zZSwgZXhwb3J0cy5QZW5kaW5nSnNvblJwY1Jlc3BvbnNlU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlID0gaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgUGVuZGluZ0pzb25ScGNSZXNwb25zZX0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSBKU09OLVJQQyByZXNwb25zZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgUGVuZGluZ0pzb25ScGNSZXNwb25zZX1cbiAqIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlKHJlc3BvbnNlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHJlc3BvbnNlLCBleHBvcnRzLlBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QsICdJbnZhbGlkIHBlbmRpbmcgSlNPTi1SUEMgcmVzcG9uc2UnLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UgPSBhc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2U7XG4vKipcbiAqIFR5cGUgZ3VhcmQgdG8gY2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHtAbGluayBKc29uUnBjUmVzcG9uc2V9LlxuICpcbiAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBvYmplY3QgaXMgYSBKc29uUnBjUmVzcG9uc2UuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY1Jlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKShyZXNwb25zZSwgZXhwb3J0cy5Kc29uUnBjUmVzcG9uc2VTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNSZXNwb25zZSA9IGlzSnNvblJwY1Jlc3BvbnNlO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1Jlc3BvbnNlfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVzcG9uc2V9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2UodmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmFsdWUsIGV4cG9ydHMuSnNvblJwY1Jlc3BvbnNlU3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyByZXNwb25zZScsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY1Jlc3BvbnNlID0gYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2U7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjU3VjY2Vzc30gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNTdWNjZXNzfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY1N1Y2Nlc3ModmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNTdWNjZXNzU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjU3VjY2VzcyA9IGlzSnNvblJwY1N1Y2Nlc3M7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjU3VjY2Vzc30gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1N1Y2Nlc3N9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjU3VjY2Vzcyh2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjU3VjY2Vzc1N0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgc3VjY2VzcyByZXNwb25zZScsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY1N1Y2Nlc3MgPSBhc3NlcnRJc0pzb25ScGNTdWNjZXNzO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0ZhaWx1cmV9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjRmFpbHVyZX0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNGYWlsdXJlKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCk7XG59XG5leHBvcnRzLmlzSnNvblJwY0ZhaWx1cmUgPSBpc0pzb25ScGNGYWlsdXJlO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0ZhaWx1cmV9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIEpzb25ScGNGYWlsdXJlfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY0ZhaWx1cmUodmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmFsdWUsIGV4cG9ydHMuSnNvblJwY0ZhaWx1cmVTdHJ1Y3QsICdJbnZhbGlkIEpTT04tUlBDIGZhaWx1cmUgcmVzcG9uc2UnLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNGYWlsdXJlID0gYXNzZXJ0SXNKc29uUnBjRmFpbHVyZTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNFcnJvcn0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNFcnJvcn0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNFcnJvcih2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjRXJyb3IgPSBpc0pzb25ScGNFcnJvcjtcbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNFcnJvcn0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0Vycm9yfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY0Vycm9yKHZhbHVlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgZXJyb3InLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNFcnJvciA9IGFzc2VydElzSnNvblJwY0Vycm9yO1xuLyoqXG4gKiBHZXRzIGEgZnVuY3Rpb24gZm9yIHZhbGlkYXRpbmcgSlNPTi1SUEMgcmVxdWVzdCAvIHJlc3BvbnNlIGBpZGAgdmFsdWVzLlxuICpcbiAqIEJ5IG1hbmlwdWxhdGluZyB0aGUgb3B0aW9ucyBvZiB0aGlzIGZhY3RvcnksIHlvdSBjYW4gY29udHJvbCB0aGUgYmVoYXZpb3JcbiAqIG9mIHRoZSByZXN1bHRpbmcgdmFsaWRhdG9yIGZvciBzb21lIGVkZ2UgY2FzZXMuIFRoaXMgaXMgdXNlZnVsIGJlY2F1c2UgZS5nLlxuICogYG51bGxgIHNob3VsZCBzb21ldGltZXMgYnV0IG5vdCBhbHdheXMgYmUgcGVybWl0dGVkLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgZW1wdHkgc3RyaW5nIChgJydgKSBpcyBhbHdheXMgcGVybWl0dGVkIGJ5IHRoZSBKU09OLVJQQ1xuICogc3BlY2lmaWNhdGlvbiwgYnV0IHRoYXQga2luZCBvZiBzdWNrcyBhbmQgeW91IG1heSB3YW50IHRvIGZvcmJpZCBpdCBpbiBzb21lXG4gKiBpbnN0YW5jZXMgYW55d2F5LlxuICpcbiAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSB0aGVcbiAqIFtKU09OLVJQQyBTcGVjaWZpY2F0aW9uXShodHRwczovL3d3dy5qc29ucnBjLm9yZy9zcGVjaWZpY2F0aW9uKS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIG9wdGlvbnMucGVybWl0RW1wdHlTdHJpbmcgLSBXaGV0aGVyIHRoZSBlbXB0eSBzdHJpbmcgKGkuZS4gYCcnYClcbiAqIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgdmFsaWQgSUQuIERlZmF1bHQ6IGB0cnVlYFxuICogQHBhcmFtIG9wdGlvbnMucGVybWl0RnJhY3Rpb25zIC0gV2hldGhlciBmcmFjdGlvbmFsIG51bWJlcnMgKGUuZy4gYDEuMmApXG4gKiBzaG91bGQgYmUgdHJlYXRlZCBhcyB2YWxpZCBJRHMuIERlZmF1bHQ6IGBmYWxzZWBcbiAqIEBwYXJhbSBvcHRpb25zLnBlcm1pdE51bGwgLSBXaGV0aGVyIGBudWxsYCBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIHZhbGlkIElELlxuICogRGVmYXVsdDogYHRydWVgXG4gKiBAcmV0dXJucyBUaGUgSlNPTi1SUEMgSUQgdmFsaWRhdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBnZXRKc29uUnBjSWRWYWxpZGF0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IHsgcGVybWl0RW1wdHlTdHJpbmcsIHBlcm1pdEZyYWN0aW9ucywgcGVybWl0TnVsbCB9ID0ge1xuICAgICAgICBwZXJtaXRFbXB0eVN0cmluZzogdHJ1ZSxcbiAgICAgICAgcGVybWl0RnJhY3Rpb25zOiBmYWxzZSxcbiAgICAgICAgcGVybWl0TnVsbDogdHJ1ZSxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFR5cGUgZ3VhcmQgZm9yIHtAbGluayBKc29uUnBjSWR9LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIEpTT04tUlBDIElEIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIElEIGlzIHZhbGlkIHBlciB0aGUgb3B0aW9ucyBnaXZlbiB0byB0aGVcbiAgICAgKiBmYWN0b3J5LlxuICAgICAqL1xuICAgIGNvbnN0IGlzVmFsaWRKc29uUnBjSWQgPSAoaWQpID0+IHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oKHR5cGVvZiBpZCA9PT0gJ251bWJlcicgJiYgKHBlcm1pdEZyYWN0aW9ucyB8fCBOdW1iZXIuaXNJbnRlZ2VyKGlkKSkpIHx8XG4gICAgICAgICAgICAodHlwZW9mIGlkID09PSAnc3RyaW5nJyAmJiAocGVybWl0RW1wdHlTdHJpbmcgfHwgaWQubGVuZ3RoID4gMCkpIHx8XG4gICAgICAgICAgICAocGVybWl0TnVsbCAmJiBpZCA9PT0gbnVsbCkpO1xuICAgIH07XG4gICAgcmV0dXJuIGlzVmFsaWRKc29uUnBjSWQ7XG59XG5leHBvcnRzLmdldEpzb25ScGNJZFZhbGlkYXRvciA9IGdldEpzb25ScGNJZFZhbGlkYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpzb24uY2pzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/dist/json.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/dist/keyring.cjs":
/*!***********************************************************!*\
  !*** ../../node_modules/@metamask/utils/dist/keyring.cjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=keyring.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2tleXJpbmcuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9rZXlyaW5nLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleXJpbmcuY2pzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/dist/keyring.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/dist/logging.cjs":
/*!***********************************************************!*\
  !*** ../../node_modules/@metamask/utils/dist/logging.cjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createModuleLogger = exports.createProjectLogger = void 0;\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/../../node_modules/debug/src/index.js\"));\nconst globalLogger = (0, debug_1.default)('metamask');\n/**\n * Creates a logger via the `debug` library whose log messages will be tagged\n * using the name of your project. By default, such messages will be\n * suppressed, but you can reveal them by setting the `DEBUG` environment\n * variable to `metamask:<projectName>`. You can also set this variable to\n * `metamask:*` if you want to see log messages from all MetaMask projects that\n * are also using this function to create their loggers.\n *\n * @param projectName - The name of your project. This should be the name of\n * your NPM package if you're developing one.\n * @returns An instance of `debug`.\n */\nfunction createProjectLogger(projectName) {\n    return globalLogger.extend(projectName);\n}\nexports.createProjectLogger = createProjectLogger;\n/**\n * Creates a logger via the `debug` library which is derived from the logger for\n * the whole project whose log messages will be tagged using the name of your\n * module. By default, such messages will be suppressed, but you can reveal them\n * by setting the `DEBUG` environment variable to\n * `metamask:<projectName>:<moduleName>`. You can also set this variable to\n * `metamask:<projectName>:*` if you want to see log messages from the project,\n * or `metamask:*` if you want to see log messages from all MetaMask projects.\n *\n * @param projectLogger - The logger created via {@link createProjectLogger}.\n * @param moduleName - The name of your module. You could use the name of the\n * file where you're using this logger or some other name.\n * @returns An instance of `debug`.\n */\nfunction createModuleLogger(projectLogger, moduleName) {\n    return projectLogger.extend(moduleName);\n}\nexports.createModuleLogger = createModuleLogger;\n//# sourceMappingURL=logging.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2xvZ2dpbmcuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLEdBQUcsMkJBQTJCO0FBQ3hELGdDQUFnQyxtQkFBTyxDQUFDLDBEQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCwwQkFBMEI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2xvZ2dpbmcuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVNb2R1bGVMb2dnZXIgPSBleHBvcnRzLmNyZWF0ZVByb2plY3RMb2dnZXIgPSB2b2lkIDA7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBnbG9iYWxMb2dnZXIgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnbWV0YW1hc2snKTtcbi8qKlxuICogQ3JlYXRlcyBhIGxvZ2dlciB2aWEgdGhlIGBkZWJ1Z2AgbGlicmFyeSB3aG9zZSBsb2cgbWVzc2FnZXMgd2lsbCBiZSB0YWdnZWRcbiAqIHVzaW5nIHRoZSBuYW1lIG9mIHlvdXIgcHJvamVjdC4gQnkgZGVmYXVsdCwgc3VjaCBtZXNzYWdlcyB3aWxsIGJlXG4gKiBzdXBwcmVzc2VkLCBidXQgeW91IGNhbiByZXZlYWwgdGhlbSBieSBzZXR0aW5nIHRoZSBgREVCVUdgIGVudmlyb25tZW50XG4gKiB2YXJpYWJsZSB0byBgbWV0YW1hc2s6PHByb2plY3ROYW1lPmAuIFlvdSBjYW4gYWxzbyBzZXQgdGhpcyB2YXJpYWJsZSB0b1xuICogYG1ldGFtYXNrOipgIGlmIHlvdSB3YW50IHRvIHNlZSBsb2cgbWVzc2FnZXMgZnJvbSBhbGwgTWV0YU1hc2sgcHJvamVjdHMgdGhhdFxuICogYXJlIGFsc28gdXNpbmcgdGhpcyBmdW5jdGlvbiB0byBjcmVhdGUgdGhlaXIgbG9nZ2Vycy5cbiAqXG4gKiBAcGFyYW0gcHJvamVjdE5hbWUgLSBUaGUgbmFtZSBvZiB5b3VyIHByb2plY3QuIFRoaXMgc2hvdWxkIGJlIHRoZSBuYW1lIG9mXG4gKiB5b3VyIE5QTSBwYWNrYWdlIGlmIHlvdSdyZSBkZXZlbG9waW5nIG9uZS5cbiAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIGBkZWJ1Z2AuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByb2plY3RMb2dnZXIocHJvamVjdE5hbWUpIHtcbiAgICByZXR1cm4gZ2xvYmFsTG9nZ2VyLmV4dGVuZChwcm9qZWN0TmFtZSk7XG59XG5leHBvcnRzLmNyZWF0ZVByb2plY3RMb2dnZXIgPSBjcmVhdGVQcm9qZWN0TG9nZ2VyO1xuLyoqXG4gKiBDcmVhdGVzIGEgbG9nZ2VyIHZpYSB0aGUgYGRlYnVnYCBsaWJyYXJ5IHdoaWNoIGlzIGRlcml2ZWQgZnJvbSB0aGUgbG9nZ2VyIGZvclxuICogdGhlIHdob2xlIHByb2plY3Qgd2hvc2UgbG9nIG1lc3NhZ2VzIHdpbGwgYmUgdGFnZ2VkIHVzaW5nIHRoZSBuYW1lIG9mIHlvdXJcbiAqIG1vZHVsZS4gQnkgZGVmYXVsdCwgc3VjaCBtZXNzYWdlcyB3aWxsIGJlIHN1cHByZXNzZWQsIGJ1dCB5b3UgY2FuIHJldmVhbCB0aGVtXG4gKiBieSBzZXR0aW5nIHRoZSBgREVCVUdgIGVudmlyb25tZW50IHZhcmlhYmxlIHRvXG4gKiBgbWV0YW1hc2s6PHByb2plY3ROYW1lPjo8bW9kdWxlTmFtZT5gLiBZb3UgY2FuIGFsc28gc2V0IHRoaXMgdmFyaWFibGUgdG9cbiAqIGBtZXRhbWFzazo8cHJvamVjdE5hbWU+OipgIGlmIHlvdSB3YW50IHRvIHNlZSBsb2cgbWVzc2FnZXMgZnJvbSB0aGUgcHJvamVjdCxcbiAqIG9yIGBtZXRhbWFzazoqYCBpZiB5b3Ugd2FudCB0byBzZWUgbG9nIG1lc3NhZ2VzIGZyb20gYWxsIE1ldGFNYXNrIHByb2plY3RzLlxuICpcbiAqIEBwYXJhbSBwcm9qZWN0TG9nZ2VyIC0gVGhlIGxvZ2dlciBjcmVhdGVkIHZpYSB7QGxpbmsgY3JlYXRlUHJvamVjdExvZ2dlcn0uXG4gKiBAcGFyYW0gbW9kdWxlTmFtZSAtIFRoZSBuYW1lIG9mIHlvdXIgbW9kdWxlLiBZb3UgY291bGQgdXNlIHRoZSBuYW1lIG9mIHRoZVxuICogZmlsZSB3aGVyZSB5b3UncmUgdXNpbmcgdGhpcyBsb2dnZXIgb3Igc29tZSBvdGhlciBuYW1lLlxuICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgYGRlYnVnYC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTW9kdWxlTG9nZ2VyKHByb2plY3RMb2dnZXIsIG1vZHVsZU5hbWUpIHtcbiAgICByZXR1cm4gcHJvamVjdExvZ2dlci5leHRlbmQobW9kdWxlTmFtZSk7XG59XG5leHBvcnRzLmNyZWF0ZU1vZHVsZUxvZ2dlciA9IGNyZWF0ZU1vZHVsZUxvZ2dlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2dpbmcuY2pzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/dist/logging.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/dist/misc.cjs":
/*!********************************************************!*\
  !*** ../../node_modules/@metamask/utils/dist/misc.cjs ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n//\n// Types\n//\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.calculateNumberSize = exports.calculateStringSize = exports.isASCII = exports.isPlainObject = exports.ESCAPE_CHARACTERS_REGEXP = exports.JsonSize = exports.getKnownPropertyNames = exports.hasProperty = exports.isObject = exports.isNullOrUndefined = exports.isNonEmptyArray = void 0;\n//\n// Type Guards\n//\n/**\n * A {@link NonEmptyArray} type guard.\n *\n * @template Element - The non-empty array member type.\n * @param value - The value to check.\n * @returns Whether the value is a non-empty array.\n */\nfunction isNonEmptyArray(value) {\n    return Array.isArray(value) && value.length > 0;\n}\nexports.isNonEmptyArray = isNonEmptyArray;\n/**\n * Type guard for \"nullishness\".\n *\n * @param value - Any value.\n * @returns `true` if the value is null or undefined, `false` otherwise.\n */\nfunction isNullOrUndefined(value) {\n    return value === null || value === undefined;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n/**\n * A type guard for {@link RuntimeObject}.\n *\n * @param value - The value to check.\n * @returns Whether the specified value has a runtime type of `object` and is\n * neither `null` nor an `Array`.\n */\nfunction isObject(value) {\n    return Boolean(value) && typeof value === 'object' && !Array.isArray(value);\n}\nexports.isObject = isObject;\n//\n// Other utility functions\n//\n/**\n * A type guard for ensuring an object has a property.\n *\n * @param objectToCheck - The object to check.\n * @param name - The property name to check for.\n * @returns Whether the specified object has an own property with the specified\n * name, regardless of whether it is enumerable or not.\n */\nconst hasProperty = (objectToCheck, name) => Object.hasOwnProperty.call(objectToCheck, name);\nexports.hasProperty = hasProperty;\n/**\n * `Object.getOwnPropertyNames()` is intentionally generic: it returns the\n * immediate property names of an object, but it cannot make guarantees about\n * the contents of that object, so the type of the property names is merely\n * `string[]`. While this is technically accurate, it is also unnecessary if we\n * have an object with a type that we own (such as an enum).\n *\n * @param object - The plain object.\n * @returns The own property names of the object which are assigned a type\n * derived from the object itself.\n */\nfunction getKnownPropertyNames(object) {\n    return Object.getOwnPropertyNames(object);\n}\nexports.getKnownPropertyNames = getKnownPropertyNames;\n/**\n * Predefined sizes (in Bytes) of specific parts of JSON structure.\n */\nvar JsonSize;\n(function (JsonSize) {\n    JsonSize[JsonSize[\"Null\"] = 4] = \"Null\";\n    JsonSize[JsonSize[\"Comma\"] = 1] = \"Comma\";\n    JsonSize[JsonSize[\"Wrapper\"] = 1] = \"Wrapper\";\n    JsonSize[JsonSize[\"True\"] = 4] = \"True\";\n    JsonSize[JsonSize[\"False\"] = 5] = \"False\";\n    JsonSize[JsonSize[\"Quote\"] = 1] = \"Quote\";\n    JsonSize[JsonSize[\"Colon\"] = 1] = \"Colon\";\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    JsonSize[JsonSize[\"Date\"] = 24] = \"Date\";\n})(JsonSize = exports.JsonSize || (exports.JsonSize = {}));\n/**\n * Regular expression with pattern matching for (special) escaped characters.\n */\nexports.ESCAPE_CHARACTERS_REGEXP = /\"|\\\\|\\n|\\r|\\t/gu;\n/**\n * Check if the value is plain object.\n *\n * @param value - Value to be checked.\n * @returns True if an object is the plain JavaScript object,\n * false if the object is not plain (e.g. function).\n */\nfunction isPlainObject(value) {\n    if (typeof value !== 'object' || value === null) {\n        return false;\n    }\n    try {\n        let proto = value;\n        while (Object.getPrototypeOf(proto) !== null) {\n            proto = Object.getPrototypeOf(proto);\n        }\n        return Object.getPrototypeOf(value) === proto;\n    }\n    catch (_) {\n        return false;\n    }\n}\nexports.isPlainObject = isPlainObject;\n/**\n * Check if character is ASCII.\n *\n * @param character - Character.\n * @returns True if a character code is ASCII, false if not.\n */\nfunction isASCII(character) {\n    return character.charCodeAt(0) <= 127;\n}\nexports.isASCII = isASCII;\n/**\n * Calculate string size.\n *\n * @param value - String value to calculate size.\n * @returns Number of bytes used to store whole string value.\n */\nfunction calculateStringSize(value) {\n    const size = value.split('').reduce((total, character) => {\n        if (isASCII(character)) {\n            return total + 1;\n        }\n        return total + 2;\n    }, 0);\n    // Also detect characters that need backslash escape\n    return size + (value.match(exports.ESCAPE_CHARACTERS_REGEXP) ?? []).length;\n}\nexports.calculateStringSize = calculateStringSize;\n/**\n * Calculate size of a number ofter JSON serialization.\n *\n * @param value - Number value to calculate size.\n * @returns Number of bytes used to store whole number in JSON.\n */\nfunction calculateNumberSize(value) {\n    return value.toString().length;\n}\nexports.calculateNumberSize = calculateNumberSize;\n//# sourceMappingURL=misc.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L21pc2MuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQixHQUFHLDJCQUEyQixHQUFHLGVBQWUsR0FBRyxxQkFBcUIsR0FBRyxnQ0FBZ0MsR0FBRyxnQkFBZ0IsR0FBRyw2QkFBNkIsR0FBRyxtQkFBbUIsR0FBRyxnQkFBZ0IsR0FBRyx5QkFBeUIsR0FBRyx1QkFBdUI7QUFDeFI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHFCQUFxQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0MsZ0JBQWdCLEtBQUs7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvbWlzYy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vL1xuLy8gVHlwZXNcbi8vXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNhbGN1bGF0ZU51bWJlclNpemUgPSBleHBvcnRzLmNhbGN1bGF0ZVN0cmluZ1NpemUgPSBleHBvcnRzLmlzQVNDSUkgPSBleHBvcnRzLmlzUGxhaW5PYmplY3QgPSBleHBvcnRzLkVTQ0FQRV9DSEFSQUNURVJTX1JFR0VYUCA9IGV4cG9ydHMuSnNvblNpemUgPSBleHBvcnRzLmdldEtub3duUHJvcGVydHlOYW1lcyA9IGV4cG9ydHMuaGFzUHJvcGVydHkgPSBleHBvcnRzLmlzT2JqZWN0ID0gZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGV4cG9ydHMuaXNOb25FbXB0eUFycmF5ID0gdm9pZCAwO1xuLy9cbi8vIFR5cGUgR3VhcmRzXG4vL1xuLyoqXG4gKiBBIHtAbGluayBOb25FbXB0eUFycmF5fSB0eXBlIGd1YXJkLlxuICpcbiAqIEB0ZW1wbGF0ZSBFbGVtZW50IC0gVGhlIG5vbi1lbXB0eSBhcnJheSBtZW1iZXIgdHlwZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgbm9uLWVtcHR5IGFycmF5LlxuICovXG5mdW5jdGlvbiBpc05vbkVtcHR5QXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID4gMDtcbn1cbmV4cG9ydHMuaXNOb25FbXB0eUFycmF5ID0gaXNOb25FbXB0eUFycmF5O1xuLyoqXG4gKiBUeXBlIGd1YXJkIGZvciBcIm51bGxpc2huZXNzXCIuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gQW55IHZhbHVlLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBudWxsIG9yIHVuZGVmaW5lZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG4vKipcbiAqIEEgdHlwZSBndWFyZCBmb3Ige0BsaW5rIFJ1bnRpbWVPYmplY3R9LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHNwZWNpZmllZCB2YWx1ZSBoYXMgYSBydW50aW1lIHR5cGUgb2YgYG9iamVjdGAgYW5kIGlzXG4gKiBuZWl0aGVyIGBudWxsYCBub3IgYW4gYEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gQm9vbGVhbih2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4vL1xuLy8gT3RoZXIgdXRpbGl0eSBmdW5jdGlvbnNcbi8vXG4vKipcbiAqIEEgdHlwZSBndWFyZCBmb3IgZW5zdXJpbmcgYW4gb2JqZWN0IGhhcyBhIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSBvYmplY3RUb0NoZWNrIC0gVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEBwYXJhbSBuYW1lIC0gVGhlIHByb3BlcnR5IG5hbWUgdG8gY2hlY2sgZm9yLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgc3BlY2lmaWVkIG9iamVjdCBoYXMgYW4gb3duIHByb3BlcnR5IHdpdGggdGhlIHNwZWNpZmllZFxuICogbmFtZSwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIGl0IGlzIGVudW1lcmFibGUgb3Igbm90LlxuICovXG5jb25zdCBoYXNQcm9wZXJ0eSA9IChvYmplY3RUb0NoZWNrLCBuYW1lKSA9PiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3RUb0NoZWNrLCBuYW1lKTtcbmV4cG9ydHMuaGFzUHJvcGVydHkgPSBoYXNQcm9wZXJ0eTtcbi8qKlxuICogYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKClgIGlzIGludGVudGlvbmFsbHkgZ2VuZXJpYzogaXQgcmV0dXJucyB0aGVcbiAqIGltbWVkaWF0ZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QsIGJ1dCBpdCBjYW5ub3QgbWFrZSBndWFyYW50ZWVzIGFib3V0XG4gKiB0aGUgY29udGVudHMgb2YgdGhhdCBvYmplY3QsIHNvIHRoZSB0eXBlIG9mIHRoZSBwcm9wZXJ0eSBuYW1lcyBpcyBtZXJlbHlcbiAqIGBzdHJpbmdbXWAuIFdoaWxlIHRoaXMgaXMgdGVjaG5pY2FsbHkgYWNjdXJhdGUsIGl0IGlzIGFsc28gdW5uZWNlc3NhcnkgaWYgd2VcbiAqIGhhdmUgYW4gb2JqZWN0IHdpdGggYSB0eXBlIHRoYXQgd2Ugb3duIChzdWNoIGFzIGFuIGVudW0pLlxuICpcbiAqIEBwYXJhbSBvYmplY3QgLSBUaGUgcGxhaW4gb2JqZWN0LlxuICogQHJldHVybnMgVGhlIG93biBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgb2JqZWN0IHdoaWNoIGFyZSBhc3NpZ25lZCBhIHR5cGVcbiAqIGRlcml2ZWQgZnJvbSB0aGUgb2JqZWN0IGl0c2VsZi5cbiAqL1xuZnVuY3Rpb24gZ2V0S25vd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpO1xufVxuZXhwb3J0cy5nZXRLbm93blByb3BlcnR5TmFtZXMgPSBnZXRLbm93blByb3BlcnR5TmFtZXM7XG4vKipcbiAqIFByZWRlZmluZWQgc2l6ZXMgKGluIEJ5dGVzKSBvZiBzcGVjaWZpYyBwYXJ0cyBvZiBKU09OIHN0cnVjdHVyZS5cbiAqL1xudmFyIEpzb25TaXplO1xuKGZ1bmN0aW9uIChKc29uU2l6ZSkge1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiTnVsbFwiXSA9IDRdID0gXCJOdWxsXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJDb21tYVwiXSA9IDFdID0gXCJDb21tYVwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiV3JhcHBlclwiXSA9IDFdID0gXCJXcmFwcGVyXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJUcnVlXCJdID0gNF0gPSBcIlRydWVcIjtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIkZhbHNlXCJdID0gNV0gPSBcIkZhbHNlXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJRdW90ZVwiXSA9IDFdID0gXCJRdW90ZVwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiQ29sb25cIl0gPSAxXSA9IFwiQ29sb25cIjtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiRGF0ZVwiXSA9IDI0XSA9IFwiRGF0ZVwiO1xufSkoSnNvblNpemUgPSBleHBvcnRzLkpzb25TaXplIHx8IChleHBvcnRzLkpzb25TaXplID0ge30pKTtcbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHdpdGggcGF0dGVybiBtYXRjaGluZyBmb3IgKHNwZWNpYWwpIGVzY2FwZWQgY2hhcmFjdGVycy5cbiAqL1xuZXhwb3J0cy5FU0NBUEVfQ0hBUkFDVEVSU19SRUdFWFAgPSAvXCJ8XFxcXHxcXG58XFxyfFxcdC9ndTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIHZhbHVlIGlzIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgVHJ1ZSBpZiBhbiBvYmplY3QgaXMgdGhlIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0LFxuICogZmFsc2UgaWYgdGhlIG9iamVjdCBpcyBub3QgcGxhaW4gKGUuZy4gZnVuY3Rpb24pLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBsZXQgcHJvdG8gPSB2YWx1ZTtcbiAgICAgICAgd2hpbGUgKE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gcHJvdG87XG4gICAgfVxuICAgIGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuLyoqXG4gKiBDaGVjayBpZiBjaGFyYWN0ZXIgaXMgQVNDSUkuXG4gKlxuICogQHBhcmFtIGNoYXJhY3RlciAtIENoYXJhY3Rlci5cbiAqIEByZXR1cm5zIFRydWUgaWYgYSBjaGFyYWN0ZXIgY29kZSBpcyBBU0NJSSwgZmFsc2UgaWYgbm90LlxuICovXG5mdW5jdGlvbiBpc0FTQ0lJKGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBjaGFyYWN0ZXIuY2hhckNvZGVBdCgwKSA8PSAxMjc7XG59XG5leHBvcnRzLmlzQVNDSUkgPSBpc0FTQ0lJO1xuLyoqXG4gKiBDYWxjdWxhdGUgc3RyaW5nIHNpemUuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gU3RyaW5nIHZhbHVlIHRvIGNhbGN1bGF0ZSBzaXplLlxuICogQHJldHVybnMgTnVtYmVyIG9mIGJ5dGVzIHVzZWQgdG8gc3RvcmUgd2hvbGUgc3RyaW5nIHZhbHVlLlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVTdHJpbmdTaXplKHZhbHVlKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHZhbHVlLnNwbGl0KCcnKS5yZWR1Y2UoKHRvdGFsLCBjaGFyYWN0ZXIpID0+IHtcbiAgICAgICAgaWYgKGlzQVNDSUkoY2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvdGFsICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWwgKyAyO1xuICAgIH0sIDApO1xuICAgIC8vIEFsc28gZGV0ZWN0IGNoYXJhY3RlcnMgdGhhdCBuZWVkIGJhY2tzbGFzaCBlc2NhcGVcbiAgICByZXR1cm4gc2l6ZSArICh2YWx1ZS5tYXRjaChleHBvcnRzLkVTQ0FQRV9DSEFSQUNURVJTX1JFR0VYUCkgPz8gW10pLmxlbmd0aDtcbn1cbmV4cG9ydHMuY2FsY3VsYXRlU3RyaW5nU2l6ZSA9IGNhbGN1bGF0ZVN0cmluZ1NpemU7XG4vKipcbiAqIENhbGN1bGF0ZSBzaXplIG9mIGEgbnVtYmVyIG9mdGVyIEpTT04gc2VyaWFsaXphdGlvbi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBOdW1iZXIgdmFsdWUgdG8gY2FsY3VsYXRlIHNpemUuXG4gKiBAcmV0dXJucyBOdW1iZXIgb2YgYnl0ZXMgdXNlZCB0byBzdG9yZSB3aG9sZSBudW1iZXIgaW4gSlNPTi5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlTnVtYmVyU2l6ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpLmxlbmd0aDtcbn1cbmV4cG9ydHMuY2FsY3VsYXRlTnVtYmVyU2l6ZSA9IGNhbGN1bGF0ZU51bWJlclNpemU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1taXNjLmNqcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/dist/misc.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/dist/number.cjs":
/*!**********************************************************!*\
  !*** ../../node_modules/@metamask/utils/dist/number.cjs ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hexToBigInt = exports.hexToNumber = exports.bigIntToHex = exports.numberToHex = void 0;\nconst assert_1 = __webpack_require__(/*! ./assert.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/assert.cjs\");\nconst hex_1 = __webpack_require__(/*! ./hex.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/hex.cjs\");\n/**\n * Convert a number to a hexadecimal string. This verifies that the number is a\n * non-negative safe integer.\n *\n * To convert a `bigint` to a hexadecimal string instead, use\n * {@link bigIntToHex}.\n *\n * @example\n * ```typescript\n * numberToHex(0); // '0x0'\n * numberToHex(1); // '0x1'\n * numberToHex(16); // '0x10'\n * ```\n * @param value - The number to convert to a hexadecimal string.\n * @returns The hexadecimal string, with the \"0x\"-prefix.\n * @throws If the number is not a non-negative safe integer.\n */\nconst numberToHex = (value) => {\n    (0, assert_1.assert)(typeof value === 'number', 'Value must be a number.');\n    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative number.');\n    (0, assert_1.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToHex` instead.');\n    return (0, hex_1.add0x)(value.toString(16));\n};\nexports.numberToHex = numberToHex;\n/**\n * Convert a `bigint` to a hexadecimal string. This verifies that the `bigint`\n * is a non-negative integer.\n *\n * To convert a number to a hexadecimal string instead, use {@link numberToHex}.\n *\n * @example\n * ```typescript\n * bigIntToHex(0n); // '0x0'\n * bigIntToHex(1n); // '0x1'\n * bigIntToHex(16n); // '0x10'\n * ```\n * @param value - The `bigint` to convert to a hexadecimal string.\n * @returns The hexadecimal string, with the \"0x\"-prefix.\n * @throws If the `bigint` is not a non-negative integer.\n */\nconst bigIntToHex = (value) => {\n    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');\n    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative bigint.');\n    return (0, hex_1.add0x)(value.toString(16));\n};\nexports.bigIntToHex = bigIntToHex;\n/**\n * Convert a hexadecimal string to a number. This verifies that the string is a\n * valid hex string, and that the resulting number is a safe integer. Both\n * \"0x\"-prefixed and unprefixed strings are supported.\n *\n * To convert a hexadecimal string to a `bigint` instead, use\n * {@link hexToBigInt}.\n *\n * @example\n * ```typescript\n * hexToNumber('0x0'); // 0\n * hexToNumber('0x1'); // 1\n * hexToNumber('0x10'); // 16\n * ```\n * @param value - The hexadecimal string to convert to a number.\n * @returns The number.\n * @throws If the value is not a valid hexadecimal string, or if the resulting\n * number is not a safe integer.\n */\nconst hexToNumber = (value) => {\n    (0, hex_1.assertIsHexString)(value);\n    // `parseInt` accepts values without the \"0x\"-prefix, whereas `Number` does\n    // not. Using this is slightly faster than `Number(add0x(value))`.\n    const numberValue = parseInt(value, 16);\n    (0, assert_1.assert)(Number.isSafeInteger(numberValue), 'Value is not a safe integer. Use `hexToBigInt` instead.');\n    return numberValue;\n};\nexports.hexToNumber = hexToNumber;\n/**\n * Convert a hexadecimal string to a `bigint`. This verifies that the string is\n * a valid hex string. Both \"0x\"-prefixed and unprefixed strings are supported.\n *\n * To convert a hexadecimal string to a number instead, use {@link hexToNumber}.\n *\n * @example\n * ```typescript\n * hexToBigInt('0x0'); // 0n\n * hexToBigInt('0x1'); // 1n\n * hexToBigInt('0x10'); // 16n\n * ```\n * @param value - The hexadecimal string to convert to a `bigint`.\n * @returns The `bigint`.\n * @throws If the value is not a valid hexadecimal string.\n */\nconst hexToBigInt = (value) => {\n    (0, hex_1.assertIsHexString)(value);\n    // The `BigInt` constructor requires the \"0x\"-prefix to parse a hex string.\n    return BigInt((0, hex_1.add0x)(value));\n};\nexports.hexToBigInt = hexToBigInt;\n//# sourceMappingURL=number.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L251bWJlci5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsbUJBQW1CLEdBQUcsbUJBQW1CLEdBQUcsbUJBQW1CO0FBQ3JGLGlCQUFpQixtQkFBTyxDQUFDLDhFQUFjO0FBQ3ZDLGNBQWMsbUJBQU8sQ0FBQyx3RUFBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrQkFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxrQkFBa0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrQkFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxrQkFBa0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L251bWJlci5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhleFRvQmlnSW50ID0gZXhwb3J0cy5oZXhUb051bWJlciA9IGV4cG9ydHMuYmlnSW50VG9IZXggPSBleHBvcnRzLm51bWJlclRvSGV4ID0gdm9pZCAwO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnQuY2pzXCIpO1xuY29uc3QgaGV4XzEgPSByZXF1aXJlKFwiLi9oZXguY2pzXCIpO1xuLyoqXG4gKiBDb252ZXJ0IGEgbnVtYmVyIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBUaGlzIHZlcmlmaWVzIHRoYXQgdGhlIG51bWJlciBpcyBhXG4gKiBub24tbmVnYXRpdmUgc2FmZSBpbnRlZ2VyLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBgYmlnaW50YCB0byBhIGhleGFkZWNpbWFsIHN0cmluZyBpbnN0ZWFkLCB1c2VcbiAqIHtAbGluayBiaWdJbnRUb0hleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIG51bWJlclRvSGV4KDApOyAvLyAnMHgwJ1xuICogbnVtYmVyVG9IZXgoMSk7IC8vICcweDEnXG4gKiBudW1iZXJUb0hleCgxNik7IC8vICcweDEwJ1xuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nLCB3aXRoIHRoZSBcIjB4XCItcHJlZml4LlxuICogQHRocm93cyBJZiB0aGUgbnVtYmVyIGlzIG5vdCBhIG5vbi1uZWdhdGl2ZSBzYWZlIGludGVnZXIuXG4gKi9cbmNvbnN0IG51bWJlclRvSGV4ID0gKHZhbHVlKSA9PiB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ1ZhbHVlIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodmFsdWUgPj0gMCwgJ1ZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSwgJ1ZhbHVlIGlzIG5vdCBhIHNhZmUgaW50ZWdlci4gVXNlIGBiaWdJbnRUb0hleGAgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gKDAsIGhleF8xLmFkZDB4KSh2YWx1ZS50b1N0cmluZygxNikpO1xufTtcbmV4cG9ydHMubnVtYmVyVG9IZXggPSBudW1iZXJUb0hleDtcbi8qKlxuICogQ29udmVydCBhIGBiaWdpbnRgIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBUaGlzIHZlcmlmaWVzIHRoYXQgdGhlIGBiaWdpbnRgXG4gKiBpcyBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBudW1iZXIgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcgaW5zdGVhZCwgdXNlIHtAbGluayBudW1iZXJUb0hleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGJpZ0ludFRvSGV4KDBuKTsgLy8gJzB4MCdcbiAqIGJpZ0ludFRvSGV4KDFuKTsgLy8gJzB4MSdcbiAqIGJpZ0ludFRvSGV4KDE2bik7IC8vICcweDEwJ1xuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYGJpZ2ludGAgdG8gY29udmVydCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcsIHdpdGggdGhlIFwiMHhcIi1wcmVmaXguXG4gKiBAdGhyb3dzIElmIHRoZSBgYmlnaW50YCBpcyBub3QgYSBub24tbmVnYXRpdmUgaW50ZWdlci5cbiAqL1xuY29uc3QgYmlnSW50VG9IZXggPSAodmFsdWUpID0+IHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnLCAnVmFsdWUgbXVzdCBiZSBhIGJpZ2ludC4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh2YWx1ZSA+PSAwLCAnVmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBiaWdpbnQuJyk7XG4gICAgcmV0dXJuICgwLCBoZXhfMS5hZGQweCkodmFsdWUudG9TdHJpbmcoMTYpKTtcbn07XG5leHBvcnRzLmJpZ0ludFRvSGV4ID0gYmlnSW50VG9IZXg7XG4vKipcbiAqIENvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBudW1iZXIuIFRoaXMgdmVyaWZpZXMgdGhhdCB0aGUgc3RyaW5nIGlzIGFcbiAqIHZhbGlkIGhleCBzdHJpbmcsIGFuZCB0aGF0IHRoZSByZXN1bHRpbmcgbnVtYmVyIGlzIGEgc2FmZSBpbnRlZ2VyLiBCb3RoXG4gKiBcIjB4XCItcHJlZml4ZWQgYW5kIHVucHJlZml4ZWQgc3RyaW5ncyBhcmUgc3VwcG9ydGVkLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBgYmlnaW50YCBpbnN0ZWFkLCB1c2VcbiAqIHtAbGluayBoZXhUb0JpZ0ludH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGhleFRvTnVtYmVyKCcweDAnKTsgLy8gMFxuICogaGV4VG9OdW1iZXIoJzB4MScpOyAvLyAxXG4gKiBoZXhUb051bWJlcignMHgxMCcpOyAvLyAxNlxuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGNvbnZlcnQgdG8gYSBudW1iZXIuXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgaGV4YWRlY2ltYWwgc3RyaW5nLCBvciBpZiB0aGUgcmVzdWx0aW5nXG4gKiBudW1iZXIgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLlxuICovXG5jb25zdCBoZXhUb051bWJlciA9ICh2YWx1ZSkgPT4ge1xuICAgICgwLCBoZXhfMS5hc3NlcnRJc0hleFN0cmluZykodmFsdWUpO1xuICAgIC8vIGBwYXJzZUludGAgYWNjZXB0cyB2YWx1ZXMgd2l0aG91dCB0aGUgXCIweFwiLXByZWZpeCwgd2hlcmVhcyBgTnVtYmVyYCBkb2VzXG4gICAgLy8gbm90LiBVc2luZyB0aGlzIGlzIHNsaWdodGx5IGZhc3RlciB0aGFuIGBOdW1iZXIoYWRkMHgodmFsdWUpKWAuXG4gICAgY29uc3QgbnVtYmVyVmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTYpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bWJlclZhbHVlKSwgJ1ZhbHVlIGlzIG5vdCBhIHNhZmUgaW50ZWdlci4gVXNlIGBoZXhUb0JpZ0ludGAgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gbnVtYmVyVmFsdWU7XG59O1xuZXhwb3J0cy5oZXhUb051bWJlciA9IGhleFRvTnVtYmVyO1xuLyoqXG4gKiBDb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgYGJpZ2ludGAuIFRoaXMgdmVyaWZpZXMgdGhhdCB0aGUgc3RyaW5nIGlzXG4gKiBhIHZhbGlkIGhleCBzdHJpbmcuIEJvdGggXCIweFwiLXByZWZpeGVkIGFuZCB1bnByZWZpeGVkIHN0cmluZ3MgYXJlIHN1cHBvcnRlZC5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgbnVtYmVyIGluc3RlYWQsIHVzZSB7QGxpbmsgaGV4VG9OdW1iZXJ9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBoZXhUb0JpZ0ludCgnMHgwJyk7IC8vIDBuXG4gKiBoZXhUb0JpZ0ludCgnMHgxJyk7IC8vIDFuXG4gKiBoZXhUb0JpZ0ludCgnMHgxMCcpOyAvLyAxNm5cbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBjb252ZXJ0IHRvIGEgYGJpZ2ludGAuXG4gKiBAcmV0dXJucyBUaGUgYGJpZ2ludGAuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmNvbnN0IGhleFRvQmlnSW50ID0gKHZhbHVlKSA9PiB7XG4gICAgKDAsIGhleF8xLmFzc2VydElzSGV4U3RyaW5nKSh2YWx1ZSk7XG4gICAgLy8gVGhlIGBCaWdJbnRgIGNvbnN0cnVjdG9yIHJlcXVpcmVzIHRoZSBcIjB4XCItcHJlZml4IHRvIHBhcnNlIGEgaGV4IHN0cmluZy5cbiAgICByZXR1cm4gQmlnSW50KCgwLCBoZXhfMS5hZGQweCkodmFsdWUpKTtcbn07XG5leHBvcnRzLmhleFRvQmlnSW50ID0gaGV4VG9CaWdJbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1iZXIuY2pzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/dist/number.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/dist/opaque.cjs":
/*!**********************************************************!*\
  !*** ../../node_modules/@metamask/utils/dist/opaque.cjs ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=opaque.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L29wYXF1ZS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L29wYXF1ZS5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcGFxdWUuY2pzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/dist/opaque.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/dist/promise.cjs":
/*!***********************************************************!*\
  !*** ../../node_modules/@metamask/utils/dist/promise.cjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createDeferredPromise = void 0;\n/**\n * Create a defered Promise.\n *\n * If the Promise is rejected prior to a handler being added, this can result in an\n * `UnhandledPromiseRejection` error. Optionally this can be suppressed with the\n * `suppressUnhandledRejection` flag, as it's common to belatedly handle deferred Promises, or to\n * ignore them if they're no longer relevant (e.g. related to a cancelled request).\n *\n * However, be very careful that you have handled the Promise if you do this. Suppressing these\n * errors is dangerous, they exist for good reason. An unhandled rejection can hide errors, making\n * debugging extremely difficult. They should only be suppressed if you're confident that the\n * Promise is always handled correctly, in both the success and failure cases.\n *\n * @param args - The arguments.\n * @param args.suppressUnhandledRejection - This option adds an empty error handler\n * to the Promise to suppress the UnhandledPromiseRejection error. This can be\n * useful if the deferred Promise is sometimes intentionally not used.\n * @returns A deferred Promise.\n * @template Result - The result type of the Promise.\n */\nfunction createDeferredPromise({ suppressUnhandledRejection = false, } = {}) {\n    let resolve;\n    let reject;\n    const promise = new Promise((innerResolve, innerReject) => {\n        resolve = innerResolve;\n        reject = innerReject;\n    });\n    if (suppressUnhandledRejection) {\n        promise.catch((_error) => {\n            // This handler is used to suppress the UnhandledPromiseRejection error\n        });\n    }\n    // @ts-expect-error We know that these are assigned, but TypeScript doesn't\n    return { promise, resolve, reject };\n}\nexports.createDeferredPromise = createDeferredPromise;\n//# sourceMappingURL=promise.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3Byb21pc2UuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHNDQUFzQyxJQUFJO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw2QkFBNkI7QUFDN0IiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3Byb21pc2UuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVEZWZlcnJlZFByb21pc2UgPSB2b2lkIDA7XG4vKipcbiAqIENyZWF0ZSBhIGRlZmVyZWQgUHJvbWlzZS5cbiAqXG4gKiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCBwcmlvciB0byBhIGhhbmRsZXIgYmVpbmcgYWRkZWQsIHRoaXMgY2FuIHJlc3VsdCBpbiBhblxuICogYFVuaGFuZGxlZFByb21pc2VSZWplY3Rpb25gIGVycm9yLiBPcHRpb25hbGx5IHRoaXMgY2FuIGJlIHN1cHByZXNzZWQgd2l0aCB0aGVcbiAqIGBzdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbmAgZmxhZywgYXMgaXQncyBjb21tb24gdG8gYmVsYXRlZGx5IGhhbmRsZSBkZWZlcnJlZCBQcm9taXNlcywgb3IgdG9cbiAqIGlnbm9yZSB0aGVtIGlmIHRoZXkncmUgbm8gbG9uZ2VyIHJlbGV2YW50IChlLmcuIHJlbGF0ZWQgdG8gYSBjYW5jZWxsZWQgcmVxdWVzdCkuXG4gKlxuICogSG93ZXZlciwgYmUgdmVyeSBjYXJlZnVsIHRoYXQgeW91IGhhdmUgaGFuZGxlZCB0aGUgUHJvbWlzZSBpZiB5b3UgZG8gdGhpcy4gU3VwcHJlc3NpbmcgdGhlc2VcbiAqIGVycm9ycyBpcyBkYW5nZXJvdXMsIHRoZXkgZXhpc3QgZm9yIGdvb2QgcmVhc29uLiBBbiB1bmhhbmRsZWQgcmVqZWN0aW9uIGNhbiBoaWRlIGVycm9ycywgbWFraW5nXG4gKiBkZWJ1Z2dpbmcgZXh0cmVtZWx5IGRpZmZpY3VsdC4gVGhleSBzaG91bGQgb25seSBiZSBzdXBwcmVzc2VkIGlmIHlvdSdyZSBjb25maWRlbnQgdGhhdCB0aGVcbiAqIFByb21pc2UgaXMgYWx3YXlzIGhhbmRsZWQgY29ycmVjdGx5LCBpbiBib3RoIHRoZSBzdWNjZXNzIGFuZCBmYWlsdXJlIGNhc2VzLlxuICpcbiAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSBhcmdzLnN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9uIC0gVGhpcyBvcHRpb24gYWRkcyBhbiBlbXB0eSBlcnJvciBoYW5kbGVyXG4gKiB0byB0aGUgUHJvbWlzZSB0byBzdXBwcmVzcyB0aGUgVW5oYW5kbGVkUHJvbWlzZVJlamVjdGlvbiBlcnJvci4gVGhpcyBjYW4gYmVcbiAqIHVzZWZ1bCBpZiB0aGUgZGVmZXJyZWQgUHJvbWlzZSBpcyBzb21ldGltZXMgaW50ZW50aW9uYWxseSBub3QgdXNlZC5cbiAqIEByZXR1cm5zIEEgZGVmZXJyZWQgUHJvbWlzZS5cbiAqIEB0ZW1wbGF0ZSBSZXN1bHQgLSBUaGUgcmVzdWx0IHR5cGUgb2YgdGhlIFByb21pc2UuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURlZmVycmVkUHJvbWlzZSh7IHN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9uID0gZmFsc2UsIH0gPSB7fSkge1xuICAgIGxldCByZXNvbHZlO1xuICAgIGxldCByZWplY3Q7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChpbm5lclJlc29sdmUsIGlubmVyUmVqZWN0KSA9PiB7XG4gICAgICAgIHJlc29sdmUgPSBpbm5lclJlc29sdmU7XG4gICAgICAgIHJlamVjdCA9IGlubmVyUmVqZWN0O1xuICAgIH0pO1xuICAgIGlmIChzdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbikge1xuICAgICAgICBwcm9taXNlLmNhdGNoKChfZXJyb3IpID0+IHtcbiAgICAgICAgICAgIC8vIFRoaXMgaGFuZGxlciBpcyB1c2VkIHRvIHN1cHByZXNzIHRoZSBVbmhhbmRsZWRQcm9taXNlUmVqZWN0aW9uIGVycm9yXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFdlIGtub3cgdGhhdCB0aGVzZSBhcmUgYXNzaWduZWQsIGJ1dCBUeXBlU2NyaXB0IGRvZXNuJ3RcbiAgICByZXR1cm4geyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfTtcbn1cbmV4cG9ydHMuY3JlYXRlRGVmZXJyZWRQcm9taXNlID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvbWlzZS5janMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/dist/promise.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/dist/superstruct.cjs":
/*!***************************************************************!*\
  !*** ../../node_modules/@metamask/utils/dist/superstruct.cjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.definePattern = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(rsc)/../../node_modules/@metamask/superstruct/dist/index.cjs\");\n/**\n * Defines a new string-struct matching a regular expression.\n *\n * @example\n * const EthAddressStruct = definePattern('EthAddress', /^0x[0-9a-f]{40}$/iu);\n * type EthAddress = Infer<typeof EthAddressStruct>; // string\n *\n * const CaipChainIdStruct = defineTypedPattern<`${string}:${string}`>(\n *   'CaipChainId',\n *   /^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$/u;\n * );\n * type CaipChainId = Infer<typeof CaipChainIdStruct>; // `${string}:${string}`\n * @param name - Type name.\n * @param pattern - Regular expression to match.\n * @template Pattern - The pattern type, defaults to `string`.\n * @returns A new string-struct that matches the given pattern.\n */\nfunction definePattern(name, pattern) {\n    return (0, superstruct_1.define)(name, (value) => {\n        return typeof value === 'string' && pattern.test(value);\n    });\n}\nexports.definePattern = definePattern;\n//# sourceMappingURL=superstruct.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3N1cGVyc3RydWN0LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckIsc0JBQXNCLG1CQUFPLENBQUMsNEZBQXVCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLEdBQUc7QUFDeEUscURBQXFEO0FBQ3JEO0FBQ0EsbURBQW1ELE9BQU8sR0FBRyxPQUFPO0FBQ3BFO0FBQ0EsaUJBQWlCLElBQUksZUFBZSxLQUFLO0FBQ3pDO0FBQ0EsdURBQXVELE1BQU0sT0FBTyxHQUFHLE9BQU87QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQjtBQUNyQiIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3Qvc3VwZXJzdHJ1Y3QuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZpbmVQYXR0ZXJuID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svc3VwZXJzdHJ1Y3RcIik7XG4vKipcbiAqIERlZmluZXMgYSBuZXcgc3RyaW5nLXN0cnVjdCBtYXRjaGluZyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgRXRoQWRkcmVzc1N0cnVjdCA9IGRlZmluZVBhdHRlcm4oJ0V0aEFkZHJlc3MnLCAvXjB4WzAtOWEtZl17NDB9JC9pdSk7XG4gKiB0eXBlIEV0aEFkZHJlc3MgPSBJbmZlcjx0eXBlb2YgRXRoQWRkcmVzc1N0cnVjdD47IC8vIHN0cmluZ1xuICpcbiAqIGNvbnN0IENhaXBDaGFpbklkU3RydWN0ID0gZGVmaW5lVHlwZWRQYXR0ZXJuPGAke3N0cmluZ306JHtzdHJpbmd9YD4oXG4gKiAgICdDYWlwQ2hhaW5JZCcsXG4gKiAgIC9eWy1hLXowLTldezMsOH06Wy1fYS16QS1aMC05XXsxLDMyfSQvdTtcbiAqICk7XG4gKiB0eXBlIENhaXBDaGFpbklkID0gSW5mZXI8dHlwZW9mIENhaXBDaGFpbklkU3RydWN0PjsgLy8gYCR7c3RyaW5nfToke3N0cmluZ31gXG4gKiBAcGFyYW0gbmFtZSAtIFR5cGUgbmFtZS5cbiAqIEBwYXJhbSBwYXR0ZXJuIC0gUmVndWxhciBleHByZXNzaW9uIHRvIG1hdGNoLlxuICogQHRlbXBsYXRlIFBhdHRlcm4gLSBUaGUgcGF0dGVybiB0eXBlLCBkZWZhdWx0cyB0byBgc3RyaW5nYC5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cmluZy1zdHJ1Y3QgdGhhdCBtYXRjaGVzIHRoZSBnaXZlbiBwYXR0ZXJuLlxuICovXG5mdW5jdGlvbiBkZWZpbmVQYXR0ZXJuKG5hbWUsIHBhdHRlcm4pIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuZGVmaW5lKShuYW1lLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgcGF0dGVybi50ZXN0KHZhbHVlKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGVmaW5lUGF0dGVybiA9IGRlZmluZVBhdHRlcm47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdXBlcnN0cnVjdC5janMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/dist/superstruct.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/dist/time.cjs":
/*!********************************************************!*\
  !*** ../../node_modules/@metamask/utils/dist/time.cjs ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.timeSince = exports.inMilliseconds = exports.Duration = void 0;\n/**\n * Common duration constants, in milliseconds.\n */\nvar Duration;\n(function (Duration) {\n    /**\n     * A millisecond.\n     */\n    Duration[Duration[\"Millisecond\"] = 1] = \"Millisecond\";\n    /**\n     * A second, in milliseconds.\n     */\n    Duration[Duration[\"Second\"] = 1000] = \"Second\";\n    /**\n     * A minute, in milliseconds.\n     */\n    Duration[Duration[\"Minute\"] = 60000] = \"Minute\";\n    /**\n     * An hour, in milliseconds.\n     */\n    Duration[Duration[\"Hour\"] = 3600000] = \"Hour\";\n    /**\n     * A day, in milliseconds.\n     */\n    Duration[Duration[\"Day\"] = 86400000] = \"Day\";\n    /**\n     * A week, in milliseconds.\n     */\n    Duration[Duration[\"Week\"] = 604800000] = \"Week\";\n    /**\n     * A year, in milliseconds.\n     */\n    Duration[Duration[\"Year\"] = 31536000000] = \"Year\";\n})(Duration = exports.Duration || (exports.Duration = {}));\nconst isNonNegativeInteger = (number) => Number.isInteger(number) && number >= 0;\nconst assertIsNonNegativeInteger = (number, name) => {\n    if (!isNonNegativeInteger(number)) {\n        throw new Error(`\"${name}\" must be a non-negative integer. Received: \"${number}\".`);\n    }\n};\n/**\n * Calculates the millisecond value of the specified number of units of time.\n *\n * @param count - The number of units of time.\n * @param duration - The unit of time to count.\n * @returns The count multiplied by the specified duration.\n */\nfunction inMilliseconds(count, duration) {\n    assertIsNonNegativeInteger(count, 'count');\n    return count * duration;\n}\nexports.inMilliseconds = inMilliseconds;\n/**\n * Gets the milliseconds since a particular Unix epoch timestamp.\n *\n * @param timestamp - A Unix millisecond timestamp.\n * @returns The number of milliseconds elapsed since the specified timestamp.\n */\nfunction timeSince(timestamp) {\n    assertIsNonNegativeInteger(timestamp, 'timestamp');\n    return Date.now() - timestamp;\n}\nexports.timeSince = timeSince;\n//# sourceMappingURL=time.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3RpbWUuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLHNCQUFzQixHQUFHLGdCQUFnQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQyxnQkFBZ0IsS0FBSztBQUN4RDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsS0FBSywrQ0FBK0MsT0FBTztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvdGltZS5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRpbWVTaW5jZSA9IGV4cG9ydHMuaW5NaWxsaXNlY29uZHMgPSBleHBvcnRzLkR1cmF0aW9uID0gdm9pZCAwO1xuLyoqXG4gKiBDb21tb24gZHVyYXRpb24gY29uc3RhbnRzLCBpbiBtaWxsaXNlY29uZHMuXG4gKi9cbnZhciBEdXJhdGlvbjtcbihmdW5jdGlvbiAoRHVyYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBBIG1pbGxpc2Vjb25kLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiTWlsbGlzZWNvbmRcIl0gPSAxXSA9IFwiTWlsbGlzZWNvbmRcIjtcbiAgICAvKipcbiAgICAgKiBBIHNlY29uZCwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiU2Vjb25kXCJdID0gMTAwMF0gPSBcIlNlY29uZFwiO1xuICAgIC8qKlxuICAgICAqIEEgbWludXRlLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJNaW51dGVcIl0gPSA2MDAwMF0gPSBcIk1pbnV0ZVwiO1xuICAgIC8qKlxuICAgICAqIEFuIGhvdXIsIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIkhvdXJcIl0gPSAzNjAwMDAwXSA9IFwiSG91clwiO1xuICAgIC8qKlxuICAgICAqIEEgZGF5LCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJEYXlcIl0gPSA4NjQwMDAwMF0gPSBcIkRheVwiO1xuICAgIC8qKlxuICAgICAqIEEgd2VlaywgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiV2Vla1wiXSA9IDYwNDgwMDAwMF0gPSBcIldlZWtcIjtcbiAgICAvKipcbiAgICAgKiBBIHllYXIsIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIlllYXJcIl0gPSAzMTUzNjAwMDAwMF0gPSBcIlllYXJcIjtcbn0pKER1cmF0aW9uID0gZXhwb3J0cy5EdXJhdGlvbiB8fCAoZXhwb3J0cy5EdXJhdGlvbiA9IHt9KSk7XG5jb25zdCBpc05vbk5lZ2F0aXZlSW50ZWdlciA9IChudW1iZXIpID0+IE51bWJlci5pc0ludGVnZXIobnVtYmVyKSAmJiBudW1iZXIgPj0gMDtcbmNvbnN0IGFzc2VydElzTm9uTmVnYXRpdmVJbnRlZ2VyID0gKG51bWJlciwgbmFtZSkgPT4ge1xuICAgIGlmICghaXNOb25OZWdhdGl2ZUludGVnZXIobnVtYmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtuYW1lfVwiIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlci4gUmVjZWl2ZWQ6IFwiJHtudW1iZXJ9XCIuYCk7XG4gICAgfVxufTtcbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbWlsbGlzZWNvbmQgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgdW5pdHMgb2YgdGltZS5cbiAqXG4gKiBAcGFyYW0gY291bnQgLSBUaGUgbnVtYmVyIG9mIHVuaXRzIG9mIHRpbWUuXG4gKiBAcGFyYW0gZHVyYXRpb24gLSBUaGUgdW5pdCBvZiB0aW1lIHRvIGNvdW50LlxuICogQHJldHVybnMgVGhlIGNvdW50IG11bHRpcGxpZWQgYnkgdGhlIHNwZWNpZmllZCBkdXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gaW5NaWxsaXNlY29uZHMoY291bnQsIGR1cmF0aW9uKSB7XG4gICAgYXNzZXJ0SXNOb25OZWdhdGl2ZUludGVnZXIoY291bnQsICdjb3VudCcpO1xuICAgIHJldHVybiBjb3VudCAqIGR1cmF0aW9uO1xufVxuZXhwb3J0cy5pbk1pbGxpc2Vjb25kcyA9IGluTWlsbGlzZWNvbmRzO1xuLyoqXG4gKiBHZXRzIHRoZSBtaWxsaXNlY29uZHMgc2luY2UgYSBwYXJ0aWN1bGFyIFVuaXggZXBvY2ggdGltZXN0YW1wLlxuICpcbiAqIEBwYXJhbSB0aW1lc3RhbXAgLSBBIFVuaXggbWlsbGlzZWNvbmQgdGltZXN0YW1wLlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgZWxhcHNlZCBzaW5jZSB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcC5cbiAqL1xuZnVuY3Rpb24gdGltZVNpbmNlKHRpbWVzdGFtcCkge1xuICAgIGFzc2VydElzTm9uTmVnYXRpdmVJbnRlZ2VyKHRpbWVzdGFtcCwgJ3RpbWVzdGFtcCcpO1xuICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGltZXN0YW1wO1xufVxuZXhwb3J0cy50aW1lU2luY2UgPSB0aW1lU2luY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lLmNqcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/dist/time.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/dist/transaction-types.cjs":
/*!*********************************************************************!*\
  !*** ../../node_modules/@metamask/utils/dist/transaction-types.cjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=transaction-types.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3RyYW5zYWN0aW9uLXR5cGVzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvdHJhbnNhY3Rpb24tdHlwZXMuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNhY3Rpb24tdHlwZXMuY2pzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/dist/transaction-types.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/dist/unitsConversion.cjs":
/*!*******************************************************************!*\
  !*** ../../node_modules/@metamask/utils/dist/unitsConversion.cjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/* eslint-disable operator-assignment */\n/*\nPrimary Attribution\nRichard Moore <ricmoo@me.com>\nhttps://github.com/ethers-io\n\nNote, Richard is a god of ether gods. Follow and respect him, and use Ethers.io!\n*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toWei = exports.fromWei = exports.numberToString = exports.getValueOfUnit = exports.unitMap = exports.numericToBigInt = void 0;\nconst zero = BigInt(0);\nconst negative1 = BigInt(-1);\n/**\n * Converts a string, number, or bigint to a bigint.\n *\n * @param arg - The value to convert to bigint.\n * @returns The bigint representation of the input.\n * @throws Error if the input type cannot be converted to bigint.\n */\nfunction numericToBigInt(arg) {\n    if (typeof arg === 'string') {\n        return BigInt(arg);\n    }\n    if (typeof arg === 'number') {\n        return BigInt(arg);\n    }\n    if (typeof arg === 'bigint') {\n        return arg;\n    }\n    throw new Error(`Cannot convert ${typeof arg} to BigInt`);\n}\nexports.numericToBigInt = numericToBigInt;\n// complete ethereum unit map\nexports.unitMap = {\n    noether: '0',\n    wei: '1',\n    kwei: '1000',\n    Kwei: '1000',\n    babbage: '1000',\n    femtoether: '1000',\n    mwei: '1000000',\n    Mwei: '1000000',\n    lovelace: '1000000',\n    picoether: '1000000',\n    gwei: '1000000000',\n    Gwei: '1000000000',\n    shannon: '1000000000',\n    nanoether: '1000000000',\n    nano: '1000000000',\n    szabo: '1000000000000',\n    microether: '1000000000000',\n    micro: '1000000000000',\n    finney: '1000000000000000',\n    milliether: '1000000000000000',\n    milli: '1000000000000000',\n    ether: '1000000000000000000',\n    kether: '1000000000000000000000',\n    grand: '1000000000000000000000',\n    mether: '1000000000000000000000000',\n    gether: '1000000000000000000000000000',\n    tether: '1000000000000000000000000000000',\n};\n// Pre-computed unit values as BigInt for performance\nconst unitMapBigInt = Object.fromEntries(Object.entries(exports.unitMap).map(([key, value]) => [key, BigInt(value)]));\nconst unitLengths = Object.fromEntries(Object.entries(exports.unitMap).map(([key, value]) => [key, value.length - 1 || 1]));\nconst NUMBER_REGEX = /^-?[0-9.]+$/u;\nconst FRACTION_REGEX = /^([0-9]*[1-9]|0)(0*)/u;\nconst COMMIFY_REGEX = /\\B(?=(\\d{3})+(?!\\d))/gu;\n/**\n * Returns value of unit in Wei.\n *\n * @param unitInput - The unit to convert to, default ether.\n * @returns Value of the unit (in Wei).\n * @throws Error if the unit is not correct.\n */\nfunction getValueOfUnit(unitInput = 'ether') {\n    const unit = unitInput.toLowerCase();\n    const unitValue = unitMapBigInt[unit];\n    if (unitValue === undefined) {\n        throw new Error(`The unit provided ${unitInput} doesn't exist, please use the one of the following units ${JSON.stringify(exports.unitMap, null, 2)}`);\n    }\n    return unitValue;\n}\nexports.getValueOfUnit = getValueOfUnit;\n/**\n * Converts a number to a string.\n *\n * @param arg - The number to convert to a string.\n * @returns The string representation of the number.\n * @throws Error if the number is invalid.\n */\nfunction numberToString(arg) {\n    if (typeof arg === 'string') {\n        if (!NUMBER_REGEX.test(arg)) {\n            throw new Error(`while converting number to string, invalid number value '${arg}', should be a number matching (^-?[0-9.]+).`);\n        }\n        return arg;\n    }\n    if (typeof arg === 'number') {\n        return String(arg);\n    }\n    if (typeof arg === 'bigint') {\n        return arg.toString();\n    }\n    throw new Error(`while converting number to string, invalid number value '${String(arg)}' type ${typeof arg}.`);\n}\nexports.numberToString = numberToString;\n/**\n * Converts a number from Wei to a string.\n *\n * @param weiInput - The number to convert from Wei.\n * @param unit - The unit to convert to, default ether.\n * @param optionsInput - The options to use for the conversion.\n * @param optionsInput.pad - Whether to pad the fractional part with zeros.\n * @param optionsInput.commify - Whether to add commas to separate thousands.\n * @returns The string representation of the number.\n * @throws Error if the number is invalid.\n */\nfunction fromWei(weiInput, unit, optionsInput) {\n    let wei = numericToBigInt(weiInput);\n    const negative = wei < zero;\n    const unitLower = unit.toLowerCase();\n    const base = unitMapBigInt[unitLower];\n    const baseLength = unitLengths[unitLower];\n    const options = optionsInput ?? {};\n    if (base === undefined) {\n        throw new Error(`The unit provided ${unit} doesn't exist, please use the one of the following units ${JSON.stringify(exports.unitMap, null, 2)}`);\n    }\n    // Handle special case of noether (base = 0)\n    if (base === zero) {\n        return negative ? '-0' : '0';\n    }\n    if (negative) {\n        wei = wei * negative1;\n    }\n    let fraction = (wei % base).toString();\n    fraction = fraction.padStart(baseLength, '0');\n    if (!options.pad) {\n        const fractionMatch = fraction.match(FRACTION_REGEX);\n        // istanbul ignore next: defensive fallback that's never reachable but necessary to satisfy TS\n        fraction = fractionMatch?.[1] ?? '0';\n    }\n    let whole = (wei / base).toString();\n    if (options.commify) {\n        whole = whole.replace(COMMIFY_REGEX, ',');\n    }\n    let value = `${whole}${fraction === '0' ? '' : `.${fraction}`}`;\n    if (negative) {\n        value = `-${value}`;\n    }\n    return value;\n}\nexports.fromWei = fromWei;\n/**\n * Converts a number to Wei.\n *\n * @param etherInput - The number to convert to Wei.\n * @param unit - The unit to convert to, default ether.\n * @returns The number in Wei.\n * @throws Error if the number is invalid.\n */\nfunction toWei(etherInput, unit) {\n    const unitLower = unit.toLowerCase();\n    const base = unitMapBigInt[unitLower];\n    const baseLength = unitLengths[unitLower];\n    if (base === undefined) {\n        throw new Error(`The unit provided ${unit} doesn't exist, please use the one of the following units ${JSON.stringify(exports.unitMap, null, 2)}`);\n    }\n    // Handle special case of noether (base = 0)\n    if (base === zero) {\n        return zero;\n    }\n    // Fast path for bigint inputs when unit is wei (no conversion needed)\n    if (typeof etherInput === 'bigint' && unitLower === 'wei') {\n        return etherInput;\n    }\n    // Fast path for bigint inputs with whole units (no fractional part)\n    if (typeof etherInput === 'bigint') {\n        return etherInput * base;\n    }\n    let ether = numberToString(etherInput);\n    // Is it negative?\n    const negative = ether.startsWith('-');\n    if (negative) {\n        ether = ether.substring(1);\n    }\n    if (ether === '.') {\n        throw new Error(`While converting number ${etherInput} to wei, invalid value`);\n    }\n    // Split it into a whole and fractional part\n    const comps = ether.split('.');\n    if (comps.length > 2) {\n        throw new Error(`While converting number ${etherInput} to wei,  too many decimal points`);\n    }\n    let whole = comps[0];\n    let fraction = comps[1];\n    if (!whole) {\n        whole = '0';\n    }\n    if (!fraction) {\n        fraction = '0';\n    }\n    if (fraction.length > baseLength) {\n        throw new Error(`While converting number ${etherInput} to wei, too many decimal places`);\n    }\n    fraction = fraction.padEnd(baseLength, '0');\n    const wholeBigInt = BigInt(whole);\n    const fractionBigInt = BigInt(fraction);\n    let wei = wholeBigInt * base + fractionBigInt;\n    if (negative) {\n        wei = wei * negative1;\n    }\n    return wei;\n}\nexports.toWei = toWei;\n//# sourceMappingURL=unitsConversion.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3VuaXRzQ29udmVyc2lvbi5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLGVBQWUsR0FBRyxzQkFBc0IsR0FBRyxzQkFBc0IsR0FBRyxlQUFlLEdBQUcsdUJBQXVCO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEVBQUU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxXQUFXLDJEQUEyRCx5Q0FBeUM7QUFDNUo7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLElBQUk7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLFlBQVksU0FBUyxXQUFXO0FBQ2hIO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU0sMkRBQTJELHlDQUF5QztBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixNQUFNLEVBQUUsNEJBQTRCLFNBQVMsRUFBRTtBQUNsRTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxNQUFNLDJEQUEyRCx5Q0FBeUM7QUFDdko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxZQUFZO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFlBQVk7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsWUFBWTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvdW5pdHNDb252ZXJzaW9uLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIGVzbGludC1kaXNhYmxlIG9wZXJhdG9yLWFzc2lnbm1lbnQgKi9cbi8qXG5QcmltYXJ5IEF0dHJpYnV0aW9uXG5SaWNoYXJkIE1vb3JlIDxyaWNtb29AbWUuY29tPlxuaHR0cHM6Ly9naXRodWIuY29tL2V0aGVycy1pb1xuXG5Ob3RlLCBSaWNoYXJkIGlzIGEgZ29kIG9mIGV0aGVyIGdvZHMuIEZvbGxvdyBhbmQgcmVzcGVjdCBoaW0sIGFuZCB1c2UgRXRoZXJzLmlvIVxuKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudG9XZWkgPSBleHBvcnRzLmZyb21XZWkgPSBleHBvcnRzLm51bWJlclRvU3RyaW5nID0gZXhwb3J0cy5nZXRWYWx1ZU9mVW5pdCA9IGV4cG9ydHMudW5pdE1hcCA9IGV4cG9ydHMubnVtZXJpY1RvQmlnSW50ID0gdm9pZCAwO1xuY29uc3QgemVybyA9IEJpZ0ludCgwKTtcbmNvbnN0IG5lZ2F0aXZlMSA9IEJpZ0ludCgtMSk7XG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nLCBudW1iZXIsIG9yIGJpZ2ludCB0byBhIGJpZ2ludC5cbiAqXG4gKiBAcGFyYW0gYXJnIC0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYmlnaW50LlxuICogQHJldHVybnMgVGhlIGJpZ2ludCByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5wdXQuXG4gKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBpbnB1dCB0eXBlIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gYmlnaW50LlxuICovXG5mdW5jdGlvbiBudW1lcmljVG9CaWdJbnQoYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQoYXJnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQoYXJnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcmcgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIHJldHVybiBhcmc7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvbnZlcnQgJHt0eXBlb2YgYXJnfSB0byBCaWdJbnRgKTtcbn1cbmV4cG9ydHMubnVtZXJpY1RvQmlnSW50ID0gbnVtZXJpY1RvQmlnSW50O1xuLy8gY29tcGxldGUgZXRoZXJldW0gdW5pdCBtYXBcbmV4cG9ydHMudW5pdE1hcCA9IHtcbiAgICBub2V0aGVyOiAnMCcsXG4gICAgd2VpOiAnMScsXG4gICAga3dlaTogJzEwMDAnLFxuICAgIEt3ZWk6ICcxMDAwJyxcbiAgICBiYWJiYWdlOiAnMTAwMCcsXG4gICAgZmVtdG9ldGhlcjogJzEwMDAnLFxuICAgIG13ZWk6ICcxMDAwMDAwJyxcbiAgICBNd2VpOiAnMTAwMDAwMCcsXG4gICAgbG92ZWxhY2U6ICcxMDAwMDAwJyxcbiAgICBwaWNvZXRoZXI6ICcxMDAwMDAwJyxcbiAgICBnd2VpOiAnMTAwMDAwMDAwMCcsXG4gICAgR3dlaTogJzEwMDAwMDAwMDAnLFxuICAgIHNoYW5ub246ICcxMDAwMDAwMDAwJyxcbiAgICBuYW5vZXRoZXI6ICcxMDAwMDAwMDAwJyxcbiAgICBuYW5vOiAnMTAwMDAwMDAwMCcsXG4gICAgc3phYm86ICcxMDAwMDAwMDAwMDAwJyxcbiAgICBtaWNyb2V0aGVyOiAnMTAwMDAwMDAwMDAwMCcsXG4gICAgbWljcm86ICcxMDAwMDAwMDAwMDAwJyxcbiAgICBmaW5uZXk6ICcxMDAwMDAwMDAwMDAwMDAwJyxcbiAgICBtaWxsaWV0aGVyOiAnMTAwMDAwMDAwMDAwMDAwMCcsXG4gICAgbWlsbGk6ICcxMDAwMDAwMDAwMDAwMDAwJyxcbiAgICBldGhlcjogJzEwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgIGtldGhlcjogJzEwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgIGdyYW5kOiAnMTAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgbWV0aGVyOiAnMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgZ2V0aGVyOiAnMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgdGV0aGVyOiAnMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG59O1xuLy8gUHJlLWNvbXB1dGVkIHVuaXQgdmFsdWVzIGFzIEJpZ0ludCBmb3IgcGVyZm9ybWFuY2VcbmNvbnN0IHVuaXRNYXBCaWdJbnQgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoZXhwb3J0cy51bml0TWFwKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW2tleSwgQmlnSW50KHZhbHVlKV0pKTtcbmNvbnN0IHVuaXRMZW5ndGhzID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGV4cG9ydHMudW5pdE1hcCkubWFwKChba2V5LCB2YWx1ZV0pID0+IFtrZXksIHZhbHVlLmxlbmd0aCAtIDEgfHwgMV0pKTtcbmNvbnN0IE5VTUJFUl9SRUdFWCA9IC9eLT9bMC05Ll0rJC91O1xuY29uc3QgRlJBQ1RJT05fUkVHRVggPSAvXihbMC05XSpbMS05XXwwKSgwKikvdTtcbmNvbnN0IENPTU1JRllfUkVHRVggPSAvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZ3U7XG4vKipcbiAqIFJldHVybnMgdmFsdWUgb2YgdW5pdCBpbiBXZWkuXG4gKlxuICogQHBhcmFtIHVuaXRJbnB1dCAtIFRoZSB1bml0IHRvIGNvbnZlcnQgdG8sIGRlZmF1bHQgZXRoZXIuXG4gKiBAcmV0dXJucyBWYWx1ZSBvZiB0aGUgdW5pdCAoaW4gV2VpKS5cbiAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIHVuaXQgaXMgbm90IGNvcnJlY3QuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlT2ZVbml0KHVuaXRJbnB1dCA9ICdldGhlcicpIHtcbiAgICBjb25zdCB1bml0ID0gdW5pdElucHV0LnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgdW5pdFZhbHVlID0gdW5pdE1hcEJpZ0ludFt1bml0XTtcbiAgICBpZiAodW5pdFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgdW5pdCBwcm92aWRlZCAke3VuaXRJbnB1dH0gZG9lc24ndCBleGlzdCwgcGxlYXNlIHVzZSB0aGUgb25lIG9mIHRoZSBmb2xsb3dpbmcgdW5pdHMgJHtKU09OLnN0cmluZ2lmeShleHBvcnRzLnVuaXRNYXAsIG51bGwsIDIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gdW5pdFZhbHVlO1xufVxuZXhwb3J0cy5nZXRWYWx1ZU9mVW5pdCA9IGdldFZhbHVlT2ZVbml0O1xuLyoqXG4gKiBDb252ZXJ0cyBhIG51bWJlciB0byBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gYXJnIC0gVGhlIG51bWJlciB0byBjb252ZXJ0IHRvIGEgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbnVtYmVyLlxuICogQHRocm93cyBFcnJvciBpZiB0aGUgbnVtYmVyIGlzIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIG51bWJlclRvU3RyaW5nKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoIU5VTUJFUl9SRUdFWC50ZXN0KGFyZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgd2hpbGUgY29udmVydGluZyBudW1iZXIgdG8gc3RyaW5nLCBpbnZhbGlkIG51bWJlciB2YWx1ZSAnJHthcmd9Jywgc2hvdWxkIGJlIGEgbnVtYmVyIG1hdGNoaW5nICheLT9bMC05Ll0rKS5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJnO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhhcmcpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgcmV0dXJuIGFyZy50b1N0cmluZygpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYHdoaWxlIGNvbnZlcnRpbmcgbnVtYmVyIHRvIHN0cmluZywgaW52YWxpZCBudW1iZXIgdmFsdWUgJyR7U3RyaW5nKGFyZyl9JyB0eXBlICR7dHlwZW9mIGFyZ30uYCk7XG59XG5leHBvcnRzLm51bWJlclRvU3RyaW5nID0gbnVtYmVyVG9TdHJpbmc7XG4vKipcbiAqIENvbnZlcnRzIGEgbnVtYmVyIGZyb20gV2VpIHRvIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB3ZWlJbnB1dCAtIFRoZSBudW1iZXIgdG8gY29udmVydCBmcm9tIFdlaS5cbiAqIEBwYXJhbSB1bml0IC0gVGhlIHVuaXQgdG8gY29udmVydCB0bywgZGVmYXVsdCBldGhlci5cbiAqIEBwYXJhbSBvcHRpb25zSW5wdXQgLSBUaGUgb3B0aW9ucyB0byB1c2UgZm9yIHRoZSBjb252ZXJzaW9uLlxuICogQHBhcmFtIG9wdGlvbnNJbnB1dC5wYWQgLSBXaGV0aGVyIHRvIHBhZCB0aGUgZnJhY3Rpb25hbCBwYXJ0IHdpdGggemVyb3MuXG4gKiBAcGFyYW0gb3B0aW9uc0lucHV0LmNvbW1pZnkgLSBXaGV0aGVyIHRvIGFkZCBjb21tYXMgdG8gc2VwYXJhdGUgdGhvdXNhbmRzLlxuICogQHJldHVybnMgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbnVtYmVyLlxuICogQHRocm93cyBFcnJvciBpZiB0aGUgbnVtYmVyIGlzIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGZyb21XZWkod2VpSW5wdXQsIHVuaXQsIG9wdGlvbnNJbnB1dCkge1xuICAgIGxldCB3ZWkgPSBudW1lcmljVG9CaWdJbnQod2VpSW5wdXQpO1xuICAgIGNvbnN0IG5lZ2F0aXZlID0gd2VpIDwgemVybztcbiAgICBjb25zdCB1bml0TG93ZXIgPSB1bml0LnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgYmFzZSA9IHVuaXRNYXBCaWdJbnRbdW5pdExvd2VyXTtcbiAgICBjb25zdCBiYXNlTGVuZ3RoID0gdW5pdExlbmd0aHNbdW5pdExvd2VyXTtcbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uc0lucHV0ID8/IHt9O1xuICAgIGlmIChiYXNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgdW5pdCBwcm92aWRlZCAke3VuaXR9IGRvZXNuJ3QgZXhpc3QsIHBsZWFzZSB1c2UgdGhlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHVuaXRzICR7SlNPTi5zdHJpbmdpZnkoZXhwb3J0cy51bml0TWFwLCBudWxsLCAyKX1gKTtcbiAgICB9XG4gICAgLy8gSGFuZGxlIHNwZWNpYWwgY2FzZSBvZiBub2V0aGVyIChiYXNlID0gMClcbiAgICBpZiAoYmFzZSA9PT0gemVybykge1xuICAgICAgICByZXR1cm4gbmVnYXRpdmUgPyAnLTAnIDogJzAnO1xuICAgIH1cbiAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgd2VpID0gd2VpICogbmVnYXRpdmUxO1xuICAgIH1cbiAgICBsZXQgZnJhY3Rpb24gPSAod2VpICUgYmFzZSkudG9TdHJpbmcoKTtcbiAgICBmcmFjdGlvbiA9IGZyYWN0aW9uLnBhZFN0YXJ0KGJhc2VMZW5ndGgsICcwJyk7XG4gICAgaWYgKCFvcHRpb25zLnBhZCkge1xuICAgICAgICBjb25zdCBmcmFjdGlvbk1hdGNoID0gZnJhY3Rpb24ubWF0Y2goRlJBQ1RJT05fUkVHRVgpO1xuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogZGVmZW5zaXZlIGZhbGxiYWNrIHRoYXQncyBuZXZlciByZWFjaGFibGUgYnV0IG5lY2Vzc2FyeSB0byBzYXRpc2Z5IFRTXG4gICAgICAgIGZyYWN0aW9uID0gZnJhY3Rpb25NYXRjaD8uWzFdID8/ICcwJztcbiAgICB9XG4gICAgbGV0IHdob2xlID0gKHdlaSAvIGJhc2UpLnRvU3RyaW5nKCk7XG4gICAgaWYgKG9wdGlvbnMuY29tbWlmeSkge1xuICAgICAgICB3aG9sZSA9IHdob2xlLnJlcGxhY2UoQ09NTUlGWV9SRUdFWCwgJywnKTtcbiAgICB9XG4gICAgbGV0IHZhbHVlID0gYCR7d2hvbGV9JHtmcmFjdGlvbiA9PT0gJzAnID8gJycgOiBgLiR7ZnJhY3Rpb259YH1gO1xuICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgICB2YWx1ZSA9IGAtJHt2YWx1ZX1gO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnRzLmZyb21XZWkgPSBmcm9tV2VpO1xuLyoqXG4gKiBDb252ZXJ0cyBhIG51bWJlciB0byBXZWkuXG4gKlxuICogQHBhcmFtIGV0aGVySW5wdXQgLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gV2VpLlxuICogQHBhcmFtIHVuaXQgLSBUaGUgdW5pdCB0byBjb252ZXJ0IHRvLCBkZWZhdWx0IGV0aGVyLlxuICogQHJldHVybnMgVGhlIG51bWJlciBpbiBXZWkuXG4gKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBudW1iZXIgaXMgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gdG9XZWkoZXRoZXJJbnB1dCwgdW5pdCkge1xuICAgIGNvbnN0IHVuaXRMb3dlciA9IHVuaXQudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBiYXNlID0gdW5pdE1hcEJpZ0ludFt1bml0TG93ZXJdO1xuICAgIGNvbnN0IGJhc2VMZW5ndGggPSB1bml0TGVuZ3Roc1t1bml0TG93ZXJdO1xuICAgIGlmIChiYXNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgdW5pdCBwcm92aWRlZCAke3VuaXR9IGRvZXNuJ3QgZXhpc3QsIHBsZWFzZSB1c2UgdGhlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHVuaXRzICR7SlNPTi5zdHJpbmdpZnkoZXhwb3J0cy51bml0TWFwLCBudWxsLCAyKX1gKTtcbiAgICB9XG4gICAgLy8gSGFuZGxlIHNwZWNpYWwgY2FzZSBvZiBub2V0aGVyIChiYXNlID0gMClcbiAgICBpZiAoYmFzZSA9PT0gemVybykge1xuICAgICAgICByZXR1cm4gemVybztcbiAgICB9XG4gICAgLy8gRmFzdCBwYXRoIGZvciBiaWdpbnQgaW5wdXRzIHdoZW4gdW5pdCBpcyB3ZWkgKG5vIGNvbnZlcnNpb24gbmVlZGVkKVxuICAgIGlmICh0eXBlb2YgZXRoZXJJbnB1dCA9PT0gJ2JpZ2ludCcgJiYgdW5pdExvd2VyID09PSAnd2VpJykge1xuICAgICAgICByZXR1cm4gZXRoZXJJbnB1dDtcbiAgICB9XG4gICAgLy8gRmFzdCBwYXRoIGZvciBiaWdpbnQgaW5wdXRzIHdpdGggd2hvbGUgdW5pdHMgKG5vIGZyYWN0aW9uYWwgcGFydClcbiAgICBpZiAodHlwZW9mIGV0aGVySW5wdXQgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIHJldHVybiBldGhlcklucHV0ICogYmFzZTtcbiAgICB9XG4gICAgbGV0IGV0aGVyID0gbnVtYmVyVG9TdHJpbmcoZXRoZXJJbnB1dCk7XG4gICAgLy8gSXMgaXQgbmVnYXRpdmU/XG4gICAgY29uc3QgbmVnYXRpdmUgPSBldGhlci5zdGFydHNXaXRoKCctJyk7XG4gICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICAgIGV0aGVyID0gZXRoZXIuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICBpZiAoZXRoZXIgPT09ICcuJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdoaWxlIGNvbnZlcnRpbmcgbnVtYmVyICR7ZXRoZXJJbnB1dH0gdG8gd2VpLCBpbnZhbGlkIHZhbHVlYCk7XG4gICAgfVxuICAgIC8vIFNwbGl0IGl0IGludG8gYSB3aG9sZSBhbmQgZnJhY3Rpb25hbCBwYXJ0XG4gICAgY29uc3QgY29tcHMgPSBldGhlci5zcGxpdCgnLicpO1xuICAgIGlmIChjb21wcy5sZW5ndGggPiAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV2hpbGUgY29udmVydGluZyBudW1iZXIgJHtldGhlcklucHV0fSB0byB3ZWksICB0b28gbWFueSBkZWNpbWFsIHBvaW50c2ApO1xuICAgIH1cbiAgICBsZXQgd2hvbGUgPSBjb21wc1swXTtcbiAgICBsZXQgZnJhY3Rpb24gPSBjb21wc1sxXTtcbiAgICBpZiAoIXdob2xlKSB7XG4gICAgICAgIHdob2xlID0gJzAnO1xuICAgIH1cbiAgICBpZiAoIWZyYWN0aW9uKSB7XG4gICAgICAgIGZyYWN0aW9uID0gJzAnO1xuICAgIH1cbiAgICBpZiAoZnJhY3Rpb24ubGVuZ3RoID4gYmFzZUxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdoaWxlIGNvbnZlcnRpbmcgbnVtYmVyICR7ZXRoZXJJbnB1dH0gdG8gd2VpLCB0b28gbWFueSBkZWNpbWFsIHBsYWNlc2ApO1xuICAgIH1cbiAgICBmcmFjdGlvbiA9IGZyYWN0aW9uLnBhZEVuZChiYXNlTGVuZ3RoLCAnMCcpO1xuICAgIGNvbnN0IHdob2xlQmlnSW50ID0gQmlnSW50KHdob2xlKTtcbiAgICBjb25zdCBmcmFjdGlvbkJpZ0ludCA9IEJpZ0ludChmcmFjdGlvbik7XG4gICAgbGV0IHdlaSA9IHdob2xlQmlnSW50ICogYmFzZSArIGZyYWN0aW9uQmlnSW50O1xuICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgICB3ZWkgPSB3ZWkgKiBuZWdhdGl2ZTE7XG4gICAgfVxuICAgIHJldHVybiB3ZWk7XG59XG5leHBvcnRzLnRvV2VpID0gdG9XZWk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bml0c0NvbnZlcnNpb24uY2pzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/dist/unitsConversion.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/dist/versions.cjs":
/*!************************************************************!*\
  !*** ../../node_modules/@metamask/utils/dist/versions.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.satisfiesVersionRange = exports.gtRange = exports.gtVersion = exports.assertIsSemVerRange = exports.assertIsSemVerVersion = exports.isValidSemVerRange = exports.isValidSemVerVersion = exports.VersionRangeStruct = exports.VersionStruct = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(rsc)/../../node_modules/@metamask/superstruct/dist/index.cjs\");\nconst semver_1 = __webpack_require__(/*! semver */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/index.js\");\nconst assert_1 = __webpack_require__(/*! ./assert.cjs */ \"(rsc)/../../node_modules/@metamask/utils/dist/assert.cjs\");\n/**\n * A struct for validating a version string.\n */\nexports.VersionStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'Version', (value) => {\n    if ((0, semver_1.valid)(value) === null) {\n        return `Expected SemVer version, got \"${value}\"`;\n    }\n    return true;\n});\nexports.VersionRangeStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'Version range', (value) => {\n    if ((0, semver_1.validRange)(value) === null) {\n        return `Expected SemVer range, got \"${value}\"`;\n    }\n    return true;\n});\n/**\n * Checks whether a SemVer version is valid.\n *\n * @param version - A potential version.\n * @returns `true` if the version is valid, and `false` otherwise.\n */\nfunction isValidSemVerVersion(version) {\n    return (0, superstruct_1.is)(version, exports.VersionStruct);\n}\nexports.isValidSemVerVersion = isValidSemVerVersion;\n/**\n * Checks whether a SemVer version range is valid.\n *\n * @param versionRange - A potential version range.\n * @returns `true` if the version range is valid, and `false` otherwise.\n */\nfunction isValidSemVerRange(versionRange) {\n    return (0, superstruct_1.is)(versionRange, exports.VersionRangeStruct);\n}\nexports.isValidSemVerRange = isValidSemVerRange;\n/**\n * Asserts that a value is a valid concrete SemVer version.\n *\n * @param version - A potential SemVer concrete version.\n */\nfunction assertIsSemVerVersion(version) {\n    (0, assert_1.assertStruct)(version, exports.VersionStruct);\n}\nexports.assertIsSemVerVersion = assertIsSemVerVersion;\n/**\n * Asserts that a value is a valid SemVer range.\n *\n * @param range - A potential SemVer range.\n */\nfunction assertIsSemVerRange(range) {\n    (0, assert_1.assertStruct)(range, exports.VersionRangeStruct);\n}\nexports.assertIsSemVerRange = assertIsSemVerRange;\n/**\n * Checks whether a SemVer version is greater than another.\n *\n * @param version1 - The left-hand version.\n * @param version2 - The right-hand version.\n * @returns `version1 > version2`.\n */\nfunction gtVersion(version1, version2) {\n    return (0, semver_1.gt)(version1, version2);\n}\nexports.gtVersion = gtVersion;\n/**\n * Checks whether a SemVer version is greater than all possibilities in a range.\n *\n * @param version - A SemvVer version.\n * @param range - The range to check against.\n * @returns `version > range`.\n */\nfunction gtRange(version, range) {\n    return (0, semver_1.gtr)(version, range);\n}\nexports.gtRange = gtRange;\n/**\n * Returns whether a SemVer version satisfies a SemVer range.\n *\n * @param version - The SemVer version to check.\n * @param versionRange - The SemVer version range to check against.\n * @returns Whether the version satisfied the version range.\n */\nfunction satisfiesVersionRange(version, versionRange) {\n    return (0, semver_1.satisfies)(version, versionRange, {\n        includePrerelease: true,\n    });\n}\nexports.satisfiesVersionRange = satisfiesVersionRange;\n//# sourceMappingURL=versions.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3ZlcnNpb25zLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRyxlQUFlLEdBQUcsaUJBQWlCLEdBQUcsMkJBQTJCLEdBQUcsNkJBQTZCLEdBQUcsMEJBQTBCLEdBQUcsNEJBQTRCLEdBQUcsMEJBQTBCLEdBQUcscUJBQXFCO0FBQ2xQLHNCQUFzQixtQkFBTyxDQUFDLDRGQUF1QjtBQUNyRCxpQkFBaUIsbUJBQU8sQ0FBQyxxRkFBUTtBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBYztBQUN2QztBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxnREFBZ0QsTUFBTTtBQUN0RDtBQUNBO0FBQ0EsQ0FBQztBQUNELDBCQUEwQjtBQUMxQjtBQUNBLDhDQUE4QyxNQUFNO0FBQ3BEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2QkFBNkI7QUFDN0IiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3ZlcnNpb25zLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2F0aXNmaWVzVmVyc2lvblJhbmdlID0gZXhwb3J0cy5ndFJhbmdlID0gZXhwb3J0cy5ndFZlcnNpb24gPSBleHBvcnRzLmFzc2VydElzU2VtVmVyUmFuZ2UgPSBleHBvcnRzLmFzc2VydElzU2VtVmVyVmVyc2lvbiA9IGV4cG9ydHMuaXNWYWxpZFNlbVZlclJhbmdlID0gZXhwb3J0cy5pc1ZhbGlkU2VtVmVyVmVyc2lvbiA9IGV4cG9ydHMuVmVyc2lvblJhbmdlU3RydWN0ID0gZXhwb3J0cy5WZXJzaW9uU3RydWN0ID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svc3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBzZW12ZXJfMSA9IHJlcXVpcmUoXCJzZW12ZXJcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydC5janNcIik7XG4vKipcbiAqIEEgc3RydWN0IGZvciB2YWxpZGF0aW5nIGEgdmVyc2lvbiBzdHJpbmcuXG4gKi9cbmV4cG9ydHMuVmVyc2lvblN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnJlZmluZSkoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCAnVmVyc2lvbicsICh2YWx1ZSkgPT4ge1xuICAgIGlmICgoMCwgc2VtdmVyXzEudmFsaWQpKHZhbHVlKSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYEV4cGVjdGVkIFNlbVZlciB2ZXJzaW9uLCBnb3QgXCIke3ZhbHVlfVwiYDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbmV4cG9ydHMuVmVyc2lvblJhbmdlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEucmVmaW5lKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksICdWZXJzaW9uIHJhbmdlJywgKHZhbHVlKSA9PiB7XG4gICAgaWYgKCgwLCBzZW12ZXJfMS52YWxpZFJhbmdlKSh2YWx1ZSkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGBFeHBlY3RlZCBTZW1WZXIgcmFuZ2UsIGdvdCBcIiR7dmFsdWV9XCJgO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gQSBwb3RlbnRpYWwgdmVyc2lvbi5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmVyc2lvbiBpcyB2YWxpZCwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkU2VtVmVyVmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2ZXJzaW9uLCBleHBvcnRzLlZlcnNpb25TdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc1ZhbGlkU2VtVmVyVmVyc2lvbiA9IGlzVmFsaWRTZW1WZXJWZXJzaW9uO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIHJhbmdlIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uUmFuZ2UgLSBBIHBvdGVudGlhbCB2ZXJzaW9uIHJhbmdlLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2ZXJzaW9uIHJhbmdlIGlzIHZhbGlkLCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRTZW1WZXJSYW5nZSh2ZXJzaW9uUmFuZ2UpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZlcnNpb25SYW5nZSwgZXhwb3J0cy5WZXJzaW9uUmFuZ2VTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc1ZhbGlkU2VtVmVyUmFuZ2UgPSBpc1ZhbGlkU2VtVmVyUmFuZ2U7XG4vKipcbiAqIEFzc2VydHMgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgY29uY3JldGUgU2VtVmVyIHZlcnNpb24uXG4gKlxuICogQHBhcmFtIHZlcnNpb24gLSBBIHBvdGVudGlhbCBTZW1WZXIgY29uY3JldGUgdmVyc2lvbi5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNTZW1WZXJWZXJzaW9uKHZlcnNpb24pIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2ZXJzaW9uLCBleHBvcnRzLlZlcnNpb25TdHJ1Y3QpO1xufVxuZXhwb3J0cy5hc3NlcnRJc1NlbVZlclZlcnNpb24gPSBhc3NlcnRJc1NlbVZlclZlcnNpb247XG4vKipcbiAqIEFzc2VydHMgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgU2VtVmVyIHJhbmdlLlxuICpcbiAqIEBwYXJhbSByYW5nZSAtIEEgcG90ZW50aWFsIFNlbVZlciByYW5nZS5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNTZW1WZXJSYW5nZShyYW5nZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHJhbmdlLCBleHBvcnRzLlZlcnNpb25SYW5nZVN0cnVjdCk7XG59XG5leHBvcnRzLmFzc2VydElzU2VtVmVyUmFuZ2UgPSBhc3NlcnRJc1NlbVZlclJhbmdlO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIGlzIGdyZWF0ZXIgdGhhbiBhbm90aGVyLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uMSAtIFRoZSBsZWZ0LWhhbmQgdmVyc2lvbi5cbiAqIEBwYXJhbSB2ZXJzaW9uMiAtIFRoZSByaWdodC1oYW5kIHZlcnNpb24uXG4gKiBAcmV0dXJucyBgdmVyc2lvbjEgPiB2ZXJzaW9uMmAuXG4gKi9cbmZ1bmN0aW9uIGd0VmVyc2lvbih2ZXJzaW9uMSwgdmVyc2lvbjIpIHtcbiAgICByZXR1cm4gKDAsIHNlbXZlcl8xLmd0KSh2ZXJzaW9uMSwgdmVyc2lvbjIpO1xufVxuZXhwb3J0cy5ndFZlcnNpb24gPSBndFZlcnNpb247XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgU2VtVmVyIHZlcnNpb24gaXMgZ3JlYXRlciB0aGFuIGFsbCBwb3NzaWJpbGl0aWVzIGluIGEgcmFuZ2UuXG4gKlxuICogQHBhcmFtIHZlcnNpb24gLSBBIFNlbXZWZXIgdmVyc2lvbi5cbiAqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMgYHZlcnNpb24gPiByYW5nZWAuXG4gKi9cbmZ1bmN0aW9uIGd0UmFuZ2UodmVyc2lvbiwgcmFuZ2UpIHtcbiAgICByZXR1cm4gKDAsIHNlbXZlcl8xLmd0cikodmVyc2lvbiwgcmFuZ2UpO1xufVxuZXhwb3J0cy5ndFJhbmdlID0gZ3RSYW5nZTtcbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIGEgU2VtVmVyIHZlcnNpb24gc2F0aXNmaWVzIGEgU2VtVmVyIHJhbmdlLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gVGhlIFNlbVZlciB2ZXJzaW9uIHRvIGNoZWNrLlxuICogQHBhcmFtIHZlcnNpb25SYW5nZSAtIFRoZSBTZW1WZXIgdmVyc2lvbiByYW5nZSB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmVyc2lvbiBzYXRpc2ZpZWQgdGhlIHZlcnNpb24gcmFuZ2UuXG4gKi9cbmZ1bmN0aW9uIHNhdGlzZmllc1ZlcnNpb25SYW5nZSh2ZXJzaW9uLCB2ZXJzaW9uUmFuZ2UpIHtcbiAgICByZXR1cm4gKDAsIHNlbXZlcl8xLnNhdGlzZmllcykodmVyc2lvbiwgdmVyc2lvblJhbmdlLCB7XG4gICAgICAgIGluY2x1ZGVQcmVyZWxlYXNlOiB0cnVlLFxuICAgIH0pO1xufVxuZXhwb3J0cy5zYXRpc2ZpZXNWZXJzaW9uUmFuZ2UgPSBzYXRpc2ZpZXNWZXJzaW9uUmFuZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9ucy5janMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/dist/versions.cjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/comparator.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/classes/comparator.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst ANY = Symbol('SemVer ANY')\n// hoisted class for cyclic dependency\nclass Comparator {\n  static get ANY () {\n    return ANY\n  }\n\n  constructor (comp, options) {\n    options = parseOptions(options)\n\n    if (comp instanceof Comparator) {\n      if (comp.loose === !!options.loose) {\n        return comp\n      } else {\n        comp = comp.value\n      }\n    }\n\n    comp = comp.trim().split(/\\s+/).join(' ')\n    debug('comparator', comp, options)\n    this.options = options\n    this.loose = !!options.loose\n    this.parse(comp)\n\n    if (this.semver === ANY) {\n      this.value = ''\n    } else {\n      this.value = this.operator + this.semver.version\n    }\n\n    debug('comp', this)\n  }\n\n  parse (comp) {\n    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n    const m = comp.match(r)\n\n    if (!m) {\n      throw new TypeError(`Invalid comparator: ${comp}`)\n    }\n\n    this.operator = m[1] !== undefined ? m[1] : ''\n    if (this.operator === '=') {\n      this.operator = ''\n    }\n\n    // if it literally is just '>' or '' then allow anything.\n    if (!m[2]) {\n      this.semver = ANY\n    } else {\n      this.semver = new SemVer(m[2], this.options.loose)\n    }\n  }\n\n  toString () {\n    return this.value\n  }\n\n  test (version) {\n    debug('Comparator.test', version, this.options.loose)\n\n    if (this.semver === ANY || version === ANY) {\n      return true\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    return cmp(version, this.operator, this.semver, this.options)\n  }\n\n  intersects (comp, options) {\n    if (!(comp instanceof Comparator)) {\n      throw new TypeError('a Comparator is required')\n    }\n\n    if (this.operator === '') {\n      if (this.value === '') {\n        return true\n      }\n      return new Range(comp.value, options).test(this.value)\n    } else if (comp.operator === '') {\n      if (comp.value === '') {\n        return true\n      }\n      return new Range(this.value, options).test(comp.semver)\n    }\n\n    options = parseOptions(options)\n\n    // Special cases where nothing can possibly be lower\n    if (options.includePrerelease &&\n      (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {\n      return false\n    }\n    if (!options.includePrerelease &&\n      (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {\n      return false\n    }\n\n    // Same direction increasing (> or >=)\n    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {\n      return true\n    }\n    // Same direction decreasing (< or <=)\n    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {\n      return true\n    }\n    // same SemVer and both sides are inclusive (<= or >=)\n    if (\n      (this.semver.version === comp.semver.version) &&\n      this.operator.includes('=') && comp.operator.includes('=')) {\n      return true\n    }\n    // opposite directions less than\n    if (cmp(this.semver, '<', comp.semver, options) &&\n      this.operator.startsWith('>') && comp.operator.startsWith('<')) {\n      return true\n    }\n    // opposite directions greater than\n    if (cmp(this.semver, '>', comp.semver, options) &&\n      this.operator.startsWith('<') && comp.operator.startsWith('>')) {\n      return true\n    }\n    return false\n  }\n}\n\nmodule.exports = Comparator\n\nconst parseOptions = __webpack_require__(/*! ../internal/parse-options */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/parse-options.js\")\nconst { safeRe: re, t } = __webpack_require__(/*! ../internal/re */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/re.js\")\nconst cmp = __webpack_require__(/*! ../functions/cmp */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/cmp.js\")\nconst debug = __webpack_require__(/*! ../internal/debug */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/debug.js\")\nconst SemVer = __webpack_require__(/*! ./semver */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/semver.js\")\nconst Range = __webpack_require__(/*! ./range */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/range.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvY29tcGFyYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQixtQkFBTyxDQUFDLHlIQUEyQjtBQUN4RCxRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsbUdBQWdCO0FBQ2xELFlBQVksbUJBQU8sQ0FBQyx1R0FBa0I7QUFDdEMsY0FBYyxtQkFBTyxDQUFDLHlHQUFtQjtBQUN6QyxlQUFlLG1CQUFPLENBQUMsZ0dBQVU7QUFDakMsY0FBYyxtQkFBTyxDQUFDLDhGQUFTIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvbm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL2NvbXBhcmF0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEFOWSA9IFN5bWJvbCgnU2VtVmVyIEFOWScpXG4vLyBob2lzdGVkIGNsYXNzIGZvciBjeWNsaWMgZGVwZW5kZW5jeVxuY2xhc3MgQ29tcGFyYXRvciB7XG4gIHN0YXRpYyBnZXQgQU5ZICgpIHtcbiAgICByZXR1cm4gQU5ZXG4gIH1cblxuICBjb25zdHJ1Y3RvciAoY29tcCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMob3B0aW9ucylcblxuICAgIGlmIChjb21wIGluc3RhbmNlb2YgQ29tcGFyYXRvcikge1xuICAgICAgaWYgKGNvbXAubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSkge1xuICAgICAgICByZXR1cm4gY29tcFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcCA9IGNvbXAudmFsdWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wID0gY29tcC50cmltKCkuc3BsaXQoL1xccysvKS5qb2luKCcgJylcbiAgICBkZWJ1ZygnY29tcGFyYXRvcicsIGNvbXAsIG9wdGlvbnMpXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2VcbiAgICB0aGlzLnBhcnNlKGNvbXApXG5cbiAgICBpZiAodGhpcy5zZW12ZXIgPT09IEFOWSkge1xuICAgICAgdGhpcy52YWx1ZSA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLm9wZXJhdG9yICsgdGhpcy5zZW12ZXIudmVyc2lvblxuICAgIH1cblxuICAgIGRlYnVnKCdjb21wJywgdGhpcylcbiAgfVxuXG4gIHBhcnNlIChjb21wKSB7XG4gICAgY29uc3QgciA9IHRoaXMub3B0aW9ucy5sb29zZSA/IHJlW3QuQ09NUEFSQVRPUkxPT1NFXSA6IHJlW3QuQ09NUEFSQVRPUl1cbiAgICBjb25zdCBtID0gY29tcC5tYXRjaChyKVxuXG4gICAgaWYgKCFtKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGNvbXBhcmF0b3I6ICR7Y29tcH1gKVxuICAgIH1cblxuICAgIHRoaXMub3BlcmF0b3IgPSBtWzFdICE9PSB1bmRlZmluZWQgPyBtWzFdIDogJydcbiAgICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJz0nKSB7XG4gICAgICB0aGlzLm9wZXJhdG9yID0gJydcbiAgICB9XG5cbiAgICAvLyBpZiBpdCBsaXRlcmFsbHkgaXMganVzdCAnPicgb3IgJycgdGhlbiBhbGxvdyBhbnl0aGluZy5cbiAgICBpZiAoIW1bMl0pIHtcbiAgICAgIHRoaXMuc2VtdmVyID0gQU5ZXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VtdmVyID0gbmV3IFNlbVZlcihtWzJdLCB0aGlzLm9wdGlvbnMubG9vc2UpXG4gICAgfVxuICB9XG5cbiAgdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlXG4gIH1cblxuICB0ZXN0ICh2ZXJzaW9uKSB7XG4gICAgZGVidWcoJ0NvbXBhcmF0b3IudGVzdCcsIHZlcnNpb24sIHRoaXMub3B0aW9ucy5sb29zZSlcblxuICAgIGlmICh0aGlzLnNlbXZlciA9PT0gQU5ZIHx8IHZlcnNpb24gPT09IEFOWSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY21wKHZlcnNpb24sIHRoaXMub3BlcmF0b3IsIHRoaXMuc2VtdmVyLCB0aGlzLm9wdGlvbnMpXG4gIH1cblxuICBpbnRlcnNlY3RzIChjb21wLCBvcHRpb25zKSB7XG4gICAgaWYgKCEoY29tcCBpbnN0YW5jZW9mIENvbXBhcmF0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhIENvbXBhcmF0b3IgaXMgcmVxdWlyZWQnKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wZXJhdG9yID09PSAnJykge1xuICAgICAgaWYgKHRoaXMudmFsdWUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKGNvbXAudmFsdWUsIG9wdGlvbnMpLnRlc3QodGhpcy52YWx1ZSlcbiAgICB9IGVsc2UgaWYgKGNvbXAub3BlcmF0b3IgPT09ICcnKSB7XG4gICAgICBpZiAoY29tcC52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmFuZ2UodGhpcy52YWx1ZSwgb3B0aW9ucykudGVzdChjb21wLnNlbXZlcilcbiAgICB9XG5cbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICAvLyBTcGVjaWFsIGNhc2VzIHdoZXJlIG5vdGhpbmcgY2FuIHBvc3NpYmx5IGJlIGxvd2VyXG4gICAgaWYgKG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgJiZcbiAgICAgICh0aGlzLnZhbHVlID09PSAnPDAuMC4wLTAnIHx8IGNvbXAudmFsdWUgPT09ICc8MC4wLjAtMCcpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmXG4gICAgICAodGhpcy52YWx1ZS5zdGFydHNXaXRoKCc8MC4wLjAnKSB8fCBjb21wLnZhbHVlLnN0YXJ0c1dpdGgoJzwwLjAuMCcpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gU2FtZSBkaXJlY3Rpb24gaW5jcmVhc2luZyAoPiBvciA+PSlcbiAgICBpZiAodGhpcy5vcGVyYXRvci5zdGFydHNXaXRoKCc+JykgJiYgY29tcC5vcGVyYXRvci5zdGFydHNXaXRoKCc+JykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIFNhbWUgZGlyZWN0aW9uIGRlY3JlYXNpbmcgKDwgb3IgPD0pXG4gICAgaWYgKHRoaXMub3BlcmF0b3Iuc3RhcnRzV2l0aCgnPCcpICYmIGNvbXAub3BlcmF0b3Iuc3RhcnRzV2l0aCgnPCcpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBzYW1lIFNlbVZlciBhbmQgYm90aCBzaWRlcyBhcmUgaW5jbHVzaXZlICg8PSBvciA+PSlcbiAgICBpZiAoXG4gICAgICAodGhpcy5zZW12ZXIudmVyc2lvbiA9PT0gY29tcC5zZW12ZXIudmVyc2lvbikgJiZcbiAgICAgIHRoaXMub3BlcmF0b3IuaW5jbHVkZXMoJz0nKSAmJiBjb21wLm9wZXJhdG9yLmluY2x1ZGVzKCc9JykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIG9wcG9zaXRlIGRpcmVjdGlvbnMgbGVzcyB0aGFuXG4gICAgaWYgKGNtcCh0aGlzLnNlbXZlciwgJzwnLCBjb21wLnNlbXZlciwgb3B0aW9ucykgJiZcbiAgICAgIHRoaXMub3BlcmF0b3Iuc3RhcnRzV2l0aCgnPicpICYmIGNvbXAub3BlcmF0b3Iuc3RhcnRzV2l0aCgnPCcpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBvcHBvc2l0ZSBkaXJlY3Rpb25zIGdyZWF0ZXIgdGhhblxuICAgIGlmIChjbXAodGhpcy5zZW12ZXIsICc+JywgY29tcC5zZW12ZXIsIG9wdGlvbnMpICYmXG4gICAgICB0aGlzLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJzwnKSAmJiBjb21wLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJz4nKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wYXJhdG9yXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3QgeyBzYWZlUmU6IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5jb25zdCBjbXAgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvY21wJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvZGVidWcnKVxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuL3JhbmdlJylcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/comparator.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/range.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/classes/range.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SPACE_CHARACTERS = /\\s+/g\n\n// hoisted class for cyclic dependency\nclass Range {\n  constructor (range, options) {\n    options = parseOptions(options)\n\n    if (range instanceof Range) {\n      if (\n        range.loose === !!options.loose &&\n        range.includePrerelease === !!options.includePrerelease\n      ) {\n        return range\n      } else {\n        return new Range(range.raw, options)\n      }\n    }\n\n    if (range instanceof Comparator) {\n      // just put it in the set and return\n      this.raw = range.value\n      this.set = [[range]]\n      this.formatted = undefined\n      return this\n    }\n\n    this.options = options\n    this.loose = !!options.loose\n    this.includePrerelease = !!options.includePrerelease\n\n    // First reduce all whitespace as much as possible so we do not have to rely\n    // on potentially slow regexes like \\s*. This is then stored and used for\n    // future error messages as well.\n    this.raw = range.trim().replace(SPACE_CHARACTERS, ' ')\n\n    // First, split on ||\n    this.set = this.raw\n      .split('||')\n      // map the range to a 2d array of comparators\n      .map(r => this.parseRange(r.trim()))\n      // throw out any comparator lists that are empty\n      // this generally means that it was not a valid range, which is allowed\n      // in loose mode, but will still throw if the WHOLE range is invalid.\n      .filter(c => c.length)\n\n    if (!this.set.length) {\n      throw new TypeError(`Invalid SemVer Range: ${this.raw}`)\n    }\n\n    // if we have any that are not the null set, throw out null sets.\n    if (this.set.length > 1) {\n      // keep the first one, in case they're all null sets\n      const first = this.set[0]\n      this.set = this.set.filter(c => !isNullSet(c[0]))\n      if (this.set.length === 0) {\n        this.set = [first]\n      } else if (this.set.length > 1) {\n        // if we have any that are *, then the range is just *\n        for (const c of this.set) {\n          if (c.length === 1 && isAny(c[0])) {\n            this.set = [c]\n            break\n          }\n        }\n      }\n    }\n\n    this.formatted = undefined\n  }\n\n  get range () {\n    if (this.formatted === undefined) {\n      this.formatted = ''\n      for (let i = 0; i < this.set.length; i++) {\n        if (i > 0) {\n          this.formatted += '||'\n        }\n        const comps = this.set[i]\n        for (let k = 0; k < comps.length; k++) {\n          if (k > 0) {\n            this.formatted += ' '\n          }\n          this.formatted += comps[k].toString().trim()\n        }\n      }\n    }\n    return this.formatted\n  }\n\n  format () {\n    return this.range\n  }\n\n  toString () {\n    return this.range\n  }\n\n  parseRange (range) {\n    // memoize range parsing for performance.\n    // this is a very hot path, and fully deterministic.\n    const memoOpts =\n      (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |\n      (this.options.loose && FLAG_LOOSE)\n    const memoKey = memoOpts + ':' + range\n    const cached = cache.get(memoKey)\n    if (cached) {\n      return cached\n    }\n\n    const loose = this.options.loose\n    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]\n    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))\n    debug('hyphen replace', range)\n\n    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)\n    debug('comparator trim', range)\n\n    // `~ 1.2.3` => `~1.2.3`\n    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)\n    debug('tilde trim', range)\n\n    // `^ 1.2.3` => `^1.2.3`\n    range = range.replace(re[t.CARETTRIM], caretTrimReplace)\n    debug('caret trim', range)\n\n    // At this point, the range is completely trimmed and\n    // ready to be split into comparators.\n\n    let rangeList = range\n      .split(' ')\n      .map(comp => parseComparator(comp, this.options))\n      .join(' ')\n      .split(/\\s+/)\n      // >=0.0.0 is equivalent to *\n      .map(comp => replaceGTE0(comp, this.options))\n\n    if (loose) {\n      // in loose mode, throw out any that are not valid comparators\n      rangeList = rangeList.filter(comp => {\n        debug('loose invalid filter', comp, this.options)\n        return !!comp.match(re[t.COMPARATORLOOSE])\n      })\n    }\n    debug('range list', rangeList)\n\n    // if any comparators are the null set, then replace with JUST null set\n    // if more than one comparator, remove any * comparators\n    // also, don't include the same comparator more than once\n    const rangeMap = new Map()\n    const comparators = rangeList.map(comp => new Comparator(comp, this.options))\n    for (const comp of comparators) {\n      if (isNullSet(comp)) {\n        return [comp]\n      }\n      rangeMap.set(comp.value, comp)\n    }\n    if (rangeMap.size > 1 && rangeMap.has('')) {\n      rangeMap.delete('')\n    }\n\n    const result = [...rangeMap.values()]\n    cache.set(memoKey, result)\n    return result\n  }\n\n  intersects (range, options) {\n    if (!(range instanceof Range)) {\n      throw new TypeError('a Range is required')\n    }\n\n    return this.set.some((thisComparators) => {\n      return (\n        isSatisfiable(thisComparators, options) &&\n        range.set.some((rangeComparators) => {\n          return (\n            isSatisfiable(rangeComparators, options) &&\n            thisComparators.every((thisComparator) => {\n              return rangeComparators.every((rangeComparator) => {\n                return thisComparator.intersects(rangeComparator, options)\n              })\n            })\n          )\n        })\n      )\n    })\n  }\n\n  // if ANY of the sets match ALL of its comparators, then pass\n  test (version) {\n    if (!version) {\n      return false\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    for (let i = 0; i < this.set.length; i++) {\n      if (testSet(this.set[i], version, this.options)) {\n        return true\n      }\n    }\n    return false\n  }\n}\n\nmodule.exports = Range\n\nconst LRU = __webpack_require__(/*! ../internal/lrucache */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/lrucache.js\")\nconst cache = new LRU()\n\nconst parseOptions = __webpack_require__(/*! ../internal/parse-options */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/parse-options.js\")\nconst Comparator = __webpack_require__(/*! ./comparator */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/comparator.js\")\nconst debug = __webpack_require__(/*! ../internal/debug */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/debug.js\")\nconst SemVer = __webpack_require__(/*! ./semver */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/semver.js\")\nconst {\n  safeRe: re,\n  t,\n  comparatorTrimReplace,\n  tildeTrimReplace,\n  caretTrimReplace,\n} = __webpack_require__(/*! ../internal/re */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/re.js\")\nconst { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = __webpack_require__(/*! ../internal/constants */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/constants.js\")\n\nconst isNullSet = c => c.value === '<0.0.0-0'\nconst isAny = c => c.value === ''\n\n// take a set of comparators and determine whether there\n// exists a version which can satisfy it\nconst isSatisfiable = (comparators, options) => {\n  let result = true\n  const remainingComparators = comparators.slice()\n  let testComparator = remainingComparators.pop()\n\n  while (result && remainingComparators.length) {\n    result = remainingComparators.every((otherComparator) => {\n      return testComparator.intersects(otherComparator, options)\n    })\n\n    testComparator = remainingComparators.pop()\n  }\n\n  return result\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nconst parseComparator = (comp, options) => {\n  comp = comp.replace(re[t.BUILD], '')\n  debug('comp', comp, options)\n  comp = replaceCarets(comp, options)\n  debug('caret', comp)\n  comp = replaceTildes(comp, options)\n  debug('tildes', comp)\n  comp = replaceXRanges(comp, options)\n  debug('xrange', comp)\n  comp = replaceStars(comp, options)\n  debug('stars', comp)\n  return comp\n}\n\nconst isX = id => !id || id.toLowerCase() === 'x' || id === '*'\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0\n// ~0.0.1 --> >=0.0.1 <0.1.0-0\nconst replaceTildes = (comp, options) => {\n  return comp\n    .trim()\n    .split(/\\s+/)\n    .map((c) => replaceTilde(c, options))\n    .join(' ')\n}\n\nconst replaceTilde = (comp, options) => {\n  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('tilde', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0-0\n      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`\n    } else if (pr) {\n      debug('replaceTilde pr', pr)\n      ret = `>=${M}.${m}.${p}-${pr\n      } <${M}.${+m + 1}.0-0`\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0-0\n      ret = `>=${M}.${m}.${p\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('tilde return', ret)\n    return ret\n  })\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0\n// ^1.2.3 --> >=1.2.3 <2.0.0-0\n// ^1.2.0 --> >=1.2.0 <2.0.0-0\n// ^0.0.1 --> >=0.0.1 <0.0.2-0\n// ^0.1.0 --> >=0.1.0 <0.2.0-0\nconst replaceCarets = (comp, options) => {\n  return comp\n    .trim()\n    .split(/\\s+/)\n    .map((c) => replaceCaret(c, options))\n    .join(' ')\n}\n\nconst replaceCaret = (comp, options) => {\n  debug('caret', comp, options)\n  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]\n  const z = options.includePrerelease ? '-0' : ''\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('caret', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`\n      } else {\n        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`\n      }\n    } else if (pr) {\n      debug('replaceCaret pr', pr)\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p}-${pr\n        } <${+M + 1}.0.0-0`\n      }\n    } else {\n      debug('no pr')\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p\n        } <${+M + 1}.0.0-0`\n      }\n    }\n\n    debug('caret return', ret)\n    return ret\n  })\n}\n\nconst replaceXRanges = (comp, options) => {\n  debug('replaceXRanges', comp, options)\n  return comp\n    .split(/\\s+/)\n    .map((c) => replaceXRange(c, options))\n    .join(' ')\n}\n\nconst replaceXRange = (comp, options) => {\n  comp = comp.trim()\n  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]\n  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr)\n    const xM = isX(M)\n    const xm = xM || isX(m)\n    const xp = xm || isX(p)\n    const anyX = xp\n\n    if (gtlt === '=' && anyX) {\n      gtlt = ''\n    }\n\n    // if we're including prereleases in the match, then we need\n    // to fix this to -0, the lowest possible prerelease value\n    pr = options.includePrerelease ? '-0' : ''\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0-0'\n      } else {\n        // nothing is forbidden\n        ret = '*'\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0\n      }\n      p = 0\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        gtlt = '>='\n        if (xm) {\n          M = +M + 1\n          m = 0\n          p = 0\n        } else {\n          m = +m + 1\n          p = 0\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm) {\n          M = +M + 1\n        } else {\n          m = +m + 1\n        }\n      }\n\n      if (gtlt === '<') {\n        pr = '-0'\n      }\n\n      ret = `${gtlt + M}.${m}.${p}${pr}`\n    } else if (xm) {\n      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`\n    } else if (xp) {\n      ret = `>=${M}.${m}.0${pr\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('xRange return', ret)\n\n    return ret\n  })\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nconst replaceStars = (comp, options) => {\n  debug('replaceStars', comp, options)\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp\n    .trim()\n    .replace(re[t.STAR], '')\n}\n\nconst replaceGTE0 = (comp, options) => {\n  debug('replaceGTE0', comp, options)\n  return comp\n    .trim()\n    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')\n}\n\n// This function is passed to string.replace(re[t.HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0-0\n// TODO build?\nconst hyphenReplace = incPr => ($0,\n  from, fM, fm, fp, fpr, fb,\n  to, tM, tm, tp, tpr) => {\n  if (isX(fM)) {\n    from = ''\n  } else if (isX(fm)) {\n    from = `>=${fM}.0.0${incPr ? '-0' : ''}`\n  } else if (isX(fp)) {\n    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`\n  } else if (fpr) {\n    from = `>=${from}`\n  } else {\n    from = `>=${from}${incPr ? '-0' : ''}`\n  }\n\n  if (isX(tM)) {\n    to = ''\n  } else if (isX(tm)) {\n    to = `<${+tM + 1}.0.0-0`\n  } else if (isX(tp)) {\n    to = `<${tM}.${+tm + 1}.0-0`\n  } else if (tpr) {\n    to = `<=${tM}.${tm}.${tp}-${tpr}`\n  } else if (incPr) {\n    to = `<${tM}.${tm}.${+tp + 1}-0`\n  } else {\n    to = `<=${to}`\n  }\n\n  return `${from} ${to}`.trim()\n}\n\nconst testSet = (set, version, options) => {\n  for (let i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (let i = 0; i < set.length; i++) {\n      debug(set[i].semver)\n      if (set[i].semver === Comparator.ANY) {\n        continue\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        const allowed = set[i].semver\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch) {\n          return true\n        }\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false\n  }\n\n  return true\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvcmFuZ2UuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMsK0dBQXNCO0FBQzFDOztBQUVBLHFCQUFxQixtQkFBTyxDQUFDLHlIQUEyQjtBQUN4RCxtQkFBbUIsbUJBQU8sQ0FBQyx3R0FBYztBQUN6QyxjQUFjLG1CQUFPLENBQUMseUdBQW1CO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyxnR0FBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxtR0FBZ0I7QUFDNUIsUUFBUSxzQ0FBc0MsRUFBRSxtQkFBTyxDQUFDLGlIQUF1Qjs7QUFFL0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04saUJBQWlCLEVBQUUsUUFBUSxPQUFPO0FBQ2xDLE1BQU07QUFDTjtBQUNBLGlCQUFpQixFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxPQUFPO0FBQzFDLE1BQU07QUFDTjtBQUNBLGlCQUFpQixFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRztBQUNoQyxRQUFRLEdBQUcsRUFBRSxHQUFHLE9BQU87QUFDdkIsTUFBTTtBQUNOO0FBQ0EsaUJBQWlCLEVBQUUsR0FBRyxFQUFFLEdBQUc7QUFDM0IsUUFBUSxHQUFHLEVBQUUsR0FBRyxPQUFPO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04saUJBQWlCLEVBQUUsTUFBTSxHQUFHLEdBQUcsT0FBTztBQUN0QyxNQUFNO0FBQ047QUFDQSxtQkFBbUIsRUFBRSxHQUFHLEVBQUUsSUFBSSxHQUFHLEdBQUcsRUFBRSxHQUFHLE9BQU87QUFDaEQsUUFBUTtBQUNSLG1CQUFtQixFQUFFLEdBQUcsRUFBRSxJQUFJLEdBQUcsR0FBRyxPQUFPO0FBQzNDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRztBQUNwQyxZQUFZLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxPQUFPO0FBQ2hDLFVBQVU7QUFDVixxQkFBcUIsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUc7QUFDcEMsWUFBWSxHQUFHLEVBQUUsR0FBRyxPQUFPO0FBQzNCO0FBQ0EsUUFBUTtBQUNSLG1CQUFtQixFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRztBQUNsQyxVQUFVLEdBQUcsT0FBTztBQUNwQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsRUFBRSxHQUFHLEVBQUUsR0FBRztBQUMvQixXQUFXLEVBQUUsR0FBRyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsT0FBTztBQUNwQyxVQUFVO0FBQ1YscUJBQXFCLEVBQUUsR0FBRyxFQUFFLEdBQUc7QUFDL0IsV0FBVyxFQUFFLEdBQUcsR0FBRyxFQUFFLEdBQUcsT0FBTztBQUMvQjtBQUNBLFFBQVE7QUFDUixtQkFBbUIsRUFBRSxHQUFHLEVBQUUsR0FBRztBQUM3QixVQUFVLEdBQUcsT0FBTztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBRSxHQUFHO0FBQ3ZDLE1BQU07QUFDTixpQkFBaUIsRUFBRSxNQUFNLElBQUksR0FBRyxPQUFPO0FBQ3ZDLE1BQU07QUFDTixpQkFBaUIsRUFBRSxHQUFHLEVBQUUsSUFBSTtBQUM1QixRQUFRLEdBQUcsRUFBRSxHQUFHLE9BQU87QUFDdkI7O0FBRUE7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGdCQUFnQixHQUFHLE1BQU0sa0JBQWtCO0FBQzNDLElBQUk7QUFDSixnQkFBZ0IsR0FBRyxHQUFHLEdBQUcsSUFBSSxrQkFBa0I7QUFDL0MsSUFBSTtBQUNKLGdCQUFnQixLQUFLO0FBQ3JCLElBQUk7QUFDSixnQkFBZ0IsS0FBSyxFQUFFLGtCQUFrQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGFBQWEsUUFBUTtBQUNyQixJQUFJO0FBQ0osYUFBYSxHQUFHLEdBQUcsUUFBUTtBQUMzQixJQUFJO0FBQ0osY0FBYyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJO0FBQ3BDLElBQUk7QUFDSixhQUFhLEdBQUcsR0FBRyxHQUFHLEdBQUcsUUFBUTtBQUNqQyxJQUFJO0FBQ0osY0FBYyxHQUFHO0FBQ2pCOztBQUVBLFlBQVksTUFBTSxFQUFFLEdBQUc7QUFDdkI7O0FBRUE7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvbm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL3JhbmdlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBTUEFDRV9DSEFSQUNURVJTID0gL1xccysvZ1xuXG4vLyBob2lzdGVkIGNsYXNzIGZvciBjeWNsaWMgZGVwZW5kZW5jeVxuY2xhc3MgUmFuZ2Uge1xuICBjb25zdHJ1Y3RvciAocmFuZ2UsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkge1xuICAgICAgaWYgKFxuICAgICAgICByYW5nZS5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlICYmXG4gICAgICAgIHJhbmdlLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gcmFuZ2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UucmF3LCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyYW5nZSBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICAgIC8vIGp1c3QgcHV0IGl0IGluIHRoZSBzZXQgYW5kIHJldHVyblxuICAgICAgdGhpcy5yYXcgPSByYW5nZS52YWx1ZVxuICAgICAgdGhpcy5zZXQgPSBbW3JhbmdlXV1cbiAgICAgIHRoaXMuZm9ybWF0dGVkID0gdW5kZWZpbmVkXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlXG4gICAgdGhpcy5pbmNsdWRlUHJlcmVsZWFzZSA9ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZVxuXG4gICAgLy8gRmlyc3QgcmVkdWNlIGFsbCB3aGl0ZXNwYWNlIGFzIG11Y2ggYXMgcG9zc2libGUgc28gd2UgZG8gbm90IGhhdmUgdG8gcmVseVxuICAgIC8vIG9uIHBvdGVudGlhbGx5IHNsb3cgcmVnZXhlcyBsaWtlIFxccyouIFRoaXMgaXMgdGhlbiBzdG9yZWQgYW5kIHVzZWQgZm9yXG4gICAgLy8gZnV0dXJlIGVycm9yIG1lc3NhZ2VzIGFzIHdlbGwuXG4gICAgdGhpcy5yYXcgPSByYW5nZS50cmltKCkucmVwbGFjZShTUEFDRV9DSEFSQUNURVJTLCAnICcpXG5cbiAgICAvLyBGaXJzdCwgc3BsaXQgb24gfHxcbiAgICB0aGlzLnNldCA9IHRoaXMucmF3XG4gICAgICAuc3BsaXQoJ3x8JylcbiAgICAgIC8vIG1hcCB0aGUgcmFuZ2UgdG8gYSAyZCBhcnJheSBvZiBjb21wYXJhdG9yc1xuICAgICAgLm1hcChyID0+IHRoaXMucGFyc2VSYW5nZShyLnRyaW0oKSkpXG4gICAgICAvLyB0aHJvdyBvdXQgYW55IGNvbXBhcmF0b3IgbGlzdHMgdGhhdCBhcmUgZW1wdHlcbiAgICAgIC8vIHRoaXMgZ2VuZXJhbGx5IG1lYW5zIHRoYXQgaXQgd2FzIG5vdCBhIHZhbGlkIHJhbmdlLCB3aGljaCBpcyBhbGxvd2VkXG4gICAgICAvLyBpbiBsb29zZSBtb2RlLCBidXQgd2lsbCBzdGlsbCB0aHJvdyBpZiB0aGUgV0hPTEUgcmFuZ2UgaXMgaW52YWxpZC5cbiAgICAgIC5maWx0ZXIoYyA9PiBjLmxlbmd0aClcblxuICAgIGlmICghdGhpcy5zZXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFNlbVZlciBSYW5nZTogJHt0aGlzLnJhd31gKVxuICAgIH1cblxuICAgIC8vIGlmIHdlIGhhdmUgYW55IHRoYXQgYXJlIG5vdCB0aGUgbnVsbCBzZXQsIHRocm93IG91dCBudWxsIHNldHMuXG4gICAgaWYgKHRoaXMuc2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIGtlZXAgdGhlIGZpcnN0IG9uZSwgaW4gY2FzZSB0aGV5J3JlIGFsbCBudWxsIHNldHNcbiAgICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5zZXRbMF1cbiAgICAgIHRoaXMuc2V0ID0gdGhpcy5zZXQuZmlsdGVyKGMgPT4gIWlzTnVsbFNldChjWzBdKSlcbiAgICAgIGlmICh0aGlzLnNldC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5zZXQgPSBbZmlyc3RdXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhbnkgdGhhdCBhcmUgKiwgdGhlbiB0aGUgcmFuZ2UgaXMganVzdCAqXG4gICAgICAgIGZvciAoY29uc3QgYyBvZiB0aGlzLnNldCkge1xuICAgICAgICAgIGlmIChjLmxlbmd0aCA9PT0gMSAmJiBpc0FueShjWzBdKSkge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSBbY11cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5mb3JtYXR0ZWQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIGdldCByYW5nZSAoKSB7XG4gICAgaWYgKHRoaXMuZm9ybWF0dGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZm9ybWF0dGVkID0gJydcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgdGhpcy5mb3JtYXR0ZWQgKz0gJ3x8J1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXBzID0gdGhpcy5zZXRbaV1cbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBjb21wcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgIGlmIChrID4gMCkge1xuICAgICAgICAgICAgdGhpcy5mb3JtYXR0ZWQgKz0gJyAnXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZm9ybWF0dGVkICs9IGNvbXBzW2tdLnRvU3RyaW5nKCkudHJpbSgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVkXG4gIH1cblxuICBmb3JtYXQgKCkge1xuICAgIHJldHVybiB0aGlzLnJhbmdlXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFuZ2VcbiAgfVxuXG4gIHBhcnNlUmFuZ2UgKHJhbmdlKSB7XG4gICAgLy8gbWVtb2l6ZSByYW5nZSBwYXJzaW5nIGZvciBwZXJmb3JtYW5jZS5cbiAgICAvLyB0aGlzIGlzIGEgdmVyeSBob3QgcGF0aCwgYW5kIGZ1bGx5IGRldGVybWluaXN0aWMuXG4gICAgY29uc3QgbWVtb09wdHMgPVxuICAgICAgKHRoaXMub3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJiBGTEFHX0lOQ0xVREVfUFJFUkVMRUFTRSkgfFxuICAgICAgKHRoaXMub3B0aW9ucy5sb29zZSAmJiBGTEFHX0xPT1NFKVxuICAgIGNvbnN0IG1lbW9LZXkgPSBtZW1vT3B0cyArICc6JyArIHJhbmdlXG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KG1lbW9LZXkpXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZFxuICAgIH1cblxuICAgIGNvbnN0IGxvb3NlID0gdGhpcy5vcHRpb25zLmxvb3NlXG4gICAgLy8gYDEuMi4zIC0gMS4yLjRgID0+IGA+PTEuMi4zIDw9MS4yLjRgXG4gICAgY29uc3QgaHIgPSBsb29zZSA/IHJlW3QuSFlQSEVOUkFOR0VMT09TRV0gOiByZVt0LkhZUEhFTlJBTkdFXVxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShociwgaHlwaGVuUmVwbGFjZSh0aGlzLm9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpKVxuICAgIGRlYnVnKCdoeXBoZW4gcmVwbGFjZScsIHJhbmdlKVxuXG4gICAgLy8gYD4gMS4yLjMgPCAxLjIuNWAgPT4gYD4xLjIuMyA8MS4yLjVgXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuQ09NUEFSQVRPUlRSSU1dLCBjb21wYXJhdG9yVHJpbVJlcGxhY2UpXG4gICAgZGVidWcoJ2NvbXBhcmF0b3IgdHJpbScsIHJhbmdlKVxuXG4gICAgLy8gYH4gMS4yLjNgID0+IGB+MS4yLjNgXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuVElMREVUUklNXSwgdGlsZGVUcmltUmVwbGFjZSlcbiAgICBkZWJ1ZygndGlsZGUgdHJpbScsIHJhbmdlKVxuXG4gICAgLy8gYF4gMS4yLjNgID0+IGBeMS4yLjNgXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuQ0FSRVRUUklNXSwgY2FyZXRUcmltUmVwbGFjZSlcbiAgICBkZWJ1ZygnY2FyZXQgdHJpbScsIHJhbmdlKVxuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIHJhbmdlIGlzIGNvbXBsZXRlbHkgdHJpbW1lZCBhbmRcbiAgICAvLyByZWFkeSB0byBiZSBzcGxpdCBpbnRvIGNvbXBhcmF0b3JzLlxuXG4gICAgbGV0IHJhbmdlTGlzdCA9IHJhbmdlXG4gICAgICAuc3BsaXQoJyAnKVxuICAgICAgLm1hcChjb21wID0+IHBhcnNlQ29tcGFyYXRvcihjb21wLCB0aGlzLm9wdGlvbnMpKVxuICAgICAgLmpvaW4oJyAnKVxuICAgICAgLnNwbGl0KC9cXHMrLylcbiAgICAgIC8vID49MC4wLjAgaXMgZXF1aXZhbGVudCB0byAqXG4gICAgICAubWFwKGNvbXAgPT4gcmVwbGFjZUdURTAoY29tcCwgdGhpcy5vcHRpb25zKSlcblxuICAgIGlmIChsb29zZSkge1xuICAgICAgLy8gaW4gbG9vc2UgbW9kZSwgdGhyb3cgb3V0IGFueSB0aGF0IGFyZSBub3QgdmFsaWQgY29tcGFyYXRvcnNcbiAgICAgIHJhbmdlTGlzdCA9IHJhbmdlTGlzdC5maWx0ZXIoY29tcCA9PiB7XG4gICAgICAgIGRlYnVnKCdsb29zZSBpbnZhbGlkIGZpbHRlcicsIGNvbXAsIHRoaXMub3B0aW9ucylcbiAgICAgICAgcmV0dXJuICEhY29tcC5tYXRjaChyZVt0LkNPTVBBUkFUT1JMT09TRV0pXG4gICAgICB9KVxuICAgIH1cbiAgICBkZWJ1ZygncmFuZ2UgbGlzdCcsIHJhbmdlTGlzdClcblxuICAgIC8vIGlmIGFueSBjb21wYXJhdG9ycyBhcmUgdGhlIG51bGwgc2V0LCB0aGVuIHJlcGxhY2Ugd2l0aCBKVVNUIG51bGwgc2V0XG4gICAgLy8gaWYgbW9yZSB0aGFuIG9uZSBjb21wYXJhdG9yLCByZW1vdmUgYW55ICogY29tcGFyYXRvcnNcbiAgICAvLyBhbHNvLCBkb24ndCBpbmNsdWRlIHRoZSBzYW1lIGNvbXBhcmF0b3IgbW9yZSB0aGFuIG9uY2VcbiAgICBjb25zdCByYW5nZU1hcCA9IG5ldyBNYXAoKVxuICAgIGNvbnN0IGNvbXBhcmF0b3JzID0gcmFuZ2VMaXN0Lm1hcChjb21wID0+IG5ldyBDb21wYXJhdG9yKGNvbXAsIHRoaXMub3B0aW9ucykpXG4gICAgZm9yIChjb25zdCBjb21wIG9mIGNvbXBhcmF0b3JzKSB7XG4gICAgICBpZiAoaXNOdWxsU2V0KGNvbXApKSB7XG4gICAgICAgIHJldHVybiBbY29tcF1cbiAgICAgIH1cbiAgICAgIHJhbmdlTWFwLnNldChjb21wLnZhbHVlLCBjb21wKVxuICAgIH1cbiAgICBpZiAocmFuZ2VNYXAuc2l6ZSA+IDEgJiYgcmFuZ2VNYXAuaGFzKCcnKSkge1xuICAgICAgcmFuZ2VNYXAuZGVsZXRlKCcnKVxuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IFsuLi5yYW5nZU1hcC52YWx1ZXMoKV1cbiAgICBjYWNoZS5zZXQobWVtb0tleSwgcmVzdWx0KVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGludGVyc2VjdHMgKHJhbmdlLCBvcHRpb25zKSB7XG4gICAgaWYgKCEocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgUmFuZ2UgaXMgcmVxdWlyZWQnKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNldC5zb21lKCh0aGlzQ29tcGFyYXRvcnMpID0+IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGlzU2F0aXNmaWFibGUodGhpc0NvbXBhcmF0b3JzLCBvcHRpb25zKSAmJlxuICAgICAgICByYW5nZS5zZXQuc29tZSgocmFuZ2VDb21wYXJhdG9ycykgPT4ge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpc1NhdGlzZmlhYmxlKHJhbmdlQ29tcGFyYXRvcnMsIG9wdGlvbnMpICYmXG4gICAgICAgICAgICB0aGlzQ29tcGFyYXRvcnMuZXZlcnkoKHRoaXNDb21wYXJhdG9yKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiByYW5nZUNvbXBhcmF0b3JzLmV2ZXJ5KChyYW5nZUNvbXBhcmF0b3IpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc0NvbXBhcmF0b3IuaW50ZXJzZWN0cyhyYW5nZUNvbXBhcmF0b3IsIG9wdGlvbnMpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9KVxuICB9XG5cbiAgLy8gaWYgQU5ZIG9mIHRoZSBzZXRzIG1hdGNoIEFMTCBvZiBpdHMgY29tcGFyYXRvcnMsIHRoZW4gcGFzc1xuICB0ZXN0ICh2ZXJzaW9uKSB7XG4gICAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGVzdFNldCh0aGlzLnNldFtpXSwgdmVyc2lvbiwgdGhpcy5vcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmdlXG5cbmNvbnN0IExSVSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2xydWNhY2hlJylcbmNvbnN0IGNhY2hlID0gbmV3IExSVSgpXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4vY29tcGFyYXRvcicpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2RlYnVnJylcbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4vc2VtdmVyJylcbmNvbnN0IHtcbiAgc2FmZVJlOiByZSxcbiAgdCxcbiAgY29tcGFyYXRvclRyaW1SZXBsYWNlLFxuICB0aWxkZVRyaW1SZXBsYWNlLFxuICBjYXJldFRyaW1SZXBsYWNlLFxufSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcbmNvbnN0IHsgRkxBR19JTkNMVURFX1BSRVJFTEVBU0UsIEZMQUdfTE9PU0UgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2NvbnN0YW50cycpXG5cbmNvbnN0IGlzTnVsbFNldCA9IGMgPT4gYy52YWx1ZSA9PT0gJzwwLjAuMC0wJ1xuY29uc3QgaXNBbnkgPSBjID0+IGMudmFsdWUgPT09ICcnXG5cbi8vIHRha2UgYSBzZXQgb2YgY29tcGFyYXRvcnMgYW5kIGRldGVybWluZSB3aGV0aGVyIHRoZXJlXG4vLyBleGlzdHMgYSB2ZXJzaW9uIHdoaWNoIGNhbiBzYXRpc2Z5IGl0XG5jb25zdCBpc1NhdGlzZmlhYmxlID0gKGNvbXBhcmF0b3JzLCBvcHRpb25zKSA9PiB7XG4gIGxldCByZXN1bHQgPSB0cnVlXG4gIGNvbnN0IHJlbWFpbmluZ0NvbXBhcmF0b3JzID0gY29tcGFyYXRvcnMuc2xpY2UoKVxuICBsZXQgdGVzdENvbXBhcmF0b3IgPSByZW1haW5pbmdDb21wYXJhdG9ycy5wb3AoKVxuXG4gIHdoaWxlIChyZXN1bHQgJiYgcmVtYWluaW5nQ29tcGFyYXRvcnMubGVuZ3RoKSB7XG4gICAgcmVzdWx0ID0gcmVtYWluaW5nQ29tcGFyYXRvcnMuZXZlcnkoKG90aGVyQ29tcGFyYXRvcikgPT4ge1xuICAgICAgcmV0dXJuIHRlc3RDb21wYXJhdG9yLmludGVyc2VjdHMob3RoZXJDb21wYXJhdG9yLCBvcHRpb25zKVxuICAgIH0pXG5cbiAgICB0ZXN0Q29tcGFyYXRvciA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLnBvcCgpXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8vIGNvbXByaXNlZCBvZiB4cmFuZ2VzLCB0aWxkZXMsIHN0YXJzLCBhbmQgZ3RsdCdzIGF0IHRoaXMgcG9pbnQuXG4vLyBhbHJlYWR5IHJlcGxhY2VkIHRoZSBoeXBoZW4gcmFuZ2VzXG4vLyB0dXJuIGludG8gYSBzZXQgb2YgSlVTVCBjb21wYXJhdG9ycy5cbmNvbnN0IHBhcnNlQ29tcGFyYXRvciA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGNvbXAgPSBjb21wLnJlcGxhY2UocmVbdC5CVUlMRF0sICcnKVxuICBkZWJ1ZygnY29tcCcsIGNvbXAsIG9wdGlvbnMpXG4gIGNvbXAgPSByZXBsYWNlQ2FyZXRzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCdjYXJldCcsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlVGlsZGVzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCd0aWxkZXMnLCBjb21wKVxuICBjb21wID0gcmVwbGFjZVhSYW5nZXMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3hyYW5nZScsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlU3RhcnMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3N0YXJzJywgY29tcClcbiAgcmV0dXJuIGNvbXBcbn1cblxuY29uc3QgaXNYID0gaWQgPT4gIWlkIHx8IGlkLnRvTG93ZXJDYXNlKCkgPT09ICd4JyB8fCBpZCA9PT0gJyonXG5cbi8vIH4sIH4+IC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gfjIsIH4yLngsIH4yLngueCwgfj4yLCB+PjIueCB+PjIueC54IC0tPiA+PTIuMC4wIDwzLjAuMC0wXG4vLyB+Mi4wLCB+Mi4wLngsIH4+Mi4wLCB+PjIuMC54IC0tPiA+PTIuMC4wIDwyLjEuMC0wXG4vLyB+MS4yLCB+MS4yLngsIH4+MS4yLCB+PjEuMi54IC0tPiA+PTEuMi4wIDwxLjMuMC0wXG4vLyB+MS4yLjMsIH4+MS4yLjMgLS0+ID49MS4yLjMgPDEuMy4wLTBcbi8vIH4xLjIuMCwgfj4xLjIuMCAtLT4gPj0xLjIuMCA8MS4zLjAtMFxuLy8gfjAuMC4xIC0tPiA+PTAuMC4xIDwwLjEuMC0wXG5jb25zdCByZXBsYWNlVGlsZGVzID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgcmV0dXJuIGNvbXBcbiAgICAudHJpbSgpXG4gICAgLnNwbGl0KC9cXHMrLylcbiAgICAubWFwKChjKSA9PiByZXBsYWNlVGlsZGUoYywgb3B0aW9ucykpXG4gICAgLmpvaW4oJyAnKVxufVxuXG5jb25zdCByZXBsYWNlVGlsZGUgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCByID0gb3B0aW9ucy5sb29zZSA/IHJlW3QuVElMREVMT09TRV0gOiByZVt0LlRJTERFXVxuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIChfLCBNLCBtLCBwLCBwcikgPT4ge1xuICAgIGRlYnVnKCd0aWxkZScsIGNvbXAsIF8sIE0sIG0sIHAsIHByKVxuICAgIGxldCByZXRcblxuICAgIGlmIChpc1goTSkpIHtcbiAgICAgIHJldCA9ICcnXG4gICAgfSBlbHNlIGlmIChpc1gobSkpIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uMC4wIDwkeytNICsgMX0uMC4wLTBgXG4gICAgfSBlbHNlIGlmIChpc1gocCkpIHtcbiAgICAgIC8vIH4xLjIgPT0gPj0xLjIuMCA8MS4zLjAtMFxuICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAgPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9IGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZVRpbGRlIHByJywgcHIpXG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICB9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIH4xLjIuMyA9PSA+PTEuMi4zIDwxLjMuMC0wXG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwXG4gICAgICB9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgfVxuXG4gICAgZGVidWcoJ3RpbGRlIHJldHVybicsIHJldClcbiAgICByZXR1cm4gcmV0XG4gIH0pXG59XG5cbi8vIF4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpXG4vLyBeMiwgXjIueCwgXjIueC54IC0tPiA+PTIuMC4wIDwzLjAuMC0wXG4vLyBeMi4wLCBeMi4wLnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbi8vIF4xLjIsIF4xLjIueCAtLT4gPj0xLjIuMCA8Mi4wLjAtMFxuLy8gXjEuMi4zIC0tPiA+PTEuMi4zIDwyLjAuMC0wXG4vLyBeMS4yLjAgLS0+ID49MS4yLjAgPDIuMC4wLTBcbi8vIF4wLjAuMSAtLT4gPj0wLjAuMSA8MC4wLjItMFxuLy8gXjAuMS4wIC0tPiA+PTAuMS4wIDwwLjIuMC0wXG5jb25zdCByZXBsYWNlQ2FyZXRzID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgcmV0dXJuIGNvbXBcbiAgICAudHJpbSgpXG4gICAgLnNwbGl0KC9cXHMrLylcbiAgICAubWFwKChjKSA9PiByZXBsYWNlQ2FyZXQoYywgb3B0aW9ucykpXG4gICAgLmpvaW4oJyAnKVxufVxuXG5jb25zdCByZXBsYWNlQ2FyZXQgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygnY2FyZXQnLCBjb21wLCBvcHRpb25zKVxuICBjb25zdCByID0gb3B0aW9ucy5sb29zZSA/IHJlW3QuQ0FSRVRMT09TRV0gOiByZVt0LkNBUkVUXVxuICBjb25zdCB6ID0gb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/ICctMCcgOiAnJ1xuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIChfLCBNLCBtLCBwLCBwcikgPT4ge1xuICAgIGRlYnVnKCdjYXJldCcsIGNvbXAsIF8sIE0sIG0sIHAsIHByKVxuICAgIGxldCByZXRcblxuICAgIGlmIChpc1goTSkpIHtcbiAgICAgIHJldCA9ICcnXG4gICAgfSBlbHNlIGlmIChpc1gobSkpIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uMC4wJHt6fSA8JHsrTSArIDF9LjAuMC0wYFxuICAgIH0gZWxzZSBpZiAoaXNYKHApKSB7XG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4wJHt6fSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAke3p9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcikge1xuICAgICAgZGVidWcoJ3JlcGxhY2VDYXJldCBwcicsIHByKVxuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICBpZiAobSA9PT0gJzAnKSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cH0tJHtwclxuICAgICAgICAgIH0gPCR7TX0uJHttfS4keytwICsgMX0tMGBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICAgICAgfSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICAgIH0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ25vIHByJylcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgaWYgKG0gPT09ICcwJykge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgICAgICB9JHt6fSA8JHtNfS4ke219LiR7K3AgKyAxfS0wYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgICAgICB9JHt6fSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwXG4gICAgICAgIH0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWJ1ZygnY2FyZXQgcmV0dXJuJywgcmV0KVxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuY29uc3QgcmVwbGFjZVhSYW5nZXMgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygncmVwbGFjZVhSYW5nZXMnLCBjb21wLCBvcHRpb25zKVxuICByZXR1cm4gY29tcFxuICAgIC5zcGxpdCgvXFxzKy8pXG4gICAgLm1hcCgoYykgPT4gcmVwbGFjZVhSYW5nZShjLCBvcHRpb25zKSlcbiAgICAuam9pbignICcpXG59XG5cbmNvbnN0IHJlcGxhY2VYUmFuZ2UgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBjb21wID0gY29tcC50cmltKClcbiAgY29uc3QgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LlhSQU5HRUxPT1NFXSA6IHJlW3QuWFJBTkdFXVxuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIChyZXQsIGd0bHQsIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ3hSYW5nZScsIGNvbXAsIHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpXG4gICAgY29uc3QgeE0gPSBpc1goTSlcbiAgICBjb25zdCB4bSA9IHhNIHx8IGlzWChtKVxuICAgIGNvbnN0IHhwID0geG0gfHwgaXNYKHApXG4gICAgY29uc3QgYW55WCA9IHhwXG5cbiAgICBpZiAoZ3RsdCA9PT0gJz0nICYmIGFueVgpIHtcbiAgICAgIGd0bHQgPSAnJ1xuICAgIH1cblxuICAgIC8vIGlmIHdlJ3JlIGluY2x1ZGluZyBwcmVyZWxlYXNlcyBpbiB0aGUgbWF0Y2gsIHRoZW4gd2UgbmVlZFxuICAgIC8vIHRvIGZpeCB0aGlzIHRvIC0wLCB0aGUgbG93ZXN0IHBvc3NpYmxlIHByZXJlbGVhc2UgdmFsdWVcbiAgICBwciA9IG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyAnLTAnIDogJydcblxuICAgIGlmICh4TSkge1xuICAgICAgaWYgKGd0bHQgPT09ICc+JyB8fCBndGx0ID09PSAnPCcpIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBhbGxvd2VkXG4gICAgICAgIHJldCA9ICc8MC4wLjAtMCdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdGhpbmcgaXMgZm9yYmlkZGVuXG4gICAgICAgIHJldCA9ICcqJ1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ3RsdCAmJiBhbnlYKSB7XG4gICAgICAvLyB3ZSBrbm93IHBhdGNoIGlzIGFuIHgsIGJlY2F1c2Ugd2UgaGF2ZSBhbnkgeCBhdCBhbGwuXG4gICAgICAvLyByZXBsYWNlIFggd2l0aCAwXG4gICAgICBpZiAoeG0pIHtcbiAgICAgICAgbSA9IDBcbiAgICAgIH1cbiAgICAgIHAgPSAwXG5cbiAgICAgIGlmIChndGx0ID09PSAnPicpIHtcbiAgICAgICAgLy8gPjEgPT4gPj0yLjAuMFxuICAgICAgICAvLyA+MS4yID0+ID49MS4zLjBcbiAgICAgICAgZ3RsdCA9ICc+PSdcbiAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgTSA9ICtNICsgMVxuICAgICAgICAgIG0gPSAwXG4gICAgICAgICAgcCA9IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtID0gK20gKyAxXG4gICAgICAgICAgcCA9IDBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChndGx0ID09PSAnPD0nKSB7XG4gICAgICAgIC8vIDw9MC43LnggaXMgYWN0dWFsbHkgPDAuOC4wLCBzaW5jZSBhbnkgMC43Lnggc2hvdWxkXG4gICAgICAgIC8vIHBhc3MuICBTaW1pbGFybHksIDw9Ny54IGlzIGFjdHVhbGx5IDw4LjAuMCwgZXRjLlxuICAgICAgICBndGx0ID0gJzwnXG4gICAgICAgIGlmICh4bSkge1xuICAgICAgICAgIE0gPSArTSArIDFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtID0gK20gKyAxXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGd0bHQgPT09ICc8Jykge1xuICAgICAgICBwciA9ICctMCdcbiAgICAgIH1cblxuICAgICAgcmV0ID0gYCR7Z3RsdCArIE19LiR7bX0uJHtwfSR7cHJ9YFxuICAgIH0gZWxzZSBpZiAoeG0pIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uMC4wJHtwcn0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICB9IGVsc2UgaWYgKHhwKSB7XG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7cHJcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9XG5cbiAgICBkZWJ1ZygneFJhbmdlIHJldHVybicsIHJldClcblxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuLy8gQmVjYXVzZSAqIGlzIEFORC1lZCB3aXRoIGV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgY29tcGFyYXRvcixcbi8vIGFuZCAnJyBtZWFucyBcImFueSB2ZXJzaW9uXCIsIGp1c3QgcmVtb3ZlIHRoZSAqcyBlbnRpcmVseS5cbmNvbnN0IHJlcGxhY2VTdGFycyA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdyZXBsYWNlU3RhcnMnLCBjb21wLCBvcHRpb25zKVxuICAvLyBMb29zZW5lc3MgaXMgaWdub3JlZCBoZXJlLiAgc3RhciBpcyBhbHdheXMgYXMgbG9vc2UgYXMgaXQgZ2V0cyFcbiAgcmV0dXJuIGNvbXBcbiAgICAudHJpbSgpXG4gICAgLnJlcGxhY2UocmVbdC5TVEFSXSwgJycpXG59XG5cbmNvbnN0IHJlcGxhY2VHVEUwID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ3JlcGxhY2VHVEUwJywgY29tcCwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXBcbiAgICAudHJpbSgpXG4gICAgLnJlcGxhY2UocmVbb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/IHQuR1RFMFBSRSA6IHQuR1RFMF0sICcnKVxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHBhc3NlZCB0byBzdHJpbmcucmVwbGFjZShyZVt0LkhZUEhFTlJBTkdFXSlcbi8vIE0sIG0sIHBhdGNoLCBwcmVyZWxlYXNlLCBidWlsZFxuLy8gMS4yIC0gMy40LjUgPT4gPj0xLjIuMCA8PTMuNC41XG4vLyAxLjIuMyAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMC0wIEFueSAzLjQueCB3aWxsIGRvXG4vLyAxLjIgLSAzLjQgPT4gPj0xLjIuMCA8My41LjAtMFxuLy8gVE9ETyBidWlsZD9cbmNvbnN0IGh5cGhlblJlcGxhY2UgPSBpbmNQciA9PiAoJDAsXG4gIGZyb20sIGZNLCBmbSwgZnAsIGZwciwgZmIsXG4gIHRvLCB0TSwgdG0sIHRwLCB0cHIpID0+IHtcbiAgaWYgKGlzWChmTSkpIHtcbiAgICBmcm9tID0gJydcbiAgfSBlbHNlIGlmIChpc1goZm0pKSB7XG4gICAgZnJvbSA9IGA+PSR7Zk19LjAuMCR7aW5jUHIgPyAnLTAnIDogJyd9YFxuICB9IGVsc2UgaWYgKGlzWChmcCkpIHtcbiAgICBmcm9tID0gYD49JHtmTX0uJHtmbX0uMCR7aW5jUHIgPyAnLTAnIDogJyd9YFxuICB9IGVsc2UgaWYgKGZwcikge1xuICAgIGZyb20gPSBgPj0ke2Zyb219YFxuICB9IGVsc2Uge1xuICAgIGZyb20gPSBgPj0ke2Zyb219JHtpbmNQciA/ICctMCcgOiAnJ31gXG4gIH1cblxuICBpZiAoaXNYKHRNKSkge1xuICAgIHRvID0gJydcbiAgfSBlbHNlIGlmIChpc1godG0pKSB7XG4gICAgdG8gPSBgPCR7K3RNICsgMX0uMC4wLTBgXG4gIH0gZWxzZSBpZiAoaXNYKHRwKSkge1xuICAgIHRvID0gYDwke3RNfS4keyt0bSArIDF9LjAtMGBcbiAgfSBlbHNlIGlmICh0cHIpIHtcbiAgICB0byA9IGA8PSR7dE19LiR7dG19LiR7dHB9LSR7dHByfWBcbiAgfSBlbHNlIGlmIChpbmNQcikge1xuICAgIHRvID0gYDwke3RNfS4ke3RtfS4keyt0cCArIDF9LTBgXG4gIH0gZWxzZSB7XG4gICAgdG8gPSBgPD0ke3RvfWBcbiAgfVxuXG4gIHJldHVybiBgJHtmcm9tfSAke3RvfWAudHJpbSgpXG59XG5cbmNvbnN0IHRlc3RTZXQgPSAoc2V0LCB2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFzZXRbaV0udGVzdCh2ZXJzaW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgaWYgKHZlcnNpb24ucHJlcmVsZWFzZS5sZW5ndGggJiYgIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAvLyBGaW5kIHRoZSBzZXQgb2YgdmVyc2lvbnMgdGhhdCBhcmUgYWxsb3dlZCB0byBoYXZlIHByZXJlbGVhc2VzXG4gICAgLy8gRm9yIGV4YW1wbGUsIF4xLjIuMy1wci4xIGRlc3VnYXJzIHRvID49MS4yLjMtcHIuMSA8Mi4wLjBcbiAgICAvLyBUaGF0IHNob3VsZCBhbGxvdyBgMS4yLjMtcHIuMmAgdG8gcGFzcy5cbiAgICAvLyBIb3dldmVyLCBgMS4yLjQtYWxwaGEubm90cmVhZHlgIHNob3VsZCBOT1QgYmUgYWxsb3dlZCxcbiAgICAvLyBldmVuIHRob3VnaCBpdCdzIHdpdGhpbiB0aGUgcmFuZ2Ugc2V0IGJ5IHRoZSBjb21wYXJhdG9ycy5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgICAgZGVidWcoc2V0W2ldLnNlbXZlcilcbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyID09PSBDb21wYXJhdG9yLkFOWSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAoc2V0W2ldLnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgYWxsb3dlZCA9IHNldFtpXS5zZW12ZXJcbiAgICAgICAgaWYgKGFsbG93ZWQubWFqb3IgPT09IHZlcnNpb24ubWFqb3IgJiZcbiAgICAgICAgICAgIGFsbG93ZWQubWlub3IgPT09IHZlcnNpb24ubWlub3IgJiZcbiAgICAgICAgICAgIGFsbG93ZWQucGF0Y2ggPT09IHZlcnNpb24ucGF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmVyc2lvbiBoYXMgYSAtcHJlLCBidXQgaXQncyBub3Qgb25lIG9mIHRoZSBvbmVzIHdlIGxpa2UuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/range.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/semver.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/classes/semver.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst debug = __webpack_require__(/*! ../internal/debug */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/debug.js\")\nconst { MAX_LENGTH, MAX_SAFE_INTEGER } = __webpack_require__(/*! ../internal/constants */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/constants.js\")\nconst { safeRe: re, t } = __webpack_require__(/*! ../internal/re */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/re.js\")\n\nconst parseOptions = __webpack_require__(/*! ../internal/parse-options */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/parse-options.js\")\nconst { compareIdentifiers } = __webpack_require__(/*! ../internal/identifiers */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/identifiers.js\")\nclass SemVer {\n  constructor (version, options) {\n    options = parseOptions(options)\n\n    if (version instanceof SemVer) {\n      if (version.loose === !!options.loose &&\n        version.includePrerelease === !!options.includePrerelease) {\n        return version\n      } else {\n        version = version.version\n      }\n    } else if (typeof version !== 'string') {\n      throw new TypeError(`Invalid version. Must be a string. Got type \"${typeof version}\".`)\n    }\n\n    if (version.length > MAX_LENGTH) {\n      throw new TypeError(\n        `version is longer than ${MAX_LENGTH} characters`\n      )\n    }\n\n    debug('SemVer', version, options)\n    this.options = options\n    this.loose = !!options.loose\n    // this isn't actually relevant for versions, but keep it so that we\n    // don't run into trouble passing this.options around.\n    this.includePrerelease = !!options.includePrerelease\n\n    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])\n\n    if (!m) {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    this.raw = version\n\n    // these are actually numbers\n    this.major = +m[1]\n    this.minor = +m[2]\n    this.patch = +m[3]\n\n    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n      throw new TypeError('Invalid major version')\n    }\n\n    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n      throw new TypeError('Invalid minor version')\n    }\n\n    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n      throw new TypeError('Invalid patch version')\n    }\n\n    // numberify any prerelease numeric ids\n    if (!m[4]) {\n      this.prerelease = []\n    } else {\n      this.prerelease = m[4].split('.').map((id) => {\n        if (/^[0-9]+$/.test(id)) {\n          const num = +id\n          if (num >= 0 && num < MAX_SAFE_INTEGER) {\n            return num\n          }\n        }\n        return id\n      })\n    }\n\n    this.build = m[5] ? m[5].split('.') : []\n    this.format()\n  }\n\n  format () {\n    this.version = `${this.major}.${this.minor}.${this.patch}`\n    if (this.prerelease.length) {\n      this.version += `-${this.prerelease.join('.')}`\n    }\n    return this.version\n  }\n\n  toString () {\n    return this.version\n  }\n\n  compare (other) {\n    debug('SemVer.compare', this.version, this.options, other)\n    if (!(other instanceof SemVer)) {\n      if (typeof other === 'string' && other === this.version) {\n        return 0\n      }\n      other = new SemVer(other, this.options)\n    }\n\n    if (other.version === this.version) {\n      return 0\n    }\n\n    return this.compareMain(other) || this.comparePre(other)\n  }\n\n  compareMain (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    if (this.major < other.major) {\n      return -1\n    }\n    if (this.major > other.major) {\n      return 1\n    }\n    if (this.minor < other.minor) {\n      return -1\n    }\n    if (this.minor > other.minor) {\n      return 1\n    }\n    if (this.patch < other.patch) {\n      return -1\n    }\n    if (this.patch > other.patch) {\n      return 1\n    }\n    return 0\n  }\n\n  comparePre (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    // NOT having a prerelease is > having one\n    if (this.prerelease.length && !other.prerelease.length) {\n      return -1\n    } else if (!this.prerelease.length && other.prerelease.length) {\n      return 1\n    } else if (!this.prerelease.length && !other.prerelease.length) {\n      return 0\n    }\n\n    let i = 0\n    do {\n      const a = this.prerelease[i]\n      const b = other.prerelease[i]\n      debug('prerelease compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  compareBuild (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    let i = 0\n    do {\n      const a = this.build[i]\n      const b = other.build[i]\n      debug('build compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  // preminor will bump the version up to the next minor release, and immediately\n  // down to pre-release. premajor and prepatch work the same way.\n  inc (release, identifier, identifierBase) {\n    if (release.startsWith('pre')) {\n      if (!identifier && identifierBase === false) {\n        throw new Error('invalid increment argument: identifier is empty')\n      }\n      // Avoid an invalid semver results\n      if (identifier) {\n        const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE])\n        if (!match || match[1] !== identifier) {\n          throw new Error(`invalid identifier: ${identifier}`)\n        }\n      }\n    }\n\n    switch (release) {\n      case 'premajor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor = 0\n        this.major++\n        this.inc('pre', identifier, identifierBase)\n        break\n      case 'preminor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor++\n        this.inc('pre', identifier, identifierBase)\n        break\n      case 'prepatch':\n        // If this is already a prerelease, it will bump to the next version\n        // drop any prereleases that might already exist, since they are not\n        // relevant at this point.\n        this.prerelease.length = 0\n        this.inc('patch', identifier, identifierBase)\n        this.inc('pre', identifier, identifierBase)\n        break\n      // If the input is a non-prerelease version, this acts the same as\n      // prepatch.\n      case 'prerelease':\n        if (this.prerelease.length === 0) {\n          this.inc('patch', identifier, identifierBase)\n        }\n        this.inc('pre', identifier, identifierBase)\n        break\n      case 'release':\n        if (this.prerelease.length === 0) {\n          throw new Error(`version ${this.raw} is not a prerelease`)\n        }\n        this.prerelease.length = 0\n        break\n\n      case 'major':\n        // If this is a pre-major version, bump up to the same major version.\n        // Otherwise increment major.\n        // 1.0.0-5 bumps to 1.0.0\n        // 1.1.0 bumps to 2.0.0\n        if (\n          this.minor !== 0 ||\n          this.patch !== 0 ||\n          this.prerelease.length === 0\n        ) {\n          this.major++\n        }\n        this.minor = 0\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'minor':\n        // If this is a pre-minor version, bump up to the same minor version.\n        // Otherwise increment minor.\n        // 1.2.0-5 bumps to 1.2.0\n        // 1.2.1 bumps to 1.3.0\n        if (this.patch !== 0 || this.prerelease.length === 0) {\n          this.minor++\n        }\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'patch':\n        // If this is not a pre-release version, it will increment the patch.\n        // If it is a pre-release it will bump up to the same patch version.\n        // 1.2.0-5 patches to 1.2.0\n        // 1.2.0 patches to 1.2.1\n        if (this.prerelease.length === 0) {\n          this.patch++\n        }\n        this.prerelease = []\n        break\n      // This probably shouldn't be used publicly.\n      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.\n      case 'pre': {\n        const base = Number(identifierBase) ? 1 : 0\n\n        if (this.prerelease.length === 0) {\n          this.prerelease = [base]\n        } else {\n          let i = this.prerelease.length\n          while (--i >= 0) {\n            if (typeof this.prerelease[i] === 'number') {\n              this.prerelease[i]++\n              i = -2\n            }\n          }\n          if (i === -1) {\n            // didn't increment anything\n            if (identifier === this.prerelease.join('.') && identifierBase === false) {\n              throw new Error('invalid increment argument: identifier already exists')\n            }\n            this.prerelease.push(base)\n          }\n        }\n        if (identifier) {\n          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n          let prerelease = [identifier, base]\n          if (identifierBase === false) {\n            prerelease = [identifier]\n          }\n          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {\n            if (isNaN(this.prerelease[1])) {\n              this.prerelease = prerelease\n            }\n          } else {\n            this.prerelease = prerelease\n          }\n        }\n        break\n      }\n      default:\n        throw new Error(`invalid increment argument: ${release}`)\n    }\n    this.raw = this.format()\n    if (this.build.length) {\n      this.raw += `+${this.build.join('.')}`\n    }\n    return this\n  }\n}\n\nmodule.exports = SemVer\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvc2VtdmVyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGNBQWMsbUJBQU8sQ0FBQyx5R0FBbUI7QUFDekMsUUFBUSwrQkFBK0IsRUFBRSxtQkFBTyxDQUFDLGlIQUF1QjtBQUN4RSxRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsbUdBQWdCOztBQUVsRCxxQkFBcUIsbUJBQU8sQ0FBQyx5SEFBMkI7QUFDeEQsUUFBUSxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLHFIQUF5QjtBQUNoRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTiwwRUFBMEUsZUFBZTtBQUN6Rjs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLFlBQVk7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsV0FBVyxHQUFHLFdBQVcsR0FBRyxXQUFXO0FBQzdEO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckM7QUFDQSxpREFBaUQsV0FBVztBQUM1RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxVQUFVO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsUUFBUTtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvbm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL3NlbXZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgZGVidWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9kZWJ1ZycpXG5jb25zdCB7IE1BWF9MRU5HVEgsIE1BWF9TQUZFX0lOVEVHRVIgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2NvbnN0YW50cycpXG5jb25zdCB7IHNhZmVSZTogcmUsIHQgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcblxuY29uc3QgcGFyc2VPcHRpb25zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGFyc2Utb3B0aW9ucycpXG5jb25zdCB7IGNvbXBhcmVJZGVudGlmaWVycyB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaWRlbnRpZmllcnMnKVxuY2xhc3MgU2VtVmVyIHtcbiAgY29uc3RydWN0b3IgKHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgICAgaWYgKHZlcnNpb24ubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSAmJlxuICAgICAgICB2ZXJzaW9uLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgICAgcmV0dXJuIHZlcnNpb25cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLnZlcnNpb25cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCB2ZXJzaW9uLiBNdXN0IGJlIGEgc3RyaW5nLiBHb3QgdHlwZSBcIiR7dHlwZW9mIHZlcnNpb259XCIuYClcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBgdmVyc2lvbiBpcyBsb25nZXIgdGhhbiAke01BWF9MRU5HVEh9IGNoYXJhY3RlcnNgXG4gICAgICApXG4gICAgfVxuXG4gICAgZGVidWcoJ1NlbVZlcicsIHZlcnNpb24sIG9wdGlvbnMpXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2VcbiAgICAvLyB0aGlzIGlzbid0IGFjdHVhbGx5IHJlbGV2YW50IGZvciB2ZXJzaW9ucywgYnV0IGtlZXAgaXQgc28gdGhhdCB3ZVxuICAgIC8vIGRvbid0IHJ1biBpbnRvIHRyb3VibGUgcGFzc2luZyB0aGlzLm9wdGlvbnMgYXJvdW5kLlxuICAgIHRoaXMuaW5jbHVkZVByZXJlbGVhc2UgPSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcblxuICAgIGNvbnN0IG0gPSB2ZXJzaW9uLnRyaW0oKS5tYXRjaChvcHRpb25zLmxvb3NlID8gcmVbdC5MT09TRV0gOiByZVt0LkZVTExdKVxuXG4gICAgaWYgKCFtKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFZlcnNpb246ICR7dmVyc2lvbn1gKVxuICAgIH1cblxuICAgIHRoaXMucmF3ID0gdmVyc2lvblxuXG4gICAgLy8gdGhlc2UgYXJlIGFjdHVhbGx5IG51bWJlcnNcbiAgICB0aGlzLm1ham9yID0gK21bMV1cbiAgICB0aGlzLm1pbm9yID0gK21bMl1cbiAgICB0aGlzLnBhdGNoID0gK21bM11cblxuICAgIGlmICh0aGlzLm1ham9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1ham9yIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtYWpvciB2ZXJzaW9uJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5taW5vciA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5taW5vciA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWlub3IgdmVyc2lvbicpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGF0Y2ggPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMucGF0Y2ggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHBhdGNoIHZlcnNpb24nKVxuICAgIH1cblxuICAgIC8vIG51bWJlcmlmeSBhbnkgcHJlcmVsZWFzZSBudW1lcmljIGlkc1xuICAgIGlmICghbVs0XSkge1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gbVs0XS5zcGxpdCgnLicpLm1hcCgoaWQpID0+IHtcbiAgICAgICAgaWYgKC9eWzAtOV0rJC8udGVzdChpZCkpIHtcbiAgICAgICAgICBjb25zdCBudW0gPSAraWRcbiAgICAgICAgICBpZiAobnVtID49IDAgJiYgbnVtIDwgTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgcmV0dXJuIG51bVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5idWlsZCA9IG1bNV0gPyBtWzVdLnNwbGl0KCcuJykgOiBbXVxuICAgIHRoaXMuZm9ybWF0KClcbiAgfVxuXG4gIGZvcm1hdCAoKSB7XG4gICAgdGhpcy52ZXJzaW9uID0gYCR7dGhpcy5tYWpvcn0uJHt0aGlzLm1pbm9yfS4ke3RoaXMucGF0Y2h9YFxuICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICB0aGlzLnZlcnNpb24gKz0gYC0ke3RoaXMucHJlcmVsZWFzZS5qb2luKCcuJyl9YFxuICAgIH1cbiAgICByZXR1cm4gdGhpcy52ZXJzaW9uXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmVyc2lvblxuICB9XG5cbiAgY29tcGFyZSAob3RoZXIpIHtcbiAgICBkZWJ1ZygnU2VtVmVyLmNvbXBhcmUnLCB0aGlzLnZlcnNpb24sIHRoaXMub3B0aW9ucywgb3RoZXIpXG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBpZiAodHlwZW9mIG90aGVyID09PSAnc3RyaW5nJyAmJiBvdGhlciA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9XG4gICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgICB9XG5cbiAgICBpZiAob3RoZXIudmVyc2lvbiA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbXBhcmVNYWluKG90aGVyKSB8fCB0aGlzLmNvbXBhcmVQcmUob3RoZXIpXG4gIH1cblxuICBjb21wYXJlTWFpbiAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm1ham9yIDwgb3RoZXIubWFqb3IpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICBpZiAodGhpcy5tYWpvciA+IG90aGVyLm1ham9yKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cbiAgICBpZiAodGhpcy5taW5vciA8IG90aGVyLm1pbm9yKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgaWYgKHRoaXMubWlub3IgPiBvdGhlci5taW5vcikge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG4gICAgaWYgKHRoaXMucGF0Y2ggPCBvdGhlci5wYXRjaCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIGlmICh0aGlzLnBhdGNoID4gb3RoZXIucGF0Y2gpIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuICAgIHJldHVybiAwXG4gIH1cblxuICBjb21wYXJlUHJlIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgLy8gTk9UIGhhdmluZyBhIHByZXJlbGVhc2UgaXMgPiBoYXZpbmcgb25lXG4gICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmIG90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH0gZWxzZSBpZiAoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIGxldCBpID0gMFxuICAgIGRvIHtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLnByZXJlbGVhc2VbaV1cbiAgICAgIGNvbnN0IGIgPSBvdGhlci5wcmVyZWxlYXNlW2ldXG4gICAgICBkZWJ1ZygncHJlcmVsZWFzZSBjb21wYXJlJywgaSwgYSwgYilcbiAgICAgIGlmIChhID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9IGVsc2UgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMVxuICAgICAgfSBlbHNlIGlmIChhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9IGVsc2UgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnMoYSwgYilcbiAgICAgIH1cbiAgICB9IHdoaWxlICgrK2kpXG4gIH1cblxuICBjb21wYXJlQnVpbGQgKG90aGVyKSB7XG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgICB9XG5cbiAgICBsZXQgaSA9IDBcbiAgICBkbyB7XG4gICAgICBjb25zdCBhID0gdGhpcy5idWlsZFtpXVxuICAgICAgY29uc3QgYiA9IG90aGVyLmJ1aWxkW2ldXG4gICAgICBkZWJ1ZygnYnVpbGQgY29tcGFyZScsIGksIGEsIGIpXG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpXG4gICAgICB9XG4gICAgfSB3aGlsZSAoKytpKVxuICB9XG5cbiAgLy8gcHJlbWlub3Igd2lsbCBidW1wIHRoZSB2ZXJzaW9uIHVwIHRvIHRoZSBuZXh0IG1pbm9yIHJlbGVhc2UsIGFuZCBpbW1lZGlhdGVseVxuICAvLyBkb3duIHRvIHByZS1yZWxlYXNlLiBwcmVtYWpvciBhbmQgcHJlcGF0Y2ggd29yayB0aGUgc2FtZSB3YXkuXG4gIGluYyAocmVsZWFzZSwgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpIHtcbiAgICBpZiAocmVsZWFzZS5zdGFydHNXaXRoKCdwcmUnKSkge1xuICAgICAgaWYgKCFpZGVudGlmaWVyICYmIGlkZW50aWZpZXJCYXNlID09PSBmYWxzZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5jcmVtZW50IGFyZ3VtZW50OiBpZGVudGlmaWVyIGlzIGVtcHR5JylcbiAgICAgIH1cbiAgICAgIC8vIEF2b2lkIGFuIGludmFsaWQgc2VtdmVyIHJlc3VsdHNcbiAgICAgIGlmIChpZGVudGlmaWVyKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gYC0ke2lkZW50aWZpZXJ9YC5tYXRjaCh0aGlzLm9wdGlvbnMubG9vc2UgPyByZVt0LlBSRVJFTEVBU0VMT09TRV0gOiByZVt0LlBSRVJFTEVBU0VdKVxuICAgICAgICBpZiAoIW1hdGNoIHx8IG1hdGNoWzFdICE9PSBpZGVudGlmaWVyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGlkZW50aWZpZXI6ICR7aWRlbnRpZmllcn1gKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoIChyZWxlYXNlKSB7XG4gICAgICBjYXNlICdwcmVtYWpvcic6XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMubWlub3IgPSAwXG4gICAgICAgIHRoaXMubWFqb3IrK1xuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwcmVtaW5vcic6XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMubWlub3IrK1xuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwcmVwYXRjaCc6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYWxyZWFkeSBhIHByZXJlbGVhc2UsIGl0IHdpbGwgYnVtcCB0byB0aGUgbmV4dCB2ZXJzaW9uXG4gICAgICAgIC8vIGRyb3AgYW55IHByZXJlbGVhc2VzIHRoYXQgbWlnaHQgYWxyZWFkeSBleGlzdCwgc2luY2UgdGhleSBhcmUgbm90XG4gICAgICAgIC8vIHJlbGV2YW50IGF0IHRoaXMgcG9pbnQuXG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIHRoaXMuaW5jKCdwYXRjaCcsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKVxuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpXG4gICAgICAgIGJyZWFrXG4gICAgICAvLyBJZiB0aGUgaW5wdXQgaXMgYSBub24tcHJlcmVsZWFzZSB2ZXJzaW9uLCB0aGlzIGFjdHMgdGhlIHNhbWUgYXNcbiAgICAgIC8vIHByZXBhdGNoLlxuICAgICAgY2FzZSAncHJlcmVsZWFzZSc6XG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncmVsZWFzZSc6XG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2ZXJzaW9uICR7dGhpcy5yYXd9IGlzIG5vdCBhIHByZXJlbGVhc2VgKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ21ham9yJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1tYWpvciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1ham9yIHZlcnNpb24uXG4gICAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWFqb3IuXG4gICAgICAgIC8vIDEuMC4wLTUgYnVtcHMgdG8gMS4wLjBcbiAgICAgICAgLy8gMS4xLjAgYnVtcHMgdG8gMi4wLjBcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMubWlub3IgIT09IDAgfHxcbiAgICAgICAgICB0aGlzLnBhdGNoICE9PSAwIHx8XG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLm1ham9yKytcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1pbm9yID0gMFxuICAgICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnbWlub3InOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgcHJlLW1pbm9yIHZlcnNpb24sIGJ1bXAgdXAgdG8gdGhlIHNhbWUgbWlub3IgdmVyc2lvbi5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCBtaW5vci5cbiAgICAgICAgLy8gMS4yLjAtNSBidW1wcyB0byAxLjIuMFxuICAgICAgICAvLyAxLjIuMSBidW1wcyB0byAxLjMuMFxuICAgICAgICBpZiAodGhpcy5wYXRjaCAhPT0gMCB8fCB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5taW5vcisrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3BhdGNoJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgYSBwcmUtcmVsZWFzZSB2ZXJzaW9uLCBpdCB3aWxsIGluY3JlbWVudCB0aGUgcGF0Y2guXG4gICAgICAgIC8vIElmIGl0IGlzIGEgcHJlLXJlbGVhc2UgaXQgd2lsbCBidW1wIHVwIHRvIHRoZSBzYW1lIHBhdGNoIHZlcnNpb24uXG4gICAgICAgIC8vIDEuMi4wLTUgcGF0Y2hlcyB0byAxLjIuMFxuICAgICAgICAvLyAxLjIuMCBwYXRjaGVzIHRvIDEuMi4xXG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5wYXRjaCsrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgICAgYnJlYWtcbiAgICAgIC8vIFRoaXMgcHJvYmFibHkgc2hvdWxkbid0IGJlIHVzZWQgcHVibGljbHkuXG4gICAgICAvLyAxLjAuMCAncHJlJyB3b3VsZCBiZWNvbWUgMS4wLjAtMCB3aGljaCBpcyB0aGUgd3JvbmcgZGlyZWN0aW9uLlxuICAgICAgY2FzZSAncHJlJzoge1xuICAgICAgICBjb25zdCBiYXNlID0gTnVtYmVyKGlkZW50aWZpZXJCYXNlKSA/IDEgOiAwXG5cbiAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbYmFzZV1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgaSA9IHRoaXMucHJlcmVsZWFzZS5sZW5ndGhcbiAgICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcmVyZWxlYXNlW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICB0aGlzLnByZXJlbGVhc2VbaV0rK1xuICAgICAgICAgICAgICBpID0gLTJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBkaWRuJ3QgaW5jcmVtZW50IGFueXRoaW5nXG4gICAgICAgICAgICBpZiAoaWRlbnRpZmllciA9PT0gdGhpcy5wcmVyZWxlYXNlLmpvaW4oJy4nKSAmJiBpZGVudGlmaWVyQmFzZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluY3JlbWVudCBhcmd1bWVudDogaWRlbnRpZmllciBhbHJlYWR5IGV4aXN0cycpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UucHVzaChiYXNlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaWRlbnRpZmllcikge1xuICAgICAgICAgIC8vIDEuMi4wLWJldGEuMSBidW1wcyB0byAxLjIuMC1iZXRhLjIsXG4gICAgICAgICAgLy8gMS4yLjAtYmV0YS5mb29ibHogb3IgMS4yLjAtYmV0YSBidW1wcyB0byAxLjIuMC1iZXRhLjBcbiAgICAgICAgICBsZXQgcHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCBiYXNlXVxuICAgICAgICAgIGlmIChpZGVudGlmaWVyQmFzZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHByZXJlbGVhc2UgPSBbaWRlbnRpZmllcl1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLnByZXJlbGVhc2VbMF0sIGlkZW50aWZpZXIpID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4odGhpcy5wcmVyZWxlYXNlWzFdKSkge1xuICAgICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBwcmVyZWxlYXNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IHByZXJlbGVhc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbmNyZW1lbnQgYXJndW1lbnQ6ICR7cmVsZWFzZX1gKVxuICAgIH1cbiAgICB0aGlzLnJhdyA9IHRoaXMuZm9ybWF0KClcbiAgICBpZiAodGhpcy5idWlsZC5sZW5ndGgpIHtcbiAgICAgIHRoaXMucmF3ICs9IGArJHt0aGlzLmJ1aWxkLmpvaW4oJy4nKX1gXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZW1WZXJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/semver.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/clean.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/functions/clean.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst parse = __webpack_require__(/*! ./parse */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/parse.js\")\nconst clean = (version, options) => {\n  const s = parse(version.trim().replace(/^[=v]+/, ''), options)\n  return s ? s.version : null\n}\nmodule.exports = clean\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jbGVhbi5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixjQUFjLG1CQUFPLENBQUMsZ0dBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NsZWFuLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgY2xlYW4gPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBzID0gcGFyc2UodmVyc2lvbi50cmltKCkucmVwbGFjZSgvXls9dl0rLywgJycpLCBvcHRpb25zKVxuICByZXR1cm4gcyA/IHMudmVyc2lvbiA6IG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gY2xlYW5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/clean.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/cmp.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/functions/cmp.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst eq = __webpack_require__(/*! ./eq */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/eq.js\")\nconst neq = __webpack_require__(/*! ./neq */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/neq.js\")\nconst gt = __webpack_require__(/*! ./gt */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/gt.js\")\nconst gte = __webpack_require__(/*! ./gte */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/gte.js\")\nconst lt = __webpack_require__(/*! ./lt */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/lt.js\")\nconst lte = __webpack_require__(/*! ./lte */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/lte.js\")\n\nconst cmp = (a, op, b, loose) => {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object') {\n        a = a.version\n      }\n      if (typeof b === 'object') {\n        b = b.version\n      }\n      return a === b\n\n    case '!==':\n      if (typeof a === 'object') {\n        a = a.version\n      }\n      if (typeof b === 'object') {\n        b = b.version\n      }\n      return a !== b\n\n    case '':\n    case '=':\n    case '==':\n      return eq(a, b, loose)\n\n    case '!=':\n      return neq(a, b, loose)\n\n    case '>':\n      return gt(a, b, loose)\n\n    case '>=':\n      return gte(a, b, loose)\n\n    case '<':\n      return lt(a, b, loose)\n\n    case '<=':\n      return lte(a, b, loose)\n\n    default:\n      throw new TypeError(`Invalid operator: ${op}`)\n  }\n}\nmodule.exports = cmp\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jbXAuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosV0FBVyxtQkFBTyxDQUFDLDBGQUFNO0FBQ3pCLFlBQVksbUJBQU8sQ0FBQyw0RkFBTztBQUMzQixXQUFXLG1CQUFPLENBQUMsMEZBQU07QUFDekIsWUFBWSxtQkFBTyxDQUFDLDRGQUFPO0FBQzNCLFdBQVcsbUJBQU8sQ0FBQywwRkFBTTtBQUN6QixZQUFZLG1CQUFPLENBQUMsNEZBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLEdBQUc7QUFDbEQ7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY21wLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBlcSA9IHJlcXVpcmUoJy4vZXEnKVxuY29uc3QgbmVxID0gcmVxdWlyZSgnLi9uZXEnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuL2d0JylcbmNvbnN0IGd0ZSA9IHJlcXVpcmUoJy4vZ3RlJylcbmNvbnN0IGx0ID0gcmVxdWlyZSgnLi9sdCcpXG5jb25zdCBsdGUgPSByZXF1aXJlKCcuL2x0ZScpXG5cbmNvbnN0IGNtcCA9IChhLCBvcCwgYiwgbG9vc2UpID0+IHtcbiAgc3dpdGNoIChvcCkge1xuICAgIGNhc2UgJz09PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGEgPSBhLnZlcnNpb25cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYiA9IGIudmVyc2lvblxuICAgICAgfVxuICAgICAgcmV0dXJuIGEgPT09IGJcblxuICAgIGNhc2UgJyE9PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGEgPSBhLnZlcnNpb25cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYiA9IGIudmVyc2lvblxuICAgICAgfVxuICAgICAgcmV0dXJuIGEgIT09IGJcblxuICAgIGNhc2UgJyc6XG4gICAgY2FzZSAnPSc6XG4gICAgY2FzZSAnPT0nOlxuICAgICAgcmV0dXJuIGVxKGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnIT0nOlxuICAgICAgcmV0dXJuIG5lcShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJz4nOlxuICAgICAgcmV0dXJuIGd0KGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPj0nOlxuICAgICAgcmV0dXJuIGd0ZShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJzwnOlxuICAgICAgcmV0dXJuIGx0KGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPD0nOlxuICAgICAgcmV0dXJuIGx0ZShhLCBiLCBsb29zZSlcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIG9wZXJhdG9yOiAke29wfWApXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gY21wXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/cmp.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/coerce.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/functions/coerce.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SemVer = __webpack_require__(/*! ../classes/semver */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/semver.js\")\nconst parse = __webpack_require__(/*! ./parse */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/parse.js\")\nconst { safeRe: re, t } = __webpack_require__(/*! ../internal/re */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/re.js\")\n\nconst coerce = (version, options) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version === 'number') {\n    version = String(version)\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  options = options || {}\n\n  let match = null\n  if (!options.rtl) {\n    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE])\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL]\n    let next\n    while ((next = coerceRtlRegex.exec(version)) &&\n        (!match || match.index + match[0].length !== version.length)\n    ) {\n      if (!match ||\n            next.index + next[0].length !== match.index + match[0].length) {\n        match = next\n      }\n      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length\n    }\n    // leave it in a clean state\n    coerceRtlRegex.lastIndex = -1\n  }\n\n  if (match === null) {\n    return null\n  }\n\n  const major = match[2]\n  const minor = match[3] || '0'\n  const patch = match[4] || '0'\n  const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : ''\n  const build = options.includePrerelease && match[6] ? `+${match[6]}` : ''\n\n  return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options)\n}\nmodule.exports = coerce\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb2VyY2UuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLHlHQUFtQjtBQUMxQyxjQUFjLG1CQUFPLENBQUMsZ0dBQVM7QUFDL0IsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLG1HQUFnQjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFNBQVM7QUFDMUUsNERBQTRELFNBQVM7O0FBRXJFLGtCQUFrQixNQUFNLEdBQUcsTUFBTSxHQUFHLE1BQU0sRUFBRSxXQUFXLEVBQUUsTUFBTTtBQUMvRDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29lcmNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgeyBzYWZlUmU6IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5cbmNvbnN0IGNvZXJjZSA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgcmV0dXJuIHZlcnNpb25cbiAgfVxuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ251bWJlcicpIHtcbiAgICB2ZXJzaW9uID0gU3RyaW5nKHZlcnNpb24pXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgbGV0IG1hdGNoID0gbnVsbFxuICBpZiAoIW9wdGlvbnMucnRsKSB7XG4gICAgbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyByZVt0LkNPRVJDRUZVTExdIDogcmVbdC5DT0VSQ0VdKVxuICB9IGVsc2Uge1xuICAgIC8vIEZpbmQgdGhlIHJpZ2h0LW1vc3QgY29lcmNpYmxlIHN0cmluZyB0aGF0IGRvZXMgbm90IHNoYXJlXG4gICAgLy8gYSB0ZXJtaW51cyB3aXRoIGEgbW9yZSBsZWZ0LXdhcmQgY29lcmNpYmxlIHN0cmluZy5cbiAgICAvLyBFZywgJzEuMi4zLjQnIHdhbnRzIHRvIGNvZXJjZSAnMi4zLjQnLCBub3QgJzMuNCcgb3IgJzQnXG4gICAgLy8gV2l0aCBpbmNsdWRlUHJlcmVsZWFzZSBvcHRpb24gc2V0LCAnMS4yLjMuNC1yYycgd2FudHMgdG8gY29lcmNlICcyLjMuNC1yYycsIG5vdCAnMi4zLjQnXG4gICAgLy9cbiAgICAvLyBXYWxrIHRocm91Z2ggdGhlIHN0cmluZyBjaGVja2luZyB3aXRoIGEgL2cgcmVnZXhwXG4gICAgLy8gTWFudWFsbHkgc2V0IHRoZSBpbmRleCBzbyBhcyB0byBwaWNrIHVwIG92ZXJsYXBwaW5nIG1hdGNoZXMuXG4gICAgLy8gU3RvcCB3aGVuIHdlIGdldCBhIG1hdGNoIHRoYXQgZW5kcyBhdCB0aGUgc3RyaW5nIGVuZCwgc2luY2Ugbm9cbiAgICAvLyBjb2VyY2libGUgc3RyaW5nIGNhbiBiZSBtb3JlIHJpZ2h0LXdhcmQgd2l0aG91dCB0aGUgc2FtZSB0ZXJtaW51cy5cbiAgICBjb25zdCBjb2VyY2VSdGxSZWdleCA9IG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyByZVt0LkNPRVJDRVJUTEZVTExdIDogcmVbdC5DT0VSQ0VSVExdXG4gICAgbGV0IG5leHRcbiAgICB3aGlsZSAoKG5leHQgPSBjb2VyY2VSdGxSZWdleC5leGVjKHZlcnNpb24pKSAmJlxuICAgICAgICAoIW1hdGNoIHx8IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoICE9PSB2ZXJzaW9uLmxlbmd0aClcbiAgICApIHtcbiAgICAgIGlmICghbWF0Y2ggfHxcbiAgICAgICAgICAgIG5leHQuaW5kZXggKyBuZXh0WzBdLmxlbmd0aCAhPT0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpIHtcbiAgICAgICAgbWF0Y2ggPSBuZXh0XG4gICAgICB9XG4gICAgICBjb2VyY2VSdGxSZWdleC5sYXN0SW5kZXggPSBuZXh0LmluZGV4ICsgbmV4dFsxXS5sZW5ndGggKyBuZXh0WzJdLmxlbmd0aFxuICAgIH1cbiAgICAvLyBsZWF2ZSBpdCBpbiBhIGNsZWFuIHN0YXRlXG4gICAgY29lcmNlUnRsUmVnZXgubGFzdEluZGV4ID0gLTFcbiAgfVxuXG4gIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCBtYWpvciA9IG1hdGNoWzJdXG4gIGNvbnN0IG1pbm9yID0gbWF0Y2hbM10gfHwgJzAnXG4gIGNvbnN0IHBhdGNoID0gbWF0Y2hbNF0gfHwgJzAnXG4gIGNvbnN0IHByZXJlbGVhc2UgPSBvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmIG1hdGNoWzVdID8gYC0ke21hdGNoWzVdfWAgOiAnJ1xuICBjb25zdCBidWlsZCA9IG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgJiYgbWF0Y2hbNl0gPyBgKyR7bWF0Y2hbNl19YCA6ICcnXG5cbiAgcmV0dXJuIHBhcnNlKGAke21ham9yfS4ke21pbm9yfS4ke3BhdGNofSR7cHJlcmVsZWFzZX0ke2J1aWxkfWAsIG9wdGlvbnMpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGNvZXJjZVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/coerce.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/compare-build.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/functions/compare-build.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SemVer = __webpack_require__(/*! ../classes/semver */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/semver.js\")\nconst compareBuild = (a, b, loose) => {\n  const versionA = new SemVer(a, loose)\n  const versionB = new SemVer(b, loose)\n  return versionA.compare(versionB) || versionA.compareBuild(versionB)\n}\nmodule.exports = compareBuild\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLWJ1aWxkLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyx5R0FBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29tcGFyZS1idWlsZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgY29tcGFyZUJ1aWxkID0gKGEsIGIsIGxvb3NlKSA9PiB7XG4gIGNvbnN0IHZlcnNpb25BID0gbmV3IFNlbVZlcihhLCBsb29zZSlcbiAgY29uc3QgdmVyc2lvbkIgPSBuZXcgU2VtVmVyKGIsIGxvb3NlKVxuICByZXR1cm4gdmVyc2lvbkEuY29tcGFyZSh2ZXJzaW9uQikgfHwgdmVyc2lvbkEuY29tcGFyZUJ1aWxkKHZlcnNpb25CKVxufVxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlQnVpbGRcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/compare-build.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/compare-loose.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/functions/compare-loose.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst compare = __webpack_require__(/*! ./compare */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/compare.js\")\nconst compareLoose = (a, b) => compare(a, b, true)\nmodule.exports = compareLoose\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLWxvb3NlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGdCQUFnQixtQkFBTyxDQUFDLG9HQUFXO0FBQ25DO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLWxvb3NlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGNvbXBhcmVMb29zZSA9IChhLCBiKSA9PiBjb21wYXJlKGEsIGIsIHRydWUpXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVMb29zZVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/compare-loose.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/compare.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/functions/compare.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SemVer = __webpack_require__(/*! ../classes/semver */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/semver.js\")\nconst compare = (a, b, loose) =>\n  new SemVer(a, loose).compare(new SemVer(b, loose))\n\nmodule.exports = compare\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyx5R0FBbUI7QUFDMUM7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IGNvbXBhcmUgPSAoYSwgYiwgbG9vc2UpID0+XG4gIG5ldyBTZW1WZXIoYSwgbG9vc2UpLmNvbXBhcmUobmV3IFNlbVZlcihiLCBsb29zZSkpXG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/compare.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/diff.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/functions/diff.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst parse = __webpack_require__(/*! ./parse.js */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/parse.js\")\n\nconst diff = (version1, version2) => {\n  const v1 = parse(version1, null, true)\n  const v2 = parse(version2, null, true)\n  const comparison = v1.compare(v2)\n\n  if (comparison === 0) {\n    return null\n  }\n\n  const v1Higher = comparison > 0\n  const highVersion = v1Higher ? v1 : v2\n  const lowVersion = v1Higher ? v2 : v1\n  const highHasPre = !!highVersion.prerelease.length\n  const lowHasPre = !!lowVersion.prerelease.length\n\n  if (lowHasPre && !highHasPre) {\n    // Going from prerelease -> no prerelease requires some special casing\n\n    // If the low version has only a major, then it will always be a major\n    // Some examples:\n    // 1.0.0-1 -> 1.0.0\n    // 1.0.0-1 -> 1.1.1\n    // 1.0.0-1 -> 2.0.0\n    if (!lowVersion.patch && !lowVersion.minor) {\n      return 'major'\n    }\n\n    // If the main part has no difference\n    if (lowVersion.compareMain(highVersion) === 0) {\n      if (lowVersion.minor && !lowVersion.patch) {\n        return 'minor'\n      }\n      return 'patch'\n    }\n  }\n\n  // add the `pre` prefix if we are going to a prerelease version\n  const prefix = highHasPre ? 'pre' : ''\n\n  if (v1.major !== v2.major) {\n    return prefix + 'major'\n  }\n\n  if (v1.minor !== v2.minor) {\n    return prefix + 'minor'\n  }\n\n  if (v1.patch !== v2.patch) {\n    return prefix + 'patch'\n  }\n\n  // high and low are preleases\n  return 'prerelease'\n}\n\nmodule.exports = diff\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9kaWZmLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGNBQWMsbUJBQU8sQ0FBQyxtR0FBWTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9kaWZmLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UuanMnKVxuXG5jb25zdCBkaWZmID0gKHZlcnNpb24xLCB2ZXJzaW9uMikgPT4ge1xuICBjb25zdCB2MSA9IHBhcnNlKHZlcnNpb24xLCBudWxsLCB0cnVlKVxuICBjb25zdCB2MiA9IHBhcnNlKHZlcnNpb24yLCBudWxsLCB0cnVlKVxuICBjb25zdCBjb21wYXJpc29uID0gdjEuY29tcGFyZSh2MilcblxuICBpZiAoY29tcGFyaXNvbiA9PT0gMCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCB2MUhpZ2hlciA9IGNvbXBhcmlzb24gPiAwXG4gIGNvbnN0IGhpZ2hWZXJzaW9uID0gdjFIaWdoZXIgPyB2MSA6IHYyXG4gIGNvbnN0IGxvd1ZlcnNpb24gPSB2MUhpZ2hlciA/IHYyIDogdjFcbiAgY29uc3QgaGlnaEhhc1ByZSA9ICEhaGlnaFZlcnNpb24ucHJlcmVsZWFzZS5sZW5ndGhcbiAgY29uc3QgbG93SGFzUHJlID0gISFsb3dWZXJzaW9uLnByZXJlbGVhc2UubGVuZ3RoXG5cbiAgaWYgKGxvd0hhc1ByZSAmJiAhaGlnaEhhc1ByZSkge1xuICAgIC8vIEdvaW5nIGZyb20gcHJlcmVsZWFzZSAtPiBubyBwcmVyZWxlYXNlIHJlcXVpcmVzIHNvbWUgc3BlY2lhbCBjYXNpbmdcblxuICAgIC8vIElmIHRoZSBsb3cgdmVyc2lvbiBoYXMgb25seSBhIG1ham9yLCB0aGVuIGl0IHdpbGwgYWx3YXlzIGJlIGEgbWFqb3JcbiAgICAvLyBTb21lIGV4YW1wbGVzOlxuICAgIC8vIDEuMC4wLTEgLT4gMS4wLjBcbiAgICAvLyAxLjAuMC0xIC0+IDEuMS4xXG4gICAgLy8gMS4wLjAtMSAtPiAyLjAuMFxuICAgIGlmICghbG93VmVyc2lvbi5wYXRjaCAmJiAhbG93VmVyc2lvbi5taW5vcikge1xuICAgICAgcmV0dXJuICdtYWpvcidcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbWFpbiBwYXJ0IGhhcyBubyBkaWZmZXJlbmNlXG4gICAgaWYgKGxvd1ZlcnNpb24uY29tcGFyZU1haW4oaGlnaFZlcnNpb24pID09PSAwKSB7XG4gICAgICBpZiAobG93VmVyc2lvbi5taW5vciAmJiAhbG93VmVyc2lvbi5wYXRjaCkge1xuICAgICAgICByZXR1cm4gJ21pbm9yJ1xuICAgICAgfVxuICAgICAgcmV0dXJuICdwYXRjaCdcbiAgICB9XG4gIH1cblxuICAvLyBhZGQgdGhlIGBwcmVgIHByZWZpeCBpZiB3ZSBhcmUgZ29pbmcgdG8gYSBwcmVyZWxlYXNlIHZlcnNpb25cbiAgY29uc3QgcHJlZml4ID0gaGlnaEhhc1ByZSA/ICdwcmUnIDogJydcblxuICBpZiAodjEubWFqb3IgIT09IHYyLm1ham9yKSB7XG4gICAgcmV0dXJuIHByZWZpeCArICdtYWpvcidcbiAgfVxuXG4gIGlmICh2MS5taW5vciAhPT0gdjIubWlub3IpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgJ21pbm9yJ1xuICB9XG5cbiAgaWYgKHYxLnBhdGNoICE9PSB2Mi5wYXRjaCkge1xuICAgIHJldHVybiBwcmVmaXggKyAncGF0Y2gnXG4gIH1cblxuICAvLyBoaWdoIGFuZCBsb3cgYXJlIHByZWxlYXNlc1xuICByZXR1cm4gJ3ByZXJlbGVhc2UnXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGlmZlxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/diff.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/eq.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/functions/eq.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst compare = __webpack_require__(/*! ./compare */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/compare.js\")\nconst eq = (a, b, loose) => compare(a, b, loose) === 0\nmodule.exports = eq\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9lcS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixnQkFBZ0IsbUJBQU8sQ0FBQyxvR0FBVztBQUNuQztBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZXEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZXEgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpID09PSAwXG5tb2R1bGUuZXhwb3J0cyA9IGVxXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/eq.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/gt.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/functions/gt.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst compare = __webpack_require__(/*! ./compare */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/compare.js\")\nconst gt = (a, b, loose) => compare(a, b, loose) > 0\nmodule.exports = gt\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9ndC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixnQkFBZ0IsbUJBQU8sQ0FBQyxvR0FBVztBQUNuQztBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZ3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZ3QgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpID4gMFxubW9kdWxlLmV4cG9ydHMgPSBndFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/gt.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/gte.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/functions/gte.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst compare = __webpack_require__(/*! ./compare */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/compare.js\")\nconst gte = (a, b, loose) => compare(a, b, loose) >= 0\nmodule.exports = gte\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9ndGUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZ0JBQWdCLG1CQUFPLENBQUMsb0dBQVc7QUFDbkM7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2d0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBndGUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpID49IDBcbm1vZHVsZS5leHBvcnRzID0gZ3RlXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/gte.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/inc.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/functions/inc.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SemVer = __webpack_require__(/*! ../classes/semver */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/semver.js\")\n\nconst inc = (version, release, options, identifier, identifierBase) => {\n  if (typeof (options) === 'string') {\n    identifierBase = identifier\n    identifier = options\n    options = undefined\n  }\n\n  try {\n    return new SemVer(\n      version instanceof SemVer ? version.version : version,\n      options\n    ).inc(release, identifier, identifierBase).version\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = inc\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9pbmMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLHlHQUFtQjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9pbmMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcblxuY29uc3QgaW5jID0gKHZlcnNpb24sIHJlbGVhc2UsIG9wdGlvbnMsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKSA9PiB7XG4gIGlmICh0eXBlb2YgKG9wdGlvbnMpID09PSAnc3RyaW5nJykge1xuICAgIGlkZW50aWZpZXJCYXNlID0gaWRlbnRpZmllclxuICAgIGlkZW50aWZpZXIgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZFxuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFNlbVZlcihcbiAgICAgIHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIgPyB2ZXJzaW9uLnZlcnNpb24gOiB2ZXJzaW9uLFxuICAgICAgb3B0aW9uc1xuICAgICkuaW5jKHJlbGVhc2UsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKS52ZXJzaW9uXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBpbmNcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/inc.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/lt.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/functions/lt.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst compare = __webpack_require__(/*! ./compare */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/compare.js\")\nconst lt = (a, b, loose) => compare(a, b, loose) < 0\nmodule.exports = lt\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9sdC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixnQkFBZ0IsbUJBQU8sQ0FBQyxvR0FBVztBQUNuQztBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbHQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgbHQgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpIDwgMFxubW9kdWxlLmV4cG9ydHMgPSBsdFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/lt.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/lte.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/functions/lte.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst compare = __webpack_require__(/*! ./compare */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/compare.js\")\nconst lte = (a, b, loose) => compare(a, b, loose) <= 0\nmodule.exports = lte\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9sdGUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZ0JBQWdCLG1CQUFPLENBQUMsb0dBQVc7QUFDbkM7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2x0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBsdGUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpIDw9IDBcbm1vZHVsZS5leHBvcnRzID0gbHRlXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/lte.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/major.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/functions/major.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SemVer = __webpack_require__(/*! ../classes/semver */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/semver.js\")\nconst major = (a, loose) => new SemVer(a, loose).major\nmodule.exports = major\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9tYWpvci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMseUdBQW1CO0FBQzFDO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9tYWpvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgbWFqb3IgPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1ham9yXG5tb2R1bGUuZXhwb3J0cyA9IG1ham9yXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/major.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/minor.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/functions/minor.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SemVer = __webpack_require__(/*! ../classes/semver */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/semver.js\")\nconst minor = (a, loose) => new SemVer(a, loose).minor\nmodule.exports = minor\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9taW5vci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMseUdBQW1CO0FBQzFDO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9taW5vci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgbWlub3IgPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1pbm9yXG5tb2R1bGUuZXhwb3J0cyA9IG1pbm9yXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/minor.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/neq.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/functions/neq.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst compare = __webpack_require__(/*! ./compare */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/compare.js\")\nconst neq = (a, b, loose) => compare(a, b, loose) !== 0\nmodule.exports = neq\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9uZXEuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZ0JBQWdCLG1CQUFPLENBQUMsb0dBQVc7QUFDbkM7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL25lcS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBuZXEgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpICE9PSAwXG5tb2R1bGUuZXhwb3J0cyA9IG5lcVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/neq.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/parse.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/functions/parse.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SemVer = __webpack_require__(/*! ../classes/semver */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/semver.js\")\nconst parse = (version, options, throwErrors = false) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n  try {\n    return new SemVer(version, options)\n  } catch (er) {\n    if (!throwErrors) {\n      return null\n    }\n    throw er\n  }\n}\n\nmodule.exports = parse\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wYXJzZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMseUdBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wYXJzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgcGFyc2UgPSAodmVyc2lvbiwgb3B0aW9ucywgdGhyb3dFcnJvcnMgPSBmYWxzZSkgPT4ge1xuICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgIHJldHVybiB2ZXJzaW9uXG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIGlmICghdGhyb3dFcnJvcnMpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHRocm93IGVyXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/parse.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/patch.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/functions/patch.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SemVer = __webpack_require__(/*! ../classes/semver */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/semver.js\")\nconst patch = (a, loose) => new SemVer(a, loose).patch\nmodule.exports = patch\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wYXRjaC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMseUdBQW1CO0FBQzFDO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wYXRjaC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgcGF0Y2ggPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLnBhdGNoXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/patch.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/prerelease.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/functions/prerelease.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst parse = __webpack_require__(/*! ./parse */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/parse.js\")\nconst prerelease = (version, options) => {\n  const parsed = parse(version, options)\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null\n}\nmodule.exports = prerelease\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wcmVyZWxlYXNlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGNBQWMsbUJBQU8sQ0FBQyxnR0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcHJlcmVsZWFzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IHByZXJlbGVhc2UgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBwYXJzZWQgPSBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKVxuICByZXR1cm4gKHBhcnNlZCAmJiBwYXJzZWQucHJlcmVsZWFzZS5sZW5ndGgpID8gcGFyc2VkLnByZXJlbGVhc2UgOiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IHByZXJlbGVhc2VcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/prerelease.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/rcompare.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/functions/rcompare.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst compare = __webpack_require__(/*! ./compare */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/compare.js\")\nconst rcompare = (a, b, loose) => compare(b, a, loose)\nmodule.exports = rcompare\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9yY29tcGFyZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixnQkFBZ0IsbUJBQU8sQ0FBQyxvR0FBVztBQUNuQztBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcmNvbXBhcmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgcmNvbXBhcmUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYiwgYSwgbG9vc2UpXG5tb2R1bGUuZXhwb3J0cyA9IHJjb21wYXJlXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/rcompare.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/rsort.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/functions/rsort.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst compareBuild = __webpack_require__(/*! ./compare-build */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/compare-build.js\")\nconst rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))\nmodule.exports = rsort\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9yc29ydC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixxQkFBcUIsbUJBQU8sQ0FBQyxnSEFBaUI7QUFDOUM7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3Jzb3J0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBjb21wYXJlQnVpbGQgPSByZXF1aXJlKCcuL2NvbXBhcmUtYnVpbGQnKVxuY29uc3QgcnNvcnQgPSAobGlzdCwgbG9vc2UpID0+IGxpc3Quc29ydCgoYSwgYikgPT4gY29tcGFyZUJ1aWxkKGIsIGEsIGxvb3NlKSlcbm1vZHVsZS5leHBvcnRzID0gcnNvcnRcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/rsort.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/satisfies.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/functions/satisfies.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Range = __webpack_require__(/*! ../classes/range */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/range.js\")\nconst satisfies = (version, range, options) => {\n  try {\n    range = new Range(range, options)\n  } catch (er) {\n    return false\n  }\n  return range.test(version)\n}\nmodule.exports = satisfies\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9zYXRpc2ZpZXMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosY0FBYyxtQkFBTyxDQUFDLHVHQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3NhdGlzZmllcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHNhdGlzZmllcyA9ICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICB0cnkge1xuICAgIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiByYW5nZS50ZXN0KHZlcnNpb24pXG59XG5tb2R1bGUuZXhwb3J0cyA9IHNhdGlzZmllc1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/satisfies.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/sort.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/functions/sort.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst compareBuild = __webpack_require__(/*! ./compare-build */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/compare-build.js\")\nconst sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))\nmodule.exports = sort\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9zb3J0LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLHFCQUFxQixtQkFBTyxDQUFDLGdIQUFpQjtBQUM5QztBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvc29ydC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgY29tcGFyZUJ1aWxkID0gcmVxdWlyZSgnLi9jb21wYXJlLWJ1aWxkJylcbmNvbnN0IHNvcnQgPSAobGlzdCwgbG9vc2UpID0+IGxpc3Quc29ydCgoYSwgYikgPT4gY29tcGFyZUJ1aWxkKGEsIGIsIGxvb3NlKSlcbm1vZHVsZS5leHBvcnRzID0gc29ydFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/sort.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/valid.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/functions/valid.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst parse = __webpack_require__(/*! ./parse */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/parse.js\")\nconst valid = (version, options) => {\n  const v = parse(version, options)\n  return v ? v.version : null\n}\nmodule.exports = valid\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy92YWxpZC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixjQUFjLG1CQUFPLENBQUMsZ0dBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3ZhbGlkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgdmFsaWQgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBjb25zdCB2ID0gcGFyc2UodmVyc2lvbiwgb3B0aW9ucylcbiAgcmV0dXJuIHYgPyB2LnZlcnNpb24gOiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IHZhbGlkXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/valid.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/index.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/index.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// just pre-load all the stuff that index.js lazily exports\nconst internalRe = __webpack_require__(/*! ./internal/re */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/re.js\")\nconst constants = __webpack_require__(/*! ./internal/constants */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/constants.js\")\nconst SemVer = __webpack_require__(/*! ./classes/semver */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/semver.js\")\nconst identifiers = __webpack_require__(/*! ./internal/identifiers */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/identifiers.js\")\nconst parse = __webpack_require__(/*! ./functions/parse */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/parse.js\")\nconst valid = __webpack_require__(/*! ./functions/valid */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/valid.js\")\nconst clean = __webpack_require__(/*! ./functions/clean */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/clean.js\")\nconst inc = __webpack_require__(/*! ./functions/inc */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/inc.js\")\nconst diff = __webpack_require__(/*! ./functions/diff */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/diff.js\")\nconst major = __webpack_require__(/*! ./functions/major */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/major.js\")\nconst minor = __webpack_require__(/*! ./functions/minor */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/minor.js\")\nconst patch = __webpack_require__(/*! ./functions/patch */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/patch.js\")\nconst prerelease = __webpack_require__(/*! ./functions/prerelease */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/prerelease.js\")\nconst compare = __webpack_require__(/*! ./functions/compare */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/compare.js\")\nconst rcompare = __webpack_require__(/*! ./functions/rcompare */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/rcompare.js\")\nconst compareLoose = __webpack_require__(/*! ./functions/compare-loose */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/compare-loose.js\")\nconst compareBuild = __webpack_require__(/*! ./functions/compare-build */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/compare-build.js\")\nconst sort = __webpack_require__(/*! ./functions/sort */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/sort.js\")\nconst rsort = __webpack_require__(/*! ./functions/rsort */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/rsort.js\")\nconst gt = __webpack_require__(/*! ./functions/gt */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/gt.js\")\nconst lt = __webpack_require__(/*! ./functions/lt */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/lt.js\")\nconst eq = __webpack_require__(/*! ./functions/eq */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/eq.js\")\nconst neq = __webpack_require__(/*! ./functions/neq */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/neq.js\")\nconst gte = __webpack_require__(/*! ./functions/gte */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/gte.js\")\nconst lte = __webpack_require__(/*! ./functions/lte */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/lte.js\")\nconst cmp = __webpack_require__(/*! ./functions/cmp */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/cmp.js\")\nconst coerce = __webpack_require__(/*! ./functions/coerce */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/coerce.js\")\nconst Comparator = __webpack_require__(/*! ./classes/comparator */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/comparator.js\")\nconst Range = __webpack_require__(/*! ./classes/range */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/range.js\")\nconst satisfies = __webpack_require__(/*! ./functions/satisfies */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/satisfies.js\")\nconst toComparators = __webpack_require__(/*! ./ranges/to-comparators */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/to-comparators.js\")\nconst maxSatisfying = __webpack_require__(/*! ./ranges/max-satisfying */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/max-satisfying.js\")\nconst minSatisfying = __webpack_require__(/*! ./ranges/min-satisfying */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/min-satisfying.js\")\nconst minVersion = __webpack_require__(/*! ./ranges/min-version */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/min-version.js\")\nconst validRange = __webpack_require__(/*! ./ranges/valid */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/valid.js\")\nconst outside = __webpack_require__(/*! ./ranges/outside */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/outside.js\")\nconst gtr = __webpack_require__(/*! ./ranges/gtr */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/gtr.js\")\nconst ltr = __webpack_require__(/*! ./ranges/ltr */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/ltr.js\")\nconst intersects = __webpack_require__(/*! ./ranges/intersects */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/intersects.js\")\nconst simplifyRange = __webpack_require__(/*! ./ranges/simplify */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/simplify.js\")\nconst subset = __webpack_require__(/*! ./ranges/subset */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/subset.js\")\nmodule.exports = {\n  parse,\n  valid,\n  clean,\n  inc,\n  diff,\n  major,\n  minor,\n  patch,\n  prerelease,\n  compare,\n  rcompare,\n  compareLoose,\n  compareBuild,\n  sort,\n  rsort,\n  gt,\n  lt,\n  eq,\n  neq,\n  gte,\n  lte,\n  cmp,\n  coerce,\n  Comparator,\n  Range,\n  satisfies,\n  toComparators,\n  maxSatisfying,\n  minSatisfying,\n  minVersion,\n  validRange,\n  outside,\n  gtr,\n  ltr,\n  intersects,\n  simplifyRange,\n  subset,\n  SemVer,\n  re: internalRe.re,\n  src: internalRe.src,\n  tokens: internalRe.t,\n  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,\n  RELEASE_TYPES: constants.RELEASE_TYPES,\n  compareIdentifiers: identifiers.compareIdentifiers,\n  rcompareIdentifiers: identifiers.rcompareIdentifiers,\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsa0dBQWU7QUFDMUMsa0JBQWtCLG1CQUFPLENBQUMsZ0hBQXNCO0FBQ2hELGVBQWUsbUJBQU8sQ0FBQyx3R0FBa0I7QUFDekMsb0JBQW9CLG1CQUFPLENBQUMsb0hBQXdCO0FBQ3BELGNBQWMsbUJBQU8sQ0FBQywwR0FBbUI7QUFDekMsY0FBYyxtQkFBTyxDQUFDLDBHQUFtQjtBQUN6QyxjQUFjLG1CQUFPLENBQUMsMEdBQW1CO0FBQ3pDLFlBQVksbUJBQU8sQ0FBQyxzR0FBaUI7QUFDckMsYUFBYSxtQkFBTyxDQUFDLHdHQUFrQjtBQUN2QyxjQUFjLG1CQUFPLENBQUMsMEdBQW1CO0FBQ3pDLGNBQWMsbUJBQU8sQ0FBQywwR0FBbUI7QUFDekMsY0FBYyxtQkFBTyxDQUFDLDBHQUFtQjtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyxvSEFBd0I7QUFDbkQsZ0JBQWdCLG1CQUFPLENBQUMsOEdBQXFCO0FBQzdDLGlCQUFpQixtQkFBTyxDQUFDLGdIQUFzQjtBQUMvQyxxQkFBcUIsbUJBQU8sQ0FBQywwSEFBMkI7QUFDeEQscUJBQXFCLG1CQUFPLENBQUMsMEhBQTJCO0FBQ3hELGFBQWEsbUJBQU8sQ0FBQyx3R0FBa0I7QUFDdkMsY0FBYyxtQkFBTyxDQUFDLDBHQUFtQjtBQUN6QyxXQUFXLG1CQUFPLENBQUMsb0dBQWdCO0FBQ25DLFdBQVcsbUJBQU8sQ0FBQyxvR0FBZ0I7QUFDbkMsV0FBVyxtQkFBTyxDQUFDLG9HQUFnQjtBQUNuQyxZQUFZLG1CQUFPLENBQUMsc0dBQWlCO0FBQ3JDLFlBQVksbUJBQU8sQ0FBQyxzR0FBaUI7QUFDckMsWUFBWSxtQkFBTyxDQUFDLHNHQUFpQjtBQUNyQyxZQUFZLG1CQUFPLENBQUMsc0dBQWlCO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyw0R0FBb0I7QUFDM0MsbUJBQW1CLG1CQUFPLENBQUMsZ0hBQXNCO0FBQ2pELGNBQWMsbUJBQU8sQ0FBQyxzR0FBaUI7QUFDdkMsa0JBQWtCLG1CQUFPLENBQUMsa0hBQXVCO0FBQ2pELHNCQUFzQixtQkFBTyxDQUFDLHNIQUF5QjtBQUN2RCxzQkFBc0IsbUJBQU8sQ0FBQyxzSEFBeUI7QUFDdkQsc0JBQXNCLG1CQUFPLENBQUMsc0hBQXlCO0FBQ3ZELG1CQUFtQixtQkFBTyxDQUFDLGdIQUFzQjtBQUNqRCxtQkFBbUIsbUJBQU8sQ0FBQyxvR0FBZ0I7QUFDM0MsZ0JBQWdCLG1CQUFPLENBQUMsd0dBQWtCO0FBQzFDLFlBQVksbUJBQU8sQ0FBQyxnR0FBYztBQUNsQyxZQUFZLG1CQUFPLENBQUMsZ0dBQWM7QUFDbEMsbUJBQW1CLG1CQUFPLENBQUMsOEdBQXFCO0FBQ2hELHNCQUFzQixtQkFBTyxDQUFDLDBHQUFtQjtBQUNqRCxlQUFlLG1CQUFPLENBQUMsc0dBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBqdXN0IHByZS1sb2FkIGFsbCB0aGUgc3R1ZmYgdGhhdCBpbmRleC5qcyBsYXppbHkgZXhwb3J0c1xuY29uc3QgaW50ZXJuYWxSZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvcmUnKVxuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9jb25zdGFudHMnKVxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBpZGVudGlmaWVycyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvaWRlbnRpZmllcnMnKVxuY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9wYXJzZScpXG5jb25zdCB2YWxpZCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3ZhbGlkJylcbmNvbnN0IGNsZWFuID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvY2xlYW4nKVxuY29uc3QgaW5jID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvaW5jJylcbmNvbnN0IGRpZmYgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9kaWZmJylcbmNvbnN0IG1ham9yID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvbWFqb3InKVxuY29uc3QgbWlub3IgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9taW5vcicpXG5jb25zdCBwYXRjaCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3BhdGNoJylcbmNvbnN0IHByZXJlbGVhc2UgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9wcmVyZWxlYXNlJylcbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb21wYXJlJylcbmNvbnN0IHJjb21wYXJlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvcmNvbXBhcmUnKVxuY29uc3QgY29tcGFyZUxvb3NlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29tcGFyZS1sb29zZScpXG5jb25zdCBjb21wYXJlQnVpbGQgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb21wYXJlLWJ1aWxkJylcbmNvbnN0IHNvcnQgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9zb3J0JylcbmNvbnN0IHJzb3J0ID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvcnNvcnQnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9ndCcpXG5jb25zdCBsdCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2x0JylcbmNvbnN0IGVxID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvZXEnKVxuY29uc3QgbmVxID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvbmVxJylcbmNvbnN0IGd0ZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2d0ZScpXG5jb25zdCBsdGUgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9sdGUnKVxuY29uc3QgY21wID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvY21wJylcbmNvbnN0IGNvZXJjZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvZXJjZScpXG5jb25zdCBDb21wYXJhdG9yID0gcmVxdWlyZSgnLi9jbGFzc2VzL2NvbXBhcmF0b3InKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvc2F0aXNmaWVzJylcbmNvbnN0IHRvQ29tcGFyYXRvcnMgPSByZXF1aXJlKCcuL3Jhbmdlcy90by1jb21wYXJhdG9ycycpXG5jb25zdCBtYXhTYXRpc2Z5aW5nID0gcmVxdWlyZSgnLi9yYW5nZXMvbWF4LXNhdGlzZnlpbmcnKVxuY29uc3QgbWluU2F0aXNmeWluZyA9IHJlcXVpcmUoJy4vcmFuZ2VzL21pbi1zYXRpc2Z5aW5nJylcbmNvbnN0IG1pblZlcnNpb24gPSByZXF1aXJlKCcuL3Jhbmdlcy9taW4tdmVyc2lvbicpXG5jb25zdCB2YWxpZFJhbmdlID0gcmVxdWlyZSgnLi9yYW5nZXMvdmFsaWQnKVxuY29uc3Qgb3V0c2lkZSA9IHJlcXVpcmUoJy4vcmFuZ2VzL291dHNpZGUnKVxuY29uc3QgZ3RyID0gcmVxdWlyZSgnLi9yYW5nZXMvZ3RyJylcbmNvbnN0IGx0ciA9IHJlcXVpcmUoJy4vcmFuZ2VzL2x0cicpXG5jb25zdCBpbnRlcnNlY3RzID0gcmVxdWlyZSgnLi9yYW5nZXMvaW50ZXJzZWN0cycpXG5jb25zdCBzaW1wbGlmeVJhbmdlID0gcmVxdWlyZSgnLi9yYW5nZXMvc2ltcGxpZnknKVxuY29uc3Qgc3Vic2V0ID0gcmVxdWlyZSgnLi9yYW5nZXMvc3Vic2V0Jylcbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXJzZSxcbiAgdmFsaWQsXG4gIGNsZWFuLFxuICBpbmMsXG4gIGRpZmYsXG4gIG1ham9yLFxuICBtaW5vcixcbiAgcGF0Y2gsXG4gIHByZXJlbGVhc2UsXG4gIGNvbXBhcmUsXG4gIHJjb21wYXJlLFxuICBjb21wYXJlTG9vc2UsXG4gIGNvbXBhcmVCdWlsZCxcbiAgc29ydCxcbiAgcnNvcnQsXG4gIGd0LFxuICBsdCxcbiAgZXEsXG4gIG5lcSxcbiAgZ3RlLFxuICBsdGUsXG4gIGNtcCxcbiAgY29lcmNlLFxuICBDb21wYXJhdG9yLFxuICBSYW5nZSxcbiAgc2F0aXNmaWVzLFxuICB0b0NvbXBhcmF0b3JzLFxuICBtYXhTYXRpc2Z5aW5nLFxuICBtaW5TYXRpc2Z5aW5nLFxuICBtaW5WZXJzaW9uLFxuICB2YWxpZFJhbmdlLFxuICBvdXRzaWRlLFxuICBndHIsXG4gIGx0cixcbiAgaW50ZXJzZWN0cyxcbiAgc2ltcGxpZnlSYW5nZSxcbiAgc3Vic2V0LFxuICBTZW1WZXIsXG4gIHJlOiBpbnRlcm5hbFJlLnJlLFxuICBzcmM6IGludGVybmFsUmUuc3JjLFxuICB0b2tlbnM6IGludGVybmFsUmUudCxcbiAgU0VNVkVSX1NQRUNfVkVSU0lPTjogY29uc3RhbnRzLlNFTVZFUl9TUEVDX1ZFUlNJT04sXG4gIFJFTEVBU0VfVFlQRVM6IGNvbnN0YW50cy5SRUxFQVNFX1RZUEVTLFxuICBjb21wYXJlSWRlbnRpZmllcnM6IGlkZW50aWZpZXJzLmNvbXBhcmVJZGVudGlmaWVycyxcbiAgcmNvbXBhcmVJZGVudGlmaWVyczogaWRlbnRpZmllcnMucmNvbXBhcmVJZGVudGlmaWVycyxcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/constants.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/internal/constants.js ***!
  \************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nconst SEMVER_SPEC_VERSION = '2.0.0'\n\nconst MAX_LENGTH = 256\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n/* istanbul ignore next */ 9007199254740991\n\n// Max safe segment length for coercion.\nconst MAX_SAFE_COMPONENT_LENGTH = 16\n\n// Max safe length for a build identifier. The max length minus 6 characters for\n// the shortest version with a build 0.0.0+BUILD.\nconst MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6\n\nconst RELEASE_TYPES = [\n  'major',\n  'premajor',\n  'minor',\n  'preminor',\n  'patch',\n  'prepatch',\n  'prerelease',\n]\n\nmodule.exports = {\n  MAX_LENGTH,\n  MAX_SAFE_COMPONENT_LENGTH,\n  MAX_SAFE_BUILD_LENGTH,\n  MAX_SAFE_INTEGER,\n  RELEASE_TYPES,\n  SEMVER_SPEC_VERSION,\n  FLAG_INCLUDE_PRERELEASE: 0b001,\n  FLAG_LOOSE: 0b010,\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBOb3RlOiB0aGlzIGlzIHRoZSBzZW12ZXIub3JnIHZlcnNpb24gb2YgdGhlIHNwZWMgdGhhdCBpdCBpbXBsZW1lbnRzXG4vLyBOb3QgbmVjZXNzYXJpbHkgdGhlIHBhY2thZ2UgdmVyc2lvbiBvZiB0aGlzIGNvZGUuXG5jb25zdCBTRU1WRVJfU1BFQ19WRVJTSU9OID0gJzIuMC4wJ1xuXG5jb25zdCBNQVhfTEVOR1RIID0gMjU2XG5jb25zdCBNQVhfU0FGRV9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHxcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIDkwMDcxOTkyNTQ3NDA5OTFcblxuLy8gTWF4IHNhZmUgc2VnbWVudCBsZW5ndGggZm9yIGNvZXJjaW9uLlxuY29uc3QgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCA9IDE2XG5cbi8vIE1heCBzYWZlIGxlbmd0aCBmb3IgYSBidWlsZCBpZGVudGlmaWVyLiBUaGUgbWF4IGxlbmd0aCBtaW51cyA2IGNoYXJhY3RlcnMgZm9yXG4vLyB0aGUgc2hvcnRlc3QgdmVyc2lvbiB3aXRoIGEgYnVpbGQgMC4wLjArQlVJTEQuXG5jb25zdCBNQVhfU0FGRV9CVUlMRF9MRU5HVEggPSBNQVhfTEVOR1RIIC0gNlxuXG5jb25zdCBSRUxFQVNFX1RZUEVTID0gW1xuICAnbWFqb3InLFxuICAncHJlbWFqb3InLFxuICAnbWlub3InLFxuICAncHJlbWlub3InLFxuICAncGF0Y2gnLFxuICAncHJlcGF0Y2gnLFxuICAncHJlcmVsZWFzZScsXG5dXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBNQVhfTEVOR1RILFxuICBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RILFxuICBNQVhfU0FGRV9CVUlMRF9MRU5HVEgsXG4gIE1BWF9TQUZFX0lOVEVHRVIsXG4gIFJFTEVBU0VfVFlQRVMsXG4gIFNFTVZFUl9TUEVDX1ZFUlNJT04sXG4gIEZMQUdfSU5DTFVERV9QUkVSRUxFQVNFOiAwYjAwMSxcbiAgRkxBR19MT09TRTogMGIwMTAsXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/constants.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/debug.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/internal/debug.js ***!
  \********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst debug = (\n  typeof process === 'object' &&\n  process.env &&\n  process.env.NODE_DEBUG &&\n  /\\bsemver\\b/i.test(process.env.NODE_DEBUG)\n) ? (...args) => console.error('SEMVER', ...args)\n  : () => {}\n\nmodule.exports = debug\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2RlYnVnLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9kZWJ1Zy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgZGVidWcgPSAoXG4gIHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJlxuICBwcm9jZXNzLmVudiAmJlxuICBwcm9jZXNzLmVudi5OT0RFX0RFQlVHICYmXG4gIC9cXGJzZW12ZXJcXGIvaS50ZXN0KHByb2Nlc3MuZW52Lk5PREVfREVCVUcpXG4pID8gKC4uLmFyZ3MpID0+IGNvbnNvbGUuZXJyb3IoJ1NFTVZFUicsIC4uLmFyZ3MpXG4gIDogKCkgPT4ge31cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJ1Z1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/debug.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/identifiers.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/internal/identifiers.js ***!
  \**************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst numeric = /^[0-9]+$/\nconst compareIdentifiers = (a, b) => {\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a === b ? 0 : a < b ? -1 : 1\n  }\n\n  const anum = numeric.test(a)\n  const bnum = numeric.test(b)\n\n  if (anum && bnum) {\n    a = +a\n    b = +b\n  }\n\n  return a === b ? 0\n    : (anum && !bnum) ? -1\n    : (bnum && !anum) ? 1\n    : a < b ? -1\n    : 1\n}\n\nconst rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)\n\nmodule.exports = {\n  compareIdentifiers,\n  rcompareIdentifiers,\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2lkZW50aWZpZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2lkZW50aWZpZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBudW1lcmljID0gL15bMC05XSskL1xuY29uc3QgY29tcGFyZUlkZW50aWZpZXJzID0gKGEsIGIpID0+IHtcbiAgaWYgKHR5cGVvZiBhID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYiA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gYSA9PT0gYiA/IDAgOiBhIDwgYiA/IC0xIDogMVxuICB9XG5cbiAgY29uc3QgYW51bSA9IG51bWVyaWMudGVzdChhKVxuICBjb25zdCBibnVtID0gbnVtZXJpYy50ZXN0KGIpXG5cbiAgaWYgKGFudW0gJiYgYm51bSkge1xuICAgIGEgPSArYVxuICAgIGIgPSArYlxuICB9XG5cbiAgcmV0dXJuIGEgPT09IGIgPyAwXG4gICAgOiAoYW51bSAmJiAhYm51bSkgPyAtMVxuICAgIDogKGJudW0gJiYgIWFudW0pID8gMVxuICAgIDogYSA8IGIgPyAtMVxuICAgIDogMVxufVxuXG5jb25zdCByY29tcGFyZUlkZW50aWZpZXJzID0gKGEsIGIpID0+IGNvbXBhcmVJZGVudGlmaWVycyhiLCBhKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29tcGFyZUlkZW50aWZpZXJzLFxuICByY29tcGFyZUlkZW50aWZpZXJzLFxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/identifiers.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/lrucache.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/internal/lrucache.js ***!
  \***********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nclass LRUCache {\n  constructor () {\n    this.max = 1000\n    this.map = new Map()\n  }\n\n  get (key) {\n    const value = this.map.get(key)\n    if (value === undefined) {\n      return undefined\n    } else {\n      // Remove the key from the map and add it to the end\n      this.map.delete(key)\n      this.map.set(key, value)\n      return value\n    }\n  }\n\n  delete (key) {\n    return this.map.delete(key)\n  }\n\n  set (key, value) {\n    const deleted = this.delete(key)\n\n    if (!deleted && value !== undefined) {\n      // If cache is full, delete the least recently used item\n      if (this.map.size >= this.max) {\n        const firstKey = this.map.keys().next().value\n        this.delete(firstKey)\n      }\n\n      this.map.set(key, value)\n    }\n\n    return this\n  }\n}\n\nmodule.exports = LRUCache\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2xydWNhY2hlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvbHJ1Y2FjaGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNsYXNzIExSVUNhY2hlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMubWF4ID0gMTAwMFxuICAgIHRoaXMubWFwID0gbmV3IE1hcCgpXG4gIH1cblxuICBnZXQgKGtleSkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5tYXAuZ2V0KGtleSlcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIGtleSBmcm9tIHRoZSBtYXAgYW5kIGFkZCBpdCB0byB0aGUgZW5kXG4gICAgICB0aGlzLm1hcC5kZWxldGUoa2V5KVxuICAgICAgdGhpcy5tYXAuc2V0KGtleSwgdmFsdWUpXG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG4gIH1cblxuICBkZWxldGUgKGtleSkge1xuICAgIHJldHVybiB0aGlzLm1hcC5kZWxldGUoa2V5KVxuICB9XG5cbiAgc2V0IChrZXksIHZhbHVlKSB7XG4gICAgY29uc3QgZGVsZXRlZCA9IHRoaXMuZGVsZXRlKGtleSlcblxuICAgIGlmICghZGVsZXRlZCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBJZiBjYWNoZSBpcyBmdWxsLCBkZWxldGUgdGhlIGxlYXN0IHJlY2VudGx5IHVzZWQgaXRlbVxuICAgICAgaWYgKHRoaXMubWFwLnNpemUgPj0gdGhpcy5tYXgpIHtcbiAgICAgICAgY29uc3QgZmlyc3RLZXkgPSB0aGlzLm1hcC5rZXlzKCkubmV4dCgpLnZhbHVlXG4gICAgICAgIHRoaXMuZGVsZXRlKGZpcnN0S2V5KVxuICAgICAgfVxuXG4gICAgICB0aGlzLm1hcC5zZXQoa2V5LCB2YWx1ZSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTFJVQ2FjaGVcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/lrucache.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/parse-options.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/internal/parse-options.js ***!
  \****************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// parse out just the options we care about\nconst looseOption = Object.freeze({ loose: true })\nconst emptyOpts = Object.freeze({ })\nconst parseOptions = options => {\n  if (!options) {\n    return emptyOpts\n  }\n\n  if (typeof options !== 'object') {\n    return looseOption\n  }\n\n  return options\n}\nmodule.exports = parseOptions\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL3BhcnNlLW9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQSxvQ0FBb0MsYUFBYTtBQUNqRCxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvcGFyc2Utb3B0aW9ucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gcGFyc2Ugb3V0IGp1c3QgdGhlIG9wdGlvbnMgd2UgY2FyZSBhYm91dFxuY29uc3QgbG9vc2VPcHRpb24gPSBPYmplY3QuZnJlZXplKHsgbG9vc2U6IHRydWUgfSlcbmNvbnN0IGVtcHR5T3B0cyA9IE9iamVjdC5mcmVlemUoeyB9KVxuY29uc3QgcGFyc2VPcHRpb25zID0gb3B0aW9ucyA9PiB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIHJldHVybiBlbXB0eU9wdHNcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbG9vc2VPcHRpb25cbiAgfVxuXG4gIHJldHVybiBvcHRpb25zXG59XG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlT3B0aW9uc1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/parse-options.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/re.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/internal/re.js ***!
  \*****************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  MAX_SAFE_COMPONENT_LENGTH,\n  MAX_SAFE_BUILD_LENGTH,\n  MAX_LENGTH,\n} = __webpack_require__(/*! ./constants */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/constants.js\")\nconst debug = __webpack_require__(/*! ./debug */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/debug.js\")\nexports = module.exports = {}\n\n// The actual regexps go on exports.re\nconst re = exports.re = []\nconst safeRe = exports.safeRe = []\nconst src = exports.src = []\nconst safeSrc = exports.safeSrc = []\nconst t = exports.t = {}\nlet R = 0\n\nconst LETTERDASHNUMBER = '[a-zA-Z0-9-]'\n\n// Replace some greedy regex tokens to prevent regex dos issues. These regex are\n// used internally via the safeRe object since all inputs in this library get\n// normalized first to trim and collapse all extra whitespace. The original\n// regexes are exported for userland consumption and lower level usage. A\n// future breaking change could export the safer regex only with a note that\n// all input should have extra whitespace removed.\nconst safeRegexReplacements = [\n  ['\\\\s', 1],\n  ['\\\\d', MAX_LENGTH],\n  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],\n]\n\nconst makeSafeRegex = (value) => {\n  for (const [token, max] of safeRegexReplacements) {\n    value = value\n      .split(`${token}*`).join(`${token}{0,${max}}`)\n      .split(`${token}+`).join(`${token}{1,${max}}`)\n  }\n  return value\n}\n\nconst createToken = (name, value, isGlobal) => {\n  const safe = makeSafeRegex(value)\n  const index = R++\n  debug(name, index, value)\n  t[name] = index\n  src[index] = value\n  safeSrc[index] = safe\n  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)\n  safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined)\n}\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\ncreateToken('NUMERICIDENTIFIER', '0|[1-9]\\\\d*')\ncreateToken('NUMERICIDENTIFIERLOOSE', '\\\\d+')\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\ncreateToken('NONNUMERICIDENTIFIER', `\\\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`)\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\ncreateToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})`)\n\ncreateToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n// Non-numberic identifiers include numberic identifiers but can be longer.\n// Therefore non-numberic identifiers must go first.\n\ncreateToken('PRERELEASEIDENTIFIER', `(?:${src[t.NONNUMERICIDENTIFIER]\n}|${src[t.NUMERICIDENTIFIER]})`)\n\ncreateToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NONNUMERICIDENTIFIER]\n}|${src[t.NUMERICIDENTIFIERLOOSE]})`)\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\ncreateToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`)\n\ncreateToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\ncreateToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`)\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\ncreateToken('BUILD', `(?:\\\\+(${src[t.BUILDIDENTIFIER]\n}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`)\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\ncreateToken('FULLPLAIN', `v?${src[t.MAINVERSION]\n}${src[t.PRERELEASE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('FULL', `^${src[t.FULLPLAIN]}$`)\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\ncreateToken('LOOSEPLAIN', `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]\n}${src[t.PRERELEASELOOSE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)\n\ncreateToken('GTLT', '((?:<|>)?=?)')\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\ncreateToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`)\ncreateToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`)\n\ncreateToken('XRANGEPLAIN', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:${src[t.PRERELEASE]})?${\n                     src[t.BUILD]}?` +\n                   `)?)?`)\n\ncreateToken('XRANGEPLAINLOOSE', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:${src[t.PRERELEASELOOSE]})?${\n                          src[t.BUILD]}?` +\n                        `)?)?`)\n\ncreateToken('XRANGE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`)\ncreateToken('XRANGELOOSE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\ncreateToken('COERCEPLAIN', `${'(^|[^\\\\d])' +\n              '(\\\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`)\ncreateToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\\\d])`)\ncreateToken('COERCEFULL', src[t.COERCEPLAIN] +\n              `(?:${src[t.PRERELEASE]})?` +\n              `(?:${src[t.BUILD]})?` +\n              `(?:$|[^\\\\d])`)\ncreateToken('COERCERTL', src[t.COERCE], true)\ncreateToken('COERCERTLFULL', src[t.COERCEFULL], true)\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\ncreateToken('LONETILDE', '(?:~>?)')\n\ncreateToken('TILDETRIM', `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true)\nexports.tildeTrimReplace = '$1~'\n\ncreateToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\ncreateToken('LONECARET', '(?:\\\\^)')\n\ncreateToken('CARETTRIM', `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true)\nexports.caretTrimReplace = '$1^'\n\ncreateToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\ncreateToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`)\ncreateToken('COMPARATOR', `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`)\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\ncreateToken('COMPARATORTRIM', `(\\\\s*)${src[t.GTLT]\n}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)\nexports.comparatorTrimReplace = '$1$2$3'\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\ncreateToken('HYPHENRANGE', `^\\\\s*(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s+-\\\\s+` +\n                   `(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s*$`)\n\ncreateToken('HYPHENRANGELOOSE', `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s+-\\\\s+` +\n                        `(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s*$`)\n\n// Star ranges basically just allow anything at all.\ncreateToken('STAR', '(<|>)?=?\\\\s*\\\\*')\n// >=0.0.0 is like a star\ncreateToken('GTE0', '^\\\\s*>=\\\\s*0\\\\.0\\\\.0\\\\s*$')\ncreateToken('GTE0PRE', '^\\\\s*>=\\\\s*0\\\\.0\\\\.0-0\\\\s*$')\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL3JlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsdUdBQWE7QUFDekIsY0FBYyxtQkFBTyxDQUFDLCtGQUFTO0FBQy9COztBQUVBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLGVBQWUsY0FBYztBQUM3QixZQUFZLFdBQVc7QUFDdkIsZ0JBQWdCLGVBQWU7QUFDL0IsVUFBVSxTQUFTO0FBQ25COztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU0sWUFBWSxPQUFPLElBQUksS0FBSztBQUNsRCxnQkFBZ0IsTUFBTSxZQUFZLE9BQU8sSUFBSSxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9ELGlCQUFpQjs7QUFFckU7QUFDQTs7QUFFQSwrQkFBK0IseUJBQXlCO0FBQ3hELHVCQUF1Qix5QkFBeUI7QUFDaEQsdUJBQXVCLHlCQUF5Qjs7QUFFaEQsb0NBQW9DLDhCQUE4QjtBQUNsRSw0QkFBNEIsOEJBQThCO0FBQzFELDRCQUE0Qiw4QkFBOEI7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQyxDQUFDLEdBQUcseUJBQXlCOztBQUU3QiwrQ0FBK0M7QUFDL0MsQ0FBQyxHQUFHLDhCQUE4Qjs7QUFFbEM7QUFDQTtBQUNBOztBQUVBLGtDQUFrQztBQUNsQyxDQUFDLFFBQVEsNEJBQTRCOztBQUVyQyx3Q0FBd0M7QUFDeEMsQ0FBQyxRQUFRLGlDQUFpQzs7QUFFMUM7QUFDQTs7QUFFQSxrQ0FBa0MsaUJBQWlCOztBQUVuRDtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CLENBQUMsUUFBUSx1QkFBdUI7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUIsQ0FBQyxFQUFFLGtCQUFrQjtBQUNyQixlQUFlOztBQUVmLHdCQUF3QixpQkFBaUI7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxDQUFDLEVBQUUsdUJBQXVCO0FBQzFCLGVBQWU7O0FBRWYseUJBQXlCLGtCQUFrQjs7QUFFM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDhCQUE4QjtBQUN0RSxtQ0FBbUMseUJBQXlCOztBQUU1RCx1Q0FBdUMsd0JBQXdCO0FBQy9ELDZCQUE2Qix3QkFBd0I7QUFDckQsNkJBQTZCLHdCQUF3QjtBQUNyRCx5QkFBeUIsa0JBQWtCO0FBQzNDLGtDQUFrQztBQUNsQzs7QUFFQSw0Q0FBNEMsNkJBQTZCO0FBQ3pFLGtDQUFrQyw2QkFBNkI7QUFDL0Qsa0NBQWtDLDZCQUE2QjtBQUMvRCw4QkFBOEIsdUJBQXVCO0FBQ3JELHVDQUF1QztBQUN2Qzs7QUFFQSwwQkFBMEIsWUFBWSxNQUFNLG1CQUFtQjtBQUMvRCwrQkFBK0IsWUFBWSxNQUFNLHdCQUF3Qjs7QUFFekU7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixvQkFBb0IsSUFBSSxFQUFFLDJCQUEyQjtBQUNyRCwwQkFBMEIsSUFBSSwyQkFBMkI7QUFDekQsMEJBQTBCLElBQUksMkJBQTJCO0FBQ3pELHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLGlCQUFpQjtBQUNuRCx3QkFBd0I7O0FBRXhCLHlCQUF5QixpQkFBaUIsRUFBRSxtQkFBbUI7QUFDL0QsOEJBQThCLGlCQUFpQixFQUFFLHdCQUF3Qjs7QUFFekU7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxpQkFBaUI7QUFDbkQsd0JBQXdCOztBQUV4Qix5QkFBeUIsaUJBQWlCLEVBQUUsbUJBQW1CO0FBQy9ELDhCQUE4QixpQkFBaUIsRUFBRSx3QkFBd0I7O0FBRXpFO0FBQ0EsbUNBQW1DLFlBQVksT0FBTyxrQkFBa0I7QUFDeEUsOEJBQThCLFlBQVksT0FBTyxpQkFBaUI7O0FBRWxFO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsQ0FBQyxPQUFPLGtCQUFrQixHQUFHLG1CQUFtQjtBQUNoRCw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1CQUFtQjtBQUN2RDtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7O0FBRUEseUNBQXlDLHdCQUF3QjtBQUNqRTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvcmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCxcbiAgTUFYX1NBRkVfQlVJTERfTEVOR1RILFxuICBNQVhfTEVOR1RILFxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnLi9kZWJ1ZycpXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB7fVxuXG4vLyBUaGUgYWN0dWFsIHJlZ2V4cHMgZ28gb24gZXhwb3J0cy5yZVxuY29uc3QgcmUgPSBleHBvcnRzLnJlID0gW11cbmNvbnN0IHNhZmVSZSA9IGV4cG9ydHMuc2FmZVJlID0gW11cbmNvbnN0IHNyYyA9IGV4cG9ydHMuc3JjID0gW11cbmNvbnN0IHNhZmVTcmMgPSBleHBvcnRzLnNhZmVTcmMgPSBbXVxuY29uc3QgdCA9IGV4cG9ydHMudCA9IHt9XG5sZXQgUiA9IDBcblxuY29uc3QgTEVUVEVSREFTSE5VTUJFUiA9ICdbYS16QS1aMC05LV0nXG5cbi8vIFJlcGxhY2Ugc29tZSBncmVlZHkgcmVnZXggdG9rZW5zIHRvIHByZXZlbnQgcmVnZXggZG9zIGlzc3Vlcy4gVGhlc2UgcmVnZXggYXJlXG4vLyB1c2VkIGludGVybmFsbHkgdmlhIHRoZSBzYWZlUmUgb2JqZWN0IHNpbmNlIGFsbCBpbnB1dHMgaW4gdGhpcyBsaWJyYXJ5IGdldFxuLy8gbm9ybWFsaXplZCBmaXJzdCB0byB0cmltIGFuZCBjb2xsYXBzZSBhbGwgZXh0cmEgd2hpdGVzcGFjZS4gVGhlIG9yaWdpbmFsXG4vLyByZWdleGVzIGFyZSBleHBvcnRlZCBmb3IgdXNlcmxhbmQgY29uc3VtcHRpb24gYW5kIGxvd2VyIGxldmVsIHVzYWdlLiBBXG4vLyBmdXR1cmUgYnJlYWtpbmcgY2hhbmdlIGNvdWxkIGV4cG9ydCB0aGUgc2FmZXIgcmVnZXggb25seSB3aXRoIGEgbm90ZSB0aGF0XG4vLyBhbGwgaW5wdXQgc2hvdWxkIGhhdmUgZXh0cmEgd2hpdGVzcGFjZSByZW1vdmVkLlxuY29uc3Qgc2FmZVJlZ2V4UmVwbGFjZW1lbnRzID0gW1xuICBbJ1xcXFxzJywgMV0sXG4gIFsnXFxcXGQnLCBNQVhfTEVOR1RIXSxcbiAgW0xFVFRFUkRBU0hOVU1CRVIsIE1BWF9TQUZFX0JVSUxEX0xFTkdUSF0sXG5dXG5cbmNvbnN0IG1ha2VTYWZlUmVnZXggPSAodmFsdWUpID0+IHtcbiAgZm9yIChjb25zdCBbdG9rZW4sIG1heF0gb2Ygc2FmZVJlZ2V4UmVwbGFjZW1lbnRzKSB7XG4gICAgdmFsdWUgPSB2YWx1ZVxuICAgICAgLnNwbGl0KGAke3Rva2VufSpgKS5qb2luKGAke3Rva2VufXswLCR7bWF4fX1gKVxuICAgICAgLnNwbGl0KGAke3Rva2VufStgKS5qb2luKGAke3Rva2VufXsxLCR7bWF4fX1gKVxuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG5jb25zdCBjcmVhdGVUb2tlbiA9IChuYW1lLCB2YWx1ZSwgaXNHbG9iYWwpID0+IHtcbiAgY29uc3Qgc2FmZSA9IG1ha2VTYWZlUmVnZXgodmFsdWUpXG4gIGNvbnN0IGluZGV4ID0gUisrXG4gIGRlYnVnKG5hbWUsIGluZGV4LCB2YWx1ZSlcbiAgdFtuYW1lXSA9IGluZGV4XG4gIHNyY1tpbmRleF0gPSB2YWx1ZVxuICBzYWZlU3JjW2luZGV4XSA9IHNhZmVcbiAgcmVbaW5kZXhdID0gbmV3IFJlZ0V4cCh2YWx1ZSwgaXNHbG9iYWwgPyAnZycgOiB1bmRlZmluZWQpXG4gIHNhZmVSZVtpbmRleF0gPSBuZXcgUmVnRXhwKHNhZmUsIGlzR2xvYmFsID8gJ2cnIDogdW5kZWZpbmVkKVxufVxuXG4vLyBUaGUgZm9sbG93aW5nIFJlZ3VsYXIgRXhwcmVzc2lvbnMgY2FuIGJlIHVzZWQgZm9yIHRva2VuaXppbmcsXG4vLyB2YWxpZGF0aW5nLCBhbmQgcGFyc2luZyBTZW1WZXIgdmVyc2lvbiBzdHJpbmdzLlxuXG4vLyAjIyBOdW1lcmljIElkZW50aWZpZXJcbi8vIEEgc2luZ2xlIGAwYCwgb3IgYSBub24temVybyBkaWdpdCBmb2xsb3dlZCBieSB6ZXJvIG9yIG1vcmUgZGlnaXRzLlxuXG5jcmVhdGVUb2tlbignTlVNRVJJQ0lERU5USUZJRVInLCAnMHxbMS05XVxcXFxkKicpXG5jcmVhdGVUb2tlbignTlVNRVJJQ0lERU5USUZJRVJMT09TRScsICdcXFxcZCsnKVxuXG4vLyAjIyBOb24tbnVtZXJpYyBJZGVudGlmaWVyXG4vLyBaZXJvIG9yIG1vcmUgZGlnaXRzLCBmb2xsb3dlZCBieSBhIGxldHRlciBvciBoeXBoZW4sIGFuZCB0aGVuIHplcm8gb3Jcbi8vIG1vcmUgbGV0dGVycywgZGlnaXRzLCBvciBoeXBoZW5zLlxuXG5jcmVhdGVUb2tlbignTk9OTlVNRVJJQ0lERU5USUZJRVInLCBgXFxcXGQqW2EtekEtWi1dJHtMRVRURVJEQVNITlVNQkVSfSpgKVxuXG4vLyAjIyBNYWluIFZlcnNpb25cbi8vIFRocmVlIGRvdC1zZXBhcmF0ZWQgbnVtZXJpYyBpZGVudGlmaWVycy5cblxuY3JlYXRlVG9rZW4oJ01BSU5WRVJTSU9OJywgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19KWApXG5cbmNyZWF0ZVRva2VuKCdNQUlOVkVSU0lPTkxPT1NFJywgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlgKVxuXG4vLyAjIyBQcmUtcmVsZWFzZSBWZXJzaW9uIElkZW50aWZpZXJcbi8vIEEgbnVtZXJpYyBpZGVudGlmaWVyLCBvciBhIG5vbi1udW1lcmljIGlkZW50aWZpZXIuXG4vLyBOb24tbnVtYmVyaWMgaWRlbnRpZmllcnMgaW5jbHVkZSBudW1iZXJpYyBpZGVudGlmaWVycyBidXQgY2FuIGJlIGxvbmdlci5cbi8vIFRoZXJlZm9yZSBub24tbnVtYmVyaWMgaWRlbnRpZmllcnMgbXVzdCBnbyBmaXJzdC5cblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0VJREVOVElGSUVSJywgYCg/OiR7c3JjW3QuTk9OTlVNRVJJQ0lERU5USUZJRVJdXG59fCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfSlgKVxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRScsIGAoPzoke3NyY1t0Lk5PTk5VTUVSSUNJREVOVElGSUVSXVxufXwke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlgKVxuXG4vLyAjIyBQcmUtcmVsZWFzZSBWZXJzaW9uXG4vLyBIeXBoZW4sIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIGRvdC1zZXBhcmF0ZWQgcHJlLXJlbGVhc2UgdmVyc2lvblxuLy8gaWRlbnRpZmllcnMuXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFJywgYCg/Oi0oJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUl1cbn0oPzpcXFxcLiR7c3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJdfSkqKSlgKVxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRUxPT1NFJywgYCg/Oi0/KCR7c3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV1cbn0oPzpcXFxcLiR7c3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV19KSopKWApXG5cbi8vICMjIEJ1aWxkIE1ldGFkYXRhIElkZW50aWZpZXJcbi8vIEFueSBjb21iaW5hdGlvbiBvZiBkaWdpdHMsIGxldHRlcnMsIG9yIGh5cGhlbnMuXG5cbmNyZWF0ZVRva2VuKCdCVUlMRElERU5USUZJRVInLCBgJHtMRVRURVJEQVNITlVNQkVSfStgKVxuXG4vLyAjIyBCdWlsZCBNZXRhZGF0YVxuLy8gUGx1cyBzaWduLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBwZXJpb2Qtc2VwYXJhdGVkIGJ1aWxkIG1ldGFkYXRhXG4vLyBpZGVudGlmaWVycy5cblxuY3JlYXRlVG9rZW4oJ0JVSUxEJywgYCg/OlxcXFwrKCR7c3JjW3QuQlVJTERJREVOVElGSUVSXVxufSg/OlxcXFwuJHtzcmNbdC5CVUlMRElERU5USUZJRVJdfSkqKSlgKVxuXG4vLyAjIyBGdWxsIFZlcnNpb24gU3RyaW5nXG4vLyBBIG1haW4gdmVyc2lvbiwgZm9sbG93ZWQgb3B0aW9uYWxseSBieSBhIHByZS1yZWxlYXNlIHZlcnNpb24gYW5kXG4vLyBidWlsZCBtZXRhZGF0YS5cblxuLy8gTm90ZSB0aGF0IHRoZSBvbmx5IG1ham9yLCBtaW5vciwgcGF0Y2gsIGFuZCBwcmUtcmVsZWFzZSBzZWN0aW9ucyBvZlxuLy8gdGhlIHZlcnNpb24gc3RyaW5nIGFyZSBjYXB0dXJpbmcgZ3JvdXBzLiAgVGhlIGJ1aWxkIG1ldGFkYXRhIGlzIG5vdCBhXG4vLyBjYXB0dXJpbmcgZ3JvdXAsIGJlY2F1c2UgaXQgc2hvdWxkIG5vdCBldmVyIGJlIHVzZWQgaW4gdmVyc2lvblxuLy8gY29tcGFyaXNvbi5cblxuY3JlYXRlVG9rZW4oJ0ZVTExQTEFJTicsIGB2PyR7c3JjW3QuTUFJTlZFUlNJT05dXG59JHtzcmNbdC5QUkVSRUxFQVNFXX0/JHtcbiAgc3JjW3QuQlVJTERdfT9gKVxuXG5jcmVhdGVUb2tlbignRlVMTCcsIGBeJHtzcmNbdC5GVUxMUExBSU5dfSRgKVxuXG4vLyBsaWtlIGZ1bGwsIGJ1dCBhbGxvd3MgdjEuMi4zIGFuZCA9MS4yLjMsIHdoaWNoIHBlb3BsZSBkbyBzb21ldGltZXMuXG4vLyBhbHNvLCAxLjAuMGFscGhhMSAocHJlcmVsZWFzZSB3aXRob3V0IHRoZSBoeXBoZW4pIHdoaWNoIGlzIHByZXR0eVxuLy8gY29tbW9uIGluIHRoZSBucG0gcmVnaXN0cnkuXG5jcmVhdGVUb2tlbignTE9PU0VQTEFJTicsIGBbdj1cXFxcc10qJHtzcmNbdC5NQUlOVkVSU0lPTkxPT1NFXVxufSR7c3JjW3QuUFJFUkVMRUFTRUxPT1NFXX0/JHtcbiAgc3JjW3QuQlVJTERdfT9gKVxuXG5jcmVhdGVUb2tlbignTE9PU0UnLCBgXiR7c3JjW3QuTE9PU0VQTEFJTl19JGApXG5cbmNyZWF0ZVRva2VuKCdHVExUJywgJygoPzo8fD4pPz0/KScpXG5cbi8vIFNvbWV0aGluZyBsaWtlIFwiMi4qXCIgb3IgXCIxLjIueFwiLlxuLy8gTm90ZSB0aGF0IFwieC54XCIgaXMgYSB2YWxpZCB4UmFuZ2UgaWRlbnRpZmVyLCBtZWFuaW5nIFwiYW55IHZlcnNpb25cIlxuLy8gT25seSB0aGUgZmlyc3QgaXRlbSBpcyBzdHJpY3RseSByZXF1aXJlZC5cbmNyZWF0ZVRva2VuKCdYUkFOR0VJREVOVElGSUVSTE9PU0UnLCBgJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX18eHxYfFxcXFwqYClcbmNyZWF0ZVRva2VuKCdYUkFOR0VJREVOVElGSUVSJywgYCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfXx4fFh8XFxcXCpgKVxuXG5jcmVhdGVUb2tlbignWFJBTkdFUExBSU4nLCBgW3Y9XFxcXHNdKigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJdfSlgICtcbiAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGAoPzoke3NyY1t0LlBSRVJFTEVBU0VdfSk/JHtcbiAgICAgICAgICAgICAgICAgICAgIHNyY1t0LkJVSUxEXX0/YCArXG4gICAgICAgICAgICAgICAgICAgYCk/KT9gKVxuXG5jcmVhdGVUb2tlbignWFJBTkdFUExBSU5MT09TRScsIGBbdj1cXFxcc10qKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJMT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCg/OiR7c3JjW3QuUFJFUkVMRUFTRUxPT1NFXX0pPyR7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1t0LkJVSUxEXX0/YCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKT8pP2ApXG5cbmNyZWF0ZVRva2VuKCdYUkFOR0UnLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqJHtzcmNbdC5YUkFOR0VQTEFJTl19JGApXG5jcmVhdGVUb2tlbignWFJBTkdFTE9PU0UnLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqJHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0kYClcblxuLy8gQ29lcmNpb24uXG4vLyBFeHRyYWN0IGFueXRoaW5nIHRoYXQgY291bGQgY29uY2VpdmFibHkgYmUgYSBwYXJ0IG9mIGEgdmFsaWQgc2VtdmVyXG5jcmVhdGVUb2tlbignQ09FUkNFUExBSU4nLCBgJHsnKF58W15cXFxcZF0pJyArXG4gICAgICAgICAgICAgICcoXFxcXGR7MSwnfSR7TUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSH19KWAgK1xuICAgICAgICAgICAgICBgKD86XFxcXC4oXFxcXGR7MSwke01BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEh9fSkpP2AgK1xuICAgICAgICAgICAgICBgKD86XFxcXC4oXFxcXGR7MSwke01BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEh9fSkpP2ApXG5jcmVhdGVUb2tlbignQ09FUkNFJywgYCR7c3JjW3QuQ09FUkNFUExBSU5dfSg/OiR8W15cXFxcZF0pYClcbmNyZWF0ZVRva2VuKCdDT0VSQ0VGVUxMJywgc3JjW3QuQ09FUkNFUExBSU5dICtcbiAgICAgICAgICAgICAgYCg/OiR7c3JjW3QuUFJFUkVMRUFTRV19KT9gICtcbiAgICAgICAgICAgICAgYCg/OiR7c3JjW3QuQlVJTERdfSk/YCArXG4gICAgICAgICAgICAgIGAoPzokfFteXFxcXGRdKWApXG5jcmVhdGVUb2tlbignQ09FUkNFUlRMJywgc3JjW3QuQ09FUkNFXSwgdHJ1ZSlcbmNyZWF0ZVRva2VuKCdDT0VSQ0VSVExGVUxMJywgc3JjW3QuQ09FUkNFRlVMTF0sIHRydWUpXG5cbi8vIFRpbGRlIHJhbmdlcy5cbi8vIE1lYW5pbmcgaXMgXCJyZWFzb25hYmx5IGF0IG9yIGdyZWF0ZXIgdGhhblwiXG5jcmVhdGVUb2tlbignTE9ORVRJTERFJywgJyg/On4+PyknKVxuXG5jcmVhdGVUb2tlbignVElMREVUUklNJywgYChcXFxccyopJHtzcmNbdC5MT05FVElMREVdfVxcXFxzK2AsIHRydWUpXG5leHBvcnRzLnRpbGRlVHJpbVJlcGxhY2UgPSAnJDF+J1xuXG5jcmVhdGVUb2tlbignVElMREUnLCBgXiR7c3JjW3QuTE9ORVRJTERFXX0ke3NyY1t0LlhSQU5HRVBMQUlOXX0kYClcbmNyZWF0ZVRva2VuKCdUSUxERUxPT1NFJywgYF4ke3NyY1t0LkxPTkVUSUxERV19JHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0kYClcblxuLy8gQ2FyZXQgcmFuZ2VzLlxuLy8gTWVhbmluZyBpcyBcImF0IGxlYXN0IGFuZCBiYWNrd2FyZHMgY29tcGF0aWJsZSB3aXRoXCJcbmNyZWF0ZVRva2VuKCdMT05FQ0FSRVQnLCAnKD86XFxcXF4pJylcblxuY3JlYXRlVG9rZW4oJ0NBUkVUVFJJTScsIGAoXFxcXHMqKSR7c3JjW3QuTE9ORUNBUkVUXX1cXFxccytgLCB0cnVlKVxuZXhwb3J0cy5jYXJldFRyaW1SZXBsYWNlID0gJyQxXidcblxuY3JlYXRlVG9rZW4oJ0NBUkVUJywgYF4ke3NyY1t0LkxPTkVDQVJFVF19JHtzcmNbdC5YUkFOR0VQTEFJTl19JGApXG5jcmVhdGVUb2tlbignQ0FSRVRMT09TRScsIGBeJHtzcmNbdC5MT05FQ0FSRVRdfSR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19JGApXG5cbi8vIEEgc2ltcGxlIGd0L2x0L2VxIHRoaW5nLCBvciBqdXN0IFwiXCIgdG8gaW5kaWNhdGUgXCJhbnkgdmVyc2lvblwiXG5jcmVhdGVUb2tlbignQ09NUEFSQVRPUkxPT1NFJywgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKigke3NyY1t0LkxPT1NFUExBSU5dfSkkfF4kYClcbmNyZWF0ZVRva2VuKCdDT01QQVJBVE9SJywgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKigke3NyY1t0LkZVTExQTEFJTl19KSR8XiRgKVxuXG4vLyBBbiBleHByZXNzaW9uIHRvIHN0cmlwIGFueSB3aGl0ZXNwYWNlIGJldHdlZW4gdGhlIGd0bHQgYW5kIHRoZSB0aGluZ1xuLy8gaXQgbW9kaWZpZXMsIHNvIHRoYXQgYD4gMS4yLjNgID09PiBgPjEuMi4zYFxuY3JlYXRlVG9rZW4oJ0NPTVBBUkFUT1JUUklNJywgYChcXFxccyopJHtzcmNbdC5HVExUXVxufVxcXFxzKigke3NyY1t0LkxPT1NFUExBSU5dfXwke3NyY1t0LlhSQU5HRVBMQUlOXX0pYCwgdHJ1ZSlcbmV4cG9ydHMuY29tcGFyYXRvclRyaW1SZXBsYWNlID0gJyQxJDIkMydcblxuLy8gU29tZXRoaW5nIGxpa2UgYDEuMi4zIC0gMS4yLjRgXG4vLyBOb3RlIHRoYXQgdGhlc2UgYWxsIHVzZSB0aGUgbG9vc2UgZm9ybSwgYmVjYXVzZSB0aGV5J2xsIGJlXG4vLyBjaGVja2VkIGFnYWluc3QgZWl0aGVyIHRoZSBzdHJpY3Qgb3IgbG9vc2UgY29tcGFyYXRvciBmb3JtXG4vLyBsYXRlci5cbmNyZWF0ZVRva2VuKCdIWVBIRU5SQU5HRScsIGBeXFxcXHMqKCR7c3JjW3QuWFJBTkdFUExBSU5dfSlgICtcbiAgICAgICAgICAgICAgICAgICBgXFxcXHMrLVxcXFxzK2AgK1xuICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5YUkFOR0VQTEFJTl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGBcXFxccyokYClcblxuY3JlYXRlVG9rZW4oJ0hZUEhFTlJBTkdFTE9PU0UnLCBgXlxcXFxzKigke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBcXFxccystXFxcXHMrYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYFxcXFxzKiRgKVxuXG4vLyBTdGFyIHJhbmdlcyBiYXNpY2FsbHkganVzdCBhbGxvdyBhbnl0aGluZyBhdCBhbGwuXG5jcmVhdGVUb2tlbignU1RBUicsICcoPHw+KT89P1xcXFxzKlxcXFwqJylcbi8vID49MC4wLjAgaXMgbGlrZSBhIHN0YXJcbmNyZWF0ZVRva2VuKCdHVEUwJywgJ15cXFxccyo+PVxcXFxzKjBcXFxcLjBcXFxcLjBcXFxccyokJylcbmNyZWF0ZVRva2VuKCdHVEUwUFJFJywgJ15cXFxccyo+PVxcXFxzKjBcXFxcLjBcXFxcLjAtMFxcXFxzKiQnKVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/internal/re.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/gtr.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/ranges/gtr.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// Determine if version is greater than all the versions possible in the range.\nconst outside = __webpack_require__(/*! ./outside */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/outside.js\")\nconst gtr = (version, range, options) => outside(version, range, '>', options)\nmodule.exports = gtr\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9ndHIuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxpR0FBVztBQUNuQztBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvZ3RyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBEZXRlcm1pbmUgaWYgdmVyc2lvbiBpcyBncmVhdGVyIHRoYW4gYWxsIHRoZSB2ZXJzaW9ucyBwb3NzaWJsZSBpbiB0aGUgcmFuZ2UuXG5jb25zdCBvdXRzaWRlID0gcmVxdWlyZSgnLi9vdXRzaWRlJylcbmNvbnN0IGd0ciA9ICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykgPT4gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgJz4nLCBvcHRpb25zKVxubW9kdWxlLmV4cG9ydHMgPSBndHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/gtr.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/intersects.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/ranges/intersects.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Range = __webpack_require__(/*! ../classes/range */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/range.js\")\nconst intersects = (r1, r2, options) => {\n  r1 = new Range(r1, options)\n  r2 = new Range(r2, options)\n  return r1.intersects(r2, options)\n}\nmodule.exports = intersects\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9pbnRlcnNlY3RzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGNBQWMsbUJBQU8sQ0FBQyx1R0FBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvaW50ZXJzZWN0cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IGludGVyc2VjdHMgPSAocjEsIHIyLCBvcHRpb25zKSA9PiB7XG4gIHIxID0gbmV3IFJhbmdlKHIxLCBvcHRpb25zKVxuICByMiA9IG5ldyBSYW5nZShyMiwgb3B0aW9ucylcbiAgcmV0dXJuIHIxLmludGVyc2VjdHMocjIsIG9wdGlvbnMpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGludGVyc2VjdHNcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/intersects.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/ltr.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/ranges/ltr.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst outside = __webpack_require__(/*! ./outside */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/outside.js\")\n// Determine if version is less than all the versions possible in the range\nconst ltr = (version, range, options) => outside(version, range, '<', options)\nmodule.exports = ltr\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9sdHIuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZ0JBQWdCLG1CQUFPLENBQUMsaUdBQVc7QUFDbkM7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbHRyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBvdXRzaWRlID0gcmVxdWlyZSgnLi9vdXRzaWRlJylcbi8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGxlc3MgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZVxuY29uc3QgbHRyID0gKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSA9PiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPCcsIG9wdGlvbnMpXG5tb2R1bGUuZXhwb3J0cyA9IGx0clxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/ltr.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/max-satisfying.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/ranges/max-satisfying.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SemVer = __webpack_require__(/*! ../classes/semver */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/semver.js\")\nconst Range = __webpack_require__(/*! ../classes/range */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/range.js\")\n\nconst maxSatisfying = (versions, range, options) => {\n  let max = null\n  let maxSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v\n        maxSV = new SemVer(max, options)\n      }\n    }\n  })\n  return max\n}\nmodule.exports = maxSatisfying\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9tYXgtc2F0aXNmeWluZy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMseUdBQW1CO0FBQzFDLGNBQWMsbUJBQU8sQ0FBQyx1R0FBa0I7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21heC1zYXRpc2Z5aW5nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuXG5jb25zdCBtYXhTYXRpc2Z5aW5nID0gKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBsZXQgbWF4ID0gbnVsbFxuICBsZXQgbWF4U1YgPSBudWxsXG4gIGxldCByYW5nZU9iaiA9IG51bGxcbiAgdHJ5IHtcbiAgICByYW5nZU9iaiA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZlcnNpb25zLmZvckVhY2goKHYpID0+IHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkge1xuICAgICAgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBvcHRpb25zKVxuICAgICAgaWYgKCFtYXggfHwgbWF4U1YuY29tcGFyZSh2KSA9PT0gLTEpIHtcbiAgICAgICAgLy8gY29tcGFyZShtYXgsIHYsIHRydWUpXG4gICAgICAgIG1heCA9IHZcbiAgICAgICAgbWF4U1YgPSBuZXcgU2VtVmVyKG1heCwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBtYXhcbn1cbm1vZHVsZS5leHBvcnRzID0gbWF4U2F0aXNmeWluZ1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/max-satisfying.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/min-satisfying.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/ranges/min-satisfying.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SemVer = __webpack_require__(/*! ../classes/semver */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/semver.js\")\nconst Range = __webpack_require__(/*! ../classes/range */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/range.js\")\nconst minSatisfying = (versions, range, options) => {\n  let min = null\n  let minSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v\n        minSV = new SemVer(min, options)\n      }\n    }\n  })\n  return min\n}\nmodule.exports = minSatisfying\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9taW4tc2F0aXNmeWluZy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMseUdBQW1CO0FBQzFDLGNBQWMsbUJBQU8sQ0FBQyx1R0FBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbWluLXNhdGlzZnlpbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBtaW5TYXRpc2Z5aW5nID0gKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBsZXQgbWluID0gbnVsbFxuICBsZXQgbWluU1YgPSBudWxsXG4gIGxldCByYW5nZU9iaiA9IG51bGxcbiAgdHJ5IHtcbiAgICByYW5nZU9iaiA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZlcnNpb25zLmZvckVhY2goKHYpID0+IHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkge1xuICAgICAgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBvcHRpb25zKVxuICAgICAgaWYgKCFtaW4gfHwgbWluU1YuY29tcGFyZSh2KSA9PT0gMSkge1xuICAgICAgICAvLyBjb21wYXJlKG1pbiwgdiwgdHJ1ZSlcbiAgICAgICAgbWluID0gdlxuICAgICAgICBtaW5TViA9IG5ldyBTZW1WZXIobWluLCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIG1pblxufVxubW9kdWxlLmV4cG9ydHMgPSBtaW5TYXRpc2Z5aW5nXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/min-satisfying.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/min-version.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/ranges/min-version.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SemVer = __webpack_require__(/*! ../classes/semver */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/semver.js\")\nconst Range = __webpack_require__(/*! ../classes/range */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/range.js\")\nconst gt = __webpack_require__(/*! ../functions/gt */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/gt.js\")\n\nconst minVersion = (range, loose) => {\n  range = new Range(range, loose)\n\n  let minver = new SemVer('0.0.0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = new SemVer('0.0.0-0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = null\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let setMin = null\n    comparators.forEach((comparator) => {\n      // Clone to avoid manipulating the comparator's semver object.\n      const compver = new SemVer(comparator.semver.version)\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++\n          } else {\n            compver.prerelease.push(0)\n          }\n          compver.raw = compver.format()\n          /* fallthrough */\n        case '':\n        case '>=':\n          if (!setMin || gt(compver, setMin)) {\n            setMin = compver\n          }\n          break\n        case '<':\n        case '<=':\n          /* Ignore maximum versions */\n          break\n        /* istanbul ignore next */\n        default:\n          throw new Error(`Unexpected operation: ${comparator.operator}`)\n      }\n    })\n    if (setMin && (!minver || gt(minver, setMin))) {\n      minver = setMin\n    }\n  }\n\n  if (minver && range.test(minver)) {\n    return minver\n  }\n\n  return null\n}\nmodule.exports = minVersion\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9taW4tdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMseUdBQW1CO0FBQzFDLGNBQWMsbUJBQU8sQ0FBQyx1R0FBa0I7QUFDeEMsV0FBVyxtQkFBTyxDQUFDLHFHQUFpQjs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxvQkFBb0I7QUFDdkU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21pbi12ZXJzaW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3QnKVxuXG5jb25zdCBtaW5WZXJzaW9uID0gKHJhbmdlLCBsb29zZSkgPT4ge1xuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpXG5cbiAgbGV0IG1pbnZlciA9IG5ldyBTZW1WZXIoJzAuMC4wJylcbiAgaWYgKHJhbmdlLnRlc3QobWludmVyKSkge1xuICAgIHJldHVybiBtaW52ZXJcbiAgfVxuXG4gIG1pbnZlciA9IG5ldyBTZW1WZXIoJzAuMC4wLTAnKVxuICBpZiAocmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgbWludmVyID0gbnVsbFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlLnNldC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldXG5cbiAgICBsZXQgc2V0TWluID0gbnVsbFxuICAgIGNvbXBhcmF0b3JzLmZvckVhY2goKGNvbXBhcmF0b3IpID0+IHtcbiAgICAgIC8vIENsb25lIHRvIGF2b2lkIG1hbmlwdWxhdGluZyB0aGUgY29tcGFyYXRvcidzIHNlbXZlciBvYmplY3QuXG4gICAgICBjb25zdCBjb21wdmVyID0gbmV3IFNlbVZlcihjb21wYXJhdG9yLnNlbXZlci52ZXJzaW9uKVxuICAgICAgc3dpdGNoIChjb21wYXJhdG9yLm9wZXJhdG9yKSB7XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgIGlmIChjb21wdmVyLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb21wdmVyLnBhdGNoKytcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcHZlci5wcmVyZWxlYXNlLnB1c2goMClcbiAgICAgICAgICB9XG4gICAgICAgICAgY29tcHZlci5yYXcgPSBjb21wdmVyLmZvcm1hdCgpXG4gICAgICAgICAgLyogZmFsbHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgIGlmICghc2V0TWluIHx8IGd0KGNvbXB2ZXIsIHNldE1pbikpIHtcbiAgICAgICAgICAgIHNldE1pbiA9IGNvbXB2ZXJcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAvKiBJZ25vcmUgbWF4aW11bSB2ZXJzaW9ucyAqL1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIG9wZXJhdGlvbjogJHtjb21wYXJhdG9yLm9wZXJhdG9yfWApXG4gICAgICB9XG4gICAgfSlcbiAgICBpZiAoc2V0TWluICYmICghbWludmVyIHx8IGd0KG1pbnZlciwgc2V0TWluKSkpIHtcbiAgICAgIG1pbnZlciA9IHNldE1pblxuICAgIH1cbiAgfVxuXG4gIGlmIChtaW52ZXIgJiYgcmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gbWluVmVyc2lvblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/min-version.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/outside.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/ranges/outside.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SemVer = __webpack_require__(/*! ../classes/semver */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/semver.js\")\nconst Comparator = __webpack_require__(/*! ../classes/comparator */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/comparator.js\")\nconst { ANY } = Comparator\nconst Range = __webpack_require__(/*! ../classes/range */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/range.js\")\nconst satisfies = __webpack_require__(/*! ../functions/satisfies */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/satisfies.js\")\nconst gt = __webpack_require__(/*! ../functions/gt */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/gt.js\")\nconst lt = __webpack_require__(/*! ../functions/lt */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/lt.js\")\nconst lte = __webpack_require__(/*! ../functions/lte */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/lte.js\")\nconst gte = __webpack_require__(/*! ../functions/gte */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/gte.js\")\n\nconst outside = (version, range, hilo, options) => {\n  version = new SemVer(version, options)\n  range = new Range(range, options)\n\n  let gtfn, ltefn, ltfn, comp, ecomp\n  switch (hilo) {\n    case '>':\n      gtfn = gt\n      ltefn = lte\n      ltfn = lt\n      comp = '>'\n      ecomp = '>='\n      break\n    case '<':\n      gtfn = lt\n      ltefn = gte\n      ltfn = gt\n      comp = '<'\n      ecomp = '<='\n      break\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"')\n  }\n\n  // If it satisfies the range it is not outside\n  if (satisfies(version, range, options)) {\n    return false\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let high = null\n    let low = null\n\n    comparators.forEach((comparator) => {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator\n      low = low || comparator\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator\n      }\n    })\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false\n    }\n  }\n  return true\n}\n\nmodule.exports = outside\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9vdXRzaWRlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyx5R0FBbUI7QUFDMUMsbUJBQW1CLG1CQUFPLENBQUMsaUhBQXVCO0FBQ2xELFFBQVEsTUFBTTtBQUNkLGNBQWMsbUJBQU8sQ0FBQyx1R0FBa0I7QUFDeEMsa0JBQWtCLG1CQUFPLENBQUMsbUhBQXdCO0FBQ2xELFdBQVcsbUJBQU8sQ0FBQyxxR0FBaUI7QUFDcEMsV0FBVyxtQkFBTyxDQUFDLHFHQUFpQjtBQUNwQyxZQUFZLG1CQUFPLENBQUMsdUdBQWtCO0FBQ3RDLFlBQVksbUJBQU8sQ0FBQyx1R0FBa0I7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixzQkFBc0I7QUFDeEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvb3V0c2lkZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvY29tcGFyYXRvcicpXG5jb25zdCB7IEFOWSB9ID0gQ29tcGFyYXRvclxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9zYXRpc2ZpZXMnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3QnKVxuY29uc3QgbHQgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvbHQnKVxuY29uc3QgbHRlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2x0ZScpXG5jb25zdCBndGUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3RlJylcblxuY29uc3Qgb3V0c2lkZSA9ICh2ZXJzaW9uLCByYW5nZSwgaGlsbywgb3B0aW9ucykgPT4ge1xuICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKVxuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcblxuICBsZXQgZ3RmbiwgbHRlZm4sIGx0Zm4sIGNvbXAsIGVjb21wXG4gIHN3aXRjaCAoaGlsbykge1xuICAgIGNhc2UgJz4nOlxuICAgICAgZ3RmbiA9IGd0XG4gICAgICBsdGVmbiA9IGx0ZVxuICAgICAgbHRmbiA9IGx0XG4gICAgICBjb21wID0gJz4nXG4gICAgICBlY29tcCA9ICc+PSdcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnPCc6XG4gICAgICBndGZuID0gbHRcbiAgICAgIGx0ZWZuID0gZ3RlXG4gICAgICBsdGZuID0gZ3RcbiAgICAgIGNvbXAgPSAnPCdcbiAgICAgIGVjb21wID0gJzw9J1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBwcm92aWRlIGEgaGlsbyB2YWwgb2YgXCI8XCIgb3IgXCI+XCInKVxuICB9XG5cbiAgLy8gSWYgaXQgc2F0aXNmaWVzIHRoZSByYW5nZSBpdCBpcyBub3Qgb3V0c2lkZVxuICBpZiAoc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gRnJvbSBub3cgb24sIHZhcmlhYmxlIHRlcm1zIGFyZSBhcyBpZiB3ZSdyZSBpbiBcImd0clwiIG1vZGUuXG4gIC8vIGJ1dCBub3RlIHRoYXQgZXZlcnl0aGluZyBpcyBmbGlwcGVkIGZvciB0aGUgXCJsdHJcIiBmdW5jdGlvbi5cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlLnNldC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldXG5cbiAgICBsZXQgaGlnaCA9IG51bGxcbiAgICBsZXQgbG93ID0gbnVsbFxuXG4gICAgY29tcGFyYXRvcnMuZm9yRWFjaCgoY29tcGFyYXRvcikgPT4ge1xuICAgICAgaWYgKGNvbXBhcmF0b3Iuc2VtdmVyID09PSBBTlkpIHtcbiAgICAgICAgY29tcGFyYXRvciA9IG5ldyBDb21wYXJhdG9yKCc+PTAuMC4wJylcbiAgICAgIH1cbiAgICAgIGhpZ2ggPSBoaWdoIHx8IGNvbXBhcmF0b3JcbiAgICAgIGxvdyA9IGxvdyB8fCBjb21wYXJhdG9yXG4gICAgICBpZiAoZ3Rmbihjb21wYXJhdG9yLnNlbXZlciwgaGlnaC5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgIGhpZ2ggPSBjb21wYXJhdG9yXG4gICAgICB9IGVsc2UgaWYgKGx0Zm4oY29tcGFyYXRvci5zZW12ZXIsIGxvdy5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgIGxvdyA9IGNvbXBhcmF0b3JcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gSWYgdGhlIGVkZ2UgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhIG9wZXJhdG9yIHRoZW4gb3VyIHZlcnNpb25cbiAgICAvLyBpc24ndCBvdXRzaWRlIGl0XG4gICAgaWYgKGhpZ2gub3BlcmF0b3IgPT09IGNvbXAgfHwgaGlnaC5vcGVyYXRvciA9PT0gZWNvbXApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBsb3dlc3QgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhbiBvcGVyYXRvciBhbmQgb3VyIHZlcnNpb25cbiAgICAvLyBpcyBsZXNzIHRoYW4gaXQgdGhlbiBpdCBpc24ndCBoaWdoZXIgdGhhbiB0aGUgcmFuZ2VcbiAgICBpZiAoKCFsb3cub3BlcmF0b3IgfHwgbG93Lm9wZXJhdG9yID09PSBjb21wKSAmJlxuICAgICAgICBsdGVmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIGlmIChsb3cub3BlcmF0b3IgPT09IGVjb21wICYmIGx0Zm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG91dHNpZGVcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/outside.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/simplify.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/ranges/simplify.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// given a set of versions and a range, create a \"simplified\" range\n// that includes the same versions that the original range does\n// If the original range is shorter than the simplified one, return that.\nconst satisfies = __webpack_require__(/*! ../functions/satisfies.js */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/satisfies.js\")\nconst compare = __webpack_require__(/*! ../functions/compare.js */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/compare.js\")\nmodule.exports = (versions, range, options) => {\n  const set = []\n  let first = null\n  let prev = null\n  const v = versions.sort((a, b) => compare(a, b, options))\n  for (const version of v) {\n    const included = satisfies(version, range, options)\n    if (included) {\n      prev = version\n      if (!first) {\n        first = version\n      }\n    } else {\n      if (prev) {\n        set.push([first, prev])\n      }\n      prev = null\n      first = null\n    }\n  }\n  if (first) {\n    set.push([first, null])\n  }\n\n  const ranges = []\n  for (const [min, max] of set) {\n    if (min === max) {\n      ranges.push(min)\n    } else if (!max && min === v[0]) {\n      ranges.push('*')\n    } else if (!max) {\n      ranges.push(`>=${min}`)\n    } else if (min === v[0]) {\n      ranges.push(`<=${max}`)\n    } else {\n      ranges.push(`${min} - ${max}`)\n    }\n  }\n  const simplified = ranges.join(' || ')\n  const original = typeof range.raw === 'string' ? range.raw : String(range)\n  return simplified.length < original.length ? simplified : range\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9zaW1wbGlmeS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxzSEFBMkI7QUFDckQsZ0JBQWdCLG1CQUFPLENBQUMsa0hBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTix1QkFBdUIsSUFBSTtBQUMzQixNQUFNO0FBQ04sdUJBQXVCLElBQUk7QUFDM0IsTUFBTTtBQUNOLHFCQUFxQixLQUFLLElBQUksSUFBSTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9zaW1wbGlmeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gZ2l2ZW4gYSBzZXQgb2YgdmVyc2lvbnMgYW5kIGEgcmFuZ2UsIGNyZWF0ZSBhIFwic2ltcGxpZmllZFwiIHJhbmdlXG4vLyB0aGF0IGluY2x1ZGVzIHRoZSBzYW1lIHZlcnNpb25zIHRoYXQgdGhlIG9yaWdpbmFsIHJhbmdlIGRvZXNcbi8vIElmIHRoZSBvcmlnaW5hbCByYW5nZSBpcyBzaG9ydGVyIHRoYW4gdGhlIHNpbXBsaWZpZWQgb25lLCByZXR1cm4gdGhhdC5cbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9zYXRpc2ZpZXMuanMnKVxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9jb21wYXJlLmpzJylcbm1vZHVsZS5leHBvcnRzID0gKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBzZXQgPSBbXVxuICBsZXQgZmlyc3QgPSBudWxsXG4gIGxldCBwcmV2ID0gbnVsbFxuICBjb25zdCB2ID0gdmVyc2lvbnMuc29ydCgoYSwgYikgPT4gY29tcGFyZShhLCBiLCBvcHRpb25zKSlcbiAgZm9yIChjb25zdCB2ZXJzaW9uIG9mIHYpIHtcbiAgICBjb25zdCBpbmNsdWRlZCA9IHNhdGlzZmllcyh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucylcbiAgICBpZiAoaW5jbHVkZWQpIHtcbiAgICAgIHByZXYgPSB2ZXJzaW9uXG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gdmVyc2lvblxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJldikge1xuICAgICAgICBzZXQucHVzaChbZmlyc3QsIHByZXZdKVxuICAgICAgfVxuICAgICAgcHJldiA9IG51bGxcbiAgICAgIGZpcnN0ID0gbnVsbFxuICAgIH1cbiAgfVxuICBpZiAoZmlyc3QpIHtcbiAgICBzZXQucHVzaChbZmlyc3QsIG51bGxdKVxuICB9XG5cbiAgY29uc3QgcmFuZ2VzID0gW11cbiAgZm9yIChjb25zdCBbbWluLCBtYXhdIG9mIHNldCkge1xuICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgcmFuZ2VzLnB1c2gobWluKVxuICAgIH0gZWxzZSBpZiAoIW1heCAmJiBtaW4gPT09IHZbMF0pIHtcbiAgICAgIHJhbmdlcy5wdXNoKCcqJylcbiAgICB9IGVsc2UgaWYgKCFtYXgpIHtcbiAgICAgIHJhbmdlcy5wdXNoKGA+PSR7bWlufWApXG4gICAgfSBlbHNlIGlmIChtaW4gPT09IHZbMF0pIHtcbiAgICAgIHJhbmdlcy5wdXNoKGA8PSR7bWF4fWApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlcy5wdXNoKGAke21pbn0gLSAke21heH1gKVxuICAgIH1cbiAgfVxuICBjb25zdCBzaW1wbGlmaWVkID0gcmFuZ2VzLmpvaW4oJyB8fCAnKVxuICBjb25zdCBvcmlnaW5hbCA9IHR5cGVvZiByYW5nZS5yYXcgPT09ICdzdHJpbmcnID8gcmFuZ2UucmF3IDogU3RyaW5nKHJhbmdlKVxuICByZXR1cm4gc2ltcGxpZmllZC5sZW5ndGggPCBvcmlnaW5hbC5sZW5ndGggPyBzaW1wbGlmaWVkIDogcmFuZ2Vcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/simplify.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/subset.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/ranges/subset.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Range = __webpack_require__(/*! ../classes/range.js */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/range.js\")\nconst Comparator = __webpack_require__(/*! ../classes/comparator.js */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/comparator.js\")\nconst { ANY } = Comparator\nconst satisfies = __webpack_require__(/*! ../functions/satisfies.js */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/satisfies.js\")\nconst compare = __webpack_require__(/*! ../functions/compare.js */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/functions/compare.js\")\n\n// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:\n// - Every simple range `r1, r2, ...` is a null set, OR\n// - Every simple range `r1, r2, ...` which is not a null set is a subset of\n//   some `R1, R2, ...`\n//\n// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:\n// - If c is only the ANY comparator\n//   - If C is only the ANY comparator, return true\n//   - Else if in prerelease mode, return false\n//   - else replace c with `[>=0.0.0]`\n// - If C is only the ANY comparator\n//   - if in prerelease mode, return true\n//   - else replace C with `[>=0.0.0]`\n// - Let EQ be the set of = comparators in c\n// - If EQ is more than one, return true (null set)\n// - Let GT be the highest > or >= comparator in c\n// - Let LT be the lowest < or <= comparator in c\n// - If GT and LT, and GT.semver > LT.semver, return true (null set)\n// - If any C is a = range, and GT or LT are set, return false\n// - If EQ\n//   - If GT, and EQ does not satisfy GT, return true (null set)\n//   - If LT, and EQ does not satisfy LT, return true (null set)\n//   - If EQ satisfies every C, return true\n//   - Else return false\n// - If GT\n//   - If GT.semver is lower than any > or >= comp in C, return false\n//   - If GT is >=, and GT.semver does not satisfy every C, return false\n//   - If GT.semver has a prerelease, and not in prerelease mode\n//     - If no C has a prerelease and the GT.semver tuple, return false\n// - If LT\n//   - If LT.semver is greater than any < or <= comp in C, return false\n//   - If LT is <=, and LT.semver does not satisfy every C, return false\n//   - If GT.semver has a prerelease, and not in prerelease mode\n//     - If no C has a prerelease and the LT.semver tuple, return false\n// - Else return true\n\nconst subset = (sub, dom, options = {}) => {\n  if (sub === dom) {\n    return true\n  }\n\n  sub = new Range(sub, options)\n  dom = new Range(dom, options)\n  let sawNonNull = false\n\n  OUTER: for (const simpleSub of sub.set) {\n    for (const simpleDom of dom.set) {\n      const isSub = simpleSubset(simpleSub, simpleDom, options)\n      sawNonNull = sawNonNull || isSub !== null\n      if (isSub) {\n        continue OUTER\n      }\n    }\n    // the null set is a subset of everything, but null simple ranges in\n    // a complex range should be ignored.  so if we saw a non-null range,\n    // then we know this isn't a subset, but if EVERY simple range was null,\n    // then it is a subset.\n    if (sawNonNull) {\n      return false\n    }\n  }\n  return true\n}\n\nconst minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')]\nconst minimumVersion = [new Comparator('>=0.0.0')]\n\nconst simpleSubset = (sub, dom, options) => {\n  if (sub === dom) {\n    return true\n  }\n\n  if (sub.length === 1 && sub[0].semver === ANY) {\n    if (dom.length === 1 && dom[0].semver === ANY) {\n      return true\n    } else if (options.includePrerelease) {\n      sub = minimumVersionWithPreRelease\n    } else {\n      sub = minimumVersion\n    }\n  }\n\n  if (dom.length === 1 && dom[0].semver === ANY) {\n    if (options.includePrerelease) {\n      return true\n    } else {\n      dom = minimumVersion\n    }\n  }\n\n  const eqSet = new Set()\n  let gt, lt\n  for (const c of sub) {\n    if (c.operator === '>' || c.operator === '>=') {\n      gt = higherGT(gt, c, options)\n    } else if (c.operator === '<' || c.operator === '<=') {\n      lt = lowerLT(lt, c, options)\n    } else {\n      eqSet.add(c.semver)\n    }\n  }\n\n  if (eqSet.size > 1) {\n    return null\n  }\n\n  let gtltComp\n  if (gt && lt) {\n    gtltComp = compare(gt.semver, lt.semver, options)\n    if (gtltComp > 0) {\n      return null\n    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {\n      return null\n    }\n  }\n\n  // will iterate one or zero times\n  for (const eq of eqSet) {\n    if (gt && !satisfies(eq, String(gt), options)) {\n      return null\n    }\n\n    if (lt && !satisfies(eq, String(lt), options)) {\n      return null\n    }\n\n    for (const c of dom) {\n      if (!satisfies(eq, String(c), options)) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  let higher, lower\n  let hasDomLT, hasDomGT\n  // if the subset has a prerelease, we need a comparator in the superset\n  // with the same tuple and a prerelease, or it's not a subset\n  let needDomLTPre = lt &&\n    !options.includePrerelease &&\n    lt.semver.prerelease.length ? lt.semver : false\n  let needDomGTPre = gt &&\n    !options.includePrerelease &&\n    gt.semver.prerelease.length ? gt.semver : false\n  // exception: <1.2.3-0 is the same as <1.2.3\n  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&\n      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {\n    needDomLTPre = false\n  }\n\n  for (const c of dom) {\n    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='\n    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='\n    if (gt) {\n      if (needDomGTPre) {\n        if (c.semver.prerelease && c.semver.prerelease.length &&\n            c.semver.major === needDomGTPre.major &&\n            c.semver.minor === needDomGTPre.minor &&\n            c.semver.patch === needDomGTPre.patch) {\n          needDomGTPre = false\n        }\n      }\n      if (c.operator === '>' || c.operator === '>=') {\n        higher = higherGT(gt, c, options)\n        if (higher === c && higher !== gt) {\n          return false\n        }\n      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {\n        return false\n      }\n    }\n    if (lt) {\n      if (needDomLTPre) {\n        if (c.semver.prerelease && c.semver.prerelease.length &&\n            c.semver.major === needDomLTPre.major &&\n            c.semver.minor === needDomLTPre.minor &&\n            c.semver.patch === needDomLTPre.patch) {\n          needDomLTPre = false\n        }\n      }\n      if (c.operator === '<' || c.operator === '<=') {\n        lower = lowerLT(lt, c, options)\n        if (lower === c && lower !== lt) {\n          return false\n        }\n      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {\n        return false\n      }\n    }\n    if (!c.operator && (lt || gt) && gtltComp !== 0) {\n      return false\n    }\n  }\n\n  // if there was a < or >, and nothing in the dom, then must be false\n  // UNLESS it was limited by another range in the other direction.\n  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0\n  if (gt && hasDomLT && !lt && gtltComp !== 0) {\n    return false\n  }\n\n  if (lt && hasDomGT && !gt && gtltComp !== 0) {\n    return false\n  }\n\n  // we needed a prerelease range in a specific tuple, but didn't get one\n  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,\n  // because it includes prereleases in the 1.2.3 tuple\n  if (needDomGTPre || needDomLTPre) {\n    return false\n  }\n\n  return true\n}\n\n// >=1.2.3 is lower than >1.2.3\nconst higherGT = (a, b, options) => {\n  if (!a) {\n    return b\n  }\n  const comp = compare(a.semver, b.semver, options)\n  return comp > 0 ? a\n    : comp < 0 ? b\n    : b.operator === '>' && a.operator === '>=' ? b\n    : a\n}\n\n// <=1.2.3 is higher than <1.2.3\nconst lowerLT = (a, b, options) => {\n  if (!a) {\n    return b\n  }\n  const comp = compare(a.semver, b.semver, options)\n  return comp < 0 ? a\n    : comp > 0 ? b\n    : b.operator === '<' && a.operator === '<=' ? b\n    : a\n}\n\nmodule.exports = subset\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9zdWJzZXQuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosY0FBYyxtQkFBTyxDQUFDLDBHQUFxQjtBQUMzQyxtQkFBbUIsbUJBQU8sQ0FBQyxvSEFBMEI7QUFDckQsUUFBUSxNQUFNO0FBQ2Qsa0JBQWtCLG1CQUFPLENBQUMsc0hBQTJCO0FBQ3JELGdCQUFnQixtQkFBTyxDQUFDLGtIQUF5Qjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvc3Vic2V0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UuanMnKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvY29tcGFyYXRvci5qcycpXG5jb25zdCB7IEFOWSB9ID0gQ29tcGFyYXRvclxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL3NhdGlzZmllcy5qcycpXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2NvbXBhcmUuanMnKVxuXG4vLyBDb21wbGV4IHJhbmdlIGByMSB8fCByMiB8fCAuLi5gIGlzIGEgc3Vic2V0IG9mIGBSMSB8fCBSMiB8fCAuLi5gIGlmZjpcbi8vIC0gRXZlcnkgc2ltcGxlIHJhbmdlIGByMSwgcjIsIC4uLmAgaXMgYSBudWxsIHNldCwgT1Jcbi8vIC0gRXZlcnkgc2ltcGxlIHJhbmdlIGByMSwgcjIsIC4uLmAgd2hpY2ggaXMgbm90IGEgbnVsbCBzZXQgaXMgYSBzdWJzZXQgb2Zcbi8vICAgc29tZSBgUjEsIFIyLCAuLi5gXG4vL1xuLy8gU2ltcGxlIHJhbmdlIGBjMSBjMiAuLi5gIGlzIGEgc3Vic2V0IG9mIHNpbXBsZSByYW5nZSBgQzEgQzIgLi4uYCBpZmY6XG4vLyAtIElmIGMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3Jcbi8vICAgLSBJZiBDIGlzIG9ubHkgdGhlIEFOWSBjb21wYXJhdG9yLCByZXR1cm4gdHJ1ZVxuLy8gICAtIEVsc2UgaWYgaW4gcHJlcmVsZWFzZSBtb2RlLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBlbHNlIHJlcGxhY2UgYyB3aXRoIGBbPj0wLjAuMF1gXG4vLyAtIElmIEMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3Jcbi8vICAgLSBpZiBpbiBwcmVyZWxlYXNlIG1vZGUsIHJldHVybiB0cnVlXG4vLyAgIC0gZWxzZSByZXBsYWNlIEMgd2l0aCBgWz49MC4wLjBdYFxuLy8gLSBMZXQgRVEgYmUgdGhlIHNldCBvZiA9IGNvbXBhcmF0b3JzIGluIGNcbi8vIC0gSWYgRVEgaXMgbW9yZSB0aGFuIG9uZSwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gLSBMZXQgR1QgYmUgdGhlIGhpZ2hlc3QgPiBvciA+PSBjb21wYXJhdG9yIGluIGNcbi8vIC0gTGV0IExUIGJlIHRoZSBsb3dlc3QgPCBvciA8PSBjb21wYXJhdG9yIGluIGNcbi8vIC0gSWYgR1QgYW5kIExULCBhbmQgR1Quc2VtdmVyID4gTFQuc2VtdmVyLCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAtIElmIGFueSBDIGlzIGEgPSByYW5nZSwgYW5kIEdUIG9yIExUIGFyZSBzZXQsIHJldHVybiBmYWxzZVxuLy8gLSBJZiBFUVxuLy8gICAtIElmIEdULCBhbmQgRVEgZG9lcyBub3Qgc2F0aXNmeSBHVCwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gICAtIElmIExULCBhbmQgRVEgZG9lcyBub3Qgc2F0aXNmeSBMVCwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gICAtIElmIEVRIHNhdGlzZmllcyBldmVyeSBDLCByZXR1cm4gdHJ1ZVxuLy8gICAtIEVsc2UgcmV0dXJuIGZhbHNlXG4vLyAtIElmIEdUXG4vLyAgIC0gSWYgR1Quc2VtdmVyIGlzIGxvd2VyIHRoYW4gYW55ID4gb3IgPj0gY29tcCBpbiBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVCBpcyA+PSwgYW5kIEdULnNlbXZlciBkb2VzIG5vdCBzYXRpc2Z5IGV2ZXJ5IEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIEdULnNlbXZlciBoYXMgYSBwcmVyZWxlYXNlLCBhbmQgbm90IGluIHByZXJlbGVhc2UgbW9kZVxuLy8gICAgIC0gSWYgbm8gQyBoYXMgYSBwcmVyZWxlYXNlIGFuZCB0aGUgR1Quc2VtdmVyIHR1cGxlLCByZXR1cm4gZmFsc2Vcbi8vIC0gSWYgTFRcbi8vICAgLSBJZiBMVC5zZW12ZXIgaXMgZ3JlYXRlciB0aGFuIGFueSA8IG9yIDw9IGNvbXAgaW4gQywgcmV0dXJuIGZhbHNlXG4vLyAgIC0gSWYgTFQgaXMgPD0sIGFuZCBMVC5zZW12ZXIgZG9lcyBub3Qgc2F0aXNmeSBldmVyeSBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVC5zZW12ZXIgaGFzIGEgcHJlcmVsZWFzZSwgYW5kIG5vdCBpbiBwcmVyZWxlYXNlIG1vZGVcbi8vICAgICAtIElmIG5vIEMgaGFzIGEgcHJlcmVsZWFzZSBhbmQgdGhlIExULnNlbXZlciB0dXBsZSwgcmV0dXJuIGZhbHNlXG4vLyAtIEVsc2UgcmV0dXJuIHRydWVcblxuY29uc3Qgc3Vic2V0ID0gKHN1YiwgZG9tLCBvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKHN1YiA9PT0gZG9tKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHN1YiA9IG5ldyBSYW5nZShzdWIsIG9wdGlvbnMpXG4gIGRvbSA9IG5ldyBSYW5nZShkb20sIG9wdGlvbnMpXG4gIGxldCBzYXdOb25OdWxsID0gZmFsc2VcblxuICBPVVRFUjogZm9yIChjb25zdCBzaW1wbGVTdWIgb2Ygc3ViLnNldCkge1xuICAgIGZvciAoY29uc3Qgc2ltcGxlRG9tIG9mIGRvbS5zZXQpIHtcbiAgICAgIGNvbnN0IGlzU3ViID0gc2ltcGxlU3Vic2V0KHNpbXBsZVN1Yiwgc2ltcGxlRG9tLCBvcHRpb25zKVxuICAgICAgc2F3Tm9uTnVsbCA9IHNhd05vbk51bGwgfHwgaXNTdWIgIT09IG51bGxcbiAgICAgIGlmIChpc1N1Yikge1xuICAgICAgICBjb250aW51ZSBPVVRFUlxuICAgICAgfVxuICAgIH1cbiAgICAvLyB0aGUgbnVsbCBzZXQgaXMgYSBzdWJzZXQgb2YgZXZlcnl0aGluZywgYnV0IG51bGwgc2ltcGxlIHJhbmdlcyBpblxuICAgIC8vIGEgY29tcGxleCByYW5nZSBzaG91bGQgYmUgaWdub3JlZC4gIHNvIGlmIHdlIHNhdyBhIG5vbi1udWxsIHJhbmdlLFxuICAgIC8vIHRoZW4gd2Uga25vdyB0aGlzIGlzbid0IGEgc3Vic2V0LCBidXQgaWYgRVZFUlkgc2ltcGxlIHJhbmdlIHdhcyBudWxsLFxuICAgIC8vIHRoZW4gaXQgaXMgYSBzdWJzZXQuXG4gICAgaWYgKHNhd05vbk51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5jb25zdCBtaW5pbXVtVmVyc2lvbldpdGhQcmVSZWxlYXNlID0gW25ldyBDb21wYXJhdG9yKCc+PTAuMC4wLTAnKV1cbmNvbnN0IG1pbmltdW1WZXJzaW9uID0gW25ldyBDb21wYXJhdG9yKCc+PTAuMC4wJyldXG5cbmNvbnN0IHNpbXBsZVN1YnNldCA9IChzdWIsIGRvbSwgb3B0aW9ucykgPT4ge1xuICBpZiAoc3ViID09PSBkb20pIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKHN1Yi5sZW5ndGggPT09IDEgJiYgc3ViWzBdLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgaWYgKGRvbS5sZW5ndGggPT09IDEgJiYgZG9tWzBdLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgICAgc3ViID0gbWluaW11bVZlcnNpb25XaXRoUHJlUmVsZWFzZVxuICAgIH0gZWxzZSB7XG4gICAgICBzdWIgPSBtaW5pbXVtVmVyc2lvblxuICAgIH1cbiAgfVxuXG4gIGlmIChkb20ubGVuZ3RoID09PSAxICYmIGRvbVswXS5zZW12ZXIgPT09IEFOWSkge1xuICAgIGlmIChvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBkb20gPSBtaW5pbXVtVmVyc2lvblxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGVxU2V0ID0gbmV3IFNldCgpXG4gIGxldCBndCwgbHRcbiAgZm9yIChjb25zdCBjIG9mIHN1Yikge1xuICAgIGlmIChjLm9wZXJhdG9yID09PSAnPicgfHwgYy5vcGVyYXRvciA9PT0gJz49Jykge1xuICAgICAgZ3QgPSBoaWdoZXJHVChndCwgYywgb3B0aW9ucylcbiAgICB9IGVsc2UgaWYgKGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nKSB7XG4gICAgICBsdCA9IGxvd2VyTFQobHQsIGMsIG9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGVxU2V0LmFkZChjLnNlbXZlcilcbiAgICB9XG4gIH1cblxuICBpZiAoZXFTZXQuc2l6ZSA+IDEpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgbGV0IGd0bHRDb21wXG4gIGlmIChndCAmJiBsdCkge1xuICAgIGd0bHRDb21wID0gY29tcGFyZShndC5zZW12ZXIsIGx0LnNlbXZlciwgb3B0aW9ucylcbiAgICBpZiAoZ3RsdENvbXAgPiAwKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0gZWxzZSBpZiAoZ3RsdENvbXAgPT09IDAgJiYgKGd0Lm9wZXJhdG9yICE9PSAnPj0nIHx8IGx0Lm9wZXJhdG9yICE9PSAnPD0nKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICAvLyB3aWxsIGl0ZXJhdGUgb25lIG9yIHplcm8gdGltZXNcbiAgZm9yIChjb25zdCBlcSBvZiBlcVNldCkge1xuICAgIGlmIChndCAmJiAhc2F0aXNmaWVzKGVxLCBTdHJpbmcoZ3QpLCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBpZiAobHQgJiYgIXNhdGlzZmllcyhlcSwgU3RyaW5nKGx0KSwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBjIG9mIGRvbSkge1xuICAgICAgaWYgKCFzYXRpc2ZpZXMoZXEsIFN0cmluZyhjKSwgb3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGxldCBoaWdoZXIsIGxvd2VyXG4gIGxldCBoYXNEb21MVCwgaGFzRG9tR1RcbiAgLy8gaWYgdGhlIHN1YnNldCBoYXMgYSBwcmVyZWxlYXNlLCB3ZSBuZWVkIGEgY29tcGFyYXRvciBpbiB0aGUgc3VwZXJzZXRcbiAgLy8gd2l0aCB0aGUgc2FtZSB0dXBsZSBhbmQgYSBwcmVyZWxlYXNlLCBvciBpdCdzIG5vdCBhIHN1YnNldFxuICBsZXQgbmVlZERvbUxUUHJlID0gbHQgJiZcbiAgICAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJlxuICAgIGx0LnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA/IGx0LnNlbXZlciA6IGZhbHNlXG4gIGxldCBuZWVkRG9tR1RQcmUgPSBndCAmJlxuICAgICFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmXG4gICAgZ3Quc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID8gZ3Quc2VtdmVyIDogZmFsc2VcbiAgLy8gZXhjZXB0aW9uOiA8MS4yLjMtMCBpcyB0aGUgc2FtZSBhcyA8MS4yLjNcbiAgaWYgKG5lZWREb21MVFByZSAmJiBuZWVkRG9tTFRQcmUucHJlcmVsZWFzZS5sZW5ndGggPT09IDEgJiZcbiAgICAgIGx0Lm9wZXJhdG9yID09PSAnPCcgJiYgbmVlZERvbUxUUHJlLnByZXJlbGVhc2VbMF0gPT09IDApIHtcbiAgICBuZWVkRG9tTFRQcmUgPSBmYWxzZVxuICB9XG5cbiAgZm9yIChjb25zdCBjIG9mIGRvbSkge1xuICAgIGhhc0RvbUdUID0gaGFzRG9tR1QgfHwgYy5vcGVyYXRvciA9PT0gJz4nIHx8IGMub3BlcmF0b3IgPT09ICc+PSdcbiAgICBoYXNEb21MVCA9IGhhc0RvbUxUIHx8IGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nXG4gICAgaWYgKGd0KSB7XG4gICAgICBpZiAobmVlZERvbUdUUHJlKSB7XG4gICAgICAgIGlmIChjLnNlbXZlci5wcmVyZWxlYXNlICYmIGMuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoICYmXG4gICAgICAgICAgICBjLnNlbXZlci5tYWpvciA9PT0gbmVlZERvbUdUUHJlLm1ham9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5taW5vciA9PT0gbmVlZERvbUdUUHJlLm1pbm9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5wYXRjaCA9PT0gbmVlZERvbUdUUHJlLnBhdGNoKSB7XG4gICAgICAgICAgbmVlZERvbUdUUHJlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGMub3BlcmF0b3IgPT09ICc+JyB8fCBjLm9wZXJhdG9yID09PSAnPj0nKSB7XG4gICAgICAgIGhpZ2hlciA9IGhpZ2hlckdUKGd0LCBjLCBvcHRpb25zKVxuICAgICAgICBpZiAoaGlnaGVyID09PSBjICYmIGhpZ2hlciAhPT0gZ3QpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChndC5vcGVyYXRvciA9PT0gJz49JyAmJiAhc2F0aXNmaWVzKGd0LnNlbXZlciwgU3RyaW5nKGMpLCBvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGx0KSB7XG4gICAgICBpZiAobmVlZERvbUxUUHJlKSB7XG4gICAgICAgIGlmIChjLnNlbXZlci5wcmVyZWxlYXNlICYmIGMuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoICYmXG4gICAgICAgICAgICBjLnNlbXZlci5tYWpvciA9PT0gbmVlZERvbUxUUHJlLm1ham9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5taW5vciA9PT0gbmVlZERvbUxUUHJlLm1pbm9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5wYXRjaCA9PT0gbmVlZERvbUxUUHJlLnBhdGNoKSB7XG4gICAgICAgICAgbmVlZERvbUxUUHJlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nKSB7XG4gICAgICAgIGxvd2VyID0gbG93ZXJMVChsdCwgYywgb3B0aW9ucylcbiAgICAgICAgaWYgKGxvd2VyID09PSBjICYmIGxvd2VyICE9PSBsdCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGx0Lm9wZXJhdG9yID09PSAnPD0nICYmICFzYXRpc2ZpZXMobHQuc2VtdmVyLCBTdHJpbmcoYyksIG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWMub3BlcmF0b3IgJiYgKGx0IHx8IGd0KSAmJiBndGx0Q29tcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlcmUgd2FzIGEgPCBvciA+LCBhbmQgbm90aGluZyBpbiB0aGUgZG9tLCB0aGVuIG11c3QgYmUgZmFsc2VcbiAgLy8gVU5MRVNTIGl0IHdhcyBsaW1pdGVkIGJ5IGFub3RoZXIgcmFuZ2UgaW4gdGhlIG90aGVyIGRpcmVjdGlvbi5cbiAgLy8gRWcsID4xLjAuMCA8MS4wLjEgaXMgc3RpbGwgYSBzdWJzZXQgb2YgPDIuMC4wXG4gIGlmIChndCAmJiBoYXNEb21MVCAmJiAhbHQgJiYgZ3RsdENvbXAgIT09IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChsdCAmJiBoYXNEb21HVCAmJiAhZ3QgJiYgZ3RsdENvbXAgIT09IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIHdlIG5lZWRlZCBhIHByZXJlbGVhc2UgcmFuZ2UgaW4gYSBzcGVjaWZpYyB0dXBsZSwgYnV0IGRpZG4ndCBnZXQgb25lXG4gIC8vIHRoZW4gdGhpcyBpc24ndCBhIHN1YnNldC4gIGVnID49MS4yLjMtcHJlIGlzIG5vdCBhIHN1YnNldCBvZiA+PTEuMC4wLFxuICAvLyBiZWNhdXNlIGl0IGluY2x1ZGVzIHByZXJlbGVhc2VzIGluIHRoZSAxLjIuMyB0dXBsZVxuICBpZiAobmVlZERvbUdUUHJlIHx8IG5lZWREb21MVFByZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gPj0xLjIuMyBpcyBsb3dlciB0aGFuID4xLjIuM1xuY29uc3QgaGlnaGVyR1QgPSAoYSwgYiwgb3B0aW9ucykgPT4ge1xuICBpZiAoIWEpIHtcbiAgICByZXR1cm4gYlxuICB9XG4gIGNvbnN0IGNvbXAgPSBjb21wYXJlKGEuc2VtdmVyLCBiLnNlbXZlciwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAgPiAwID8gYVxuICAgIDogY29tcCA8IDAgPyBiXG4gICAgOiBiLm9wZXJhdG9yID09PSAnPicgJiYgYS5vcGVyYXRvciA9PT0gJz49JyA/IGJcbiAgICA6IGFcbn1cblxuLy8gPD0xLjIuMyBpcyBoaWdoZXIgdGhhbiA8MS4yLjNcbmNvbnN0IGxvd2VyTFQgPSAoYSwgYiwgb3B0aW9ucykgPT4ge1xuICBpZiAoIWEpIHtcbiAgICByZXR1cm4gYlxuICB9XG4gIGNvbnN0IGNvbXAgPSBjb21wYXJlKGEuc2VtdmVyLCBiLnNlbXZlciwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAgPCAwID8gYVxuICAgIDogY29tcCA+IDAgPyBiXG4gICAgOiBiLm9wZXJhdG9yID09PSAnPCcgJiYgYS5vcGVyYXRvciA9PT0gJzw9JyA/IGJcbiAgICA6IGFcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdWJzZXRcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/subset.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/to-comparators.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/ranges/to-comparators.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Range = __webpack_require__(/*! ../classes/range */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/range.js\")\n\n// Mostly just for testing and legacy API reasons\nconst toComparators = (range, options) =>\n  new Range(range, options).set\n    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))\n\nmodule.exports = toComparators\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy90by1jb21wYXJhdG9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixjQUFjLG1CQUFPLENBQUMsdUdBQWtCOztBQUV4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3RvLWNvbXBhcmF0b3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuXG4vLyBNb3N0bHkganVzdCBmb3IgdGVzdGluZyBhbmQgbGVnYWN5IEFQSSByZWFzb25zXG5jb25zdCB0b0NvbXBhcmF0b3JzID0gKHJhbmdlLCBvcHRpb25zKSA9PlxuICBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpLnNldFxuICAgIC5tYXAoY29tcCA9PiBjb21wLm1hcChjID0+IGMudmFsdWUpLmpvaW4oJyAnKS50cmltKCkuc3BsaXQoJyAnKSlcblxubW9kdWxlLmV4cG9ydHMgPSB0b0NvbXBhcmF0b3JzXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/to-comparators.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/valid.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@metamask/utils/node_modules/semver/ranges/valid.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Range = __webpack_require__(/*! ../classes/range */ \"(rsc)/../../node_modules/@metamask/utils/node_modules/semver/classes/range.js\")\nconst validRange = (range, options) => {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*'\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = validRange\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy92YWxpZC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixjQUFjLG1CQUFPLENBQUMsdUdBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy92YWxpZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHZhbGlkUmFuZ2UgPSAocmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBSZXR1cm4gJyonIGluc3RlYWQgb2YgJycgc28gdGhhdCB0cnV0aGluZXNzIHdvcmtzLlxuICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiBpdCdzIGludmFsaWQgYW55d2F5XG4gICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucykucmFuZ2UgfHwgJyonXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZFJhbmdlXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@metamask/utils/node_modules/semver/ranges/valid.js\n");

/***/ })

};
;