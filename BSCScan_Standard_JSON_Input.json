{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/draft-IERC6093.sol)\npragma solidity >=0.8.4;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /// @inheritdoc IERC20\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /// @inheritdoc IERC20\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/AggregatedOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./SoraOracle.sol\";\n\n/**\n * @title AggregatedOracle\n * @notice Combines multiple oracle providers for consensus-based answers\n * @dev Uses weighted voting and confidence thresholds for accuracy\n */\ncontract AggregatedOracle is Ownable, ReentrancyGuard {\n    \n    struct OracleProvider {\n        address providerAddress;\n        uint16 weight;              // 1-10000 (basis points)\n        uint32 totalAnswers;\n        uint32 successfulAnswers;\n        bool active;\n    }\n\n    struct AggregatedAnswer {\n        uint64 numericAnswer;       // Weighted median\n        uint8 confidenceScore;      // Weighted average confidence\n        uint32 timestamp;\n        uint8 providerCount;        // Number of providers who answered\n        bool finalized;\n    }\n\n    struct ProviderSubmission {\n        uint64 numericAnswer;\n        uint8 confidenceScore;\n        uint32 timestamp;\n        bool submitted;\n    }\n\n    mapping(uint256 => mapping(address => ProviderSubmission)) public submissions;\n    mapping(uint256 => AggregatedAnswer) public aggregatedAnswers;\n    mapping(address => OracleProvider) public providers;\n    address[] public providerList;\n\n    uint8 public minimumProviders = 3;\n    uint8 public consensusThreshold = 70; // 70% weighted agreement required\n    uint256 public submissionWindow = 1 hours;\n\n    event ProviderAdded(address indexed provider, uint16 weight);\n    event ProviderRemoved(address indexed provider);\n    event SubmissionReceived(uint256 indexed questionId, address indexed provider, uint64 answer, uint8 confidence);\n    event AnswerAggregated(uint256 indexed questionId, uint64 finalAnswer, uint8 confidence, uint8 providerCount);\n\n    constructor() Ownable(msg.sender) {}\n\n    /**\n     * @notice Add oracle provider with voting weight\n     * @param _provider Address of the oracle provider\n     * @param _weight Voting weight (1-10000 basis points)\n     */\n    function addProvider(address _provider, uint16 _weight) external onlyOwner {\n        require(_provider != address(0), \"Invalid provider\");\n        require(_weight > 0 && _weight <= 10000, \"Invalid weight\");\n        require(!providers[_provider].active, \"Provider exists\");\n\n        providers[_provider] = OracleProvider({\n            providerAddress: _provider,\n            weight: _weight,\n            totalAnswers: 0,\n            successfulAnswers: 0,\n            active: true\n        });\n\n        providerList.push(_provider);\n        emit ProviderAdded(_provider, _weight);\n    }\n\n    /**\n     * @notice Remove oracle provider\n     */\n    function removeProvider(address _provider) external onlyOwner {\n        require(providers[_provider].active, \"Provider not active\");\n        providers[_provider].active = false;\n        emit ProviderRemoved(_provider);\n    }\n\n    /**\n     * @notice Submit answer as oracle provider\n     * @param _questionId Question ID from SoraOracle\n     * @param _numericAnswer Numeric answer\n     * @param _confidenceScore Confidence (0-100)\n     */\n    function submitAnswer(\n        uint256 _questionId,\n        uint64 _numericAnswer,\n        uint8 _confidenceScore\n    ) external nonReentrant {\n        require(providers[msg.sender].active, \"Not authorized provider\");\n        require(!submissions[_questionId][msg.sender].submitted, \"Already submitted\");\n        require(_confidenceScore <= 100, \"Invalid confidence\");\n        require(!aggregatedAnswers[_questionId].finalized, \"Already finalized\");\n\n        submissions[_questionId][msg.sender] = ProviderSubmission({\n            numericAnswer: _numericAnswer,\n            confidenceScore: _confidenceScore,\n            timestamp: uint32(block.timestamp),\n            submitted: true\n        });\n\n        providers[msg.sender].totalAnswers++;\n        emit SubmissionReceived(_questionId, msg.sender, _numericAnswer, _confidenceScore);\n    }\n\n    /**\n     * @notice Aggregate all submissions into final answer\n     * @param _questionId Question ID to aggregate\n     */\n    function aggregateAnswer(uint256 _questionId) external nonReentrant {\n        require(!aggregatedAnswers[_questionId].finalized, \"Already finalized\");\n\n        uint8 submissionCount = 0;\n        uint256 totalWeight = 0;\n        uint256 weightedSum = 0;\n        uint256 weightedConfidence = 0;\n\n        // Collect all submissions and calculate weighted values\n        for (uint256 i = 0; i < providerList.length; i++) {\n            address provider = providerList[i];\n            if (submissions[_questionId][provider].submitted && providers[provider].active) {\n                ProviderSubmission memory sub = submissions[_questionId][provider];\n                uint16 weight = providers[provider].weight;\n\n                weightedSum += uint256(sub.numericAnswer) * weight;\n                weightedConfidence += uint256(sub.confidenceScore) * weight;\n                totalWeight += weight;\n                submissionCount++;\n            }\n        }\n\n        require(submissionCount >= minimumProviders, \"Insufficient submissions\");\n\n        // Calculate weighted average\n        uint64 finalAnswer = uint64(weightedSum / totalWeight);\n        uint8 finalConfidence = uint8(weightedConfidence / totalWeight);\n\n        aggregatedAnswers[_questionId] = AggregatedAnswer({\n            numericAnswer: finalAnswer,\n            confidenceScore: finalConfidence,\n            timestamp: uint32(block.timestamp),\n            providerCount: submissionCount,\n            finalized: true\n        });\n\n        // Update successful answer counts\n        for (uint256 i = 0; i < providerList.length; i++) {\n            address provider = providerList[i];\n            if (submissions[_questionId][provider].submitted && providers[provider].active) {\n                providers[provider].successfulAnswers++;\n            }\n        }\n\n        emit AnswerAggregated(_questionId, finalAnswer, finalConfidence, submissionCount);\n    }\n\n    /**\n     * @notice Get aggregated answer for question\n     */\n    function getAnswer(uint256 _questionId) external view returns (\n        uint64 numericAnswer,\n        uint8 confidenceScore,\n        uint32 timestamp,\n        uint8 providerCount,\n        bool finalized\n    ) {\n        AggregatedAnswer memory answer = aggregatedAnswers[_questionId];\n        return (\n            answer.numericAnswer,\n            answer.confidenceScore,\n            answer.timestamp,\n            answer.providerCount,\n            answer.finalized\n        );\n    }\n\n    /**\n     * @notice Get provider stats\n     */\n    function getProviderStats(address _provider) external view returns (\n        uint16 weight,\n        uint32 totalAnswers,\n        uint32 successfulAnswers,\n        bool active\n    ) {\n        OracleProvider memory provider = providers[_provider];\n        return (provider.weight, provider.totalAnswers, provider.successfulAnswers, provider.active);\n    }\n\n    /**\n     * @notice Update minimum providers required\n     */\n    function setMinimumProviders(uint8 _minimum) external onlyOwner {\n        require(_minimum >= 2, \"Must be at least 2\");\n        minimumProviders = _minimum;\n    }\n\n    /**\n     * @notice Update consensus threshold\n     */\n    function setConsensusThreshold(uint8 _threshold) external onlyOwner {\n        require(_threshold >= 51 && _threshold <= 100, \"Invalid threshold\");\n        consensusThreshold = _threshold;\n    }\n}\n"
    },
    "contracts/AMMMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title AMMMarket\n * @notice Automated Market Maker for prediction markets (like Polymarket)\n * @dev Uses constant product formula (x * y = k) for continuous liquidity\n */\ncontract AMMMarket is Ownable, ReentrancyGuard {\n    \n    struct Market {\n        string question;\n        uint256 yesReserve;        // YES token reserve\n        uint256 noReserve;         // NO token reserve\n        uint256 k;                 // Constant product (x * y = k)\n        uint256 totalLiquidity;\n        uint32 createdAt;\n        uint32 resolvedAt;\n        bool resolved;\n        bool finalOutcome;\n    }\n\n    struct LiquidityPosition {\n        uint256 liquidityTokens;\n        uint256 yesTokens;\n        uint256 noTokens;\n        bool claimed;\n    }\n\n    struct UserPosition {\n        uint256 yesTokens;\n        uint256 noTokens;\n        bool claimed;\n    }\n\n    mapping(uint256 => Market) public markets;\n    mapping(uint256 => mapping(address => LiquidityPosition)) public liquidityProviders;\n    mapping(uint256 => mapping(address => UserPosition)) public userPositions;\n    \n    uint256 public marketCounter;\n    uint256 public tradingFee = 30; // 0.3% (in basis points)\n    uint256 public constant MINIMUM_LIQUIDITY = 1000;\n\n    event MarketCreated(uint256 indexed marketId, string question, uint256 initialLiquidity);\n    event LiquidityAdded(uint256 indexed marketId, address indexed provider, uint256 yesAmount, uint256 noAmount, uint256 liquidityTokens);\n    event LiquidityRemoved(uint256 indexed marketId, address indexed provider, uint256 yesAmount, uint256 noAmount);\n    event TokensTraded(uint256 indexed marketId, address indexed trader, bool buyYes, uint256 amountIn, uint256 amountOut);\n    event MarketResolved(uint256 indexed marketId, bool outcome);\n\n    constructor() Ownable(msg.sender) {}\n\n    /**\n     * @notice Create AMM market with initial liquidity\n     * @param _question Market question\n     * @param _initialYes Initial YES tokens\n     * @param _initialNo Initial NO tokens\n     */\n    function createMarket(\n        string memory _question,\n        uint256 _initialYes,\n        uint256 _initialNo\n    ) external payable returns (uint256 marketId) {\n        require(bytes(_question).length > 0, \"Empty question\");\n        require(_initialYes >= MINIMUM_LIQUIDITY && _initialNo >= MINIMUM_LIQUIDITY, \"Insufficient liquidity\");\n        require(msg.value == _initialYes + _initialNo, \"Incorrect BNB amount\");\n\n        marketId = marketCounter++;\n\n        uint256 k = _initialYes * _initialNo;\n        uint256 liquidityTokens = sqrt(k);\n\n        markets[marketId] = Market({\n            question: _question,\n            yesReserve: _initialYes,\n            noReserve: _initialNo,\n            k: k,\n            totalLiquidity: liquidityTokens,\n            createdAt: uint32(block.timestamp),\n            resolvedAt: 0,\n            resolved: false,\n            finalOutcome: false\n        });\n\n        liquidityProviders[marketId][msg.sender] = LiquidityPosition({\n            liquidityTokens: liquidityTokens,\n            yesTokens: _initialYes,\n            noTokens: _initialNo,\n            claimed: false\n        });\n\n        emit MarketCreated(marketId, _question, liquidityTokens);\n        emit LiquidityAdded(marketId, msg.sender, _initialYes, _initialNo, liquidityTokens);\n\n        return marketId;\n    }\n\n    /**\n     * @notice Add liquidity to existing market\n     * @param _marketId Market to add liquidity\n     * @param _yesAmount YES tokens to add\n     * @param _noAmount NO tokens to add\n     */\n    function addLiquidity(\n        uint256 _marketId,\n        uint256 _yesAmount,\n        uint256 _noAmount\n    ) external payable nonReentrant {\n        Market storage market = markets[_marketId];\n        require(!market.resolved, \"Market resolved\");\n        require(msg.value == _yesAmount + _noAmount, \"Incorrect BNB\");\n\n        // Calculate optimal amounts based on current ratio\n        uint256 yesRatio = (market.yesReserve * 1e18) / market.totalLiquidity;\n        uint256 noRatio = (market.noReserve * 1e18) / market.totalLiquidity;\n\n        uint256 liquidityTokens = (_yesAmount * 1e18) / yesRatio;\n\n        market.yesReserve += _yesAmount;\n        market.noReserve += _noAmount;\n        market.k = market.yesReserve * market.noReserve;\n        market.totalLiquidity += liquidityTokens;\n\n        LiquidityPosition storage position = liquidityProviders[_marketId][msg.sender];\n        position.liquidityTokens += liquidityTokens;\n        position.yesTokens += _yesAmount;\n        position.noTokens += _noAmount;\n\n        emit LiquidityAdded(_marketId, msg.sender, _yesAmount, _noAmount, liquidityTokens);\n    }\n\n    /**\n     * @notice Remove liquidity from market\n     * @param _marketId Market ID\n     * @param _liquidityTokens Amount of liquidity tokens to burn\n     */\n    function removeLiquidity(uint256 _marketId, uint256 _liquidityTokens) external nonReentrant {\n        Market storage market = markets[_marketId];\n        require(!market.resolved, \"Market resolved\");\n\n        LiquidityPosition storage position = liquidityProviders[_marketId][msg.sender];\n        require(position.liquidityTokens >= _liquidityTokens, \"Insufficient liquidity\");\n\n        uint256 yesAmount = (market.yesReserve * _liquidityTokens) / market.totalLiquidity;\n        uint256 noAmount = (market.noReserve * _liquidityTokens) / market.totalLiquidity;\n\n        position.liquidityTokens -= _liquidityTokens;\n        position.yesTokens -= yesAmount;\n        position.noTokens -= noAmount;\n\n        market.yesReserve -= yesAmount;\n        market.noReserve -= noAmount;\n        market.totalLiquidity -= _liquidityTokens;\n        market.k = market.yesReserve * market.noReserve;\n\n        payable(msg.sender).transfer(yesAmount + noAmount);\n\n        emit LiquidityRemoved(_marketId, msg.sender, yesAmount, noAmount);\n    }\n\n    /**\n     * @notice Buy outcome tokens (YES or NO)\n     * @param _marketId Market ID\n     * @param _buyYes True to buy YES, false to buy NO\n     */\n    function buyTokens(uint256 _marketId, bool _buyYes) external payable nonReentrant {\n        Market storage market = markets[_marketId];\n        require(!market.resolved, \"Market resolved\");\n        require(msg.value > 0, \"Must send BNB\");\n\n        uint256 fee = (msg.value * tradingFee) / 10000;\n        uint256 amountIn = msg.value - fee;\n\n        uint256 amountOut;\n        if (_buyYes) {\n            // Buy YES tokens: Add to NO reserve, remove from YES reserve\n            amountOut = getAmountOut(amountIn, market.noReserve, market.yesReserve);\n            market.noReserve += amountIn;\n            market.yesReserve -= amountOut;\n            userPositions[_marketId][msg.sender].yesTokens += amountOut;\n        } else {\n            // Buy NO tokens: Add to YES reserve, remove from NO reserve\n            amountOut = getAmountOut(amountIn, market.yesReserve, market.noReserve);\n            market.yesReserve += amountIn;\n            market.noReserve -= amountOut;\n            userPositions[_marketId][msg.sender].noTokens += amountOut;\n        }\n\n        // Update k\n        market.k = market.yesReserve * market.noReserve;\n\n        emit TokensTraded(_marketId, msg.sender, _buyYes, amountIn, amountOut);\n    }\n\n    /**\n     * @notice Sell outcome tokens\n     * @param _marketId Market ID\n     * @param _sellYes True to sell YES, false to sell NO\n     * @param _amount Amount of tokens to sell\n     */\n    function sellTokens(uint256 _marketId, bool _sellYes, uint256 _amount) external nonReentrant {\n        Market storage market = markets[_marketId];\n        require(!market.resolved, \"Market resolved\");\n\n        UserPosition storage position = userPositions[_marketId][msg.sender];\n        \n        uint256 amountOut;\n        if (_sellYes) {\n            require(position.yesTokens >= _amount, \"Insufficient YES tokens\");\n            amountOut = getAmountOut(_amount, market.yesReserve, market.noReserve);\n            market.yesReserve += _amount;\n            market.noReserve -= amountOut;\n            position.yesTokens -= _amount;\n        } else {\n            require(position.noTokens >= _amount, \"Insufficient NO tokens\");\n            amountOut = getAmountOut(_amount, market.noReserve, market.yesReserve);\n            market.noReserve += _amount;\n            market.yesReserve -= amountOut;\n            position.noTokens -= _amount;\n        }\n\n        uint256 fee = (amountOut * tradingFee) / 10000;\n        uint256 amountOutAfterFee = amountOut - fee;\n\n        market.k = market.yesReserve * market.noReserve;\n\n        payable(msg.sender).transfer(amountOutAfterFee);\n\n        emit TokensTraded(_marketId, msg.sender, !_sellYes, _amount, amountOutAfterFee);\n    }\n\n    /**\n     * @notice Calculate output amount using constant product formula\n     * @param amountIn Input amount\n     * @param reserveIn Input reserve\n     * @param reserveOut Output reserve\n     */\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) public pure returns (uint256 amountOut) {\n        require(amountIn > 0, \"Insufficient input\");\n        require(reserveIn > 0 && reserveOut > 0, \"Insufficient liquidity\");\n\n        uint256 numerator = amountIn * reserveOut;\n        uint256 denominator = reserveIn + amountIn;\n        amountOut = numerator / denominator;\n    }\n\n    /**\n     * @notice Resolve market\n     */\n    function resolveMarket(uint256 _marketId, bool _outcome) external onlyOwner nonReentrant {\n        Market storage market = markets[_marketId];\n        require(!market.resolved, \"Already resolved\");\n\n        market.resolved = true;\n        market.finalOutcome = _outcome;\n        market.resolvedAt = uint32(block.timestamp);\n\n        emit MarketResolved(_marketId, _outcome);\n    }\n\n    /**\n     * @notice Claim winnings after resolution\n     */\n    function claimWinnings(uint256 _marketId) external nonReentrant {\n        Market storage market = markets[_marketId];\n        require(market.resolved, \"Not resolved\");\n\n        UserPosition storage position = userPositions[_marketId][msg.sender];\n        require(!position.claimed, \"Already claimed\");\n\n        uint256 winningTokens = market.finalOutcome ? position.yesTokens : position.noTokens;\n        require(winningTokens > 0, \"No winning position\");\n\n        // Each winning token is worth 1 BNB\n        position.claimed = true;\n        payable(msg.sender).transfer(winningTokens);\n    }\n\n    /**\n     * @notice Get current price (probability) of YES outcome\n     * @return Price in basis points (5000 = 50%)\n     */\n    function getCurrentPrice(uint256 _marketId) external view returns (uint256) {\n        Market memory market = markets[_marketId];\n        return (market.noReserve * 10000) / (market.yesReserve + market.noReserve);\n    }\n\n    /**\n     * @notice Square root function for liquidity calculation\n     */\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\n        uint256 z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n    }\n}\n"
    },
    "contracts/AutomatedMarketResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./SoraOracle.sol\";\nimport \"./SimplePredictionMarket.sol\";\n\n/**\n * @title AutomatedMarketResolver\n * @notice Automated helper contract for resolving prediction markets\n * @dev Monitors oracle answers and automatically resolves markets when conditions are met\n */\ncontract AutomatedMarketResolver {\n    \n    SoraOracle public immutable oracle;\n    SimplePredictionMarket public immutable market;\n    \n    uint256 public constant MIN_CONFIDENCE_THRESHOLD = 80;\n    \n    event MarketAutoResolved(\n        uint256 indexed marketId,\n        uint256 indexed questionId,\n        bool outcome,\n        uint8 confidence\n    );\n    \n    event ResolutionFailed(\n        uint256 indexed marketId,\n        string reason\n    );\n    \n    constructor(address _oracle, address _market) {\n        require(_oracle != address(0), \"Invalid oracle\");\n        require(_market != address(0), \"Invalid market\");\n        oracle = SoraOracle(payable(_oracle));\n        market = SimplePredictionMarket(_market);\n    }\n    \n    /**\n     * @notice Automatically resolve a market if oracle answer meets requirements\n     * @param _marketId Market ID to resolve\n     * @return success True if market was resolved\n     */\n    function tryResolveMarket(uint256 _marketId) \n        external \n        returns (bool success) \n    {\n        // Get market details\n        SimplePredictionMarket.Market memory marketData;\n        (\n            marketData.question,\n            marketData.questionId,\n            marketData.resolutionTime,\n            marketData.yesPool,\n            marketData.noPool,\n            marketData.status,\n            marketData.outcome,\n            marketData.totalFees\n        ) = market.markets(_marketId);\n        \n        uint256 questionId = marketData.questionId;\n        SimplePredictionMarket.MarketStatus status = marketData.status;\n        \n        // Verify market is still open or closed (not resolved)\n        if (\n            status != SimplePredictionMarket.MarketStatus.OPEN &&\n            status != SimplePredictionMarket.MarketStatus.CLOSED\n        ) {\n            emit ResolutionFailed(_marketId, \"Market already resolved or canceled\");\n            return false;\n        }\n        \n        // Get oracle answer\n        (, SoraOracle.Answer memory answer) = oracle.getQuestionWithAnswer(questionId);\n        \n        // Check if answer exists\n        if (answer.provider == address(0)) {\n            emit ResolutionFailed(_marketId, \"No answer yet\");\n            return false;\n        }\n        \n        // Check confidence threshold\n        if (answer.confidenceScore < MIN_CONFIDENCE_THRESHOLD) {\n            emit ResolutionFailed(_marketId, \"Confidence too low\");\n            return false;\n        }\n        \n        // Resolve market\n        try market.resolveMarket(_marketId) {\n            emit MarketAutoResolved(\n                _marketId,\n                questionId,\n                answer.boolAnswer,\n                answer.confidenceScore\n            );\n            return true;\n        } catch Error(string memory reason) {\n            emit ResolutionFailed(_marketId, reason);\n            return false;\n        } catch {\n            emit ResolutionFailed(_marketId, \"Unknown error\");\n            return false;\n        }\n    }\n    \n    /**\n     * @notice Batch resolve multiple markets\n     * @param _marketIds Array of market IDs to resolve\n     * @return successCount Number of successfully resolved markets\n     */\n    function batchResolveMarkets(uint256[] calldata _marketIds) \n        external \n        returns (uint256 successCount) \n    {\n        for (uint256 i = 0; i < _marketIds.length; i++) {\n            if (this.tryResolveMarket(_marketIds[i])) {\n                successCount++;\n            }\n        }\n    }\n    \n    /**\n     * @notice Check if a market is ready to be resolved\n     * @param _marketId Market ID\n     * @return ready True if market can be resolved\n     * @return reason Reason why it can or cannot be resolved\n     */\n    function canResolveMarket(uint256 _marketId) \n        external \n        view \n        returns (bool ready, string memory reason) \n    {\n        // Get market details\n        SimplePredictionMarket.Market memory marketData;\n        (\n            marketData.question,\n            marketData.questionId,\n            marketData.resolutionTime,\n            marketData.yesPool,\n            marketData.noPool,\n            marketData.status,\n            marketData.outcome,\n            marketData.totalFees\n        ) = market.markets(_marketId);\n        \n        uint256 questionId = marketData.questionId;\n        uint256 resolutionTime = marketData.resolutionTime;\n        SimplePredictionMarket.MarketStatus status = marketData.status;\n        \n        // Check market status\n        if (status == SimplePredictionMarket.MarketStatus.RESOLVED) {\n            return (false, \"Already resolved\");\n        }\n        \n        if (status == SimplePredictionMarket.MarketStatus.CANCELED) {\n            return (false, \"Market canceled\");\n        }\n        \n        // Check if resolution time has passed\n        if (block.timestamp < resolutionTime) {\n            return (false, \"Resolution time not reached\");\n        }\n        \n        // Get oracle answer\n        (, SoraOracle.Answer memory answer) = oracle.getQuestionWithAnswer(questionId);\n        \n        if (answer.provider == address(0)) {\n            return (false, \"No answer yet\");\n        }\n        \n        if (answer.confidenceScore < MIN_CONFIDENCE_THRESHOLD) {\n            return (false, \"Confidence too low\");\n        }\n        \n        return (true, \"Ready to resolve\");\n    }\n    \n    /**\n     * @notice Get batch resolution status for multiple markets\n     * @param _marketIds Array of market IDs\n     * @return readyMarkets Array of market IDs that are ready to resolve\n     */\n    function getBatchResolutionStatus(uint256[] calldata _marketIds) \n        external \n        view \n        returns (uint256[] memory readyMarkets) \n    {\n        uint256 readyCount = 0;\n        uint256[] memory temp = new uint256[](_marketIds.length);\n        \n        for (uint256 i = 0; i < _marketIds.length; i++) {\n            (bool ready, ) = this.canResolveMarket(_marketIds[i]);\n            if (ready) {\n                temp[readyCount] = _marketIds[i];\n                readyCount++;\n            }\n        }\n        \n        readyMarkets = new uint256[](readyCount);\n        for (uint256 i = 0; i < readyCount; i++) {\n            readyMarkets[i] = temp[i];\n        }\n    }\n}\n"
    },
    "contracts/BatchOracleOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./SoraOracle.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title BatchOracleOperations\n * @notice Gas-efficient batch operations for asking and answering multiple questions\n * @dev Reduces gas costs by ~30% when processing multiple questions in one transaction\n */\ncontract BatchOracleOperations is ReentrancyGuard {\n    \n    SoraOracle public immutable oracle;\n    \n    event BatchQuestionsAsked(uint256[] questionIds, address indexed requester);\n    event BatchAnswersProvided(uint256[] questionIds, address indexed provider);\n    \n    constructor(address _oracle) {\n        require(_oracle != address(0), \"Invalid oracle\");\n        oracle = SoraOracle(payable(_oracle));\n    }\n    \n    /**\n     * @notice Ask multiple general questions in one transaction\n     * @param _questions Array of question texts\n     * @param _deadlines Array of deadlines for each question\n     * @return questionIds Array of created question IDs\n     */\n    function batchAskQuestions(\n        string[] calldata _questions,\n        uint256[] calldata _deadlines\n    ) external payable nonReentrant returns (uint256[] memory questionIds) {\n        require(_questions.length == _deadlines.length, \"Length mismatch\");\n        require(_questions.length > 0, \"Empty batch\");\n        require(_questions.length <= 20, \"Batch too large\"); // Prevent block gas limit issues\n        \n        uint256 oracleFee = oracle.oracleFee();\n        uint256 totalFee = oracleFee * _questions.length;\n        require(msg.value >= totalFee, \"Insufficient fee\");\n        \n        questionIds = new uint256[](_questions.length);\n        \n        for (uint256 i = 0; i < _questions.length; i++) {\n            questionIds[i] = oracle.askOracle{value: oracleFee}(\n                _questions[i],\n                _deadlines[i]\n            );\n        }\n        \n        // Refund excess\n        if (msg.value > totalFee) {\n            (bool success, ) = msg.sender.call{value: msg.value - totalFee}(\"\");\n            require(success, \"Refund failed\");\n        }\n        \n        emit BatchQuestionsAsked(questionIds, msg.sender);\n    }\n    \n    /**\n     * @notice Ask multiple yes/no questions in one transaction\n     * @param _questions Array of yes/no question texts\n     * @param _deadlines Array of deadlines\n     * @return questionIds Array of created question IDs\n     */\n    function batchAskYesNoQuestions(\n        string[] calldata _questions,\n        uint256[] calldata _deadlines\n    ) external payable nonReentrant returns (uint256[] memory questionIds) {\n        require(_questions.length == _deadlines.length, \"Length mismatch\");\n        require(_questions.length > 0, \"Empty batch\");\n        require(_questions.length <= 20, \"Batch too large\");\n        \n        uint256 oracleFee = oracle.oracleFee();\n        uint256 totalFee = oracleFee * _questions.length;\n        require(msg.value >= totalFee, \"Insufficient fee\");\n        \n        questionIds = new uint256[](_questions.length);\n        \n        for (uint256 i = 0; i < _questions.length; i++) {\n            questionIds[i] = oracle.askYesNoQuestion{value: oracleFee}(\n                _questions[i],\n                _deadlines[i]\n            );\n        }\n        \n        if (msg.value > totalFee) {\n            (bool success, ) = msg.sender.call{value: msg.value - totalFee}(\"\");\n            require(success, \"Refund failed\");\n        }\n        \n        emit BatchQuestionsAsked(questionIds, msg.sender);\n    }\n    \n    /**\n     * @notice Provide answers to multiple questions in one transaction\n     * @dev Can only be called by the oracle provider\n     * @param _questionIds Array of question IDs to answer\n     * @param _textAnswers Array of text answers\n     * @param _numericAnswers Array of numeric answers\n     * @param _boolAnswers Array of boolean answers\n     * @param _confidenceScores Array of confidence scores (0-100)\n     * @param _dataSources Array of data source descriptions\n     */\n    function batchProvideAnswers(\n        uint256[] calldata _questionIds,\n        string[] calldata _textAnswers,\n        uint256[] calldata _numericAnswers,\n        bool[] calldata _boolAnswers,\n        uint8[] calldata _confidenceScores,\n        string[] calldata _dataSources\n    ) external {\n        require(_questionIds.length == _textAnswers.length, \"Length mismatch\");\n        require(_questionIds.length == _numericAnswers.length, \"Length mismatch\");\n        require(_questionIds.length == _boolAnswers.length, \"Length mismatch\");\n        require(_questionIds.length == _confidenceScores.length, \"Length mismatch\");\n        require(_questionIds.length == _dataSources.length, \"Length mismatch\");\n        require(_questionIds.length > 0, \"Empty batch\");\n        require(_questionIds.length <= 20, \"Batch too large\");\n        \n        // Verify caller is oracle provider\n        require(msg.sender == oracle.oracleProvider(), \"Not oracle provider\");\n        \n        for (uint256 i = 0; i < _questionIds.length; i++) {\n            oracle.provideAnswer(\n                _questionIds[i],\n                _textAnswers[i],\n                _numericAnswers[i],\n                _boolAnswers[i],\n                _confidenceScores[i],\n                _dataSources[i]\n            );\n        }\n        \n        emit BatchAnswersProvided(_questionIds, msg.sender);\n    }\n    \n    /**\n     * @notice Get the total cost for asking N questions\n     * @param _numQuestions Number of questions to ask\n     * @return Total cost in BNB\n     */\n    function getBatchQuestionCost(uint256 _numQuestions) external view returns (uint256) {\n        return oracle.oracleFee() * _numQuestions;\n    }\n    \n    /**\n     * @notice Check if a batch of questions have all been answered\n     * @param _questionIds Array of question IDs to check\n     * @return allAnswered True if all questions answered\n     * @return answeredCount Number of answered questions\n     */\n    function checkBatchStatus(uint256[] calldata _questionIds) \n        external \n        view \n        returns (bool allAnswered, uint256 answeredCount) \n    {\n        answeredCount = 0;\n        \n        for (uint256 i = 0; i < _questionIds.length; i++) {\n            (, SoraOracle.Answer memory answer) = oracle.getQuestionWithAnswer(_questionIds[i]);\n            if (answer.provider != address(0)) {\n                answeredCount++;\n            }\n        }\n        \n        allAnswered = (answeredCount == _questionIds.length);\n    }\n}\n"
    },
    "contracts/BatchPayoutDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./SimplePredictionMarket.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title BatchPayoutDistributor\n * @notice Automatically distributes winnings to all market participants\n * @dev Enables gas-efficient batch payouts instead of individual claims\n */\ncontract BatchPayoutDistributor is Ownable, ReentrancyGuard {\n    \n    SimplePredictionMarket public immutable market;\n    \n    // Track distributed payouts to prevent double-claims\n    mapping(uint256 => mapping(address => bool)) public distributed;\n    \n    event BatchDistributionStarted(uint256 indexed marketId, uint256 participantCount);\n    event WinningsDistributed(uint256 indexed marketId, address indexed winner, uint256 amount);\n    event DistributionFailed(uint256 indexed marketId, address indexed participant, string reason);\n    event DistributionCompleted(uint256 indexed marketId, uint256 successCount, uint256 failureCount);\n    \n    constructor(address _market) Ownable(msg.sender) {\n        require(_market != address(0), \"Invalid market\");\n        market = SimplePredictionMarket(_market);\n    }\n    \n    /**\n     * @notice Batch distribute winnings to all participants in a resolved market\n     * @param _marketId Market ID\n     * @param _participants Array of all addresses that participated in the market\n     * @dev Caller must provide participant list since contract can't enumerate mappings\n     * @return successCount Number of successful distributions\n     * @return failureCount Number of failed distributions\n     */\n    function distributeWinnings(\n        uint256 _marketId,\n        address[] calldata _participants\n    ) \n        external\n        nonReentrant\n        returns (uint256 successCount, uint256 failureCount)\n    {\n        require(_participants.length > 0, \"No participants\");\n        require(_participants.length <= 100, \"Too many participants, split into batches\");\n        \n        // Verify market is resolved\n        SimplePredictionMarket.Market memory marketData = market.getMarket(_marketId);\n        require(\n            marketData.status == SimplePredictionMarket.MarketStatus.RESOLVED,\n            \"Market not resolved\"\n        );\n        \n        emit BatchDistributionStarted(_marketId, _participants.length);\n        \n        for (uint256 i = 0; i < _participants.length; i++) {\n            address participant = _participants[i];\n            \n            // Skip if already distributed\n            if (distributed[_marketId][participant]) {\n                continue;\n            }\n            \n            // Check if participant has winnings\n            uint256 winnings = market.calculateWinnings(_marketId, participant);\n            \n            if (winnings == 0) {\n                failureCount++;\n                emit DistributionFailed(_marketId, participant, \"No winnings\");\n                continue;\n            }\n            \n            // Check if already claimed directly\n            SimplePredictionMarket.Position memory position = market.getPosition(_marketId, participant);\n            if (position.claimed) {\n                distributed[_marketId][participant] = true;\n                failureCount++;\n                emit DistributionFailed(_marketId, participant, \"Already claimed\");\n                continue;\n            }\n            \n            // Attempt distribution via market's claimWinnings\n            // We use a try-catch to handle any failures gracefully\n            try this._distributeSingle(_marketId, participant) {\n                distributed[_marketId][participant] = true;\n                successCount++;\n                emit WinningsDistributed(_marketId, participant, winnings);\n            } catch Error(string memory reason) {\n                failureCount++;\n                emit DistributionFailed(_marketId, participant, reason);\n            } catch {\n                failureCount++;\n                emit DistributionFailed(_marketId, participant, \"Unknown error\");\n            }\n        }\n        \n        emit DistributionCompleted(_marketId, successCount, failureCount);\n    }\n    \n    /**\n     * @notice Internal helper to distribute to a single participant\n     * @dev Separated for try-catch in batch distribution\n     * @param _marketId Market ID\n     * @param _participant Participant address\n     */\n    function _distributeSingle(uint256 _marketId, address _participant) external {\n        require(msg.sender == address(this), \"Internal only\");\n        \n        // Use delegated claiming (requires this contract to be approved distributor)\n        market.claimWinningsFor(_marketId, _participant);\n    }\n    \n    /**\n     * @notice Check how many participants have unclaimed winnings\n     * @param _marketId Market ID\n     * @param _participants Array of potential winners\n     * @return unclaimedCount Number of participants with unclaimed winnings\n     * @return totalUnclaimed Total amount of unclaimed winnings\n     */\n    function getUnclaimedStats(\n        uint256 _marketId,\n        address[] calldata _participants\n    )\n        external\n        view\n        returns (uint256 unclaimedCount, uint256 totalUnclaimed)\n    {\n        for (uint256 i = 0; i < _participants.length; i++) {\n            SimplePredictionMarket.Position memory position = market.getPosition(_marketId, _participants[i]);\n            \n            if (!position.claimed && !distributed[_marketId][_participants[i]]) {\n                uint256 winnings = market.calculateWinnings(_marketId, _participants[i]);\n                if (winnings > 0) {\n                    unclaimedCount++;\n                    totalUnclaimed += winnings;\n                }\n            }\n        }\n    }\n    \n    /**\n     * @notice Get list of participants with unclaimed winnings\n     * @param _marketId Market ID  \n     * @param _participants Array of potential winners\n     * @return winners Array of addresses with unclaimed winnings\n     * @return amounts Array of corresponding winning amounts\n     */\n    function getUnclaimedWinners(\n        uint256 _marketId,\n        address[] calldata _participants\n    )\n        external\n        view\n        returns (address[] memory winners, uint256[] memory amounts)\n    {\n        // First pass: count unclaimed\n        uint256 count = 0;\n        for (uint256 i = 0; i < _participants.length; i++) {\n            SimplePredictionMarket.Position memory position = market.getPosition(_marketId, _participants[i]);\n            if (!position.claimed && !distributed[_marketId][_participants[i]]) {\n                uint256 winnings = market.calculateWinnings(_marketId, _participants[i]);\n                if (winnings > 0) {\n                    count++;\n                }\n            }\n        }\n        \n        // Second pass: collect data\n        winners = new address[](count);\n        amounts = new uint256[](count);\n        uint256 index = 0;\n        \n        for (uint256 i = 0; i < _participants.length; i++) {\n            SimplePredictionMarket.Position memory position = market.getPosition(_marketId, _participants[i]);\n            if (!position.claimed && !distributed[_marketId][_participants[i]]) {\n                uint256 winnings = market.calculateWinnings(_marketId, _participants[i]);\n                if (winnings > 0) {\n                    winners[index] = _participants[i];\n                    amounts[index] = winnings;\n                    index++;\n                }\n            }\n        }\n    }\n}\n"
    },
    "contracts/ConditionalMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./SimplePredictionMarket.sol\";\n\n/**\n * @title ConditionalMarket\n * @notice Prediction market that depends on outcomes of other markets\n * @dev Example: \"Will BTC hit $100k IF Fed cuts rates?\" depends on Fed rate decision market\n */\ncontract ConditionalMarket is Ownable, ReentrancyGuard {\n    \n    enum MarketStatus { ACTIVE, PARENT_UNRESOLVED, CONDITION_NOT_MET, RESOLVED, CANCELLED }\n\n    struct Market {\n        string question;\n        address parentMarket;       // Market this depends on\n        uint8 requiredParentOutcome; // Outcome needed for this market to activate\n        uint256 yesPool;\n        uint256 noPool;\n        uint256 totalFees;\n        uint32 createdAt;\n        uint32 resolvedAt;\n        MarketStatus status;\n        bool finalOutcome;\n    }\n\n    struct Position {\n        uint256 yesAmount;\n        uint256 noAmount;\n        bool claimed;\n    }\n\n    mapping(uint256 => Market) public markets;\n    mapping(uint256 => mapping(address => Position)) public positions;\n    uint256 public marketCounter;\n    uint256 public feePercentage = 200; // 2%\n\n    event MarketCreated(uint256 indexed marketId, string question, address indexed parentMarket, uint8 requiredOutcome);\n    event PositionTaken(uint256 indexed marketId, address indexed user, bool prediction, uint256 amount);\n    event ParentResolved(uint256 indexed marketId, bool conditionMet);\n    event MarketResolved(uint256 indexed marketId, bool outcome);\n    event WinningsClaimed(uint256 indexed marketId, address indexed user, uint256 amount);\n\n    constructor() Ownable(msg.sender) {}\n\n    /**\n     * @notice Create conditional market\n     * @param _question Market question\n     * @param _parentMarket Address of parent market\n     * @param _requiredParentOutcome Required parent outcome (0=no, 1=yes for binary)\n     */\n    function createMarket(\n        string memory _question,\n        address _parentMarket,\n        uint8 _requiredParentOutcome\n    ) external payable returns (uint256 marketId) {\n        require(bytes(_question).length > 0, \"Empty question\");\n        require(_parentMarket != address(0), \"Invalid parent market\");\n\n        marketId = marketCounter++;\n\n        markets[marketId] = Market({\n            question: _question,\n            parentMarket: _parentMarket,\n            requiredParentOutcome: _requiredParentOutcome,\n            yesPool: 0,\n            noPool: 0,\n            totalFees: 0,\n            createdAt: uint32(block.timestamp),\n            resolvedAt: 0,\n            status: MarketStatus.ACTIVE,\n            finalOutcome: false\n        });\n\n        emit MarketCreated(marketId, _question, _parentMarket, _requiredParentOutcome);\n        return marketId;\n    }\n\n    /**\n     * @notice Take position in conditional market\n     * @param _marketId Market ID\n     * @param _prediction True for yes, false for no\n     */\n    function takePosition(uint256 _marketId, bool _prediction) external payable nonReentrant {\n        Market storage market = markets[_marketId];\n        require(market.status == MarketStatus.ACTIVE, \"Market not active\");\n        require(msg.value > 0, \"Must send BNB\");\n\n        // Calculate fee\n        uint256 fee = (msg.value * feePercentage) / 10000;\n        uint256 betAmount = msg.value - fee;\n\n        market.totalFees += fee;\n\n        if (_prediction) {\n            market.yesPool += betAmount;\n            positions[_marketId][msg.sender].yesAmount += betAmount;\n        } else {\n            market.noPool += betAmount;\n            positions[_marketId][msg.sender].noAmount += betAmount;\n        }\n\n        emit PositionTaken(_marketId, msg.sender, _prediction, betAmount);\n    }\n\n    /**\n     * @notice Check parent market and update status\n     * @param _marketId Market to check\n     */\n    function checkParentMarket(uint256 _marketId) external nonReentrant {\n        Market storage market = markets[_marketId];\n        require(market.status == MarketStatus.ACTIVE, \"Market not active\");\n\n        // Try to get parent market outcome\n        SimplePredictionMarket parentMarket = SimplePredictionMarket(market.parentMarket);\n        \n        // Check parent market status and outcome\n        try parentMarket.markets(0) returns (\n            string memory,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            SimplePredictionMarket.MarketStatus status,\n            SimplePredictionMarket.Outcome outcome,\n            uint256\n        ) {\n            // Check if resolved\n            if (status == SimplePredictionMarket.MarketStatus.RESOLVED) {\n                // Check if condition met\n                bool conditionMet = (outcome == SimplePredictionMarket.Outcome.YES && market.requiredParentOutcome == 1) || \n                                   (outcome == SimplePredictionMarket.Outcome.NO && market.requiredParentOutcome == 0);\n                \n                if (conditionMet) {\n                    market.status = MarketStatus.PARENT_UNRESOLVED; // Ready for resolution\n                } else {\n                    market.status = MarketStatus.CONDITION_NOT_MET;\n                    _refundAll(_marketId);\n                }\n\n                emit ParentResolved(_marketId, conditionMet);\n            }\n        } catch {\n            revert(\"Invalid parent market\");\n        }\n    }\n\n    /**\n     * @notice Resolve conditional market (only if parent condition met)\n     * @param _marketId Market to resolve\n     * @param _outcome Final outcome\n     */\n    function resolveMarket(uint256 _marketId, bool _outcome) external onlyOwner nonReentrant {\n        Market storage market = markets[_marketId];\n        require(\n            market.status == MarketStatus.PARENT_UNRESOLVED || market.status == MarketStatus.ACTIVE,\n            \"Cannot resolve\"\n        );\n\n        market.finalOutcome = _outcome;\n        market.resolvedAt = uint32(block.timestamp);\n        market.status = MarketStatus.RESOLVED;\n\n        emit MarketResolved(_marketId, _outcome);\n    }\n\n    /**\n     * @notice Claim winnings\n     */\n    function claimWinnings(uint256 _marketId) external nonReentrant {\n        Market storage market = markets[_marketId];\n        require(market.status == MarketStatus.RESOLVED, \"Not resolved\");\n        \n        Position storage position = positions[_marketId][msg.sender];\n        require(!position.claimed, \"Already claimed\");\n        require(position.yesAmount > 0 || position.noAmount > 0, \"No position\");\n\n        uint256 winningPool = market.finalOutcome ? market.yesPool : market.noPool;\n        uint256 losingPool = market.finalOutcome ? market.noPool : market.yesPool;\n        uint256 userWinningAmount = market.finalOutcome ? position.yesAmount : position.noAmount;\n\n        require(userWinningAmount > 0, \"Not a winner\");\n\n        // Calculate payout: original bet + proportional share of losing pool\n        uint256 payout = userWinningAmount + ((userWinningAmount * losingPool) / winningPool);\n\n        position.claimed = true;\n        payable(msg.sender).transfer(payout);\n\n        emit WinningsClaimed(_marketId, msg.sender, payout);\n    }\n\n    /**\n     * @notice Refund all participants if condition not met\n     */\n    function _refundAll(uint256 _marketId) private {\n        Market storage market = markets[_marketId];\n        market.status = MarketStatus.CANCELLED;\n        \n        // Note: In production, would need to track all participants\n        // For now, users can call refund() themselves\n    }\n\n    /**\n     * @notice Get refund if market cancelled\n     */\n    function getRefund(uint256 _marketId) external nonReentrant {\n        Market storage market = markets[_marketId];\n        require(market.status == MarketStatus.CONDITION_NOT_MET || market.status == MarketStatus.CANCELLED, \"Not cancelled\");\n        \n        Position storage position = positions[_marketId][msg.sender];\n        require(!position.claimed, \"Already claimed\");\n        require(position.yesAmount > 0 || position.noAmount > 0, \"No position\");\n\n        uint256 refundAmount = position.yesAmount + position.noAmount;\n        position.claimed = true;\n        \n        payable(msg.sender).transfer(refundAmount);\n    }\n\n    /**\n     * @notice Get market details\n     */\n    function getMarket(uint256 _marketId) external view returns (\n        string memory question,\n        address parentMarket,\n        uint256 yesPool,\n        uint256 noPool,\n        MarketStatus status,\n        bool finalOutcome\n    ) {\n        Market memory market = markets[_marketId];\n        return (\n            market.question,\n            market.parentMarket,\n            market.yesPool,\n            market.noPool,\n            market.status,\n            market.finalOutcome\n        );\n    }\n\n    /**\n     * @notice Get user position\n     */\n    function getPosition(uint256 _marketId, address _user) external view returns (\n        uint256 yesAmount,\n        uint256 noAmount,\n        bool claimed\n    ) {\n        Position memory position = positions[_marketId][_user];\n        return (position.yesAmount, position.noAmount, position.claimed);\n    }\n}\n"
    },
    "contracts/CrossChainBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title CrossChainBridge\n * @notice Bridge oracle data between BNB Chain and other networks\n * @dev Uses message verification and relayer system for cross-chain communication\n */\ncontract CrossChainBridge is Ownable, ReentrancyGuard {\n    \n    enum ChainType { ETHEREUM, POLYGON, ARBITRUM, OPTIMISM, BASE }\n    enum MessageStatus { PENDING, VERIFIED, EXECUTED, FAILED }\n\n    struct CrossChainMessage {\n        uint256 sourceChainId;\n        uint256 targetChainId;\n        bytes32 messageHash;\n        bytes payload;\n        uint32 timestamp;\n        MessageStatus status;\n        address relayer;\n    }\n\n    struct ChainConfig {\n        ChainType chainType;\n        uint256 chainId;\n        address bridgeContract;\n        bool active;\n        uint32 confirmationBlocks;\n    }\n\n    mapping(bytes32 => CrossChainMessage) public messages;\n    mapping(uint256 => ChainConfig) public chainConfigs;\n    mapping(address => bool) public authorizedRelayers;\n    mapping(bytes32 => mapping(address => bool)) public messageVerifications;\n    \n    bytes32[] public pendingMessages;\n    uint256[] public supportedChains;\n    address[] public relayerList;\n    \n    uint8 public requiredVerifications = 2;\n    uint256 public relayerFee = 0.005 ether;\n\n    event ChainConfigured(uint256 indexed chainId, ChainType chainType, address bridgeContract);\n    event MessageSent(bytes32 indexed messageHash, uint256 sourceChain, uint256 targetChain, bytes payload);\n    event MessageVerified(bytes32 indexed messageHash, address indexed relayer);\n    event MessageExecuted(bytes32 indexed messageHash, bool success);\n    event RelayerAdded(address indexed relayer);\n    event RelayerRemoved(address indexed relayer);\n\n    constructor() Ownable(msg.sender) {}\n\n    /**\n     * @notice Configure a supported chain\n     * @param _chainId Chain ID (1 for Ethereum, 137 for Polygon, etc.)\n     * @param _chainType Type of chain\n     * @param _bridgeContract Bridge contract address on that chain\n     * @param _confirmationBlocks Required block confirmations\n     */\n    function configureChain(\n        uint256 _chainId,\n        ChainType _chainType,\n        address _bridgeContract,\n        uint32 _confirmationBlocks\n    ) external onlyOwner {\n        require(_bridgeContract != address(0), \"Invalid bridge contract\");\n        require(_confirmationBlocks > 0, \"Invalid confirmations\");\n\n        chainConfigs[_chainId] = ChainConfig({\n            chainType: _chainType,\n            chainId: _chainId,\n            bridgeContract: _bridgeContract,\n            active: true,\n            confirmationBlocks: _confirmationBlocks\n        });\n\n        // Add to supported chains if new\n        bool exists = false;\n        for (uint256 i = 0; i < supportedChains.length; i++) {\n            if (supportedChains[i] == _chainId) {\n                exists = true;\n                break;\n            }\n        }\n        if (!exists) {\n            supportedChains.push(_chainId);\n        }\n\n        emit ChainConfigured(_chainId, _chainType, _bridgeContract);\n    }\n\n    /**\n     * @notice Add authorized relayer\n     */\n    function addRelayer(address _relayer) external onlyOwner {\n        require(_relayer != address(0), \"Invalid relayer\");\n        require(!authorizedRelayers[_relayer], \"Already relayer\");\n        authorizedRelayers[_relayer] = true;\n        relayerList.push(_relayer);\n        emit RelayerAdded(_relayer);\n    }\n\n    /**\n     * @notice Remove relayer\n     */\n    function removeRelayer(address _relayer) external onlyOwner {\n        require(authorizedRelayers[_relayer], \"Not a relayer\");\n        authorizedRelayers[_relayer] = false;\n        emit RelayerRemoved(_relayer);\n    }\n\n    /**\n     * @notice Send oracle data to another chain\n     * @param _targetChainId Destination chain\n     * @param _payload Encoded oracle data\n     */\n    function sendCrossChainMessage(\n        uint256 _targetChainId,\n        bytes memory _payload\n    ) external payable nonReentrant returns (bytes32 messageHash) {\n        require(msg.value >= relayerFee, \"Insufficient relay fee\");\n        require(chainConfigs[_targetChainId].active, \"Chain not supported\");\n\n        uint256 sourceChainId = block.chainid;\n        messageHash = keccak256(abi.encodePacked(\n            sourceChainId,\n            _targetChainId,\n            _payload,\n            block.timestamp,\n            msg.sender\n        ));\n\n        messages[messageHash] = CrossChainMessage({\n            sourceChainId: sourceChainId,\n            targetChainId: _targetChainId,\n            messageHash: messageHash,\n            payload: _payload,\n            timestamp: uint32(block.timestamp),\n            status: MessageStatus.PENDING,\n            relayer: address(0)\n        });\n\n        pendingMessages.push(messageHash);\n        emit MessageSent(messageHash, sourceChainId, _targetChainId, _payload);\n\n        return messageHash;\n    }\n\n    /**\n     * @notice Verify a cross-chain message (called by relayers)\n     * @param _messageHash Message to verify\n     */\n    function verifyMessage(bytes32 _messageHash) external nonReentrant {\n        require(authorizedRelayers[msg.sender], \"Not authorized relayer\");\n        require(messages[_messageHash].status == MessageStatus.PENDING, \"Not pending\");\n        require(!messageVerifications[_messageHash][msg.sender], \"Already verified\");\n\n        messageVerifications[_messageHash][msg.sender] = true;\n\n        // Count all verifications for this message by checking all authorized relayers\n        uint8 verificationCount = 0;\n        for (uint256 i = 0; i < relayerList.length; i++) {\n            if (messageVerifications[_messageHash][relayerList[i]]) {\n                verificationCount++;\n            }\n        }\n\n        emit MessageVerified(_messageHash, msg.sender);\n\n        // If enough verifications, mark as verified\n        if (verificationCount >= requiredVerifications) {\n            messages[_messageHash].status = MessageStatus.VERIFIED;\n        }\n    }\n\n    /**\n     * @notice Execute verified cross-chain message\n     * @param _messageHash Message to execute\n     */\n    function executeMessage(bytes32 _messageHash) external nonReentrant {\n        CrossChainMessage storage message = messages[_messageHash];\n        require(message.status == MessageStatus.VERIFIED, \"Not verified\");\n        \n        // Mark as executed\n        message.status = MessageStatus.EXECUTED;\n        message.relayer = msg.sender;\n\n        // Decode and execute payload (implementation specific)\n        // For oracle data: could trigger answer submission, market resolution, etc.\n        \n        emit MessageExecuted(_messageHash, true);\n    }\n\n    /**\n     * @notice Get message details\n     */\n    function getMessage(bytes32 _messageHash) external view returns (\n        uint256 sourceChainId,\n        uint256 targetChainId,\n        bytes memory payload,\n        uint32 timestamp,\n        MessageStatus status\n    ) {\n        CrossChainMessage memory message = messages[_messageHash];\n        return (\n            message.sourceChainId,\n            message.targetChainId,\n            message.payload,\n            message.timestamp,\n            message.status\n        );\n    }\n\n    /**\n     * @notice Get all pending messages\n     */\n    function getPendingMessages() external view returns (bytes32[] memory) {\n        uint256 count = 0;\n        for (uint256 i = 0; i < pendingMessages.length; i++) {\n            if (messages[pendingMessages[i]].status == MessageStatus.PENDING) {\n                count++;\n            }\n        }\n\n        bytes32[] memory result = new bytes32[](count);\n        uint256 index = 0;\n        for (uint256 i = 0; i < pendingMessages.length; i++) {\n            if (messages[pendingMessages[i]].status == MessageStatus.PENDING) {\n                result[index] = pendingMessages[i];\n                index++;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @notice Get supported chains\n     */\n    function getSupportedChains() external view returns (uint256[] memory) {\n        return supportedChains;\n    }\n\n    /**\n     * @notice Update required verifications\n     */\n    function setRequiredVerifications(uint8 _required) external onlyOwner {\n        require(_required >= 1, \"Must require at least 1\");\n        requiredVerifications = _required;\n    }\n\n    /**\n     * @notice Update relayer fee\n     */\n    function setRelayerFee(uint256 _newFee) external onlyOwner {\n        relayerFee = _newFee;\n    }\n\n    /**\n     * @notice Withdraw accumulated fees\n     */\n    function withdrawFees() external onlyOwner {\n        uint256 balance = address(this).balance;\n        require(balance > 0, \"No fees to withdraw\");\n        payable(owner()).transfer(balance);\n    }\n}\n"
    },
    "contracts/DAOGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title DAOGovernance\n * @notice Decentralized governance for oracle system parameters\n * @dev Token-weighted voting on proposals (fees, parameters, oracle providers)\n */\ncontract DAOGovernance is Ownable, ReentrancyGuard {\n    \n    enum ProposalType { FEE_CHANGE, PARAMETER_CHANGE, ORACLE_ADDITION, ORACLE_REMOVAL, GENERAL }\n    enum ProposalStatus { PENDING, ACTIVE, PASSED, FAILED, EXECUTED, CANCELLED }\n\n    struct Proposal {\n        uint256 id;\n        ProposalType proposalType;\n        string title;\n        string description;\n        address proposer;\n        uint256 forVotes;\n        uint256 againstVotes;\n        uint32 startTime;\n        uint32 endTime;\n        ProposalStatus status;\n        bytes executionData;        // Encoded function call\n    }\n\n    struct Vote {\n        bool hasVoted;\n        bool support;\n        uint256 votePower;\n    }\n\n    mapping(uint256 => Proposal) public proposals;\n    mapping(uint256 => mapping(address => Vote)) public votes;\n    mapping(address => uint256) public votingPower;  // Based on stake/activity\n    \n    uint256 public proposalCounter;\n    uint256 public proposalThreshold = 100 ether;   // Min stake to create proposal\n    uint256 public quorum = 1000 ether;              // Min votes for validity\n    uint32 public votingPeriod = 3 days;\n    uint16 public passPercentage = 6000;            // 60% required to pass\n\n    address[] public voters;\n\n    event ProposalCreated(uint256 indexed proposalId, ProposalType proposalType, string title, address proposer);\n    event VoteCast(uint256 indexed proposalId, address indexed voter, bool support, uint256 votePower);\n    event ProposalExecuted(uint256 indexed proposalId, bool success);\n    event ProposalCancelled(uint256 indexed proposalId);\n    event VotingPowerUpdated(address indexed voter, uint256 newPower);\n\n    constructor() Ownable(msg.sender) {}\n\n    /**\n     * @notice Create governance proposal\n     * @param _proposalType Type of proposal\n     * @param _title Proposal title\n     * @param _description Detailed description\n     * @param _executionData Encoded function call (if applicable)\n     */\n    function createProposal(\n        ProposalType _proposalType,\n        string memory _title,\n        string memory _description,\n        bytes memory _executionData\n    ) external nonReentrant returns (uint256 proposalId) {\n        require(votingPower[msg.sender] >= proposalThreshold, \"Insufficient voting power\");\n        require(bytes(_title).length > 0, \"Empty title\");\n\n        proposalId = proposalCounter++;\n\n        proposals[proposalId] = Proposal({\n            id: proposalId,\n            proposalType: _proposalType,\n            title: _title,\n            description: _description,\n            proposer: msg.sender,\n            forVotes: 0,\n            againstVotes: 0,\n            startTime: uint32(block.timestamp),\n            endTime: uint32(block.timestamp + votingPeriod),\n            status: ProposalStatus.ACTIVE,\n            executionData: _executionData\n        });\n\n        emit ProposalCreated(proposalId, _proposalType, _title, msg.sender);\n        return proposalId;\n    }\n\n    /**\n     * @notice Cast vote on proposal\n     * @param _proposalId Proposal to vote on\n     * @param _support True for yes, false for no\n     */\n    function castVote(uint256 _proposalId, bool _support) external nonReentrant {\n        require(votingPower[msg.sender] > 0, \"No voting power\");\n        \n        Proposal storage proposal = proposals[_proposalId];\n        require(proposal.status == ProposalStatus.ACTIVE, \"Proposal not active\");\n        require(block.timestamp <= proposal.endTime, \"Voting ended\");\n\n        Vote storage vote = votes[_proposalId][msg.sender];\n        require(!vote.hasVoted, \"Already voted\");\n\n        uint256 power = votingPower[msg.sender];\n\n        vote.hasVoted = true;\n        vote.support = _support;\n        vote.votePower = power;\n\n        if (_support) {\n            proposal.forVotes += power;\n        } else {\n            proposal.againstVotes += power;\n        }\n\n        emit VoteCast(_proposalId, msg.sender, _support, power);\n    }\n\n    /**\n     * @notice Finalize proposal after voting period\n     */\n    function finalizeProposal(uint256 _proposalId) external nonReentrant {\n        Proposal storage proposal = proposals[_proposalId];\n        require(proposal.status == ProposalStatus.ACTIVE, \"Not active\");\n        require(block.timestamp > proposal.endTime, \"Voting not ended\");\n\n        uint256 totalVotes = proposal.forVotes + proposal.againstVotes;\n        \n        // Check quorum\n        if (totalVotes < quorum) {\n            proposal.status = ProposalStatus.FAILED;\n            return;\n        }\n\n        // Check if passed\n        uint256 forPercentage = (proposal.forVotes * 10000) / totalVotes;\n        if (forPercentage >= passPercentage) {\n            proposal.status = ProposalStatus.PASSED;\n        } else {\n            proposal.status = ProposalStatus.FAILED;\n        }\n    }\n\n    /**\n     * @notice Execute passed proposal\n     */\n    function executeProposal(uint256 _proposalId) external nonReentrant onlyOwner {\n        Proposal storage proposal = proposals[_proposalId];\n        require(proposal.status == ProposalStatus.PASSED, \"Not passed\");\n\n        proposal.status = ProposalStatus.EXECUTED;\n\n        // Execute proposal action (if executionData provided)\n        if (proposal.executionData.length > 0) {\n            (bool success,) = address(this).call(proposal.executionData);\n            emit ProposalExecuted(_proposalId, success);\n        } else {\n            emit ProposalExecuted(_proposalId, true);\n        }\n    }\n\n    /**\n     * @notice Cancel proposal (proposer or owner only)\n     */\n    function cancelProposal(uint256 _proposalId) external nonReentrant {\n        Proposal storage proposal = proposals[_proposalId];\n        require(\n            msg.sender == proposal.proposer || msg.sender == owner(),\n            \"Not authorized\"\n        );\n        require(\n            proposal.status == ProposalStatus.PENDING || proposal.status == ProposalStatus.ACTIVE,\n            \"Cannot cancel\"\n        );\n\n        proposal.status = ProposalStatus.CANCELLED;\n        emit ProposalCancelled(_proposalId);\n    }\n\n    /**\n     * @notice Update voting power (called by staking contract)\n     * @param _voter Address of voter\n     * @param _power New voting power\n     */\n    function updateVotingPower(address _voter, uint256 _power) external onlyOwner {\n        uint256 oldPower = votingPower[_voter];\n        votingPower[_voter] = _power;\n\n        // Add to voters list if new\n        if (oldPower == 0 && _power > 0) {\n            voters.push(_voter);\n        }\n\n        emit VotingPowerUpdated(_voter, _power);\n    }\n\n    /**\n     * @notice Get proposal details\n     */\n    function getProposal(uint256 _proposalId) external view returns (\n        ProposalType proposalType,\n        string memory title,\n        string memory description,\n        address proposer,\n        uint256 forVotes,\n        uint256 againstVotes,\n        uint32 endTime,\n        ProposalStatus status\n    ) {\n        Proposal memory proposal = proposals[_proposalId];\n        return (\n            proposal.proposalType,\n            proposal.title,\n            proposal.description,\n            proposal.proposer,\n            proposal.forVotes,\n            proposal.againstVotes,\n            proposal.endTime,\n            proposal.status\n        );\n    }\n\n    /**\n     * @notice Get vote details\n     */\n    function getVote(uint256 _proposalId, address _voter) external view returns (\n        bool hasVoted,\n        bool support,\n        uint256 votePower\n    ) {\n        Vote memory vote = votes[_proposalId][_voter];\n        return (vote.hasVoted, vote.support, vote.votePower);\n    }\n\n    /**\n     * @notice Get active proposals\n     */\n    function getActiveProposals() external view returns (uint256[] memory) {\n        uint256 count = 0;\n        for (uint256 i = 0; i < proposalCounter; i++) {\n            if (proposals[i].status == ProposalStatus.ACTIVE) {\n                count++;\n            }\n        }\n\n        uint256[] memory activeList = new uint256[](count);\n        uint256 index = 0;\n        for (uint256 i = 0; i < proposalCounter; i++) {\n            if (proposals[i].status == ProposalStatus.ACTIVE) {\n                activeList[index] = i;\n                index++;\n            }\n        }\n\n        return activeList;\n    }\n\n    /**\n     * @notice Update governance parameters\n     */\n    function setProposalThreshold(uint256 _newThreshold) external onlyOwner {\n        proposalThreshold = _newThreshold;\n    }\n\n    function setQuorum(uint256 _newQuorum) external onlyOwner {\n        quorum = _newQuorum;\n    }\n\n    function setVotingPeriod(uint32 _newPeriod) external onlyOwner {\n        require(_newPeriod >= 1 days && _newPeriod <= 14 days, \"Invalid period\");\n        votingPeriod = _newPeriod;\n    }\n\n    function setPassPercentage(uint16 _newPercentage) external onlyOwner {\n        require(_newPercentage >= 5000 && _newPercentage <= 9000, \"Must be 50-90%\");\n        passPercentage = _newPercentage;\n    }\n}\n"
    },
    "contracts/DisputeResolution.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./SoraOracle.sol\";\n\n/**\n * @title DisputeResolution\n * @notice Decentralized dispute resolution for oracle answers with stake-based voting\n * @dev Allows community to challenge answers by staking BNB\n */\ncontract DisputeResolution is Ownable, ReentrancyGuard {\n    \n    enum DisputeStatus { PENDING, VOTING, RESOLVED, CANCELED }\n    enum DisputeOutcome { UNDECIDED, CHALLENGER_WINS, PROVIDER_WINS }\n    \n    struct Dispute {\n        uint256 questionId;\n        address challenger;\n        address oracleProvider;\n        uint256 challengeStake;\n        uint256 providerStake;\n        uint256 totalVotesFor;\n        uint256 totalVotesAgainst;\n        uint256 createdAt;\n        uint256 votingDeadline;\n        DisputeStatus status;\n        DisputeOutcome outcome;\n        string reason;\n        string proposedAnswer;\n    }\n    \n    struct Vote {\n        uint256 stake;\n        bool votedForChallenger;\n        bool claimed;\n    }\n    \n    SoraOracle public immutable oracle;\n    \n    uint256 public constant MIN_CHALLENGE_STAKE = 0.05 ether;\n    uint256 public constant VOTING_PERIOD = 3 days;\n    uint256 public constant MIN_PROVIDER_STAKE = 0.1 ether;\n    \n    uint256 public disputeCounter;\n    \n    mapping(uint256 => Dispute) public disputes;\n    mapping(uint256 => mapping(address => Vote)) public votes;\n    mapping(uint256 => bool) public questionDisputed; // questionId => has active dispute\n    \n    event DisputeCreated(\n        uint256 indexed disputeId,\n        uint256 indexed questionId,\n        address indexed challenger,\n        uint256 stake,\n        string reason\n    );\n    \n    event VoteCast(\n        uint256 indexed disputeId,\n        address indexed voter,\n        uint256 stake,\n        bool votedForChallenger\n    );\n    \n    event DisputeResolved(\n        uint256 indexed disputeId,\n        DisputeOutcome outcome,\n        uint256 totalStake\n    );\n    \n    event StakeClaimed(\n        uint256 indexed disputeId,\n        address indexed claimer,\n        uint256 amount\n    );\n    \n    constructor(address _oracle) Ownable(msg.sender) {\n        require(_oracle != address(0), \"Invalid oracle\");\n        oracle = SoraOracle(payable(_oracle));\n    }\n    \n    /**\n     * @notice Challenge an oracle answer\n     * @param _questionId Question ID to challenge\n     * @param _reason Reason for challenge\n     * @param _proposedAnswer Proposed correct answer\n     */\n    function createDispute(\n        uint256 _questionId,\n        string calldata _reason,\n        string calldata _proposedAnswer\n    ) external payable nonReentrant returns (uint256 disputeId) {\n        require(msg.value >= MIN_CHALLENGE_STAKE, \"Insufficient stake\");\n        require(!questionDisputed[_questionId], \"Already disputed\");\n        require(bytes(_reason).length > 0, \"Reason required\");\n        \n        // Get question and answer from oracle\n        (SoraOracle.Question memory question, SoraOracle.Answer memory answer) = \n            oracle.getQuestionWithAnswer(_questionId);\n        \n        require(answer.provider != address(0), \"Question not answered\");\n        require(\n            question.status == SoraOracle.AnswerStatus.ANSWERED,\n            \"Invalid status\"\n        );\n        \n        disputeId = disputeCounter++;\n        \n        disputes[disputeId] = Dispute({\n            questionId: _questionId,\n            challenger: msg.sender,\n            oracleProvider: answer.provider,\n            challengeStake: msg.value,\n            providerStake: 0,\n            totalVotesFor: 0,\n            totalVotesAgainst: 0,\n            createdAt: block.timestamp,\n            votingDeadline: block.timestamp + VOTING_PERIOD,\n            status: DisputeStatus.PENDING,\n            outcome: DisputeOutcome.UNDECIDED,\n            reason: _reason,\n            proposedAnswer: _proposedAnswer\n        });\n        \n        questionDisputed[_questionId] = true;\n        \n        emit DisputeCreated(disputeId, _questionId, msg.sender, msg.value, _reason);\n    }\n    \n    /**\n     * @notice Oracle provider responds to dispute by staking\n     * @param _disputeId Dispute ID\n     */\n    function respondToDispute(uint256 _disputeId) external payable nonReentrant {\n        Dispute storage dispute = disputes[_disputeId];\n        \n        require(msg.sender == dispute.oracleProvider, \"Not the provider\");\n        require(dispute.status == DisputeStatus.PENDING, \"Not pending\");\n        require(msg.value >= MIN_PROVIDER_STAKE, \"Insufficient stake\");\n        \n        dispute.providerStake = msg.value;\n        dispute.status = DisputeStatus.VOTING;\n        \n        emit VoteCast(_disputeId, msg.sender, msg.value, false);\n    }\n    \n    /**\n     * @notice Vote on a dispute by staking\n     * @param _disputeId Dispute ID\n     * @param _voteForChallenger True to vote for challenger, false for provider\n     */\n    function voteOnDispute(uint256 _disputeId, bool _voteForChallenger) \n        external \n        payable \n        nonReentrant \n    {\n        require(msg.value > 0, \"Must stake to vote\");\n        Dispute storage dispute = disputes[_disputeId];\n        \n        require(dispute.status == DisputeStatus.VOTING, \"Not in voting phase\");\n        require(block.timestamp < dispute.votingDeadline, \"Voting ended\");\n        require(votes[_disputeId][msg.sender].stake == 0, \"Already voted\");\n        \n        votes[_disputeId][msg.sender] = Vote({\n            stake: msg.value,\n            votedForChallenger: _voteForChallenger,\n            claimed: false\n        });\n        \n        if (_voteForChallenger) {\n            dispute.totalVotesFor += msg.value;\n        } else {\n            dispute.totalVotesAgainst += msg.value;\n        }\n        \n        emit VoteCast(_disputeId, msg.sender, msg.value, _voteForChallenger);\n    }\n    \n    /**\n     * @notice Resolve dispute after voting period ends\n     * @param _disputeId Dispute ID\n     */\n    function resolveDispute(uint256 _disputeId) external nonReentrant {\n        Dispute storage dispute = disputes[_disputeId];\n        \n        require(dispute.status == DisputeStatus.VOTING, \"Not in voting\");\n        require(block.timestamp >= dispute.votingDeadline, \"Voting ongoing\");\n        \n        // Determine outcome based on total stakes\n        uint256 totalForChallenger = dispute.totalVotesFor + dispute.challengeStake;\n        uint256 totalForProvider = dispute.totalVotesAgainst + dispute.providerStake;\n        \n        if (totalForChallenger > totalForProvider) {\n            dispute.outcome = DisputeOutcome.CHALLENGER_WINS;\n        } else {\n            dispute.outcome = DisputeOutcome.PROVIDER_WINS;\n        }\n        \n        dispute.status = DisputeStatus.RESOLVED;\n        \n        uint256 totalStake = totalForChallenger + totalForProvider;\n        \n        emit DisputeResolved(_disputeId, dispute.outcome, totalStake);\n    }\n    \n    /**\n     * @notice Claim winnings after dispute is resolved\n     * @param _disputeId Dispute ID\n     */\n    function claimWinnings(uint256 _disputeId) external nonReentrant {\n        Dispute storage dispute = disputes[_disputeId];\n        \n        require(dispute.status == DisputeStatus.RESOLVED, \"Not resolved\");\n        \n        uint256 payout = 0;\n        \n        // Challenger claim\n        if (msg.sender == dispute.challenger && dispute.outcome == DisputeOutcome.CHALLENGER_WINS) {\n            uint256 totalWinningStake = dispute.totalVotesFor + dispute.challengeStake;\n            uint256 totalLosingStake = dispute.totalVotesAgainst + dispute.providerStake;\n            uint256 totalStake = totalWinningStake + totalLosingStake;\n            \n            payout = (dispute.challengeStake * totalStake) / totalWinningStake;\n            dispute.challengeStake = 0;\n        }\n        // Provider claim\n        else if (msg.sender == dispute.oracleProvider && dispute.outcome == DisputeOutcome.PROVIDER_WINS) {\n            uint256 totalWinningStake = dispute.totalVotesAgainst + dispute.providerStake;\n            uint256 totalLosingStake = dispute.totalVotesFor + dispute.challengeStake;\n            uint256 totalStake = totalWinningStake + totalLosingStake;\n            \n            payout = (dispute.providerStake * totalStake) / totalWinningStake;\n            dispute.providerStake = 0;\n        }\n        // Voter claim\n        else {\n            Vote storage vote = votes[_disputeId][msg.sender];\n            require(vote.stake > 0, \"No vote\");\n            require(!vote.claimed, \"Already claimed\");\n            \n            bool wonDispute = (\n                (dispute.outcome == DisputeOutcome.CHALLENGER_WINS && vote.votedForChallenger) ||\n                (dispute.outcome == DisputeOutcome.PROVIDER_WINS && !vote.votedForChallenger)\n            );\n            \n            if (wonDispute) {\n                uint256 totalWinningStake;\n                uint256 totalLosingStake;\n                \n                if (dispute.outcome == DisputeOutcome.CHALLENGER_WINS) {\n                    totalWinningStake = dispute.totalVotesFor + dispute.challengeStake;\n                    totalLosingStake = dispute.totalVotesAgainst + dispute.providerStake;\n                } else {\n                    totalWinningStake = dispute.totalVotesAgainst + dispute.providerStake;\n                    totalLosingStake = dispute.totalVotesFor + dispute.challengeStake;\n                }\n                \n                uint256 totalStake = totalWinningStake + totalLosingStake;\n                payout = (vote.stake * totalStake) / totalWinningStake;\n            }\n            \n            vote.claimed = true;\n        }\n        \n        require(payout > 0, \"No winnings\");\n        \n        (bool success, ) = msg.sender.call{value: payout}(\"\");\n        require(success, \"Transfer failed\");\n        \n        emit StakeClaimed(_disputeId, msg.sender, payout);\n    }\n    \n    /**\n     * @notice Cancel dispute if provider doesn't respond in time\n     * @param _disputeId Dispute ID\n     */\n    function cancelDispute(uint256 _disputeId) external nonReentrant {\n        Dispute storage dispute = disputes[_disputeId];\n        \n        require(dispute.status == DisputeStatus.PENDING, \"Not pending\");\n        require(\n            block.timestamp > dispute.createdAt + 1 days,\n            \"Wait for provider response\"\n        );\n        \n        dispute.status = DisputeStatus.CANCELED;\n        dispute.outcome = DisputeOutcome.CHALLENGER_WINS;\n        questionDisputed[dispute.questionId] = false;\n        \n        // Refund challenger\n        (bool success, ) = dispute.challenger.call{value: dispute.challengeStake}(\"\");\n        require(success, \"Refund failed\");\n        \n        emit DisputeResolved(_disputeId, DisputeOutcome.CHALLENGER_WINS, dispute.challengeStake);\n    }\n    \n    /**\n     * @notice Get dispute details\n     * @param _disputeId Dispute ID\n     * @return dispute Dispute information\n     */\n    function getDispute(uint256 _disputeId) external view returns (Dispute memory dispute) {\n        return disputes[_disputeId];\n    }\n    \n    /**\n     * @notice Get voter information for a dispute\n     * @param _disputeId Dispute ID\n     * @param _voter Voter address\n     * @return vote Vote information\n     */\n    function getVote(uint256 _disputeId, address _voter) external view returns (Vote memory vote) {\n        return votes[_disputeId][_voter];\n    }\n    \n    /**\n     * @notice Check if a question has an active dispute\n     * @param _questionId Question ID\n     * @return hasDispute True if there's an active dispute\n     */\n    function hasActiveDispute(uint256 _questionId) external view returns (bool hasDispute) {\n        return questionDisputed[_questionId];\n    }\n}\n"
    },
    "contracts/interfaces/IIntegrations.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IReferralRewards {\n    function recordVolume(address _user, uint256 _volume, uint256 _fee) external payable;\n}\n\ninterface ILiquidityIncentives {\n    function registerMarketCreation(uint256 _marketId, address _creator) external;\n    function addLiquidityIncentive(uint256 _marketId, uint256 _liquidityAmount) external;\n}\n\ninterface IMarketFactory {\n    enum MarketType { BINARY, MULTI_OUTCOME }\n    \n    function registerMarket(\n        address _marketContract,\n        uint256 _marketId,\n        MarketType _marketType,\n        string memory _category,\n        string[] memory _tags,\n        address _creator\n    ) external returns (uint256 globalId);\n}\n"
    },
    "contracts/interfaces/IPancakeFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IPancakeFactory {\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n}\n"
    },
    "contracts/interfaces/IPancakePair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IPancakePair {\n    function price0CumulativeLast() external view returns (uint256);\n    function price1CumulativeLast() external view returns (uint256);\n    function getReserves() external view returns (\n        uint112 reserve0,\n        uint112 reserve1,\n        uint32 blockTimestampLast\n    );\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n}\n"
    },
    "contracts/LiquidityIncentives.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title LiquidityIncentives\n * @notice Reward early market creators and liquidity providers\n * @dev Distributes rewards to users who create markets and provide initial liquidity\n */\ncontract LiquidityIncentives is Ownable, ReentrancyGuard {\n    \n    struct MarketIncentive {\n        address creator;\n        uint256 createdAt;\n        uint256 initialLiquidity;\n        uint256 rewardEarned;\n        bool rewardClaimed;\n    }\n\n    struct CreatorStats {\n        uint256 marketsCreated;\n        uint256 totalLiquidityProvided;\n        uint256 totalRewardsEarned;\n        uint256 totalRewardsClaimed;\n    }\n\n    // Reward pool\n    uint256 public rewardPool;\n    \n    // Reward per market created (0.01 BNB)\n    uint256 public constant MARKET_CREATION_REWARD = 0.01 ether;\n    \n    // Reward percentage for initial liquidity (1% of liquidity provided)\n    uint256 public constant LIQUIDITY_REWARD_PERCENTAGE = 1;\n    \n    // Minimum liquidity to qualify for rewards (0.1 BNB)\n    uint256 public constant MIN_LIQUIDITY_FOR_REWARD = 0.1 ether;\n\n    mapping(uint256 => MarketIncentive) public marketIncentives;\n    mapping(address => CreatorStats) public creatorStats;\n    mapping(address => bool) public authorizedMarkets;\n    \n    uint256 public totalRewardsDistributed;\n    uint256 public totalMarketsIncentivized;\n\n    event MarketIncentiveRegistered(uint256 indexed marketId, address indexed creator, uint256 reward);\n    event LiquidityIncentiveAdded(uint256 indexed marketId, uint256 liquidity, uint256 reward);\n    event IncentiveRewardClaimed(uint256 indexed marketId, address indexed creator, uint256 amount);\n    event RewardPoolFunded(uint256 amount);\n    event MarketAuthorized(address indexed market, bool authorized);\n\n    constructor() Ownable(msg.sender) {}\n\n    /**\n     * @notice Authorize/deauthorize market contracts\n     */\n    function setMarketAuthorization(address _market, bool _authorized) external onlyOwner {\n        require(_market != address(0), \"Invalid market\");\n        authorizedMarkets[_market] = _authorized;\n        emit MarketAuthorized(_market, _authorized);\n    }\n\n    /**\n     * @notice Fund the reward pool\n     */\n    function fundRewardPool() external payable {\n        require(msg.value > 0, \"Zero amount\");\n        rewardPool += msg.value;\n        emit RewardPoolFunded(msg.value);\n    }\n\n    /**\n     * @notice Register market creation incentive\n     * @param _marketId Market ID\n     * @param _creator Market creator\n     */\n    function registerMarketCreation(uint256 _marketId, address _creator) \n        external \n    {\n        require(authorizedMarkets[msg.sender], \"Not authorized market\");\n        require(marketIncentives[_marketId].creator == address(0), \"Already registered\");\n\n        uint256 reward = MARKET_CREATION_REWARD;\n        if (rewardPool < reward) {\n            reward = 0; // No reward if pool empty\n        }\n\n        marketIncentives[_marketId] = MarketIncentive({\n            creator: _creator,\n            createdAt: block.timestamp,\n            initialLiquidity: 0,\n            rewardEarned: reward,\n            rewardClaimed: false\n        });\n\n        if (reward > 0) {\n            rewardPool -= reward;\n        }\n\n        CreatorStats storage stats = creatorStats[_creator];\n        stats.marketsCreated++;\n        stats.totalRewardsEarned += reward;\n\n        totalMarketsIncentivized++;\n\n        emit MarketIncentiveRegistered(_marketId, _creator, reward);\n    }\n\n    /**\n     * @notice Add liquidity incentive\n     * @param _marketId Market ID\n     * @param _liquidityAmount Liquidity provided\n     */\n    function addLiquidityIncentive(uint256 _marketId, uint256 _liquidityAmount) \n        external \n    {\n        require(authorizedMarkets[msg.sender], \"Not authorized market\");\n        MarketIncentive storage incentive = marketIncentives[_marketId];\n        require(incentive.creator != address(0), \"Market not registered\");\n        require(_liquidityAmount >= MIN_LIQUIDITY_FOR_REWARD, \"Liquidity too low\");\n\n        uint256 reward = (_liquidityAmount * LIQUIDITY_REWARD_PERCENTAGE) / 100;\n        if (rewardPool < reward) {\n            reward = 0;\n        }\n\n        if (reward > 0) {\n            incentive.rewardEarned += reward;\n            incentive.initialLiquidity += _liquidityAmount;\n            rewardPool -= reward;\n\n            CreatorStats storage stats = creatorStats[incentive.creator];\n            stats.totalLiquidityProvided += _liquidityAmount;\n            stats.totalRewardsEarned += reward;\n\n            emit LiquidityIncentiveAdded(_marketId, _liquidityAmount, reward);\n        }\n    }\n\n    /**\n     * @notice Claim market creation and liquidity rewards\n     * @param _marketId Market ID\n     */\n    function claimReward(uint256 _marketId) external nonReentrant {\n        MarketIncentive storage incentive = marketIncentives[_marketId];\n        require(incentive.creator == msg.sender, \"Not creator\");\n        require(!incentive.rewardClaimed, \"Already claimed\");\n        require(incentive.rewardEarned > 0, \"No reward\");\n\n        uint256 reward = incentive.rewardEarned;\n        incentive.rewardClaimed = true;\n\n        CreatorStats storage stats = creatorStats[msg.sender];\n        stats.totalRewardsClaimed += reward;\n        totalRewardsDistributed += reward;\n\n        (bool success, ) = msg.sender.call{value: reward}(\"\");\n        require(success, \"Transfer failed\");\n\n        emit IncentiveRewardClaimed(_marketId, msg.sender, reward);\n    }\n\n    /**\n     * @notice Claim rewards from multiple markets\n     * @param _marketIds Array of market IDs\n     */\n    function claimMultipleRewards(uint256[] calldata _marketIds) \n        external \n        nonReentrant \n    {\n        uint256 totalReward = 0;\n\n        for (uint i = 0; i < _marketIds.length; i++) {\n            MarketIncentive storage incentive = marketIncentives[_marketIds[i]];\n            \n            if (incentive.creator == msg.sender && \n                !incentive.rewardClaimed && \n                incentive.rewardEarned > 0) \n            {\n                totalReward += incentive.rewardEarned;\n                incentive.rewardClaimed = true;\n                emit IncentiveRewardClaimed(_marketIds[i], msg.sender, incentive.rewardEarned);\n            }\n        }\n\n        require(totalReward > 0, \"No rewards to claim\");\n\n        CreatorStats storage stats = creatorStats[msg.sender];\n        stats.totalRewardsClaimed += totalReward;\n        totalRewardsDistributed += totalReward;\n\n        (bool success, ) = msg.sender.call{value: totalReward}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    /**\n     * @notice Get creator statistics\n     */\n    function getCreatorStats(address _creator) \n        external \n        view \n        returns (\n            uint256 marketsCreated,\n            uint256 totalLiquidityProvided,\n            uint256 totalRewardsEarned,\n            uint256 totalRewardsClaimed,\n            uint256 pendingRewards\n        ) \n    {\n        CreatorStats storage stats = creatorStats[_creator];\n        return (\n            stats.marketsCreated,\n            stats.totalLiquidityProvided,\n            stats.totalRewardsEarned,\n            stats.totalRewardsClaimed,\n            stats.totalRewardsEarned - stats.totalRewardsClaimed\n        );\n    }\n\n    /**\n     * @notice Get market incentive info\n     */\n    function getMarketIncentive(uint256 _marketId) \n        external \n        view \n        returns (\n            address creator,\n            uint256 initialLiquidity,\n            uint256 rewardEarned,\n            bool rewardClaimed\n        ) \n    {\n        MarketIncentive storage incentive = marketIncentives[_marketId];\n        return (\n            incentive.creator,\n            incentive.initialLiquidity,\n            incentive.rewardEarned,\n            incentive.rewardClaimed\n        );\n    }\n\n    /**\n     * @notice Owner can withdraw excess funds\n     */\n    function withdrawExcess(uint256 _amount) external onlyOwner {\n        require(_amount <= rewardPool, \"Insufficient pool\");\n        rewardPool -= _amount;\n        (bool success, ) = owner().call{value: _amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    receive() external payable {\n        rewardPool += msg.value;\n        emit RewardPoolFunded(msg.value);\n    }\n}\n"
    },
    "contracts/MarketFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./SimplePredictionMarket.sol\";\nimport \"./MultiOutcomeMarket.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title MarketFactory\n * @notice Factory contract for creating and tracking all types of markets\n * @dev Provides centralized market creation with metadata and discovery\n */\ncontract MarketFactory is Ownable {\n    \n    enum MarketType { BINARY, MULTI_OUTCOME }\n    \n    struct MarketMetadata {\n        address marketContract;\n        uint256 marketId;\n        MarketType marketType;\n        string category;\n        string[] tags;\n        address creator;\n        uint256 createdAt;\n        uint256 totalVolume;\n        bool isFeatured;\n    }\n\n    // All markets across all contracts\n    MarketMetadata[] public allMarkets;\n    \n    // Category => market indices\n    mapping(string => uint256[]) public marketsByCategory;\n    \n    // Tag => market indices\n    mapping(string => uint256[]) public marketsByTag;\n    \n    // Creator => market indices\n    mapping(address => uint256[]) public marketsByCreator;\n    \n    // Contract addresses\n    address public binaryMarketContract;\n    address public multiOutcomeMarketContract;\n    \n    mapping(address => bool) public authorizedMarkets;\n    \n    uint256 public totalVolume;\n    uint256 public totalMarkets;\n\n    event MarketCreated(\n        uint256 indexed globalId,\n        address indexed marketContract,\n        uint256 marketId,\n        MarketType marketType,\n        string category,\n        address indexed creator\n    );\n    event MarketVolumeUpdated(uint256 indexed globalId, uint256 newVolume);\n    event MarketFeatured(uint256 indexed globalId, bool featured);\n    event MarketAuthorized(address indexed market, bool authorized);\n\n    constructor(address _binaryMarket, address _multiOutcomeMarket) Ownable(msg.sender) {\n        binaryMarketContract = _binaryMarket;\n        multiOutcomeMarketContract = _multiOutcomeMarket;\n        authorizedMarkets[_binaryMarket] = true;\n        authorizedMarkets[_multiOutcomeMarket] = true;\n    }\n\n    /**\n     * @notice Authorize/deauthorize market contracts\n     */\n    function setMarketAuthorization(address _market, bool _authorized) external onlyOwner {\n        require(_market != address(0), \"Invalid market\");\n        authorizedMarkets[_market] = _authorized;\n        emit MarketAuthorized(_market, _authorized);\n    }\n\n    /**\n     * @notice Register a newly created market\n     * @dev Called after market is created in specific contract\n     */\n    function registerMarket(\n        address _marketContract,\n        uint256 _marketId,\n        MarketType _marketType,\n        string memory _category,\n        string[] memory _tags,\n        address _creator\n    ) external returns (uint256 globalId) {\n        require(authorizedMarkets[msg.sender], \"Not authorized market\");\n        \n        globalId = allMarkets.length;\n        \n        allMarkets.push(MarketMetadata({\n            marketContract: _marketContract,\n            marketId: _marketId,\n            marketType: _marketType,\n            category: _category,\n            tags: _tags,\n            creator: _creator,\n            createdAt: block.timestamp,\n            totalVolume: 0,\n            isFeatured: false\n        }));\n\n        marketsByCategory[_category].push(globalId);\n        marketsByCreator[_creator].push(globalId);\n        \n        for (uint i = 0; i < _tags.length; i++) {\n            marketsByTag[_tags[i]].push(globalId);\n        }\n\n        totalMarkets++;\n\n        emit MarketCreated(globalId, _marketContract, _marketId, _marketType, _category, _creator);\n    }\n\n    /**\n     * @notice Update market volume\n     */\n    function updateMarketVolume(uint256 _globalId, uint256 _newVolume) external {\n        require(authorizedMarkets[msg.sender], \"Not authorized market\");\n        require(_globalId < allMarkets.length, \"Invalid market\");\n        \n        MarketMetadata storage market = allMarkets[_globalId];\n        uint256 volumeIncrease = _newVolume - market.totalVolume;\n        \n        market.totalVolume = _newVolume;\n        totalVolume += volumeIncrease;\n\n        emit MarketVolumeUpdated(_globalId, _newVolume);\n    }\n\n    /**\n     * @notice Feature/unfeature a market (owner only)\n     */\n    function setFeatured(uint256 _globalId, bool _featured) external onlyOwner {\n        require(_globalId < allMarkets.length, \"Invalid market\");\n        allMarkets[_globalId].isFeatured = _featured;\n        emit MarketFeatured(_globalId, _featured);\n    }\n\n    /**\n     * @notice Get markets by category\n     */\n    function getMarketsByCategory(string memory _category) \n        external \n        view \n        returns (uint256[] memory) \n    {\n        return marketsByCategory[_category];\n    }\n\n    /**\n     * @notice Get markets by tag\n     */\n    function getMarketsByTag(string memory _tag) \n        external \n        view \n        returns (uint256[] memory) \n    {\n        return marketsByTag[_tag];\n    }\n\n    /**\n     * @notice Get markets by creator\n     */\n    function getMarketsByCreator(address _creator) \n        external \n        view \n        returns (uint256[] memory) \n    {\n        return marketsByCreator[_creator];\n    }\n\n    /**\n     * @notice Get all featured markets\n     */\n    function getFeaturedMarkets() external view returns (uint256[] memory) {\n        uint256 featuredCount = 0;\n        for (uint i = 0; i < allMarkets.length; i++) {\n            if (allMarkets[i].isFeatured) featuredCount++;\n        }\n\n        uint256[] memory featured = new uint256[](featuredCount);\n        uint256 index = 0;\n        for (uint i = 0; i < allMarkets.length; i++) {\n            if (allMarkets[i].isFeatured) {\n                featured[index++] = i;\n            }\n        }\n\n        return featured;\n    }\n\n    /**\n     * @notice Get total number of markets\n     */\n    function getMarketCount() external view returns (uint256) {\n        return allMarkets.length;\n    }\n\n    /**\n     * @notice Get market metadata\n     */\n    function getMarket(uint256 _globalId) \n        external \n        view \n        returns (\n            address marketContract,\n            uint256 marketId,\n            MarketType marketType,\n            string memory category,\n            address creator,\n            uint256 createdAt,\n            uint256 volume,\n            bool featured\n        ) \n    {\n        require(_globalId < allMarkets.length, \"Invalid market\");\n        MarketMetadata storage market = allMarkets[_globalId];\n        \n        return (\n            market.marketContract,\n            market.marketId,\n            market.marketType,\n            market.category,\n            market.creator,\n            market.createdAt,\n            market.totalVolume,\n            market.isFeatured\n        );\n    }\n}\n"
    },
    "contracts/MultiOutcomeMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./SoraOracle.sol\";\nimport \"./interfaces/IIntegrations.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title MultiOutcomeMarket\n * @notice Prediction markets with multiple outcomes (not just yes/no)\n * @dev Example: \"Who will win the election?\" -> [Candidate A, Candidate B, Candidate C]\n */\ncontract MultiOutcomeMarket is Ownable, ReentrancyGuard {\n    \n    enum MarketStatus { OPEN, CLOSED, RESOLVED, CANCELED }\n\n    struct Market {\n        string question;\n        uint256 questionId;\n        uint256 resolutionTime;\n        uint8 numOutcomes;\n        mapping(uint8 => uint256) outcomePools; // outcome index => BNB pooled\n        mapping(uint8 => string) outcomeLabels; // outcome index => label\n        MarketStatus status;\n        uint8 winningOutcome;\n        uint256 totalPool;\n        uint256 totalFees;\n    }\n\n    struct Position {\n        mapping(uint8 => uint256) amounts; // outcome index => amount\n        bool claimed;\n    }\n\n    SoraOracle public oracle;\n    uint256 public marketCounter;\n    uint256 public constant FEE_PERCENTAGE = 2;\n    uint256 public accumulatedFees;\n    \n    // Optional integration contracts (can be address(0) if not used)\n    address public referralRewards;\n    address public marketFactory;\n    address public liquidityIncentives;\n    \n    mapping(uint256 => Market) public markets;\n    mapping(uint256 => mapping(address => Position)) public positions;\n\n    event MultiOutcomeMarketCreated(\n        uint256 indexed marketId, \n        string question, \n        uint8 numOutcomes,\n        uint256 resolutionTime\n    );\n    event OutcomePositionTaken(\n        uint256 indexed marketId, \n        address indexed user, \n        uint8 outcome, \n        uint256 amount\n    );\n    event MultiOutcomeMarketResolved(uint256 indexed marketId, uint8 winningOutcome);\n    event MultiOutcomeWinningsClaimed(uint256 indexed marketId, address indexed user, uint256 amount);\n\n    constructor(address payable _oracle) Ownable(msg.sender) {\n        require(_oracle != address(0), \"Invalid oracle\");\n        oracle = SoraOracle(_oracle);\n    }\n\n    /**\n     * @notice Set integration contract addresses (owner only)\n     */\n    function setIntegrations(\n        address _referralRewards,\n        address _marketFactory,\n        address _liquidityIncentives\n    ) external onlyOwner {\n        referralRewards = _referralRewards;\n        marketFactory = _marketFactory;\n        liquidityIncentives = _liquidityIncentives;\n    }\n\n    /**\n     * @notice Create a multi-outcome prediction market\n     * @param _question The question\n     * @param _outcomeLabels Array of outcome labels (e.g., [\"Alice\", \"Bob\", \"Charlie\"])\n     * @param _resolutionTime When the market resolves\n     */\n    function createMarket(\n        string memory _question,\n        string[] memory _outcomeLabels,\n        uint256 _resolutionTime\n    ) external payable returns (uint256 marketId) {\n        require(_resolutionTime > block.timestamp, \"Invalid resolution time\");\n        require(_outcomeLabels.length >= 2 && _outcomeLabels.length <= 10, \"2-10 outcomes required\");\n        require(bytes(_question).length > 0, \"Question empty\");\n\n        uint256 oracleFee = oracle.oracleFee();\n        require(msg.value >= oracleFee, \"Insufficient oracle fee\");\n        \n        // Ask as general question - oracle will provide numeric answer (0-9 for outcome index)\n        uint256 questionId = oracle.askOracle{value: oracleFee}(_question, _resolutionTime);\n        \n        marketId = marketCounter++;\n        Market storage market = markets[marketId];\n        market.question = _question;\n        market.questionId = questionId;\n        market.resolutionTime = _resolutionTime;\n        market.numOutcomes = uint8(_outcomeLabels.length);\n        market.status = MarketStatus.OPEN;\n        \n        for (uint8 i = 0; i < _outcomeLabels.length; i++) {\n            market.outcomeLabels[i] = _outcomeLabels[i];\n        }\n\n        emit MultiOutcomeMarketCreated(marketId, _question, uint8(_outcomeLabels.length), _resolutionTime);\n\n        // Integrate with LiquidityIncentives if set\n        if (liquidityIncentives != address(0)) {\n            try ILiquidityIncentives(liquidityIncentives).registerMarketCreation(marketId, msg.sender) {} \n            catch {}\n        }\n\n        if (msg.value > oracleFee) {\n            (bool success, ) = msg.sender.call{value: msg.value - oracleFee}(\"\");\n            require(success, \"Refund failed\");\n        }\n    }\n\n    /**\n     * @notice Take a position on a specific outcome\n     * @param _marketId Market ID\n     * @param _outcome Outcome index (0 to numOutcomes-1)\n     */\n    function takePosition(uint256 _marketId, uint8 _outcome) \n        external \n        payable \n        nonReentrant \n    {\n        Market storage market = markets[_marketId];\n        require(market.status == MarketStatus.OPEN, \"Market not open\");\n        require(_outcome < market.numOutcomes, \"Invalid outcome\");\n        require(msg.value > 0, \"Zero bet\");\n        require(block.timestamp < market.resolutionTime, \"Market expired\");\n\n        uint256 fee = (msg.value * FEE_PERCENTAGE) / 100;\n        uint256 netAmount = msg.value - fee;\n\n        market.outcomePools[_outcome] += netAmount;\n        market.totalPool += netAmount;\n        market.totalFees += fee;\n        // Note: fees are NOT added to accumulatedFees yet - only when market resolves\n\n        positions[_marketId][msg.sender].amounts[_outcome] += netAmount;\n\n        emit OutcomePositionTaken(_marketId, msg.sender, _outcome, netAmount);\n\n        // Integrate with ReferralRewards if set\n        if (referralRewards != address(0) && fee > 0) {\n            uint256 referralReward = (fee * 5) / 100;\n            try IReferralRewards(referralRewards).recordVolume{value: referralReward}(\n                msg.sender,\n                msg.value,\n                fee\n            ) {} catch {}\n        }\n\n        // Integrate with LiquidityIncentives if set\n        if (liquidityIncentives != address(0) && market.totalPool > 0) {\n            try ILiquidityIncentives(liquidityIncentives).addLiquidityIncentive(\n                _marketId,\n                netAmount\n            ) {} catch {}\n        }\n    }\n\n    /**\n     * @notice Resolve market based on oracle answer\n     * @dev Reads numeric answer from oracle and uses it as winning outcome index\n     */\n    function resolveMarket(uint256 _marketId) \n        external \n        nonReentrant\n    {\n        Market storage market = markets[_marketId];\n        require(market.status == MarketStatus.OPEN, \"Market not open\");\n        require(block.timestamp >= market.resolutionTime, \"Too early\");\n\n        // Get oracle answer - numeric answer contains the outcome index (0 to numOutcomes-1)\n        (, SoraOracle.Answer memory answer) = oracle.getQuestionWithAnswer(market.questionId);\n        require(answer.confidenceScore > 0, \"Not answered yet\");\n        \n        // Oracle provides numeric answer as the winning outcome index\n        uint8 winningOutcome = uint8(answer.numericAnswer);\n        require(winningOutcome < market.numOutcomes, \"Invalid outcome from oracle\");\n        \n        market.status = MarketStatus.RESOLVED;\n        market.winningOutcome = winningOutcome;\n\n        // Release platform fees now that market is resolved (won't be canceled)\n        accumulatedFees += market.totalFees;\n\n        emit MultiOutcomeMarketResolved(_marketId, winningOutcome);\n    }\n\n    /**\n     * @notice Claim winnings from resolved market\n     */\n    function claimWinnings(uint256 _marketId) \n        external \n        nonReentrant \n    {\n        Market storage market = markets[_marketId];\n        require(market.status == MarketStatus.RESOLVED, \"Not resolved\");\n        \n        Position storage position = positions[_marketId][msg.sender];\n        require(!position.claimed, \"Already claimed\");\n\n        uint256 winningAmount = position.amounts[market.winningOutcome];\n        require(winningAmount > 0, \"No winning position\");\n\n        uint256 winningPool = market.outcomePools[market.winningOutcome];\n        require(winningPool > 0, \"No winning pool\");\n\n        uint256 payout = (winningAmount * market.totalPool) / winningPool;\n        \n        position.claimed = true;\n\n        (bool success, ) = msg.sender.call{value: payout}(\"\");\n        require(success, \"Transfer failed\");\n\n        emit MultiOutcomeWinningsClaimed(_marketId, msg.sender, payout);\n    }\n\n    /**\n     * @notice Get outcome label\n     */\n    function getOutcomeLabel(uint256 _marketId, uint8 _outcome) \n        external \n        view \n        returns (string memory) \n    {\n        return markets[_marketId].outcomeLabels[_outcome];\n    }\n\n    /**\n     * @notice Get pool for specific outcome\n     */\n    function getOutcomePool(uint256 _marketId, uint8 _outcome) \n        external \n        view \n        returns (uint256) \n    {\n        return markets[_marketId].outcomePools[_outcome];\n    }\n\n    /**\n     * @notice Get user position for specific outcome\n     */\n    function getUserPosition(uint256 _marketId, address _user, uint8 _outcome) \n        external \n        view \n        returns (uint256) \n    {\n        return positions[_marketId][_user].amounts[_outcome];\n    }\n\n    /**\n     * @notice Cancel a market if oracle hasn't answered\n     * @param _marketId Market ID\n     * @dev Allows users to reclaim bets if oracle fails to answer\n     */\n    function cancelMarket(uint256 _marketId) external nonReentrant {\n        Market storage market = markets[_marketId];\n        require(market.status == MarketStatus.OPEN, \"Market not open\");\n        require(block.timestamp > market.resolutionTime + 7 days, \"Too early to cancel\");\n\n        // In production, verify oracle hasn't answered\n        // For now, allow cancellation after 7 days\n\n        market.status = MarketStatus.CANCELED;\n        // Note: market.totalFees never added to accumulatedFees, so will be refunded\n    }\n\n    /**\n     * @notice Claim refund from canceled market\n     * @param _marketId Market ID\n     */\n    function claimRefund(uint256 _marketId) external nonReentrant {\n        Market storage market = markets[_marketId];\n        Position storage position = positions[_marketId][msg.sender];\n        \n        require(market.status == MarketStatus.CANCELED, \"Market not canceled\");\n        require(!position.claimed, \"Already claimed\");\n\n        // Calculate total position across all outcomes\n        uint256 totalPosition = 0;\n        for (uint8 i = 0; i < market.numOutcomes; i++) {\n            totalPosition += position.amounts[i];\n        }\n\n        // Calculate fees paid proportionally\n        uint256 feesPaid = 0;\n        if (market.totalPool > 0) {\n            feesPaid = (totalPosition * market.totalFees) / market.totalPool;\n        }\n\n        uint256 fullRefund = totalPosition + feesPaid;\n        require(fullRefund > 0, \"No position\");\n\n        position.claimed = true;\n\n        (bool success, ) = msg.sender.call{value: fullRefund}(\"\");\n        require(success, \"Refund failed\");\n    }\n\n    /**\n     * @notice Get market basic info (since struct has mappings, can't return full struct)\n     */\n    function getMarket(uint256 _marketId)\n        external\n        view\n        returns (\n            string memory question,\n            uint256 questionId,\n            uint256 resolutionTime,\n            uint8 numOutcomes,\n            MarketStatus status,\n            uint8 winningOutcome,\n            uint256 totalPool,\n            uint256 totalFees\n        )\n    {\n        Market storage m = markets[_marketId];\n        return (\n            m.question,\n            m.questionId,\n            m.resolutionTime,\n            m.numOutcomes,\n            m.status,\n            m.winningOutcome,\n            m.totalPool,\n            m.totalFees\n        );\n    }\n\n    /**\n     * @notice Owner withdraws accumulated fees\n     */\n    function withdrawFees() external onlyOwner nonReentrant {\n        uint256 amount = accumulatedFees;\n        require(amount > 0, \"No fees to withdraw\");\n        accumulatedFees = 0;\n        (bool success, ) = owner().call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}\n"
    },
    "contracts/OracleReputationTracker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title OracleReputationTracker\n * @notice Tracks oracle provider performance, accuracy, and reputation metrics\n * @dev Decentralized reputation system for oracle providers\n */\ncontract OracleReputationTracker is Ownable {\n    \n    struct ProviderStats {\n        uint256 totalAnswers;\n        uint256 totalEarnings;\n        uint256 challengesLost;\n        uint256 challengesWon;\n        uint256 avgConfidenceScore;\n        uint256 avgResponseTime;\n        uint256 firstAnswerTimestamp;\n        uint256 lastAnswerTimestamp;\n        bool isActive;\n    }\n    \n    struct AnswerRecord {\n        uint256 questionId;\n        uint256 timestamp;\n        uint8 confidenceScore;\n        uint256 responseTime;\n        bool challenged;\n        bool challengeResult; // true if provider won\n        uint256 earnings;\n    }\n    \n    mapping(address => ProviderStats) public providerStats;\n    mapping(address => AnswerRecord[]) public providerHistory;\n    mapping(address => mapping(uint256 => bool)) public hasRecorded;\n    mapping(address => bool) public authorizedRecorders;\n    \n    address[] public allProviders;\n    \n    event AnswerRecorded(\n        address indexed provider,\n        uint256 indexed questionId,\n        uint256 earnings,\n        uint8 confidenceScore\n    );\n    \n    event ChallengeRecorded(\n        address indexed provider,\n        uint256 indexed questionId,\n        bool providerWon\n    );\n    \n    event ProviderActivated(address indexed provider);\n    event ProviderDeactivated(address indexed provider);\n    event RecorderAuthorized(address indexed recorder);\n    event RecorderRevoked(address indexed recorder);\n    \n    modifier onlyAuthorized() {\n        require(\n            authorizedRecorders[msg.sender] || msg.sender == owner(),\n            \"Not authorized to record\"\n        );\n        _;\n    }\n    \n    constructor() Ownable(msg.sender) {}\n    \n    /**\n     * @notice Authorize an address to record answers (e.g., oracle contract, bot)\n     * @param _recorder Address to authorize\n     */\n    function authorizeRecorder(address _recorder) external onlyOwner {\n        require(_recorder != address(0), \"Invalid recorder\");\n        authorizedRecorders[_recorder] = true;\n        emit RecorderAuthorized(_recorder);\n    }\n    \n    /**\n     * @notice Revoke recorder authorization\n     * @param _recorder Address to revoke\n     */\n    function revokeRecorder(address _recorder) external onlyOwner {\n        authorizedRecorders[_recorder] = false;\n        emit RecorderRevoked(_recorder);\n    }\n    \n    /**\n     * @notice Record a new answer provided by an oracle\n     * @param _provider Address of the oracle provider\n     * @param _questionId Question ID that was answered\n     * @param _questionTimestamp When the question was asked\n     * @param _answerTimestamp When the answer was provided\n     * @param _confidenceScore Confidence score (0-100)\n     * @param _earnings Amount earned for this answer\n     */\n    function recordAnswer(\n        address _provider,\n        uint256 _questionId,\n        uint256 _questionTimestamp,\n        uint256 _answerTimestamp,\n        uint8 _confidenceScore,\n        uint256 _earnings\n    ) external onlyAuthorized {\n        require(_provider != address(0), \"Invalid provider\");\n        require(!hasRecorded[_provider][_questionId], \"Already recorded\");\n        require(_answerTimestamp >= _questionTimestamp, \"Invalid timestamps\");\n        \n        ProviderStats storage stats = providerStats[_provider];\n        \n        // Initialize if first answer\n        if (stats.totalAnswers == 0) {\n            stats.firstAnswerTimestamp = _answerTimestamp;\n            stats.isActive = true;\n            allProviders.push(_provider);\n            emit ProviderActivated(_provider);\n        }\n        \n        // Calculate response time\n        uint256 responseTime = _answerTimestamp - _questionTimestamp;\n        \n        // Update rolling averages\n        stats.avgConfidenceScore = (\n            (stats.avgConfidenceScore * stats.totalAnswers) + _confidenceScore\n        ) / (stats.totalAnswers + 1);\n        \n        stats.avgResponseTime = (\n            (stats.avgResponseTime * stats.totalAnswers) + responseTime\n        ) / (stats.totalAnswers + 1);\n        \n        // Update stats\n        stats.totalAnswers++;\n        stats.totalEarnings += _earnings;\n        stats.lastAnswerTimestamp = _answerTimestamp;\n        \n        // Record answer\n        providerHistory[_provider].push(AnswerRecord({\n            questionId: _questionId,\n            timestamp: _answerTimestamp,\n            confidenceScore: _confidenceScore,\n            responseTime: responseTime,\n            challenged: false,\n            challengeResult: false,\n            earnings: _earnings\n        }));\n        \n        hasRecorded[_provider][_questionId] = true;\n        \n        emit AnswerRecorded(_provider, _questionId, _earnings, _confidenceScore);\n    }\n    \n    /**\n     * @notice Record the result of a challenge/dispute\n     * @param _provider Oracle provider address\n     * @param _questionId Question that was challenged\n     * @param _providerWon True if provider's answer was upheld\n     */\n    function recordChallenge(\n        address _provider,\n        uint256 _questionId,\n        bool _providerWon\n    ) external onlyAuthorized {\n        require(hasRecorded[_provider][_questionId], \"Answer not recorded\");\n        \n        ProviderStats storage stats = providerStats[_provider];\n        \n        if (_providerWon) {\n            stats.challengesWon++;\n        } else {\n            stats.challengesLost++;\n        }\n        \n        // Update answer record\n        AnswerRecord[] storage history = providerHistory[_provider];\n        for (uint256 i = 0; i < history.length; i++) {\n            if (history[i].questionId == _questionId) {\n                history[i].challenged = true;\n                history[i].challengeResult = _providerWon;\n                break;\n            }\n        }\n        \n        emit ChallengeRecorded(_provider, _questionId, _providerWon);\n    }\n    \n    /**\n     * @notice Calculate reputation score for a provider (0-1000)\n     * @param _provider Provider address\n     * @return score Reputation score\n     */\n    function getReputationScore(address _provider) external view returns (uint256 score) {\n        ProviderStats memory stats = providerStats[_provider];\n        \n        if (stats.totalAnswers == 0) {\n            return 0;\n        }\n        \n        // Base score from total answers (max 300 points)\n        uint256 volumeScore = stats.totalAnswers > 100 \n            ? 300 \n            : (stats.totalAnswers * 3);\n        \n        // Accuracy score from challenges (max 400 points)\n        uint256 totalChallenges = stats.challengesWon + stats.challengesLost;\n        uint256 accuracyScore = totalChallenges == 0 \n            ? 400 \n            : (stats.challengesWon * 400) / totalChallenges;\n        \n        // Confidence score (max 200 points)\n        uint256 confidenceScore = (stats.avgConfidenceScore * 2);\n        \n        // Speed bonus (max 100 points) - faster responses = higher score\n        uint256 speedScore = 100;\n        if (stats.avgResponseTime > 1 days) {\n            speedScore = 50;\n        } else if (stats.avgResponseTime > 12 hours) {\n            speedScore = 75;\n        }\n        \n        score = volumeScore + accuracyScore + confidenceScore + speedScore;\n    }\n    \n    /**\n     * @notice Get provider statistics\n     * @param _provider Provider address\n     * @return stats Provider statistics\n     */\n    function getProviderStats(address _provider) external view returns (ProviderStats memory stats) {\n        return providerStats[_provider];\n    }\n    \n    /**\n     * @notice Get provider answer history\n     * @param _provider Provider address\n     * @param _offset Starting index\n     * @param _limit Number of records to return\n     * @return records Answer records\n     */\n    function getProviderHistory(\n        address _provider,\n        uint256 _offset,\n        uint256 _limit\n    ) external view returns (AnswerRecord[] memory records) {\n        AnswerRecord[] storage history = providerHistory[_provider];\n        \n        if (_offset >= history.length) {\n            return new AnswerRecord[](0);\n        }\n        \n        uint256 end = _offset + _limit;\n        if (end > history.length) {\n            end = history.length;\n        }\n        \n        uint256 resultLength = end - _offset;\n        records = new AnswerRecord[](resultLength);\n        \n        for (uint256 i = 0; i < resultLength; i++) {\n            records[i] = history[_offset + i];\n        }\n    }\n    \n    /**\n     * @notice Get total number of oracle providers\n     * @return Total providers count\n     */\n    function getTotalProviders() external view returns (uint256) {\n        return allProviders.length;\n    }\n    \n    /**\n     * @notice Get leaderboard of top providers\n     * @param _limit Number of top providers to return\n     * @return providers Array of provider addresses sorted by reputation\n     * @return scores Array of reputation scores\n     */\n    function getLeaderboard(uint256 _limit) \n        external \n        view \n        returns (address[] memory providers, uint256[] memory scores) \n    {\n        uint256 totalProviders = allProviders.length;\n        uint256 resultLength = _limit > totalProviders ? totalProviders : _limit;\n        \n        providers = new address[](resultLength);\n        scores = new uint256[](resultLength);\n        \n        // Simple selection (not optimized for large datasets)\n        for (uint256 i = 0; i < resultLength; i++) {\n            uint256 maxScore = 0;\n            address maxProvider = address(0);\n            \n            for (uint256 j = 0; j < totalProviders; j++) {\n                address provider = allProviders[j];\n                uint256 score = this.getReputationScore(provider);\n                \n                // Check if already in results\n                bool alreadyAdded = false;\n                for (uint256 k = 0; k < i; k++) {\n                    if (providers[k] == provider) {\n                        alreadyAdded = true;\n                        break;\n                    }\n                }\n                \n                if (!alreadyAdded && score > maxScore) {\n                    maxScore = score;\n                    maxProvider = provider;\n                }\n            }\n            \n            providers[i] = maxProvider;\n            scores[i] = maxScore;\n        }\n    }\n    \n    /**\n     * @notice Mark a provider as inactive (owner only)\n     * @param _provider Provider to deactivate\n     */\n    function deactivateProvider(address _provider) external onlyOwner {\n        providerStats[_provider].isActive = false;\n        emit ProviderDeactivated(_provider);\n    }\n}\n"
    },
    "contracts/OracleStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title OracleStaking\n * @notice Oracle providers stake BNB to build reputation and earn rewards\n * @dev Higher stakes = higher weight in aggregated oracles\n */\ncontract OracleStaking is Ownable, ReentrancyGuard {\n    \n    struct Staker {\n        uint256 stakedAmount;\n        uint256 rewardDebt;\n        uint32 stakeTimestamp;\n        uint32 totalAnswers;\n        uint32 accurateAnswers;\n        uint16 reputationScore;     // 0-1000\n        bool active;\n    }\n\n    struct RewardPool {\n        uint256 totalRewards;\n        uint256 rewardsPerShare;    // Accumulated rewards per staked BNB\n        uint256 lastUpdateTime;\n    }\n\n    mapping(address => Staker) public stakers;\n    address[] public stakerList;\n    \n    RewardPool public rewardPool;\n    \n    uint256 public totalStaked;\n    uint256 public minimumStake = 0.1 ether;\n    uint256 public rewardRate = 100; // Rewards per second per BNB staked (scaled by 1e18)\n    uint32 public unstakeLockPeriod = 7 days;\n\n    event Staked(address indexed staker, uint256 amount);\n    event Unstaked(address indexed staker, uint256 amount);\n    event RewardsClaimed(address indexed staker, uint256 reward);\n    event AnswerRecorded(address indexed staker, bool accurate);\n    event ReputationUpdated(address indexed staker, uint16 newScore);\n\n    constructor() Ownable(msg.sender) {\n        rewardPool.lastUpdateTime = block.timestamp;\n    }\n\n    /**\n     * @notice Stake BNB to become oracle provider\n     */\n    function stake() external payable nonReentrant {\n        require(msg.value >= minimumStake, \"Below minimum stake\");\n\n        _updateRewardPool();\n\n        Staker storage staker = stakers[msg.sender];\n        \n        // Claim pending rewards if already staking\n        if (staker.stakedAmount > 0) {\n            _claimRewards(msg.sender);\n        } else {\n            // New staker\n            stakerList.push(msg.sender);\n            staker.stakeTimestamp = uint32(block.timestamp);\n            staker.active = true;\n        }\n\n        staker.stakedAmount += msg.value;\n        staker.rewardDebt = (staker.stakedAmount * rewardPool.rewardsPerShare) / 1e18;\n        totalStaked += msg.value;\n\n        emit Staked(msg.sender, msg.value);\n    }\n\n    /**\n     * @notice Unstake BNB and claim rewards\n     * @param _amount Amount to unstake\n     */\n    function unstake(uint256 _amount) external nonReentrant {\n        Staker storage staker = stakers[msg.sender];\n        require(staker.stakedAmount >= _amount, \"Insufficient stake\");\n        require(\n            block.timestamp >= staker.stakeTimestamp + unstakeLockPeriod,\n            \"Stake locked\"\n        );\n\n        _updateRewardPool();\n        \n        // Claim rewards before updating stake\n        if (staker.stakedAmount > 0) {\n            uint256 pending = ((staker.stakedAmount * rewardPool.rewardsPerShare) / 1e18) - staker.rewardDebt;\n            if (pending > 0 && address(this).balance >= pending + _amount) {\n                payable(msg.sender).transfer(pending);\n                emit RewardsClaimed(msg.sender, pending);\n            }\n        }\n\n        staker.stakedAmount -= _amount;\n        totalStaked -= _amount;\n\n        if (staker.stakedAmount == 0) {\n            staker.active = false;\n            staker.rewardDebt = 0;\n        } else {\n            staker.rewardDebt = (staker.stakedAmount * rewardPool.rewardsPerShare) / 1e18;\n        }\n\n        payable(msg.sender).transfer(_amount);\n\n        emit Unstaked(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Claim pending rewards\n     */\n    function claimRewards() external nonReentrant {\n        _updateRewardPool();\n        _claimRewards(msg.sender);\n    }\n\n    /**\n     * @notice Internal reward claim\n     */\n    function _claimRewards(address _staker) private {\n        Staker storage staker = stakers[_staker];\n        if (staker.stakedAmount == 0) return;\n\n        uint256 pending = ((staker.stakedAmount * rewardPool.rewardsPerShare) / 1e18) - staker.rewardDebt;\n        \n        if (pending > 0 && address(this).balance >= pending) {\n            payable(_staker).transfer(pending);\n            emit RewardsClaimed(_staker, pending);\n        }\n\n        staker.rewardDebt = (staker.stakedAmount * rewardPool.rewardsPerShare) / 1e18;\n    }\n\n    /**\n     * @notice Update reward pool accumulator\n     */\n    function _updateRewardPool() private {\n        if (block.timestamp <= rewardPool.lastUpdateTime) return;\n        if (totalStaked == 0) {\n            rewardPool.lastUpdateTime = block.timestamp;\n            return;\n        }\n\n        uint256 timeElapsed = block.timestamp - rewardPool.lastUpdateTime;\n        uint256 rewards = timeElapsed * rewardRate * totalStaked / 1e18;\n\n        rewardPool.rewardsPerShare += (rewards * 1e18) / totalStaked;\n        rewardPool.totalRewards += rewards;\n        rewardPool.lastUpdateTime = block.timestamp;\n    }\n\n    /**\n     * @notice Record oracle answer (called by oracle contract)\n     * @param _provider Oracle provider address\n     * @param _accurate Whether answer was accurate\n     */\n    function recordAnswer(address _provider, bool _accurate) external onlyOwner {\n        Staker storage staker = stakers[_provider];\n        require(staker.active, \"Not active staker\");\n\n        staker.totalAnswers++;\n        if (_accurate) {\n            staker.accurateAnswers++;\n        }\n\n        // Update reputation score\n        uint16 newScore = _calculateReputation(staker.accurateAnswers, staker.totalAnswers);\n        staker.reputationScore = newScore;\n\n        emit AnswerRecorded(_provider, _accurate);\n        emit ReputationUpdated(_provider, newScore);\n    }\n\n    /**\n     * @notice Calculate reputation score (0-1000)\n     */\n    function _calculateReputation(uint32 accurate, uint32 total) private pure returns (uint16) {\n        if (total == 0) return 500; // Default neutral score\n        \n        uint256 accuracy = (uint256(accurate) * 1000) / uint256(total);\n        \n        // Bonus for high volume\n        uint256 volumeBonus = 0;\n        if (total >= 100) volumeBonus = 50;\n        else if (total >= 50) volumeBonus = 30;\n        else if (total >= 10) volumeBonus = 10;\n\n        uint256 finalScore = accuracy + volumeBonus;\n        if (finalScore > 1000) finalScore = 1000;\n\n        return uint16(finalScore);\n    }\n\n    /**\n     * @notice Get pending rewards for staker\n     */\n    function pendingRewards(address _staker) external view returns (uint256) {\n        Staker memory staker = stakers[_staker];\n        if (staker.stakedAmount == 0) return 0;\n\n        uint256 currentRewardsPerShare = rewardPool.rewardsPerShare;\n        \n        if (block.timestamp > rewardPool.lastUpdateTime && totalStaked > 0) {\n            uint256 timeElapsed = block.timestamp - rewardPool.lastUpdateTime;\n            uint256 rewards = timeElapsed * rewardRate * totalStaked / 1e18;\n            currentRewardsPerShare += (rewards * 1e18) / totalStaked;\n        }\n\n        return ((staker.stakedAmount * currentRewardsPerShare) / 1e18) - staker.rewardDebt;\n    }\n\n    /**\n     * @notice Get staker info\n     */\n    function getStaker(address _staker) external view returns (\n        uint256 stakedAmount,\n        uint32 totalAnswers,\n        uint32 accurateAnswers,\n        uint16 reputationScore,\n        bool active\n    ) {\n        Staker memory staker = stakers[_staker];\n        return (\n            staker.stakedAmount,\n            staker.totalAnswers,\n            staker.accurateAnswers,\n            staker.reputationScore,\n            staker.active\n        );\n    }\n\n    /**\n     * @notice Get stake weight (for aggregated oracle)\n     * @return weight in basis points (0-10000)\n     */\n    function getStakeWeight(address _staker) external view returns (uint16) {\n        Staker memory staker = stakers[_staker];\n        if (!staker.active || totalStaked == 0) return 0;\n\n        // Weight based on stake amount and reputation\n        uint256 stakeRatio = (staker.stakedAmount * 5000) / totalStaked; // Max 50% from stake\n        uint256 reputationBonus = (uint256(staker.reputationScore) * 5000) / 1000; // Max 50% from reputation\n\n        uint256 totalWeight = stakeRatio + reputationBonus;\n        if (totalWeight > 10000) totalWeight = 10000;\n\n        return uint16(totalWeight);\n    }\n\n    /**\n     * @notice Get all active stakers\n     */\n    function getActiveStakers() external view returns (address[] memory) {\n        uint256 count = 0;\n        for (uint256 i = 0; i < stakerList.length; i++) {\n            if (stakers[stakerList[i]].active) {\n                count++;\n            }\n        }\n\n        address[] memory activeList = new address[](count);\n        uint256 index = 0;\n        for (uint256 i = 0; i < stakerList.length; i++) {\n            if (stakers[stakerList[i]].active) {\n                activeList[index] = stakerList[i];\n                index++;\n            }\n        }\n\n        return activeList;\n    }\n\n    /**\n     * @notice Update minimum stake\n     */\n    function setMinimumStake(uint256 _newMinimum) external onlyOwner {\n        minimumStake = _newMinimum;\n    }\n\n    /**\n     * @notice Update reward rate\n     */\n    function setRewardRate(uint256 _newRate) external onlyOwner {\n        _updateRewardPool();\n        rewardRate = _newRate;\n    }\n\n    /**\n     * @notice Add rewards to pool\n     */\n    function addRewards() external payable onlyOwner {\n        require(msg.value > 0, \"No rewards\");\n        _updateRewardPool();\n    }\n\n    /**\n     * @notice Emergency withdraw (owner only)\n     */\n    function emergencyWithdraw(uint256 _amount) external onlyOwner {\n        require(address(this).balance >= _amount, \"Insufficient balance\");\n        payable(owner()).transfer(_amount);\n    }\n\n    receive() external payable {\n        // Accept BNB for rewards\n    }\n}\n"
    },
    "contracts/OrderBookMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./SoraOracle.sol\";\n\ncontract OrderBookMarket is Ownable, ReentrancyGuard {\n    SoraOracle public oracle;\n\n    struct Order {\n        address trader;\n        bool isBuy;\n        bool isYes;\n        uint256 price;\n        uint256 amount;\n        uint256 filled;\n        uint256 timestamp;\n        bool cancelled;\n    }\n\n    struct Market {\n        uint256 questionId;\n        string question;\n        uint32 deadline;\n        uint256 totalYesVolume;\n        uint256 totalNoVolume;\n        bool resolved;\n        bool outcome;\n        uint256 feePercentage;\n        uint256 collectedFees;\n    }\n\n    uint256 public marketCounter;\n    uint256 public orderCounter;\n\n    mapping(uint256 => Market) public markets;\n    mapping(uint256 => mapping(uint256 => Order)) public orders;\n    mapping(uint256 => uint256[]) public marketOrders;\n    mapping(address => uint256[]) public userOrders;\n    mapping(uint256 => mapping(address => uint256)) public yesPositions;\n    mapping(uint256 => mapping(address => uint256)) public noPositions;\n\n    uint256 public constant FEE_PERCENTAGE = 200;\n    uint256 public constant MIN_ORDER_SIZE = 0.01 ether;\n    uint256 public constant MAX_PRICE = 10000;\n\n    event MarketCreated(uint256 indexed marketId, string question, uint32 deadline);\n    event OrderPlaced(uint256 indexed marketId, uint256 indexed orderId, address indexed trader, bool isBuy, bool isYes, uint256 price, uint256 amount);\n    event OrderMatched(uint256 indexed marketId, uint256 buyOrderId, uint256 sellOrderId, uint256 matchedAmount, uint256 price);\n    event OrderCancelled(uint256 indexed marketId, uint256 indexed orderId, address indexed trader);\n    event MarketResolved(uint256 indexed marketId, bool outcome);\n    event WinningsClaimed(uint256 indexed marketId, address indexed trader, uint256 amount);\n\n    constructor(address _oracleAddress) Ownable(msg.sender) {\n        oracle = SoraOracle(payable(_oracleAddress));\n    }\n\n    function createMarket(\n        string memory _question,\n        uint32 _deadline\n    ) external payable returns (uint256) {\n        require(bytes(_question).length > 0, \"Empty question\");\n        require(_deadline > block.timestamp, \"Invalid deadline\");\n        require(msg.value >= 0.01 ether, \"Insufficient creation fee\");\n\n        uint256 questionId = oracle.askOracle{value: msg.value}(_question, _deadline);\n        uint256 marketId = marketCounter++;\n\n        markets[marketId] = Market({\n            questionId: questionId,\n            question: _question,\n            deadline: _deadline,\n            totalYesVolume: 0,\n            totalNoVolume: 0,\n            resolved: false,\n            outcome: false,\n            feePercentage: FEE_PERCENTAGE,\n            collectedFees: 0\n        });\n\n        emit MarketCreated(marketId, _question, _deadline);\n        return marketId;\n    }\n\n    function placeOrder(\n        uint256 _marketId,\n        bool _isBuy,\n        bool _isYes,\n        uint256 _price,\n        uint256 _amount\n    ) external payable nonReentrant returns (uint256) {\n        Market storage market = markets[_marketId];\n        require(!market.resolved, \"Market resolved\");\n        require(block.timestamp < market.deadline, \"Market expired\");\n        require(_price > 0 && _price <= MAX_PRICE, \"Invalid price\");\n        require(_amount >= MIN_ORDER_SIZE, \"Order too small\");\n\n        uint256 requiredDeposit = _isBuy ? (_amount * _price) / MAX_PRICE : _amount;\n        require(msg.value >= requiredDeposit, \"Insufficient deposit\");\n\n        uint256 orderId = orderCounter++;\n\n        orders[_marketId][orderId] = Order({\n            trader: msg.sender,\n            isBuy: _isBuy,\n            isYes: _isYes,\n            price: _price,\n            amount: _amount,\n            filled: 0,\n            timestamp: block.timestamp,\n            cancelled: false\n        });\n\n        marketOrders[_marketId].push(orderId);\n        userOrders[msg.sender].push(orderId);\n\n        emit OrderPlaced(_marketId, orderId, msg.sender, _isBuy, _isYes, _price, _amount);\n\n        uint256 spent = _matchOrders(_marketId, orderId);\n\n        if (_isBuy) {\n            Order storage placedOrder = orders[_marketId][orderId];\n            uint256 unfilledDeposit = ((placedOrder.amount - placedOrder.filled) * placedOrder.price) / MAX_PRICE;\n            uint256 totalUsed = spent + unfilledDeposit;\n            if (msg.value > totalUsed) {\n                payable(msg.sender).transfer(msg.value - totalUsed);\n            }\n        } else {\n            if (msg.value > requiredDeposit) {\n                payable(msg.sender).transfer(msg.value - requiredDeposit);\n            }\n        }\n\n        return orderId;\n    }\n\n    function _matchOrders(uint256 _marketId, uint256 _newOrderId) internal returns (uint256 totalSpent) {\n        Order storage newOrder = orders[_marketId][_newOrderId];\n        uint256[] storage orderIds = marketOrders[_marketId];\n        totalSpent = 0;\n\n        while (newOrder.filled < newOrder.amount) {\n            uint256 bestOrderId = type(uint256).max;\n            uint256 bestPrice = newOrder.isBuy ? type(uint256).max : 0;\n            uint256 bestTime = type(uint256).max;\n\n            for (uint256 i = 0; i < orderIds.length; i++) {\n                if (orderIds[i] == _newOrderId) continue;\n                \n                Order storage existing = orders[_marketId][orderIds[i]];\n                if (existing.cancelled || existing.filled >= existing.amount) continue;\n                if ((newOrder.isBuy == existing.isBuy) || (newOrder.isYes != existing.isYes)) continue;\n                \n                bool priceOk = newOrder.isBuy ? newOrder.price >= existing.price : newOrder.price <= existing.price;\n                if (!priceOk) continue;\n\n                bool isBetterPrice = newOrder.isBuy \n                    ? existing.price < bestPrice\n                    : existing.price > bestPrice;\n                \n                bool isSamePrice = existing.price == bestPrice;\n                bool isEarlier = existing.timestamp < bestTime;\n\n                if (isBetterPrice || (isSamePrice && isEarlier)) {\n                    bestOrderId = orderIds[i];\n                    bestPrice = existing.price;\n                    bestTime = existing.timestamp;\n                }\n            }\n\n            if (bestOrderId == type(uint256).max) break;\n\n            Order storage bestOrder = orders[_marketId][bestOrderId];\n            uint256 matchQty = _min(newOrder.amount - newOrder.filled, bestOrder.amount - bestOrder.filled);\n\n            newOrder.filled += matchQty;\n            bestOrder.filled += matchQty;\n\n            if (newOrder.isBuy) {\n                totalSpent += (matchQty * bestPrice) / MAX_PRICE;\n            }\n\n            _processMatch(_marketId, newOrder.isBuy ? _newOrderId : bestOrderId, newOrder.isBuy ? bestOrderId : _newOrderId, matchQty, bestPrice, newOrder.isYes, newOrder.isBuy ? newOrder.trader : bestOrder.trader);\n        }\n        \n        return totalSpent;\n    }\n\n    function _processMatch(uint256 _marketId, uint256 _buyId, uint256 _sellId, uint256 _amt, uint256 _px, bool _isYes, address _buyer) internal {\n        uint256 fee = (_amt * FEE_PERCENTAGE) / 10000;\n        markets[_marketId].collectedFees += fee;\n\n        address seller = orders[_marketId][_sellId].trader;\n\n        if (_isYes) {\n            markets[_marketId].totalYesVolume += _amt;\n            yesPositions[_marketId][_buyer] += _amt;\n            noPositions[_marketId][seller] += _amt;\n        } else {\n            markets[_marketId].totalNoVolume += _amt;\n            noPositions[_marketId][_buyer] += _amt;\n            yesPositions[_marketId][seller] += _amt;\n        }\n\n        uint256 cost = (_amt * _px) / MAX_PRICE;\n        if (cost > fee) {\n            payable(seller).transfer(cost - fee);\n        }\n\n        emit OrderMatched(_marketId, _buyId, _sellId, _amt, _px);\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function cancelOrder(uint256 _marketId, uint256 _orderId) external nonReentrant {\n        Order storage order = orders[_marketId][_orderId];\n        require(order.trader == msg.sender, \"Not order owner\");\n        require(!order.cancelled, \"Already cancelled\");\n        require(order.filled < order.amount, \"Fully filled\");\n\n        order.cancelled = true;\n\n        uint256 unfilledAmount = order.amount - order.filled;\n        uint256 refund = order.isBuy\n            ? (unfilledAmount * order.price) / MAX_PRICE\n            : unfilledAmount;\n\n        if (refund > 0) {\n            payable(msg.sender).transfer(refund);\n        }\n\n        emit OrderCancelled(_marketId, _orderId, msg.sender);\n    }\n\n    function resolveMarket(uint256 _marketId) external nonReentrant {\n        Market storage market = markets[_marketId];\n        require(!market.resolved, \"Already resolved\");\n        require(block.timestamp >= market.deadline, \"Not expired\");\n\n        (address provider, uint8 confidenceScore, bool boolAnswer, uint64 numericAnswer, uint32 answerTimestamp) = oracle.answers(market.questionId);\n        require(provider != address(0), \"Not answered\");\n\n        market.resolved = true;\n        market.outcome = numericAnswer > 0 || boolAnswer;\n\n        emit MarketResolved(_marketId, market.outcome);\n    }\n\n    function claimWinnings(uint256 _marketId) external nonReentrant {\n        Market storage market = markets[_marketId];\n        require(market.resolved, \"Not resolved\");\n\n        uint256 yesPos = yesPositions[_marketId][msg.sender];\n        uint256 noPos = noPositions[_marketId][msg.sender];\n        require(yesPos > 0 || noPos > 0, \"No position\");\n\n        yesPositions[_marketId][msg.sender] = 0;\n        noPositions[_marketId][msg.sender] = 0;\n\n        uint256 payout = market.outcome ? yesPos : noPos;\n\n        if (payout > 0) {\n            payable(msg.sender).transfer(payout);\n            emit WinningsClaimed(_marketId, msg.sender, payout);\n        }\n    }\n\n    function getOrderBook(uint256 _marketId, bool _isYes) external view returns (\n        Order[] memory buyOrders,\n        Order[] memory sellOrders\n    ) {\n        uint256[] storage orderIds = marketOrders[_marketId];\n        uint256 buyCount = 0;\n        uint256 sellCount = 0;\n\n        for (uint256 i = 0; i < orderIds.length; i++) {\n            Order storage order = orders[_marketId][orderIds[i]];\n            if (order.cancelled || order.filled >= order.amount || order.isYes != _isYes) continue;\n\n            if (order.isBuy) {\n                buyCount++;\n            } else {\n                sellCount++;\n            }\n        }\n\n        buyOrders = new Order[](buyCount);\n        sellOrders = new Order[](sellCount);\n\n        uint256 buyIndex = 0;\n        uint256 sellIndex = 0;\n\n        for (uint256 i = 0; i < orderIds.length; i++) {\n            Order storage order = orders[_marketId][orderIds[i]];\n            if (order.cancelled || order.filled >= order.amount || order.isYes != _isYes) continue;\n\n            if (order.isBuy) {\n                buyOrders[buyIndex++] = order;\n            } else {\n                sellOrders[sellIndex++] = order;\n            }\n        }\n\n        return (buyOrders, sellOrders);\n    }\n\n    function getMarketPrice(uint256 _marketId, bool _isYes) external view returns (uint256) {\n        uint256[] storage orderIds = marketOrders[_marketId];\n        uint256 bestBid = 0;\n        uint256 bestAsk = MAX_PRICE;\n\n        for (uint256 i = 0; i < orderIds.length; i++) {\n            Order storage order = orders[_marketId][orderIds[i]];\n            if (order.cancelled || order.filled >= order.amount || order.isYes != _isYes) continue;\n\n            if (order.isBuy && order.price > bestBid) {\n                bestBid = order.price;\n            } else if (!order.isBuy && order.price < bestAsk) {\n                bestAsk = order.price;\n            }\n        }\n\n        return bestBid > 0 ? (bestBid + bestAsk) / 2 : 5000;\n    }\n\n    function getUserOrders(address _user) external view returns (uint256[] memory) {\n        return userOrders[_user];\n    }\n\n    function getMarketOrders(uint256 _marketId) external view returns (uint256[] memory) {\n        return marketOrders[_marketId];\n    }\n\n    function setOracle(address payable _oracleAddress) external onlyOwner {\n        require(_oracleAddress != address(0), \"Invalid oracle\");\n        oracle = SoraOracle(_oracleAddress);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/PancakeTWAPOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./interfaces/IPancakePair.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title PancakeTWAPOracle\n * @notice Time-Weighted Average Price oracle for PancakeSwap V2 pairs\n * @dev Provides manipulation-resistant price feeds using Uniswap V2 TWAP pattern\n */\ncontract PancakeTWAPOracle is Ownable {\n    struct Observation {\n        uint32 timestamp;\n        uint256 price0Cumulative;\n        uint256 price1Cumulative;\n    }\n\n    IPancakePair public immutable pair;\n    address public immutable token0;\n    address public immutable token1;\n    \n    Observation public observationOld;\n    Observation public observationNew;\n    \n    uint32 public constant MIN_PERIOD = 5 minutes;\n    uint224 constant Q112 = 2**112;\n\n    event OracleUpdated(uint32 timestamp, uint256 price0Cumulative, uint256 price1Cumulative);\n\n    constructor(address _pair) Ownable(msg.sender) {\n        require(_pair != address(0), \"Invalid pair address\");\n        pair = IPancakePair(_pair);\n        token0 = pair.token0();\n        token1 = pair.token1();\n        \n        (uint256 price0Cumulative, uint256 price1Cumulative, uint32 blockTimestamp) = currentCumulativePrices();\n        require(price0Cumulative > 0 || price1Cumulative > 0, \"No data\");\n        \n        observationOld = Observation({\n            timestamp: blockTimestamp,\n            price0Cumulative: price0Cumulative,\n            price1Cumulative: price1Cumulative\n        });\n        \n        observationNew = observationOld;\n    }\n\n    /**\n     * @notice Compute current cumulative prices\n     * @dev Follows Uniswap V2 oracle pattern - adds time-weighted price since last update\n     */\n    function currentCumulativePrices() public view returns (\n        uint256 price0Cumulative,\n        uint256 price1Cumulative,\n        uint32 blockTimestamp\n    ) {\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = pair.getReserves();\n        \n        price0Cumulative = pair.price0CumulativeLast();\n        price1Cumulative = pair.price1CumulativeLast();\n        blockTimestamp = uint32(block.timestamp);\n        \n        // If time has elapsed since the last update, compute the time-weighted price\n        if (blockTimestampLast != blockTimestamp) {\n            uint32 timeElapsed;\n            unchecked {\n                timeElapsed = blockTimestamp - blockTimestampLast;\n            }\n            \n            // Add the accumulated price during the elapsed time\n            // price0 = reserve1 / reserve0, encoded as UQ112x112\n            // price1 = reserve0 / reserve1, encoded as UQ112x112\n            if (reserve0 != 0 && reserve1 != 0) {\n                unchecked {\n                    price0Cumulative += uint256(uint224(reserve1)) * Q112 / reserve0 * timeElapsed;\n                    price1Cumulative += uint256(uint224(reserve0)) * Q112 / reserve1 * timeElapsed;\n                }\n            }\n        }\n    }\n\n    function update() external {\n        (uint256 price0Cumulative, uint256 price1Cumulative, uint32 blockTimestamp) = currentCumulativePrices();\n        uint32 timeElapsed;\n        unchecked {\n            timeElapsed = blockTimestamp - observationNew.timestamp;\n        }\n        \n        require(timeElapsed >= MIN_PERIOD, \"Period not elapsed\");\n        \n        observationOld = observationNew;\n        \n        observationNew = Observation({\n            timestamp: blockTimestamp,\n            price0Cumulative: price0Cumulative,\n            price1Cumulative: price1Cumulative\n        });\n\n        emit OracleUpdated(blockTimestamp, price0Cumulative, price1Cumulative);\n    }\n\n    /**\n     * @notice Get TWAP price - falls back to spot if bootstrapping\n     * @dev Permissionless: returns spot price for first 5 min after oracle creation\n     * @param token Token to price  \n     * @param amountIn Amount of input token\n     * @return amountOut Expected output based on TWAP (or spot during bootstrap)\n     */\n    function consult(address token, uint256 amountIn) external view returns (uint256 amountOut) {\n        require(token == token0 || token == token1, \"Invalid token\");\n        \n        uint32 timeElapsed;\n        unchecked {\n            timeElapsed = observationNew.timestamp - observationOld.timestamp;\n        }\n        \n        // Bootstrap mode: return spot price if not enough data yet\n        if (timeElapsed < MIN_PERIOD) {\n            return _getCurrentPrice(token, amountIn);\n        }\n        \n        // Normal mode: return TWAP\n        uint256 priceCumulativeDelta;\n        if (token == token0) {\n            unchecked {\n                priceCumulativeDelta = observationNew.price0Cumulative - observationOld.price0Cumulative;\n            }\n            uint224 priceAverage = uint224(priceCumulativeDelta / timeElapsed);\n            amountOut = (amountIn * priceAverage) / Q112;\n        } else {\n            unchecked {\n                priceCumulativeDelta = observationNew.price1Cumulative - observationOld.price1Cumulative;\n            }\n            uint224 priceAverage = uint224(priceCumulativeDelta / timeElapsed);\n            amountOut = (amountIn * priceAverage) / Q112;\n        }\n    }\n    \n    /**\n     * @notice Check if oracle has enough data for true TWAP (vs spot fallback)\n     * @return bool True if MIN_PERIOD elapsed (using TWAP), false if using spot\n     */\n    function canConsult() external view returns (bool) {\n        uint32 timeElapsed;\n        unchecked {\n            timeElapsed = observationNew.timestamp - observationOld.timestamp;\n        }\n        return timeElapsed >= MIN_PERIOD;\n    }\n\n    function getCurrentPrice(address token, uint256 amountIn) external view returns (uint256 amountOut) {\n        return _getCurrentPrice(token, amountIn);\n    }\n\n    function _getCurrentPrice(address token, uint256 amountIn) internal view returns (uint256 amountOut) {\n        require(token == token0 || token == token1, \"Invalid token\");\n        \n        (uint112 reserve0, uint112 reserve1,) = pair.getReserves();\n        require(reserve0 != 0 && reserve1 != 0, \"No reserves\");\n        \n        if (token == token0) {\n            amountOut = (amountIn * reserve1) / reserve0;\n        } else {\n            amountOut = (amountIn * reserve0) / reserve1;\n        }\n    }\n\n    function canUpdate() external view returns (bool) {\n        uint32 timeElapsed;\n        unchecked {\n            timeElapsed = uint32(block.timestamp) - observationNew.timestamp;\n        }\n        return timeElapsed >= MIN_PERIOD;\n    }\n}\n"
    },
    "contracts/PredictionMarketV5.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./TokenFactory.sol\";\n\n/**\n * @title PredictionMarketV5\n * @notice Enhanced prediction market with integrated token factory and x402 payment verification\n * @dev Combines market creation, token minting, and micropayment validation\n */\ncontract PredictionMarketV5 is Ownable, ReentrancyGuard {\n    struct Market {\n        uint256 id;\n        string question;\n        address oracleFeed;\n        address marketToken;\n        uint256 resolutionTime;\n        bool resolved;\n        bool outcome;\n        uint256 totalYesPool;\n        uint256 totalNoPool;\n        uint256 createdAt;\n        address creator;\n    }\n\n    struct X402PaymentProof {\n        bytes32 nonce;\n        uint256 amount;\n        address token;\n        address from;\n        address facilitator;\n        bytes signature;\n    }\n\n    TokenFactory public immutable tokenFactory;\n    address public immutable x402Facilitator;\n    address public immutable usdcToken;\n    \n    // x402 Pricing Tiers (USDC, 6 decimals)\n    uint256 public constant MARKET_CREATION_FEE = 50000;   // $0.05 USDC\n    uint256 public constant PLACE_BET_FEE = 10000;         // $0.01 USDC\n    uint256 public constant RESOLVE_MARKET_FEE = 100000;   // $0.10 USDC\n\n    uint256 public marketCount;\n    mapping(uint256 => Market) public markets;\n    mapping(bytes32 => bool) public usedNonces; // Prevent replay attacks\n    mapping(address => uint256[]) public creatorMarkets;\n\n    event MarketCreated(\n        uint256 indexed marketId,\n        string question,\n        address indexed marketToken,\n        address indexed oracleFeed,\n        uint256 resolutionTime,\n        address creator\n    );\n\n    event PositionTaken(\n        uint256 indexed marketId,\n        address indexed user,\n        bool position,\n        uint256 amount\n    );\n\n    event MarketResolved(\n        uint256 indexed marketId,\n        bool outcome,\n        uint256 totalPayout\n    );\n\n    event PaymentVerified(\n        address indexed payer,\n        uint256 amount,\n        bytes32 nonce\n    );\n\n    constructor(\n        address _tokenFactory,\n        address _x402Facilitator,\n        address _usdcToken\n    ) Ownable(msg.sender) {\n        require(_tokenFactory != address(0), \"Invalid factory\");\n        require(_x402Facilitator != address(0), \"Invalid facilitator\");\n        require(_usdcToken != address(0), \"Invalid USDC\");\n\n        tokenFactory = TokenFactory(_tokenFactory);\n        x402Facilitator = _x402Facilitator;\n        usdcToken = _usdcToken;\n    }\n\n    /**\n     * @notice Create a new prediction market with OPTIONAL token minting and x402 payment verification\n     * @param marketQuestion Human-readable question\n     * @param oracleFeed Address of oracle feed for resolution\n     * @param resolutionTime Unix timestamp when market can be resolved\n     * @param useToken Whether to deploy a market token (OPTIONAL)\n     * @param tokenSupply Initial supply for market token (ignored if useToken = false)\n     * @param paymentProof x402 payment verification data\n     */\n    function createMarket(\n        string memory marketQuestion,\n        address oracleFeed,\n        uint256 resolutionTime,\n        bool useToken,\n        uint256 tokenSupply,\n        X402PaymentProof memory paymentProof\n    ) external nonReentrant returns (uint256 marketId) {\n        require(bytes(marketQuestion).length > 0, \"Question required\");\n        require(oracleFeed != address(0), \"Oracle required\");\n        require(resolutionTime > block.timestamp, \"Invalid resolution time\");\n\n        // Verify x402 payment for market creation\n        _verifyPayment(paymentProof, MARKET_CREATION_FEE);\n\n        // Generate unique market ID\n        marketId = ++marketCount;\n\n        // Deploy market token ONLY if requested\n        address marketToken = address(0);\n        if (useToken) {\n            require(tokenSupply > 0 && tokenSupply <= 1e36, \"Invalid supply\");\n            \n            string memory marketName = string(\n                abi.encodePacked(\"Market-\", _uint2str(marketId))\n            );\n\n            marketToken = tokenFactory.createToken(\n                marketName,\n                tokenSupply,\n                oracleFeed\n            );\n        }\n\n        // Create market\n        markets[marketId] = Market({\n            id: marketId,\n            question: marketQuestion,\n            oracleFeed: oracleFeed,\n            marketToken: marketToken,\n            resolutionTime: resolutionTime,\n            resolved: false,\n            outcome: false,\n            totalYesPool: 0,\n            totalNoPool: 0,\n            createdAt: block.timestamp,\n            creator: msg.sender\n        });\n\n        creatorMarkets[msg.sender].push(marketId);\n\n        emit MarketCreated(\n            marketId,\n            marketQuestion,\n            marketToken,\n            oracleFeed,\n            resolutionTime,\n            msg.sender\n        );\n\n        return marketId;\n    }\n\n    /**\n     * @notice Verify x402 payment proof with facilitator\n     * @dev Enforces differentiated pricing per operation\n     * @param proof Payment proof from user\n     * @param requiredAmount Required payment amount for this operation\n     */\n    function _verifyPayment(\n        X402PaymentProof memory proof,\n        uint256 requiredAmount\n    ) internal {\n        require(proof.from == msg.sender, \"Invalid payer\");\n        require(proof.token == usdcToken, \"Invalid token\");\n        require(proof.amount >= requiredAmount, \"Insufficient payment\");\n        require(proof.facilitator == x402Facilitator, \"Invalid facilitator\");\n        require(!usedNonces[proof.nonce], \"Nonce already used\");\n\n        // Reconstruct the signed message (MUST match X402Client.createPayment format)\n        bytes32 message = keccak256(\n            abi.encodePacked(\n                proof.nonce,\n                proof.amount,\n                proof.token,\n                proof.from,\n                proof.facilitator\n            )\n        );\n\n        // Add Ethereum Signed Message prefix\n        bytes32 ethSignedMessageHash = keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", message)\n        );\n\n        // Recover signer from signature\n        address recoveredSigner = _recoverSigner(ethSignedMessageHash, proof.signature);\n\n        // Verify signer matches claimed payer\n        require(recoveredSigner == proof.from, \"Invalid signature\");\n\n        // Mark nonce as used (prevent replay attacks)\n        usedNonces[proof.nonce] = true;\n\n        emit PaymentVerified(proof.from, proof.amount, proof.nonce);\n    }\n\n    /**\n     * @notice Recover signer address from signature\n     * @dev Standard ECDSA signature recovery\n     */\n    function _recoverSigner(\n        bytes32 ethSignedMessageHash,\n        bytes memory signature\n    ) internal pure returns (address) {\n        require(signature.length == 65, \"Invalid signature length\");\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // Split signature into r, s, v components\n        assembly {\n            r := mload(add(signature, 32))\n            s := mload(add(signature, 64))\n            v := byte(0, mload(add(signature, 96)))\n        }\n\n        // Handle legacy v values (27/28)\n        if (v < 27) {\n            v += 27;\n        }\n\n        require(v == 27 || v == 28, \"Invalid signature v value\");\n\n        return ecrecover(ethSignedMessageHash, v, r, s);\n    }\n\n    /**\n     * @notice Take a position on a market with x402 payment\n     * @param marketId Market to bet on\n     * @param position true = YES, false = NO\n     * @param paymentProof x402 payment proof ($0.01 USDC)\n     */\n    function takePosition(\n        uint256 marketId,\n        bool position,\n        X402PaymentProof memory paymentProof\n    ) external payable nonReentrant {\n        Market storage market = markets[marketId];\n        require(market.id != 0, \"Market not found\");\n        require(!market.resolved, \"Market resolved\");\n        require(block.timestamp < market.resolutionTime, \"Market closed\");\n        require(msg.value > 0, \"Amount required\");\n\n        // Verify x402 payment for bet\n        _verifyPayment(paymentProof, PLACE_BET_FEE);\n\n        if (position) {\n            market.totalYesPool += msg.value;\n        } else {\n            market.totalNoPool += msg.value;\n        }\n\n        emit PositionTaken(marketId, msg.sender, position, msg.value);\n    }\n\n    /**\n     * @notice Resolve market based on oracle feed with x402 payment\n     * @dev Can be called by anyone after resolution time (pays $0.10 for AI research)\n     * @param marketId Market to resolve\n     * @param outcome Resolution outcome (true = YES, false = NO)\n     * @param paymentProof x402 payment proof ($0.10 USDC)\n     */\n    function resolveMarket(\n        uint256 marketId,\n        bool outcome,\n        X402PaymentProof memory paymentProof\n    ) external nonReentrant {\n        Market storage market = markets[marketId];\n        require(market.id != 0, \"Market not found\");\n        require(!market.resolved, \"Already resolved\");\n        require(block.timestamp >= market.resolutionTime, \"Too early\");\n\n        // Verify x402 payment for resolution\n        _verifyPayment(paymentProof, RESOLVE_MARKET_FEE);\n\n        market.resolved = true;\n        market.outcome = outcome;\n\n        uint256 totalPayout = market.totalYesPool + market.totalNoPool;\n\n        emit MarketResolved(marketId, outcome, totalPayout);\n    }\n\n    /**\n     * @notice Get market details\n     */\n    function getMarket(uint256 marketId) external view returns (Market memory) {\n        return markets[marketId];\n    }\n\n    /**\n     * @notice Get markets created by address\n     */\n    function getMarketsByCreator(\n        address creator\n    ) external view returns (uint256[] memory) {\n        return creatorMarkets[creator];\n    }\n\n    /**\n     * @notice Convert uint to string\n     */\n    function _uint2str(uint256 _i) internal pure returns (string memory) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len;\n        while (_i != 0) {\n            k = k - 1;\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n}\n"
    },
    "contracts/RangeMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./SoraOracle.sol\";\n\n/**\n * @title RangeMarket\n * @notice Bet on whether a value will fall within a specific range\n * @dev Example: \"Will BTC be between $30k-$35k on Dec 31?\"\n */\ncontract RangeMarket is Ownable, ReentrancyGuard {\n    \n    struct Market {\n        string question;\n        uint256 questionId;         // SoraOracle question ID\n        uint64 lowerBound;\n        uint64 upperBound;\n        uint256 inRangePool;\n        uint256 outRangePool;\n        uint256 totalFees;\n        uint32 createdAt;\n        uint32 deadline;\n        uint32 resolvedAt;\n        bool resolved;\n        bool inRange;               // Final outcome: true if in range\n    }\n\n    struct Position {\n        uint256 inRangeAmount;\n        uint256 outRangeAmount;\n        bool claimed;\n    }\n\n    mapping(uint256 => Market) public markets;\n    mapping(uint256 => mapping(address => Position)) public positions;\n    \n    uint256 public marketCounter;\n    uint256 public feePercentage = 200; // 2%\n    SoraOracle public oracle;\n\n    event MarketCreated(uint256 indexed marketId, string question, uint64 lowerBound, uint64 upperBound, uint32 deadline);\n    event PositionTaken(uint256 indexed marketId, address indexed user, bool predictInRange, uint256 amount);\n    event MarketResolved(uint256 indexed marketId, uint64 finalValue, bool inRange);\n    event WinningsClaimed(uint256 indexed marketId, address indexed user, uint256 payout);\n\n    constructor(address payable _oracleAddress) Ownable(msg.sender) {\n        require(_oracleAddress != address(0), \"Invalid oracle\");\n        oracle = SoraOracle(_oracleAddress);\n    }\n\n    /**\n     * @notice Create range prediction market\n     * @param _question Market question\n     * @param _lowerBound Lower bound of range\n     * @param _upperBound Upper bound of range\n     * @param _deadline Resolution deadline\n     */\n    function createMarket(\n        string memory _question,\n        uint64 _lowerBound,\n        uint64 _upperBound,\n        uint32 _deadline\n    ) external payable returns (uint256 marketId) {\n        require(bytes(_question).length > 0, \"Empty question\");\n        require(_upperBound > _lowerBound, \"Invalid range\");\n        require(_deadline > block.timestamp, \"Invalid deadline\");\n\n        // Ask oracle for the value at deadline\n        uint256 questionId = oracle.askOracle{value: msg.value}(_question, _deadline);\n\n        marketId = marketCounter++;\n\n        markets[marketId] = Market({\n            question: _question,\n            questionId: questionId,\n            lowerBound: _lowerBound,\n            upperBound: _upperBound,\n            inRangePool: 0,\n            outRangePool: 0,\n            totalFees: 0,\n            createdAt: uint32(block.timestamp),\n            deadline: _deadline,\n            resolvedAt: 0,\n            resolved: false,\n            inRange: false\n        });\n\n        emit MarketCreated(marketId, _question, _lowerBound, _upperBound, _deadline);\n        return marketId;\n    }\n\n    /**\n     * @notice Take position on range outcome\n     * @param _marketId Market ID\n     * @param _predictInRange True to bet IN range, false for OUT of range\n     */\n    function takePosition(uint256 _marketId, bool _predictInRange) external payable nonReentrant {\n        Market storage market = markets[_marketId];\n        require(!market.resolved, \"Market resolved\");\n        require(block.timestamp < market.deadline, \"Market closed\");\n        require(msg.value > 0, \"Must send BNB\");\n\n        uint256 fee = (msg.value * feePercentage) / 10000;\n        uint256 betAmount = msg.value - fee;\n\n        market.totalFees += fee;\n\n        if (_predictInRange) {\n            market.inRangePool += betAmount;\n            positions[_marketId][msg.sender].inRangeAmount += betAmount;\n        } else {\n            market.outRangePool += betAmount;\n            positions[_marketId][msg.sender].outRangeAmount += betAmount;\n        }\n\n        emit PositionTaken(_marketId, msg.sender, _predictInRange, betAmount);\n    }\n\n    /**\n     * @notice Resolve market using oracle answer\n     */\n    function resolveMarket(uint256 _marketId) external nonReentrant {\n        Market storage market = markets[_marketId];\n        require(!market.resolved, \"Already resolved\");\n        require(block.timestamp >= market.deadline, \"Not yet deadline\");\n\n        // Get answer from oracle\n        (, , , uint64 numericAnswer,) = oracle.answers(market.questionId);\n        require(numericAnswer > 0, \"Oracle not answered yet\");\n\n        // Check if value is in range\n        bool valueInRange = numericAnswer >= market.lowerBound && numericAnswer <= market.upperBound;\n\n        market.inRange = valueInRange;\n        market.resolved = true;\n        market.resolvedAt = uint32(block.timestamp);\n\n        emit MarketResolved(_marketId, numericAnswer, valueInRange);\n    }\n\n    /**\n     * @notice Claim winnings\n     */\n    function claimWinnings(uint256 _marketId) external nonReentrant {\n        Market storage market = markets[_marketId];\n        require(market.resolved, \"Not resolved\");\n\n        Position storage position = positions[_marketId][msg.sender];\n        require(!position.claimed, \"Already claimed\");\n        require(position.inRangeAmount > 0 || position.outRangeAmount > 0, \"No position\");\n\n        uint256 winningPool = market.inRange ? market.inRangePool : market.outRangePool;\n        uint256 losingPool = market.inRange ? market.outRangePool : market.inRangePool;\n        uint256 userWinningAmount = market.inRange ? position.inRangeAmount : position.outRangeAmount;\n\n        require(userWinningAmount > 0, \"Not a winner\");\n        require(winningPool > 0, \"No winning pool\");\n\n        // Parimutuel payout\n        uint256 payout = userWinningAmount + ((userWinningAmount * losingPool) / winningPool);\n\n        position.claimed = true;\n        payable(msg.sender).transfer(payout);\n\n        emit WinningsClaimed(_marketId, msg.sender, payout);\n    }\n\n    /**\n     * @notice Get market details\n     */\n    function getMarket(uint256 _marketId) external view returns (\n        string memory question,\n        uint64 lowerBound,\n        uint64 upperBound,\n        uint256 inRangePool,\n        uint256 outRangePool,\n        uint32 deadline,\n        bool resolved,\n        bool inRange\n    ) {\n        Market memory market = markets[_marketId];\n        return (\n            market.question,\n            market.lowerBound,\n            market.upperBound,\n            market.inRangePool,\n            market.outRangePool,\n            market.deadline,\n            market.resolved,\n            market.inRange\n        );\n    }\n\n    /**\n     * @notice Get user position\n     */\n    function getPosition(uint256 _marketId, address _user) external view returns (\n        uint256 inRangeAmount,\n        uint256 outRangeAmount,\n        bool claimed\n    ) {\n        Position memory position = positions[_marketId][_user];\n        return (position.inRangeAmount, position.outRangeAmount, position.claimed);\n    }\n\n    /**\n     * @notice Get current odds\n     */\n    function getOdds(uint256 _marketId) external view returns (\n        uint256 inRangeOdds,\n        uint256 outRangeOdds\n    ) {\n        Market memory market = markets[_marketId];\n        uint256 totalPool = market.inRangePool + market.outRangePool;\n        \n        if (totalPool == 0) {\n            return (5000, 5000); // 50/50 if no bets\n        }\n\n        // Calculate as percentage of total pool (basis points)\n        if (market.inRangePool == 0) {\n            inRangeOdds = 1; // Minimum odds to avoid zero\n            outRangeOdds = 9999;\n        } else if (market.outRangePool == 0) {\n            inRangeOdds = 9999;\n            outRangeOdds = 1; // Minimum odds to avoid zero\n        } else {\n            inRangeOdds = (market.inRangePool * 10000) / totalPool;\n            outRangeOdds = 10000 - inRangeOdds;\n        }\n    }\n\n    /**\n     * @notice Update oracle address\n     */\n    function setOracle(address payable _oracleAddress) external onlyOwner {\n        require(_oracleAddress != address(0), \"Invalid oracle\");\n        oracle = SoraOracle(_oracleAddress);\n    }\n}\n"
    },
    "contracts/ReferralRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title ReferralRewards\n * @notice Reward users for referring traders to the platform\n * @dev Tracks referrals and distributes rewards from trading fees\n */\ncontract ReferralRewards is Ownable, ReentrancyGuard {\n    \n    struct Referrer {\n        uint256 totalReferrals;\n        uint256 totalVolume;      // Total volume from referrals\n        uint256 earnedRewards;\n        uint256 claimedRewards;\n        bool isActive;\n    }\n\n    struct Referral {\n        address referrer;\n        uint256 timestamp;\n        uint256 volumeGenerated;\n    }\n\n    // Referral reward percentage (5% of trading fees go to referrer)\n    uint256 public constant REFERRAL_REWARD_PERCENTAGE = 5;\n    \n    // Minimum volume to become eligible referrer (1 BNB)\n    uint256 public constant MIN_VOLUME_FOR_REFERRER = 1 ether;\n\n    mapping(address => Referrer) public referrers;\n    mapping(address => Referral) public referrals; // user => their referral info\n    mapping(address => address[]) public referredUsers; // referrer => list of referred users\n    \n    uint256 public totalReferralRewards;\n    uint256 public totalReferrals;\n\n    mapping(address => bool) public authorizedMarkets;\n\n    event ReferralRegistered(address indexed referee, address indexed referrer);\n    event MarketAuthorized(address indexed market, bool authorized);\n    event ReferralVolumeRecorded(address indexed referrer, address indexed referee, uint256 volume);\n    event ReferralRewardEarned(address indexed referrer, uint256 amount);\n    event ReferralRewardClaimed(address indexed referrer, uint256 amount);\n    event ReferrerActivated(address indexed referrer);\n\n    constructor() Ownable(msg.sender) {}\n\n    /**\n     * @notice Authorize/deauthorize market contracts\n     */\n    function setMarketAuthorization(address _market, bool _authorized) external onlyOwner {\n        require(_market != address(0), \"Invalid market\");\n        authorizedMarkets[_market] = _authorized;\n        emit MarketAuthorized(_market, _authorized);\n    }\n\n    /**\n     * @notice Register a referral relationship\n     * @param _referrer Address of the referrer\n     */\n    function registerReferral(address _referrer) external {\n        require(_referrer != address(0), \"Invalid referrer\");\n        require(_referrer != msg.sender, \"Cannot refer yourself\");\n        require(referrals[msg.sender].referrer == address(0), \"Already referred\");\n        require(referrers[_referrer].isActive || referrers[_referrer].totalVolume >= MIN_VOLUME_FOR_REFERRER, \n                \"Referrer not eligible\");\n\n        referrals[msg.sender] = Referral({\n            referrer: _referrer,\n            timestamp: block.timestamp,\n            volumeGenerated: 0\n        });\n\n        referrers[_referrer].totalReferrals++;\n        referredUsers[_referrer].push(msg.sender);\n        totalReferrals++;\n\n        emit ReferralRegistered(msg.sender, _referrer);\n    }\n\n    /**\n     * @notice Record volume from a referred user and distribute rewards\n     * @dev Called by authorized contracts (prediction markets)\n     * @param _user User who generated volume\n     * @param _volume Volume generated\n     * @param _fee Fee collected from this volume\n     */\n    function recordVolume(address _user, uint256 _volume, uint256 _fee) \n        external \n        payable \n    {\n        require(authorizedMarkets[msg.sender], \"Not authorized market\");\n        require(msg.value == _fee * REFERRAL_REWARD_PERCENTAGE / 100, \"Incorrect reward amount\");\n\n        Referral storage referral = referrals[_user];\n        if (referral.referrer == address(0)) {\n            // No referrer, return funds\n            (bool success, ) = msg.sender.call{value: msg.value}(\"\");\n            require(success, \"Refund failed\");\n            return;\n        }\n\n        // Update referral stats\n        referral.volumeGenerated += _volume;\n        \n        Referrer storage referrer = referrers[referral.referrer];\n        referrer.totalVolume += _volume;\n        referrer.earnedRewards += msg.value;\n        \n        totalReferralRewards += msg.value;\n\n        emit ReferralVolumeRecorded(referral.referrer, _user, _volume);\n        emit ReferralRewardEarned(referral.referrer, msg.value);\n    }\n\n    /**\n     * @notice Claim accumulated referral rewards\n     */\n    function claimRewards() external nonReentrant {\n        Referrer storage referrer = referrers[msg.sender];\n        uint256 pending = referrer.earnedRewards - referrer.claimedRewards;\n        require(pending > 0, \"No rewards to claim\");\n\n        referrer.claimedRewards += pending;\n\n        (bool success, ) = msg.sender.call{value: pending}(\"\");\n        require(success, \"Transfer failed\");\n\n        emit ReferralRewardClaimed(msg.sender, pending);\n    }\n\n    /**\n     * @notice Activate as referrer (for users who meet volume requirement)\n     */\n    function activateAsReferrer() external {\n        Referrer storage referrer = referrers[msg.sender];\n        require(!referrer.isActive, \"Already active\");\n        require(referrer.totalVolume >= MIN_VOLUME_FOR_REFERRER, \"Volume too low\");\n\n        referrer.isActive = true;\n        emit ReferrerActivated(msg.sender);\n    }\n\n    /**\n     * @notice Get pending rewards for referrer\n     */\n    function getPendingRewards(address _referrer) external view returns (uint256) {\n        Referrer storage referrer = referrers[_referrer];\n        return referrer.earnedRewards - referrer.claimedRewards;\n    }\n\n    /**\n     * @notice Get referrer's referred users\n     */\n    function getReferredUsers(address _referrer) external view returns (address[] memory) {\n        return referredUsers[_referrer];\n    }\n\n    /**\n     * @notice Get referrer info\n     */\n    function getReferrerInfo(address _referrer) \n        external \n        view \n        returns (\n            uint256 referralCount,\n            uint256 volumeGenerated,\n            uint256 earnedRewards,\n            uint256 claimedRewards,\n            uint256 pendingRewards,\n            bool isActive\n        ) \n    {\n        Referrer storage ref = referrers[_referrer];\n        return (\n            ref.totalReferrals,\n            ref.totalVolume,\n            ref.earnedRewards,\n            ref.claimedRewards,\n            ref.earnedRewards - ref.claimedRewards,\n            ref.isActive\n        );\n    }\n\n    /**\n     * @notice Check if user was referred\n     */\n    function getReferrer(address _user) external view returns (address) {\n        return referrals[_user].referrer;\n    }\n}\n"
    },
    "contracts/S402Facilitator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title S402Facilitator\n * @notice Sora's HTTP 402 protocol facilitator for BNB Chain\n * @dev Implements EIP-2612 permit() + transferFrom() for gasless approvals\n * \n * SECURITY FIXES v2:\n * - Recipient is now part of signed message (prevents front-running)\n * - Batch function uses internal calls (fixes reentrancy issue)\n * - Emergency pause mechanism (Pausable)\n * - Comprehensive input validation\n * \n * S402 (SORA 402):\n * - Inspired by Coinbase's x402 but optimized for BNB Chain\n * - EIP-2612 permit() (BNB Chain USDC compatibility)\n * - Sequential nonces (handled by USDC contract)\n * - Two-step process: permit() then transferFrom()\n * - NOT x402-compliant (honest branding)\n * \n * Network: BNB Chain (56) / BNB Testnet (97)\n * Token: USDC on BNB Chain (EIP-2612 compliant)\n * \n * Reference: S402_SPECIFICATION.md\n */\ncontract S402Facilitator is ReentrancyGuard, Pausable, Ownable {\n    \n    // =============================================================================\n    // STATE VARIABLES\n    // =============================================================================\n    \n    // USDC on BNB Chain (EIP-2612 compliant)\n    IERC20 public immutable usdc;\n    \n    // Platform fee (basis points, e.g., 100 = 1%)\n    uint256 public platformFeeBps = 100; // 1% platform fee\n    uint256 public constant MAX_PLATFORM_FEE_BPS = 1000; // 10% max\n    \n    // Accumulated platform fees\n    uint256 public accumulatedFees;\n    \n    // Payment tracking\n    mapping(address => uint256) public totalPaid;\n    mapping(address => uint256) public totalReceived;\n    \n    // Used payment tracking (prevents replay) - NOW INCLUDES RECIPIENT\n    mapping(bytes32 => bool) public usedPayments;\n    \n    // Domain separator for EIP-712\n    bytes32 public immutable DOMAIN_SEPARATOR;\n    \n    // EIP-712 TypeHash for payment authorization\n    bytes32 public constant PAYMENT_TYPEHASH = keccak256(\n        \"PaymentAuthorization(address owner,address spender,uint256 value,uint256 deadline,address recipient,bytes32 nonce)\"\n    );\n    \n    // =============================================================================\n    // EVENTS\n    // =============================================================================\n    \n    event PaymentSettled(\n        address indexed from,\n        address indexed to,\n        uint256 value,\n        uint256 platformFee,\n        bytes32 nonce\n    );\n    \n    event PlatformFeeUpdated(uint256 oldFee, uint256 newFee);\n    event FeesWithdrawn(address indexed to, uint256 amount);\n    event EmergencyPause(address indexed by);\n    event EmergencyUnpause(address indexed by);\n    \n    // =============================================================================\n    // CONSTRUCTOR\n    // =============================================================================\n    \n    /**\n     * @notice Initialize facilitator with USDC address\n     * @param _usdc USDC contract address on BNB Chain\n     */\n    constructor(address _usdc) Ownable(msg.sender) {\n        require(_usdc != address(0), \"Invalid USDC address\");\n        usdc = IERC20(_usdc);\n        \n        // Set up EIP-712 domain separator\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(\"S402Facilitator\")),\n                keccak256(bytes(\"1\")),\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    \n    // =============================================================================\n    // EIP-2612: PERMIT + TRANSFERFROM (s402 Core) - FIXED VERSION\n    // =============================================================================\n    \n    /**\n     * @notice Settle payment using EIP-2612 permit with signed recipient\n     * @dev SECURITY FIX: Recipient is now part of signed authorization\n     * \n     * User signs: PaymentAuthorization(owner, spender, value, deadline, recipient, nonce)\n     * This prevents front-running attacks where recipient could be changed\n     * \n     * @param owner User's address (payer)\n     * @param value Amount to transfer (USDC, 6 decimals)\n     * @param deadline Permit expiration timestamp\n     * @param recipient Final recipient (service provider) - NOW VERIFIED IN SIGNATURE\n     * @param nonce Random nonce (prevents replay)\n     * @param permitV Permit signature v\n     * @param permitR Permit signature r\n     * @param permitS Permit signature s\n     * @param authV Authorization signature v\n     * @param authR Authorization signature r\n     * @param authS Authorization signature s\n     * @return success True if payment settled successfully\n     */\n    function settlePaymentWithPermit(\n        address owner,\n        uint256 value,\n        uint256 deadline,\n        address recipient,\n        bytes32 nonce,\n        // Permit signature (for USDC approval)\n        uint8 permitV,\n        bytes32 permitR,\n        bytes32 permitS,\n        // Authorization signature (for payment details including recipient)\n        uint8 authV,\n        bytes32 authR,\n        bytes32 authS\n    ) external nonReentrant whenNotPaused returns (bool success) {\n        // Input validation\n        require(owner != address(0), \"Invalid owner\");\n        require(recipient != address(0), \"Invalid recipient\");\n        require(block.timestamp <= deadline, \"Deadline expired\");\n        require(value > 0, \"Invalid value\");\n        \n        // Check payment hasn't been used (prevents replay)\n        bytes32 paymentHash = keccak256(abi.encodePacked(\n            owner,\n            recipient,\n            value,\n            deadline,\n            nonce\n        ));\n        \n        require(!usedPayments[paymentHash], \"Payment already used\");\n        usedPayments[paymentHash] = true;\n        \n        // SECURITY FIX: Verify authorization signature includes recipient\n        bytes32 authDigest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(\n                    PAYMENT_TYPEHASH,\n                    owner,\n                    address(this), // spender\n                    value,\n                    deadline,\n                    recipient,     // ← RECIPIENT IS NOW PART OF SIGNATURE\n                    nonce\n                ))\n            )\n        );\n        \n        address authSigner = ecrecover(authDigest, authV, authR, authS);\n        require(authSigner == owner, \"Invalid authorization signature\");\n        require(authSigner != address(0), \"Invalid signature\");\n        \n        // Step 1: Execute EIP-2612 permit (sets approval on USDC contract)\n        IERC20Permit(address(usdc)).permit(\n            owner,\n            address(this), // spender\n            value,\n            deadline,\n            permitV,\n            permitR,\n            permitS\n        );\n        \n        // Calculate platform fee\n        uint256 platformFee = (value * platformFeeBps) / 10000;\n        uint256 recipientAmount = value - platformFee;\n        \n        // Step 2: Execute transfers using permit approval\n        // Transfer to recipient\n        require(\n            usdc.transferFrom(owner, recipient, recipientAmount),\n            \"Transfer to recipient failed\"\n        );\n        \n        // Transfer platform fee to this contract\n        if (platformFee > 0) {\n            require(\n                usdc.transferFrom(owner, address(this), platformFee),\n                \"Platform fee transfer failed\"\n            );\n            accumulatedFees += platformFee;\n        }\n        \n        // Update tracking\n        totalPaid[owner] += value;\n        totalReceived[recipient] += recipientAmount;\n        \n        emit PaymentSettled(owner, recipient, value, platformFee, nonce);\n        \n        return true;\n    }\n    \n    /**\n     * @notice Batch settle multiple payments - FIXED VERSION\n     * @dev Uses internal function to avoid reentrancy guard issues\n     */\n    function batchSettlePayments(\n        address[] calldata owners,\n        uint256[] calldata values,\n        uint256[] calldata deadlines,\n        address[] calldata recipients,\n        bytes32[] calldata nonces,\n        uint8[] calldata permitV,\n        bytes32[] calldata permitR,\n        bytes32[] calldata permitS,\n        uint8[] calldata authV,\n        bytes32[] calldata authR,\n        bytes32[] calldata authS\n    ) external whenNotPaused returns (bool success) {\n        require(\n            owners.length == values.length &&\n            owners.length == deadlines.length &&\n            owners.length == recipients.length &&\n            owners.length == nonces.length &&\n            owners.length == permitV.length &&\n            owners.length == authV.length,\n            \"Array length mismatch\"\n        );\n        \n        // SECURITY FIX: Use internal settlement to avoid reentrancy issues\n        for (uint256 i = 0; i < owners.length; i++) {\n            _settlePaymentInternal(\n                owners[i],\n                values[i],\n                deadlines[i],\n                recipients[i],\n                nonces[i],\n                permitV[i], permitR[i], permitS[i],\n                authV[i], authR[i], authS[i]\n            );\n        }\n        \n        return true;\n    }\n    \n    /**\n     * @notice Internal settlement function (no reentrancy guard)\n     * @dev Used by batch function to avoid reentrancy conflicts\n     */\n    function _settlePaymentInternal(\n        address owner,\n        uint256 value,\n        uint256 deadline,\n        address recipient,\n        bytes32 nonce,\n        uint8 permitV, bytes32 permitR, bytes32 permitS,\n        uint8 authV, bytes32 authR, bytes32 authS\n    ) internal {\n        // Input validation\n        require(owner != address(0), \"Invalid owner\");\n        require(recipient != address(0), \"Invalid recipient\");\n        require(block.timestamp <= deadline, \"Deadline expired\");\n        require(value > 0, \"Invalid value\");\n        \n        // Check payment hasn't been used\n        bytes32 paymentHash = keccak256(abi.encodePacked(\n            owner, recipient, value, deadline, nonce\n        ));\n        require(!usedPayments[paymentHash], \"Payment already used\");\n        usedPayments[paymentHash] = true;\n        \n        // Verify authorization signature\n        bytes32 authDigest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(\n                    PAYMENT_TYPEHASH,\n                    owner,\n                    address(this),\n                    value,\n                    deadline,\n                    recipient,\n                    nonce\n                ))\n            )\n        );\n        \n        address authSigner = ecrecover(authDigest, authV, authR, authS);\n        require(authSigner == owner && authSigner != address(0), \"Invalid authorization\");\n        \n        // Execute permit\n        IERC20Permit(address(usdc)).permit(\n            owner, address(this), value, deadline,\n            permitV, permitR, permitS\n        );\n        \n        // Calculate fees and transfer\n        uint256 platformFee = (value * platformFeeBps) / 10000;\n        uint256 recipientAmount = value - platformFee;\n        \n        require(usdc.transferFrom(owner, recipient, recipientAmount), \"Transfer failed\");\n        \n        if (platformFee > 0) {\n            require(usdc.transferFrom(owner, address(this), platformFee), \"Fee transfer failed\");\n            accumulatedFees += platformFee;\n        }\n        \n        totalPaid[owner] += value;\n        totalReceived[recipient] += recipientAmount;\n        \n        emit PaymentSettled(owner, recipient, value, platformFee, nonce);\n    }\n    \n    // =============================================================================\n    // ADMIN FUNCTIONS\n    // =============================================================================\n    \n    /**\n     * @notice Update platform fee\n     * @param newFeeBps New fee in basis points (100 = 1%)\n     */\n    function updatePlatformFee(uint256 newFeeBps) external onlyOwner {\n        require(newFeeBps <= MAX_PLATFORM_FEE_BPS, \"Fee too high\");\n        uint256 oldFee = platformFeeBps;\n        platformFeeBps = newFeeBps;\n        emit PlatformFeeUpdated(oldFee, newFeeBps);\n    }\n    \n    /**\n     * @notice Withdraw accumulated platform fees\n     * @param to Recipient address\n     */\n    function withdrawFees(address to) external onlyOwner {\n        require(to != address(0), \"Invalid recipient\");\n        require(accumulatedFees > 0, \"No fees to withdraw\");\n        \n        uint256 amount = accumulatedFees;\n        accumulatedFees = 0;\n        \n        require(usdc.transfer(to, amount), \"Transfer failed\");\n        \n        emit FeesWithdrawn(to, amount);\n    }\n    \n    /**\n     * @notice Emergency pause (stops all settlements)\n     */\n    function pause() external onlyOwner {\n        _pause();\n        emit EmergencyPause(msg.sender);\n    }\n    \n    /**\n     * @notice Unpause contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n        emit EmergencyUnpause(msg.sender);\n    }\n    \n    // =============================================================================\n    // VIEW FUNCTIONS\n    // =============================================================================\n    \n    /**\n     * @notice Get payment statistics for a user\n     */\n    function getStats(address user) external view returns (\n        uint256 paid,\n        uint256 received,\n        uint256 balance\n    ) {\n        return (\n            totalPaid[user],\n            totalReceived[user],\n            usdc.balanceOf(user)\n        );\n    }\n    \n    /**\n     * @notice Check if payment has been used\n     */\n    function isPaymentUsed(\n        address owner,\n        address recipient,\n        uint256 value,\n        uint256 deadline,\n        bytes32 nonce\n    ) external view returns (bool) {\n        bytes32 paymentHash = keccak256(abi.encodePacked(\n            owner, recipient, value, deadline, nonce\n        ));\n        return usedPayments[paymentHash];\n    }\n    \n    /**\n     * @notice Get payment hash for tracking\n     */\n    function getPaymentHash(\n        address owner,\n        address recipient,\n        uint256 value,\n        uint256 deadline,\n        bytes32 nonce\n    ) external pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\n            owner, recipient, value, deadline, nonce\n        ));\n    }\n}\n\n/**\n * @dev Interface for EIP-2612 permit function\n */\ninterface IERC20Permit {\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n    \n    function nonces(address owner) external view returns (uint256);\n}\n"
    },
    "contracts/ScheduledOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./PancakeTWAPOracle.sol\";\n\n/**\n * @title ScheduledOracle\n * @notice Provides automatic, recurring data feeds for prices, weather, sports, etc.\n * @dev Supports custom update intervals and on-chain cron jobs\n */\ncontract ScheduledOracle is Ownable, ReentrancyGuard {\n    \n    enum FeedType { PRICE, WEATHER, SPORTS, CUSTOM }\n\n    struct DataFeed {\n        FeedType feedType;\n        uint32 updateInterval;      // Seconds between updates\n        uint32 lastUpdate;\n        uint64 currentValue;\n        uint8 confidenceScore;\n        bool active;\n        address dataProvider;\n    }\n\n    struct PriceConfig {\n        address pancakePair;\n        address twapOracle;\n        bool useTWAP;\n    }\n\n    mapping(bytes32 => DataFeed) public feeds;\n    mapping(bytes32 => PriceConfig) public priceConfigs;\n    mapping(bytes32 => uint64[]) public feedHistory; // Last 100 values\n    \n    bytes32[] public activeFeedIds;\n    uint256 public updateFee = 0.001 ether;\n    uint8 public constant MAX_HISTORY = 100;\n\n    event FeedCreated(bytes32 indexed feedId, FeedType feedType, uint32 updateInterval, address dataProvider);\n    event FeedUpdated(bytes32 indexed feedId, uint64 newValue, uint8 confidence, uint32 timestamp);\n    event FeedDeactivated(bytes32 indexed feedId);\n\n    constructor() Ownable(msg.sender) {}\n\n    /**\n     * @notice Create a scheduled price feed\n     * @param _feedId Unique identifier for feed\n     * @param _updateInterval Seconds between updates\n     * @param _pancakePair PancakeSwap pair address\n     * @param _useTWAP Whether to use TWAP oracle\n     */\n    function createPriceFeed(\n        bytes32 _feedId,\n        uint32 _updateInterval,\n        address _pancakePair,\n        bool _useTWAP\n    ) external payable onlyOwner {\n        require(msg.value >= updateFee, \"Insufficient fee\");\n        require(!feeds[_feedId].active, \"Feed exists\");\n        require(_updateInterval >= 60, \"Min 1 minute interval\");\n\n        feeds[_feedId] = DataFeed({\n            feedType: FeedType.PRICE,\n            updateInterval: _updateInterval,\n            lastUpdate: 0,\n            currentValue: 0,\n            confidenceScore: 100,\n            active: true,\n            dataProvider: address(this)\n        });\n\n        priceConfigs[_feedId] = PriceConfig({\n            pancakePair: _pancakePair,\n            twapOracle: address(0),\n            useTWAP: _useTWAP\n        });\n\n        activeFeedIds.push(_feedId);\n        emit FeedCreated(_feedId, FeedType.PRICE, _updateInterval, address(this));\n    }\n\n    /**\n     * @notice Create a custom data feed (weather, sports, etc.)\n     * @param _feedId Unique identifier\n     * @param _feedType Type of data\n     * @param _updateInterval Update frequency\n     * @param _dataProvider Address authorized to update\n     */\n    function createCustomFeed(\n        bytes32 _feedId,\n        FeedType _feedType,\n        uint32 _updateInterval,\n        address _dataProvider\n    ) external payable onlyOwner {\n        require(msg.value >= updateFee, \"Insufficient fee\");\n        require(!feeds[_feedId].active, \"Feed exists\");\n        require(_updateInterval >= 60, \"Min 1 minute interval\");\n        require(_dataProvider != address(0), \"Invalid provider\");\n\n        feeds[_feedId] = DataFeed({\n            feedType: _feedType,\n            updateInterval: _updateInterval,\n            lastUpdate: 0,\n            currentValue: 0,\n            confidenceScore: 0,\n            active: true,\n            dataProvider: _dataProvider\n        });\n\n        activeFeedIds.push(_feedId);\n        emit FeedCreated(_feedId, _feedType, _updateInterval, _dataProvider);\n    }\n\n    /**\n     * @notice Update a data feed value (called by keeper/provider)\n     * @param _feedId Feed to update\n     * @param _value New value\n     * @param _confidence Confidence score (0-100)\n     */\n    function updateFeed(\n        bytes32 _feedId,\n        uint64 _value,\n        uint8 _confidence\n    ) external nonReentrant {\n        DataFeed storage feed = feeds[_feedId];\n        require(feed.active, \"Feed not active\");\n        require(msg.sender == feed.dataProvider || msg.sender == owner(), \"Not authorized\");\n        require(_confidence <= 100, \"Invalid confidence\");\n        require(block.timestamp >= feed.lastUpdate + feed.updateInterval, \"Too early\");\n\n        feed.currentValue = _value;\n        feed.confidenceScore = _confidence;\n        feed.lastUpdate = uint32(block.timestamp);\n\n        // Store in history (circular buffer)\n        uint64[] storage history = feedHistory[_feedId];\n        if (history.length < MAX_HISTORY) {\n            history.push(_value);\n        } else {\n            // Overwrite oldest value\n            history[uint256(feed.lastUpdate) % MAX_HISTORY] = _value;\n        }\n\n        emit FeedUpdated(_feedId, _value, _confidence, uint32(block.timestamp));\n    }\n\n    /**\n     * @notice Auto-update price feed from TWAP oracle\n     * @param _feedId Feed to update\n     */\n    function autoUpdatePriceFeed(bytes32 _feedId) external nonReentrant {\n        DataFeed storage feed = feeds[_feedId];\n        require(feed.active, \"Feed not active\");\n        require(feed.feedType == FeedType.PRICE, \"Not price feed\");\n        require(block.timestamp >= feed.lastUpdate + feed.updateInterval, \"Too early\");\n\n        PriceConfig memory config = priceConfigs[_feedId];\n        require(config.pancakePair != address(0), \"No pair configured\");\n\n        uint64 price;\n        if (config.useTWAP && config.twapOracle != address(0)) {\n            // Get TWAP price\n            PancakeTWAPOracle twap = PancakeTWAPOracle(config.twapOracle);\n            address token = twap.token0(); // Get token0 address\n            price = uint64(twap.consult(token, 1e18)); // 1 token worth in token1\n        } else {\n            // Get spot price (would need PancakeSwap interface)\n            revert(\"Spot price not implemented yet\");\n        }\n\n        feed.currentValue = price;\n        feed.confidenceScore = 95; // TWAP is high confidence\n        feed.lastUpdate = uint32(block.timestamp);\n\n        // Store in history\n        uint64[] storage history = feedHistory[_feedId];\n        if (history.length < MAX_HISTORY) {\n            history.push(price);\n        } else {\n            history[uint256(feed.lastUpdate) % MAX_HISTORY] = price;\n        }\n\n        emit FeedUpdated(_feedId, price, 95, uint32(block.timestamp));\n    }\n\n    /**\n     * @notice Get current feed value\n     */\n    function getCurrentValue(bytes32 _feedId) external view returns (\n        uint64 value,\n        uint8 confidence,\n        uint32 lastUpdate,\n        bool needsUpdate\n    ) {\n        DataFeed memory feed = feeds[_feedId];\n        bool needs = block.timestamp >= feed.lastUpdate + feed.updateInterval;\n        return (feed.currentValue, feed.confidenceScore, feed.lastUpdate, needs);\n    }\n\n    /**\n     * @notice Get feed history\n     */\n    function getFeedHistory(bytes32 _feedId) external view returns (uint64[] memory) {\n        return feedHistory[_feedId];\n    }\n\n    /**\n     * @notice Get all feeds that need updating\n     */\n    function getFeedsNeedingUpdate() external view returns (bytes32[] memory) {\n        uint256 count = 0;\n        for (uint256 i = 0; i < activeFeedIds.length; i++) {\n            DataFeed memory feed = feeds[activeFeedIds[i]];\n            if (feed.active && block.timestamp >= feed.lastUpdate + feed.updateInterval) {\n                count++;\n            }\n        }\n\n        bytes32[] memory result = new bytes32[](count);\n        uint256 index = 0;\n        for (uint256 i = 0; i < activeFeedIds.length; i++) {\n            DataFeed memory feed = feeds[activeFeedIds[i]];\n            if (feed.active && block.timestamp >= feed.lastUpdate + feed.updateInterval) {\n                result[index] = activeFeedIds[i];\n                index++;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @notice Deactivate a feed\n     */\n    function deactivateFeed(bytes32 _feedId) external onlyOwner {\n        require(feeds[_feedId].active, \"Feed not active\");\n        feeds[_feedId].active = false;\n        emit FeedDeactivated(_feedId);\n    }\n\n    /**\n     * @notice Set TWAP oracle for price feed\n     */\n    function setTWAPOracle(bytes32 _feedId, address _twapOracle) external onlyOwner {\n        require(feeds[_feedId].active, \"Feed not active\");\n        require(feeds[_feedId].feedType == FeedType.PRICE, \"Not price feed\");\n        priceConfigs[_feedId].twapOracle = _twapOracle;\n    }\n\n    /**\n     * @notice Update fee for creating feeds\n     */\n    function setUpdateFee(uint256 _newFee) external onlyOwner {\n        updateFee = _newFee;\n    }\n}\n"
    },
    "contracts/SimplePredictionMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./SoraOracle.sol\";\nimport \"./interfaces/IIntegrations.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title SimplePredictionMarket\n * @notice MVP prediction market that uses Sora Oracle for outcome resolution\n * @dev Supports binary (yes/no) prediction markets\n */\ncontract SimplePredictionMarket is Ownable, ReentrancyGuard {\n    \n    enum MarketStatus { OPEN, CLOSED, RESOLVED, CANCELED }\n    enum Outcome { UNRESOLVED, YES, NO }\n\n    struct Market {\n        string question;\n        uint256 questionId;\n        uint256 resolutionTime;\n        uint256 yesPool;\n        uint256 noPool;\n        MarketStatus status;\n        Outcome outcome;\n        uint256 totalFees;\n    }\n\n    struct Position {\n        uint96 yesAmount;    // 12 bytes - max ~79B BNB (plenty)\n        uint96 noAmount;     // 12 bytes\n        uint48 feesPaid;     // 6 bytes - max ~281k BNB fees\n        bool claimed;        // 1 byte\n        // Total: 31 bytes (1 slot)\n    }\n\n    SoraOracle public oracle;\n    uint256 public marketCounter;\n    uint256 public constant FEE_PERCENTAGE = 2; // 2% platform fee\n    uint256 public accumulatedFees;\n    \n    // Optional integration contracts (can be address(0) if not used)\n    address public referralRewards;\n    address public marketFactory;\n    address public liquidityIncentives;\n    \n    mapping(uint256 => Market) public markets;\n    mapping(uint256 => mapping(address => Position)) public positions;\n    mapping(address => bool) public approvedDistributors; // Authorized batch distributors\n\n    event MarketCreated(uint256 indexed marketId, string question, uint256 resolutionTime);\n    event PositionTaken(uint256 indexed marketId, address indexed user, bool isYes, uint256 amount);\n    event MarketResolved(uint256 indexed marketId, Outcome outcome);\n    event MarketCanceled(uint256 indexed marketId);\n    event WinningsClaimed(uint256 indexed marketId, address indexed user, uint256 amount);\n    event FeesWithdrawn(address indexed owner, uint256 amount);\n    event DistributorApproved(address indexed distributor, bool approved);\n\n    constructor(address payable _oracle) Ownable(msg.sender) {\n        require(_oracle != address(0), \"Invalid oracle\");\n        oracle = SoraOracle(_oracle);\n    }\n\n    /**\n     * @notice Set integration contract addresses (owner only)\n     * @dev Addresses can be zero to disable integration\n     */\n    function setIntegrations(\n        address _referralRewards,\n        address _marketFactory,\n        address _liquidityIncentives\n    ) external onlyOwner {\n        referralRewards = _referralRewards;\n        marketFactory = _marketFactory;\n        liquidityIncentives = _liquidityIncentives;\n    }\n\n    /**\n     * @notice Create a new prediction market\n     * @param _question The yes/no question\n     * @param _resolutionTime When the market should resolve\n     */\n    function createMarket(string memory _question, uint256 _resolutionTime) \n        external \n        payable \n        returns (uint256 marketId) \n    {\n        require(_resolutionTime > block.timestamp, \"Invalid resolution time\");\n        require(bytes(_question).length > 0, \"Question empty\");\n\n        // Ask the oracle (forwards the fee)\n        uint256 oracleFee = oracle.oracleFee();\n        require(msg.value >= oracleFee, \"Insufficient oracle fee\");\n        \n        uint256 questionId = oracle.askYesNoQuestion{value: oracleFee}(_question, _resolutionTime);\n        \n        marketId = marketCounter++;\n        markets[marketId] = Market({\n            question: _question,\n            questionId: questionId,\n            resolutionTime: _resolutionTime,\n            yesPool: 0,\n            noPool: 0,\n            status: MarketStatus.OPEN,\n            outcome: Outcome.UNRESOLVED,\n            totalFees: 0\n        });\n\n        emit MarketCreated(marketId, _question, _resolutionTime);\n\n        // Integrate with MarketFactory if set\n        if (marketFactory != address(0)) {\n            // Note: Would need category and tags - for now skip or use defaults\n            // This requires MarketFactory integration - left as TODO for production\n        }\n\n        // Integrate with LiquidityIncentives if set\n        if (liquidityIncentives != address(0)) {\n            try ILiquidityIncentives(liquidityIncentives).registerMarketCreation(marketId, msg.sender) {} \n            catch {}\n        }\n\n        // Return any excess payment\n        if (msg.value > oracleFee) {\n            (bool success, ) = msg.sender.call{value: msg.value - oracleFee}(\"\");\n            require(success, \"Refund failed\");\n        }\n    }\n\n    /**\n     * @notice Take a position on a market\n     * @param _marketId Market ID\n     * @param _isYes True for YES, false for NO\n     */\n    function takePosition(uint256 _marketId, bool _isYes) \n        external \n        payable \n        nonReentrant \n    {\n        Market storage market = markets[_marketId];\n        require(market.status == MarketStatus.OPEN, \"Market not open\");\n        require(block.timestamp < market.resolutionTime, \"Market expired\");\n        require(msg.value > 0, \"Amount must be > 0\");\n\n        uint256 fee = (msg.value * FEE_PERCENTAGE) / 100;\n        uint256 betAmount = msg.value - fee;\n\n        market.totalFees += fee;\n        // Note: fees are NOT added to accumulatedFees yet - only when market resolves\n\n        Position storage position = positions[_marketId][msg.sender];\n        uint256 newFees = uint256(position.feesPaid) + fee;\n        uint256 newYes = uint256(position.yesAmount) + (_isYes ? betAmount : 0);\n        uint256 newNo = uint256(position.noAmount) + (_isYes ? 0 : betAmount);\n        \n        require(newFees <= type(uint48).max, \"Fee overflow\");\n        require(newYes <= type(uint96).max, \"YES amount overflow\");\n        require(newNo <= type(uint96).max, \"NO amount overflow\");\n        \n        position.feesPaid = uint48(newFees);\n        \n        if (_isYes) {\n            market.yesPool += betAmount;\n            position.yesAmount = uint96(newYes);\n        } else {\n            market.noPool += betAmount;\n            position.noAmount = uint96(newNo);\n        }\n\n        emit PositionTaken(_marketId, msg.sender, _isYes, betAmount);\n\n        // Integrate with ReferralRewards if set (5% of fee goes to referrer)\n        if (referralRewards != address(0) && fee > 0) {\n            uint256 referralReward = (fee * 5) / 100; // 5% of fee\n            try IReferralRewards(referralRewards).recordVolume{value: referralReward}(\n                msg.sender, \n                msg.value, \n                fee\n            ) {} catch {}\n        }\n\n        // Integrate with LiquidityIncentives if set\n        if (liquidityIncentives != address(0) && (market.yesPool + market.noPool) > 0) {\n            try ILiquidityIncentives(liquidityIncentives).addLiquidityIncentive(\n                _marketId,\n                betAmount\n            ) {} catch {}\n        }\n    }\n\n    /**\n     * @notice Resolve market using oracle answer\n     * @param _marketId Market ID\n     */\n    function resolveMarket(uint256 _marketId) external nonReentrant {\n        Market storage market = markets[_marketId];\n        require(market.status == MarketStatus.OPEN, \"Market not open\");\n        require(block.timestamp >= market.resolutionTime, \"Too early\");\n\n        // Get oracle answer\n        (, SoraOracle.Answer memory answer) = oracle.getQuestionWithAnswer(market.questionId);\n        require(answer.confidenceScore > 0, \"Not answered yet\");\n\n        market.outcome = answer.boolAnswer ? Outcome.YES : Outcome.NO;\n        market.status = MarketStatus.RESOLVED;\n\n        // Release platform fees now that market is resolved (won't be canceled)\n        accumulatedFees += market.totalFees;\n\n        emit MarketResolved(_marketId, market.outcome);\n    }\n\n    /**\n     * @notice Claim winnings from a resolved market\n     * @param _marketId Market ID\n     */\n    function claimWinnings(uint256 _marketId) external nonReentrant {\n        _claimWinningsFor(_marketId, msg.sender);\n    }\n    \n    /**\n     * @notice Claim winnings on behalf of a user (only approved distributors)\n     * @param _marketId Market ID\n     * @param _user User address to claim for\n     */\n    function claimWinningsFor(uint256 _marketId, address _user) external nonReentrant {\n        require(approvedDistributors[msg.sender], \"Not approved distributor\");\n        _claimWinningsFor(_marketId, _user);\n    }\n    \n    /**\n     * @notice Internal function to claim winnings\n     * @param _marketId Market ID\n     * @param _user User to claim for\n     */\n    function _claimWinningsFor(uint256 _marketId, address _user) internal {\n        Market storage market = markets[_marketId];\n        Position storage position = positions[_marketId][_user];\n        \n        require(market.status == MarketStatus.RESOLVED, \"Not resolved\");\n        require(!position.claimed, \"Already claimed\");\n\n        uint256 winnings = calculateWinnings(_marketId, _user);\n        require(winnings > 0, \"No winnings\");\n\n        position.claimed = true;\n\n        (bool success, ) = payable(_user).call{value: winnings}(\"\");\n        require(success, \"Transfer failed\");\n\n        emit WinningsClaimed(_marketId, _user, winnings);\n    }\n    \n    /**\n     * @notice Approve or revoke a batch distributor\n     * @param _distributor Distributor address\n     * @param _approved True to approve, false to revoke\n     */\n    function setDistributorApproval(address _distributor, bool _approved) external onlyOwner {\n        require(_distributor != address(0), \"Invalid distributor\");\n        approvedDistributors[_distributor] = _approved;\n        emit DistributorApproved(_distributor, _approved);\n    }\n\n    /**\n     * @notice Calculate potential winnings for a user\n     * @param _marketId Market ID\n     * @param _user User address\n     */\n    function calculateWinnings(uint256 _marketId, address _user) \n        public \n        view \n        returns (uint256) \n    {\n        Market storage market = markets[_marketId];\n        Position storage position = positions[_marketId][_user];\n\n        if (market.status != MarketStatus.RESOLVED || position.claimed) {\n            return 0;\n        }\n\n        uint256 totalPool = market.yesPool + market.noPool;\n        if (totalPool == 0) return 0;\n\n        if (market.outcome == Outcome.YES && position.yesAmount > 0) {\n            if (market.yesPool == 0) return 0;\n            return (position.yesAmount * totalPool) / market.yesPool;\n        } else if (market.outcome == Outcome.NO && position.noAmount > 0) {\n            if (market.noPool == 0) return 0;\n            return (position.noAmount * totalPool) / market.noPool;\n        }\n\n        return 0;\n    }\n\n    /**\n     * @notice Get market details\n     */\n    function getMarket(uint256 _marketId) \n        external \n        view \n        returns (Market memory) \n    {\n        return markets[_marketId];\n    }\n\n    /**\n     * @notice Get user position\n     */\n    function getPosition(uint256 _marketId, address _user) \n        external \n        view \n        returns (Position memory) \n    {\n        return positions[_marketId][_user];\n    }\n\n    /**\n     * @notice Cancel a market if oracle hasn't answered\n     * @param _marketId Market ID\n     * @dev Allows users to reclaim bets if oracle fails to answer\n     */\n    function cancelMarket(uint256 _marketId) external nonReentrant {\n        Market storage market = markets[_marketId];\n        require(market.status == MarketStatus.OPEN, \"Market not open\");\n        require(block.timestamp > market.resolutionTime + 7 days, \"Too early to cancel\");\n\n        (, SoraOracle.Answer memory answer) = oracle.getQuestionWithAnswer(market.questionId);\n        require(answer.confidenceScore == 0, \"Already answered\");\n\n        market.status = MarketStatus.CANCELED;\n        emit MarketCanceled(_marketId);\n    }\n\n    /**\n     * @notice Claim refund from canceled market\n     * @param _marketId Market ID\n     * @dev Returns full stake including exact fees paid\n     * Note: Canceled market fees were never added to accumulatedFees, so no deduction needed\n     */\n    function claimRefund(uint256 _marketId) external nonReentrant {\n        Market storage market = markets[_marketId];\n        Position storage position = positions[_marketId][msg.sender];\n        \n        require(market.status == MarketStatus.CANCELED, \"Market not canceled\");\n        require(!position.claimed, \"Already claimed\");\n\n        uint256 netPosition = position.yesAmount + position.noAmount;\n        uint256 feesPaid = position.feesPaid;\n        uint256 fullRefund = netPosition + feesPaid;\n        \n        require(fullRefund > 0, \"No position\");\n\n        position.claimed = true;\n\n        (bool success, ) = msg.sender.call{value: fullRefund}(\"\");\n        require(success, \"Refund failed\");\n    }\n\n    /**\n     * @notice Withdraw accumulated platform fees\n     * @dev Only owner can withdraw\n     */\n    function withdrawFees() external onlyOwner nonReentrant {\n        uint256 amount = accumulatedFees;\n        require(amount > 0, \"No fees to withdraw\");\n\n        accumulatedFees = 0;\n\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Withdrawal failed\");\n\n        emit FeesWithdrawn(msg.sender, amount);\n    }\n}\n"
    },
    "contracts/SlashingMechanism.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./OracleStaking.sol\";\n\n/**\n * @title SlashingMechanism\n * @notice Penalize dishonest oracle providers\n * @dev Integrates with OracleStaking to slash stakes for bad behavior\n */\ncontract SlashingMechanism is Ownable, ReentrancyGuard {\n    \n    enum ViolationType { WRONG_ANSWER, DELAYED_ANSWER, MANIPULATION, COLLUSION }\n    enum DisputeStatus { PENDING, INVESTIGATING, PROVEN, DISMISSED }\n\n    struct Dispute {\n        uint256 id;\n        address accused;\n        address accuser;\n        ViolationType violationType;\n        uint256 questionId;\n        string evidence;\n        uint256 slashAmount;\n        uint32 timestamp;\n        DisputeStatus status;\n        uint8 votes;\n        mapping(address => bool) voted;\n    }\n\n    struct SlashingRecord {\n        address provider;\n        uint256 amount;\n        ViolationType violationType;\n        uint32 timestamp;\n        bool refunded;\n    }\n\n    mapping(uint256 => Dispute) public disputes;\n    mapping(address => SlashingRecord[]) public slashingHistory;\n    mapping(address => uint256) public totalSlashed;\n    \n    uint256 public disputeCounter;\n    OracleStaking public stakingContract;\n    \n    uint256 public minimumSlashAmount = 0.01 ether;\n    uint256 public maximumSlashPercentage = 5000; // 50% of stake\n    uint8 public requiredVotes = 3;\n    uint32 public disputePeriod = 3 days;\n\n    event DisputeRaised(uint256 indexed disputeId, address indexed accused, ViolationType violationType);\n    event DisputeVoted(uint256 indexed disputeId, address indexed voter, bool guilty);\n    event Slashed(address indexed provider, uint256 amount, ViolationType violationType);\n    event DisputeDismissed(uint256 indexed disputeId);\n    event SlashRefunded(address indexed provider, uint256 amount);\n\n    constructor(address _stakingContract) Ownable(msg.sender) {\n        require(_stakingContract != address(0), \"Invalid staking contract\");\n        stakingContract = OracleStaking(payable(_stakingContract));\n    }\n\n    /**\n     * @notice Raise dispute against oracle provider\n     * @param _accused Address of oracle provider\n     * @param _violationType Type of violation\n     * @param _questionId Related question ID\n     * @param _evidence Evidence description\n     */\n    function raiseDispute(\n        address _accused,\n        ViolationType _violationType,\n        uint256 _questionId,\n        string memory _evidence\n    ) external payable nonReentrant returns (uint256 disputeId) {\n        require(msg.value >= 0.01 ether, \"Insufficient dispute fee\");\n        require(_accused != address(0), \"Invalid accused\");\n        require(bytes(_evidence).length > 0, \"No evidence\");\n\n        // Check if accused is staking\n        (uint256 stakedAmount,,,,) = stakingContract.getStaker(_accused);\n        require(stakedAmount > 0, \"Not a staker\");\n\n        disputeId = disputeCounter++;\n\n        Dispute storage dispute = disputes[disputeId];\n        dispute.id = disputeId;\n        dispute.accused = _accused;\n        dispute.accuser = msg.sender;\n        dispute.violationType = _violationType;\n        dispute.questionId = _questionId;\n        dispute.evidence = _evidence;\n        dispute.slashAmount = _calculateSlashAmount(_accused, _violationType);\n        dispute.timestamp = uint32(block.timestamp);\n        dispute.status = DisputeStatus.PENDING;\n        dispute.votes = 0;\n\n        emit DisputeRaised(disputeId, _accused, _violationType);\n        return disputeId;\n    }\n\n    /**\n     * @notice Vote on dispute (for authorized judges/stakers)\n     * @param _disputeId Dispute ID\n     * @param _guilty True if provider is guilty\n     */\n    function voteOnDispute(uint256 _disputeId, bool _guilty) external nonReentrant {\n        Dispute storage dispute = disputes[_disputeId];\n        require(dispute.status == DisputeStatus.PENDING || dispute.status == DisputeStatus.INVESTIGATING, \"Not open\");\n        require(!dispute.voted[msg.sender], \"Already voted\");\n        require(block.timestamp <= dispute.timestamp + disputePeriod, \"Dispute expired\");\n\n        // Check voter has voting power (is staker)\n        (uint256 stakedAmount,,,,) = stakingContract.getStaker(msg.sender);\n        require(stakedAmount >= 1 ether, \"Insufficient stake to vote\");\n\n        dispute.voted[msg.sender] = true;\n        dispute.status = DisputeStatus.INVESTIGATING;\n\n        if (_guilty) {\n            dispute.votes++;\n        }\n\n        emit DisputeVoted(_disputeId, msg.sender, _guilty);\n\n        // Check if enough votes to finalize\n        if (dispute.votes >= requiredVotes) {\n            _executeSlash(_disputeId);\n        }\n    }\n\n    /**\n     * @notice Execute slash if dispute proven\n     */\n    function _executeSlash(uint256 _disputeId) private {\n        Dispute storage dispute = disputes[_disputeId];\n        require(dispute.votes >= requiredVotes, \"Not enough votes\");\n        require(dispute.status == DisputeStatus.INVESTIGATING, \"Not investigating\");\n\n        dispute.status = DisputeStatus.PROVEN;\n\n        // Record slashing\n        slashingHistory[dispute.accused].push(SlashingRecord({\n            provider: dispute.accused,\n            amount: dispute.slashAmount,\n            violationType: dispute.violationType,\n            timestamp: uint32(block.timestamp),\n            refunded: false\n        }));\n\n        totalSlashed[dispute.accused] += dispute.slashAmount;\n\n        // Note: Actual stake slashing would require integration with OracleStaking contract\n        // For now, just emit event\n        emit Slashed(dispute.accused, dispute.slashAmount, dispute.violationType);\n    }\n\n    /**\n     * @notice Dismiss dispute if not enough evidence\n     */\n    function dismissDispute(uint256 _disputeId) external nonReentrant {\n        Dispute storage dispute = disputes[_disputeId];\n        require(\n            msg.sender == owner() || msg.sender == dispute.accuser,\n            \"Not authorized\"\n        );\n        require(\n            dispute.status == DisputeStatus.PENDING || dispute.status == DisputeStatus.INVESTIGATING,\n            \"Cannot dismiss\"\n        );\n        require(block.timestamp > dispute.timestamp + disputePeriod, \"Dispute period active\");\n\n        dispute.status = DisputeStatus.DISMISSED;\n\n        // Refund dispute fee to accuser\n        payable(dispute.accuser).transfer(0.01 ether);\n\n        emit DisputeDismissed(_disputeId);\n    }\n\n    /**\n     * @notice Calculate slash amount based on violation\n     */\n    function _calculateSlashAmount(address _provider, ViolationType _violationType) private view returns (uint256) {\n        (uint256 stakedAmount,,,,) = stakingContract.getStaker(_provider);\n\n        uint256 slashPercentage;\n        if (_violationType == ViolationType.MANIPULATION || _violationType == ViolationType.COLLUSION) {\n            slashPercentage = maximumSlashPercentage; // 50%\n        } else if (_violationType == ViolationType.WRONG_ANSWER) {\n            slashPercentage = 2000; // 20%\n        } else { // DELAYED_ANSWER\n            slashPercentage = 500; // 5%\n        }\n\n        uint256 slashAmount = (stakedAmount * slashPercentage) / 10000;\n        \n        // Ensure minimum and doesn't exceed maximum\n        if (slashAmount < minimumSlashAmount) {\n            slashAmount = minimumSlashAmount;\n        }\n        if (slashAmount > (stakedAmount * maximumSlashPercentage) / 10000) {\n            slashAmount = (stakedAmount * maximumSlashPercentage) / 10000;\n        }\n\n        return slashAmount;\n    }\n\n    /**\n     * @notice Get dispute details\n     */\n    function getDispute(uint256 _disputeId) external view returns (\n        address accused,\n        address accuser,\n        ViolationType violationType,\n        uint256 slashAmount,\n        uint32 timestamp,\n        DisputeStatus status,\n        uint8 votes\n    ) {\n        Dispute storage dispute = disputes[_disputeId];\n        return (\n            dispute.accused,\n            dispute.accuser,\n            dispute.violationType,\n            dispute.slashAmount,\n            dispute.timestamp,\n            dispute.status,\n            dispute.votes\n        );\n    }\n\n    /**\n     * @notice Get slashing history for provider\n     */\n    function getSlashingHistory(address _provider) external view returns (SlashingRecord[] memory) {\n        return slashingHistory[_provider];\n    }\n\n    /**\n     * @notice Get pending disputes\n     */\n    function getPendingDisputes() external view returns (uint256[] memory) {\n        uint256 count = 0;\n        for (uint256 i = 0; i < disputeCounter; i++) {\n            if (disputes[i].status == DisputeStatus.PENDING || disputes[i].status == DisputeStatus.INVESTIGATING) {\n                count++;\n            }\n        }\n\n        uint256[] memory pending = new uint256[](count);\n        uint256 index = 0;\n        for (uint256 i = 0; i < disputeCounter; i++) {\n            if (disputes[i].status == DisputeStatus.PENDING || disputes[i].status == DisputeStatus.INVESTIGATING) {\n                pending[index] = i;\n                index++;\n            }\n        }\n\n        return pending;\n    }\n\n    /**\n     * @notice Update parameters\n     */\n    function setRequiredVotes(uint8 _required) external onlyOwner {\n        require(_required >= 2 && _required <= 10, \"Invalid vote count\");\n        requiredVotes = _required;\n    }\n\n    function setMaximumSlashPercentage(uint256 _percentage) external onlyOwner {\n        require(_percentage <= 10000, \"Cannot exceed 100%\");\n        maximumSlashPercentage = _percentage;\n    }\n\n    function setDisputePeriod(uint32 _period) external onlyOwner {\n        require(_period >= 1 days && _period <= 7 days, \"Invalid period\");\n        disputePeriod = _period;\n    }\n\n    /**\n     * @notice Withdraw accumulated fees\n     */\n    function withdrawFees() external onlyOwner {\n        uint256 balance = address(this).balance;\n        require(balance > 0, \"No fees\");\n        payable(owner()).transfer(balance);\n    }\n\n    receive() external payable {\n        // Accept dispute fees\n    }\n}\n"
    },
    "contracts/SoraOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"./PancakeTWAPOracle.sol\";\n\n/**\n * @title SoraOracle\n * @notice Decentralized oracle for prediction markets with TWAP integration\n * @dev Supports price feeds, yes/no questions, and numeric predictions\n */\ncontract SoraOracle is Ownable, ReentrancyGuard, Pausable {\n    \n    enum QuestionType { GENERAL, PRICE, YESNO, NUMERIC }\n    enum AnswerStatus { PENDING, ANSWERED, DISPUTED, FINALIZED }\n\n    struct Question {\n        address requester;          // 20 bytes\n        uint88 bounty;              // 11 bytes (max ~309k BNB - plenty)\n        uint32 timestamp;           // 4 bytes (good until 2106)\n        uint32 deadline;            // 4 bytes\n        QuestionType questionType;  // 1 byte\n        AnswerStatus status;        // 1 byte\n        bool refunded;              // 1 byte\n        // Total: 32 bytes (1 slot) + hash in separate mapping\n    }\n\n    struct Answer {\n        address provider;           // 20 bytes\n        uint8 confidenceScore;      // 1 byte (0-100)\n        bool boolAnswer;            // 1 byte\n        // 10 bytes free in slot\n        uint64 numericAnswer;       // 8 bytes (for most price data)\n        uint32 timestamp;           // 4 bytes\n        // Slot 2: 12 bytes used, 20 free\n        // Text/dataSource in events only\n    }\n\n    mapping(uint256 => Question) public questions;\n    mapping(uint256 => Answer) public answers;\n    mapping(uint256 => bytes32) public questionHashes; // Hash of question text\n    mapping(address => PancakeTWAPOracle) public twapOracles;\n    \n    uint256 public questionCounter;\n    uint256 public oracleFee = 0.01 ether;\n    address public oracleProvider;\n    uint256 public providerBalance;\n    uint256 public constant REFUND_PERIOD = 7 days;\n    uint256 public constant TWAP_DEPLOYMENT_FEE = 0.02 ether; // Covers ~2M gas deployment cost\n\n    event QuestionAsked(\n        uint256 indexed questionId,\n        address indexed requester,\n        QuestionType questionType,\n        string question,\n        uint256 bounty,\n        uint256 deadline\n    );\n\n    event AnswerProvided(\n        uint256 indexed questionId,\n        string textAnswer,\n        uint256 numericAnswer,\n        uint8 confidenceScore,\n        string dataSource\n    );\n\n    event TWAPOracleAdded(address indexed pairAddress, address indexed oracleAddress);\n    event OracleFeeUpdated(uint256 oldFee, uint256 newFee);\n\n    modifier onlyOracleProvider() {\n        require(msg.sender == oracleProvider, \"Only oracle provider\");\n        _;\n    }\n\n    constructor(address _oracleProvider) Ownable(msg.sender) {\n        require(_oracleProvider != address(0), \"Invalid provider\");\n        oracleProvider = _oracleProvider;\n    }\n\n    /**\n     * @notice Ask a general question to the oracle\n     * @param _question The question to ask\n     * @param _deadline Timestamp by which answer is needed\n     */\n    function askOracle(\n        string memory _question,\n        uint256 _deadline\n    ) external payable whenNotPaused nonReentrant returns (uint256 questionId) {\n        return _askQuestion(QuestionType.GENERAL, _question, _deadline);\n    }\n\n    /**\n     * @notice Ask a price-related question (can use TWAP)\n     * @param _question The price question\n     * @param _deadline Timestamp by which answer is needed\n     */\n    function askPriceQuestion(\n        string memory _question,\n        uint256 _deadline\n    ) external payable whenNotPaused nonReentrant returns (uint256 questionId) {\n        return _askQuestion(QuestionType.PRICE, _question, _deadline);\n    }\n\n    /**\n     * @notice Ask a yes/no question\n     * @param _question The yes/no question\n     * @param _deadline Timestamp by which answer is needed\n     */\n    function askYesNoQuestion(\n        string memory _question,\n        uint256 _deadline\n    ) external payable whenNotPaused nonReentrant returns (uint256 questionId) {\n        return _askQuestion(QuestionType.YESNO, _question, _deadline);\n    }\n\n    function _askQuestion(\n        QuestionType _type,\n        string memory _question,\n        uint256 _deadline\n    ) private returns (uint256 questionId) {\n        require(msg.value >= oracleFee, \"Insufficient fee\");\n        require(bytes(_question).length > 0, \"Question empty\");\n        require(bytes(_question).length <= 500, \"Question too long\");\n        require(_deadline > block.timestamp, \"Invalid deadline\");\n        require(_deadline <= type(uint32).max, \"Deadline overflow\");\n        require(msg.value <= type(uint88).max, \"Bounty overflow\");\n\n        questionId = questionCounter++;\n        \n        questions[questionId] = Question({\n            requester: msg.sender,\n            questionType: _type,\n            bounty: uint88(msg.value),\n            timestamp: uint32(block.timestamp),\n            deadline: uint32(_deadline),\n            status: AnswerStatus.PENDING,\n            refunded: false\n        });\n\n        // Store question hash, emit full text in event\n        questionHashes[questionId] = keccak256(bytes(_question));\n        emit QuestionAsked(questionId, msg.sender, _type, _question, msg.value, _deadline);\n    }\n\n    /**\n     * @notice Provide an answer to a question\n     * @param _questionId The question ID\n     * @param _textAnswer Text answer (for general questions) - emitted in event only\n     * @param _numericAnswer Numeric answer (for price/numeric questions) - max uint64\n     * @param _boolAnswer Boolean answer (for yes/no questions)\n     * @param _confidenceScore Confidence score 0-100\n     * @param _dataSource Data source used (e.g., \"TWAP\", \"Manual\", \"API\") - emitted in event only\n     */\n    function provideAnswer(\n        uint256 _questionId,\n        string memory _textAnswer,\n        uint256 _numericAnswer,\n        bool _boolAnswer,\n        uint8 _confidenceScore,\n        string memory _dataSource\n    ) external onlyOracleProvider whenNotPaused nonReentrant {\n        Question storage q = questions[_questionId];\n        require(q.status == AnswerStatus.PENDING, \"Already answered\");\n        require(!q.refunded, \"Already refunded\");\n        require(_confidenceScore <= 100, \"Invalid confidence\");\n        require(bytes(_dataSource).length > 0, \"Data source required\");\n        require(_numericAnswer <= type(uint64).max, \"Numeric answer overflow\");\n\n        answers[_questionId] = Answer({\n            provider: msg.sender,\n            confidenceScore: _confidenceScore,\n            boolAnswer: _boolAnswer,\n            numericAnswer: uint64(_numericAnswer),\n            timestamp: uint32(block.timestamp)\n        });\n\n        q.status = AnswerStatus.ANSWERED;\n        providerBalance += q.bounty;\n\n        emit AnswerProvided(_questionId, _textAnswer, _numericAnswer, _confidenceScore, _dataSource);\n    }\n\n    /**\n     * @notice Get price from TWAP oracle for a token pair\n     * @dev Oracle must exist (use addTWAPOracle first)\n     * @param _pairAddress PancakeSwap pair address\n     * @param _token Token to price\n     * @param _amount Amount of tokens\n     */\n    function getTWAPPrice(\n        address _pairAddress,\n        address _token,\n        uint256 _amount\n    ) external view returns (uint256) {\n        require(address(twapOracles[_pairAddress]) != address(0), \"Oracle not found - call addTWAPOracle first\");\n        return twapOracles[_pairAddress].consult(_token, _amount);\n    }\n\n    /**\n     * @notice Add a TWAP oracle for a trading pair (permissionless)\n     * @dev Anyone can add any PancakeSwap pair - caller pays deployment cost\n     * @param _pairAddress PancakeSwap pair address\n     */\n    function addTWAPOracle(address _pairAddress) external payable {\n        require(address(twapOracles[_pairAddress]) == address(0), \"Already exists\");\n        require(msg.value >= TWAP_DEPLOYMENT_FEE, \"Insufficient deployment fee\");\n        _createTWAPOracle(_pairAddress);\n        \n        // Refund excess\n        if (msg.value > TWAP_DEPLOYMENT_FEE) {\n            (bool success, ) = payable(msg.sender).call{value: msg.value - TWAP_DEPLOYMENT_FEE}(\"\");\n            require(success, \"Refund failed\");\n        }\n    }\n\n    /**\n     * @notice Internal function to create TWAP oracle\n     * @param _pairAddress PancakeSwap pair address\n     */\n    function _createTWAPOracle(address _pairAddress) internal {\n        require(_pairAddress != address(0), \"Invalid pair\");\n        \n        PancakeTWAPOracle newOracle = new PancakeTWAPOracle(_pairAddress);\n        twapOracles[_pairAddress] = newOracle;\n        \n        emit TWAPOracleAdded(_pairAddress, address(newOracle));\n    }\n\n    /**\n     * @notice Refund unanswered question after refund period\n     */\n    function refundUnansweredQuestion(uint256 _questionId) external nonReentrant {\n        Question storage q = questions[_questionId];\n        require(msg.sender == q.requester, \"Only requester\");\n        require(q.status == AnswerStatus.PENDING, \"Already answered\");\n        require(!q.refunded, \"Already refunded\");\n        require(block.timestamp >= q.timestamp + REFUND_PERIOD, \"Too early\");\n\n        q.refunded = true;\n        uint256 refundAmount = q.bounty;\n        q.bounty = 0;\n\n        (bool success, ) = payable(msg.sender).call{value: refundAmount}(\"\");\n        require(success, \"Refund failed\");\n    }\n\n    /**\n     * @notice Withdraw oracle provider earnings\n     */\n    function withdraw() external onlyOracleProvider nonReentrant {\n        uint256 amount = providerBalance;\n        require(amount > 0, \"No balance\");\n\n        providerBalance = 0;\n        \n        (bool success, ) = payable(oracleProvider).call{value: amount}(\"\");\n        require(success, \"Withdrawal failed\");\n    }\n\n    /**\n     * @notice Get full question and answer data\n     */\n    function getQuestionWithAnswer(uint256 _questionId) \n        external \n        view \n        returns (\n            Question memory question,\n            Answer memory answer\n        ) \n    {\n        return (questions[_questionId], answers[_questionId]);\n    }\n\n    /**\n     * @notice Update oracle fee\n     */\n    function setOracleFee(uint256 _newFee) external onlyOwner {\n        uint256 oldFee = oracleFee;\n        oracleFee = _newFee;\n        emit OracleFeeUpdated(oldFee, _newFee);\n    }\n\n    /**\n     * @notice Update oracle provider address\n     */\n    function setOracleProvider(address _newProvider) external onlyOwner {\n        require(_newProvider != address(0), \"Invalid provider\");\n        oracleProvider = _newProvider;\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    receive() external payable {\n        revert(\"Direct transfers not allowed\");\n    }\n}\n"
    },
    "contracts/TimeSeriesMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./SoraOracle.sol\";\n\n/**\n * @title TimeSeriesMarket\n * @notice Prediction market over multiple time periods\n * @dev Example: \"Will BTC increase each month for Q1 2025?\" (3 periods)\n */\ncontract TimeSeriesMarket is Ownable, ReentrancyGuard {\n    \n    struct TimePeriod {\n        uint32 deadline;\n        uint256 questionId;         // Oracle question ID\n        uint64 result;              // Actual value at deadline\n        bool resolved;\n    }\n\n    struct Market {\n        string question;\n        TimePeriod[] periods;\n        uint256 successPool;        // Bet on ALL periods succeeding\n        uint256 failurePool;        // Bet on ANY period failing\n        uint256 totalFees;\n        uint32 createdAt;\n        bool allResolved;\n        bool allSuccess;            // True if all periods succeeded\n    }\n\n    struct Position {\n        uint256 successAmount;\n        uint256 failureAmount;\n        bool claimed;\n    }\n\n    mapping(uint256 => Market) public markets;\n    mapping(uint256 => mapping(address => Position)) public positions;\n    \n    uint256 public marketCounter;\n    uint256 public feePercentage = 200; // 2%\n    SoraOracle public oracle;\n\n    event MarketCreated(uint256 indexed marketId, string question, uint8 periodCount);\n    event PositionTaken(uint256 indexed marketId, address indexed user, bool predictSuccess, uint256 amount);\n    event PeriodResolved(uint256 indexed marketId, uint8 periodIndex, uint64 result);\n    event MarketResolved(uint256 indexed marketId, bool allSuccess);\n    event WinningsClaimed(uint256 indexed marketId, address indexed user, uint256 payout);\n\n    constructor(address payable _oracleAddress) Ownable(msg.sender) {\n        require(_oracleAddress != address(0), \"Invalid oracle\");\n        oracle = SoraOracle(_oracleAddress);\n    }\n\n    /**\n     * @notice Create time series market\n     * @param _question Base question\n     * @param _deadlines Array of period deadlines\n     */\n    function createMarket(\n        string memory _question,\n        uint32[] memory _deadlines\n    ) external payable returns (uint256 marketId) {\n        require(bytes(_question).length > 0, \"Empty question\");\n        require(_deadlines.length >= 2 && _deadlines.length <= 12, \"2-12 periods only\");\n        \n        // Verify deadlines are in ascending order\n        for (uint256 i = 1; i < _deadlines.length; i++) {\n            require(_deadlines[i] > _deadlines[i-1], \"Deadlines not ascending\");\n        }\n\n        marketId = marketCounter++;\n\n        // Create market with empty periods array\n        Market storage market = markets[marketId];\n        market.question = _question;\n        market.successPool = 0;\n        market.failurePool = 0;\n        market.totalFees = 0;\n        market.createdAt = uint32(block.timestamp);\n        market.allResolved = false;\n        market.allSuccess = false;\n\n        // Ask oracle for each period\n        uint256 oracleFeePerQuestion = 0.01 ether; // Standard oracle fee\n        require(msg.value >= oracleFeePerQuestion * _deadlines.length, \"Insufficient oracle fees\");\n\n        for (uint256 i = 0; i < _deadlines.length; i++) {\n            string memory periodQuestion = string(abi.encodePacked(\n                _question,\n                \" - Period \",\n                uint2str(i + 1)\n            ));\n\n            uint256 questionId = oracle.askOracle{value: oracleFeePerQuestion}(\n                periodQuestion,\n                _deadlines[i]\n            );\n\n            market.periods.push(TimePeriod({\n                deadline: _deadlines[i],\n                questionId: questionId,\n                result: 0,\n                resolved: false\n            }));\n        }\n\n        emit MarketCreated(marketId, _question, uint8(_deadlines.length));\n        return marketId;\n    }\n\n    /**\n     * @notice Take position\n     * @param _marketId Market ID\n     * @param _predictAllSuccess True to bet all periods succeed\n     */\n    function takePosition(uint256 _marketId, bool _predictAllSuccess) external payable nonReentrant {\n        Market storage market = markets[_marketId];\n        require(!market.allResolved, \"Market resolved\");\n        require(msg.value > 0, \"Must send BNB\");\n\n        uint256 fee = (msg.value * feePercentage) / 10000;\n        uint256 betAmount = msg.value - fee;\n\n        market.totalFees += fee;\n\n        if (_predictAllSuccess) {\n            market.successPool += betAmount;\n            positions[_marketId][msg.sender].successAmount += betAmount;\n        } else {\n            market.failurePool += betAmount;\n            positions[_marketId][msg.sender].failureAmount += betAmount;\n        }\n\n        emit PositionTaken(_marketId, msg.sender, _predictAllSuccess, betAmount);\n    }\n\n    /**\n     * @notice Resolve a specific period\n     * @param _marketId Market ID\n     * @param _periodIndex Period to resolve\n     */\n    function resolvePeriod(uint256 _marketId, uint8 _periodIndex) external nonReentrant {\n        Market storage market = markets[_marketId];\n        require(_periodIndex < market.periods.length, \"Invalid period\");\n        \n        TimePeriod storage period = market.periods[_periodIndex];\n        require(!period.resolved, \"Period already resolved\");\n        require(block.timestamp >= period.deadline, \"Not yet deadline\");\n\n        // Get answer from oracle\n        (, , , uint64 numericAnswer,) = oracle.answers(period.questionId);\n        require(numericAnswer > 0, \"Oracle not answered\");\n\n        period.result = numericAnswer;\n        period.resolved = true;\n\n        emit PeriodResolved(_marketId, _periodIndex, numericAnswer);\n\n        // Check if all periods resolved\n        _checkAllResolved(_marketId);\n    }\n\n    /**\n     * @notice Check if all periods resolved and finalize market\n     */\n    function _checkAllResolved(uint256 _marketId) private {\n        Market storage market = markets[_marketId];\n        \n        bool allResolved = true;\n        bool allSuccess = true;\n\n        for (uint256 i = 0; i < market.periods.length; i++) {\n            if (!market.periods[i].resolved) {\n                allResolved = false;\n                break;\n            }\n\n            // Check success criteria (can be customized per market type)\n            // For now, assume success = result > 0\n            if (market.periods[i].result == 0) {\n                allSuccess = false;\n            }\n        }\n\n        if (allResolved) {\n            market.allResolved = true;\n            market.allSuccess = allSuccess;\n            emit MarketResolved(_marketId, allSuccess);\n        }\n    }\n\n    /**\n     * @notice Claim winnings\n     */\n    function claimWinnings(uint256 _marketId) external nonReentrant {\n        Market storage market = markets[_marketId];\n        require(market.allResolved, \"Not all periods resolved\");\n\n        Position storage position = positions[_marketId][msg.sender];\n        require(!position.claimed, \"Already claimed\");\n        require(position.successAmount > 0 || position.failureAmount > 0, \"No position\");\n\n        uint256 winningPool = market.allSuccess ? market.successPool : market.failurePool;\n        uint256 losingPool = market.allSuccess ? market.failurePool : market.successPool;\n        uint256 userWinningAmount = market.allSuccess ? position.successAmount : position.failureAmount;\n\n        require(userWinningAmount > 0, \"Not a winner\");\n        require(winningPool > 0, \"No winning pool\");\n\n        // Parimutuel payout\n        uint256 payout = userWinningAmount + ((userWinningAmount * losingPool) / winningPool);\n\n        position.claimed = true;\n        payable(msg.sender).transfer(payout);\n\n        emit WinningsClaimed(_marketId, msg.sender, payout);\n    }\n\n    /**\n     * @notice Get market details\n     */\n    function getMarket(uint256 _marketId) external view returns (\n        string memory question,\n        uint8 periodCount,\n        uint256 successPool,\n        uint256 failurePool,\n        bool allResolved,\n        bool allSuccess\n    ) {\n        Market storage market = markets[_marketId];\n        return (\n            market.question,\n            uint8(market.periods.length),\n            market.successPool,\n            market.failurePool,\n            market.allResolved,\n            market.allSuccess\n        );\n    }\n\n    /**\n     * @notice Get period details\n     */\n    function getPeriod(uint256 _marketId, uint8 _periodIndex) external view returns (\n        uint32 deadline,\n        uint64 result,\n        bool resolved\n    ) {\n        Market storage market = markets[_marketId];\n        require(_periodIndex < market.periods.length, \"Invalid period\");\n        \n        TimePeriod storage period = market.periods[_periodIndex];\n        return (period.deadline, period.result, period.resolved);\n    }\n\n    /**\n     * @notice Get user position\n     */\n    function getPosition(uint256 _marketId, address _user) external view returns (\n        uint256 successAmount,\n        uint256 failureAmount,\n        bool claimed\n    ) {\n        Position memory position = positions[_marketId][_user];\n        return (position.successAmount, position.failureAmount, position.claimed);\n    }\n\n    /**\n     * @notice Convert uint to string (helper)\n     */\n    function uint2str(uint256 _i) internal pure returns (string memory) {\n        if (_i == 0) return \"0\";\n        \n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        \n        bytes memory bstr = new bytes(len);\n        uint256 k = len;\n        while (_i != 0) {\n            k = k - 1;\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        \n        return string(bstr);\n    }\n}\n"
    },
    "contracts/TokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title MarketToken\n * @notice Minimal ERC-20 token for prediction markets\n * @dev Deployed by TokenFactory for each new market\n */\ncontract MarketToken is ERC20 {\n    address public immutable oracleFeed;\n    uint256 public immutable createdAt;\n    string public marketName;\n\n    constructor(\n        string memory _marketName,\n        string memory _symbol,\n        uint256 _initialSupply,\n        address _oracleFeed,\n        address _recipient\n    ) ERC20(_marketName, _symbol) {\n        require(_initialSupply > 0, \"Initial supply must be > 0\");\n        require(_oracleFeed != address(0), \"Invalid oracle feed\");\n        require(_recipient != address(0), \"Invalid recipient\");\n\n        marketName = _marketName;\n        oracleFeed = _oracleFeed;\n        createdAt = block.timestamp;\n\n        _mint(_recipient, _initialSupply);\n    }\n}\n\n/**\n * @title TokenFactory\n * @notice Factory contract to deploy ERC-20 tokens for prediction markets\n * @dev Gas-optimized for BNB Chain deployment\n */\ncontract TokenFactory is Ownable {\n    struct TokenMetadata {\n        string name;\n        string symbol;\n        uint256 totalSupply;\n        address oracleFeed;\n        uint256 createdAt;\n    }\n\n    // Deployed tokens registry\n    address[] public deployedTokens;\n    mapping(address => TokenMetadata) public tokenMetadata;\n    mapping(string => address) public marketNameToToken;\n\n    // Events\n    event TokenCreated(\n        address indexed tokenAddress,\n        string marketName,\n        string symbol,\n        uint256 initialSupply,\n        address oracleFeed\n    );\n\n    constructor() Ownable(msg.sender) {}\n\n    /**\n     * @notice Deploy a new market token\n     * @param marketName Human-readable market name (e.g., \"BTC-100K\")\n     * @param initialSupply Token supply in wei (e.g., 1e27 for 1B tokens)\n     * @param oracleFeed Address of validated oracle feed\n     * @return tokenAddress Address of deployed token\n     */\n    function createToken(\n        string memory marketName,\n        uint256 initialSupply,\n        address oracleFeed\n    ) external returns (address tokenAddress) {\n        require(bytes(marketName).length > 0, \"Market name required\");\n        require(initialSupply > 0 && initialSupply <= 1e36, \"Invalid supply\");\n        require(oracleFeed != address(0), \"Invalid oracle feed\");\n        require(\n            marketNameToToken[marketName] == address(0),\n            \"Market already exists\"\n        );\n\n        // Generate symbol from market name\n        string memory symbol = _generateSymbol(marketName);\n\n        // Deploy new token\n        MarketToken token = new MarketToken(\n            marketName,\n            symbol,\n            initialSupply,\n            oracleFeed,\n            msg.sender\n        );\n\n        tokenAddress = address(token);\n\n        // Register token\n        deployedTokens.push(tokenAddress);\n        tokenMetadata[tokenAddress] = TokenMetadata({\n            name: marketName,\n            symbol: symbol,\n            totalSupply: initialSupply,\n            oracleFeed: oracleFeed,\n            createdAt: block.timestamp\n        });\n        marketNameToToken[marketName] = tokenAddress;\n\n        emit TokenCreated(\n            tokenAddress,\n            marketName,\n            symbol,\n            initialSupply,\n            oracleFeed\n        );\n\n        return tokenAddress;\n    }\n\n    /**\n     * @notice Get all deployed token addresses\n     */\n    function getDeployedTokens() external view returns (address[] memory) {\n        return deployedTokens;\n    }\n\n    /**\n     * @notice Get token metadata\n     */\n    function getTokenMetadata(\n        address token\n    ) external view returns (TokenMetadata memory) {\n        return tokenMetadata[token];\n    }\n\n    /**\n     * @notice Check if market exists\n     */\n    function marketExists(string memory marketName) external view returns (bool) {\n        return marketNameToToken[marketName] != address(0);\n    }\n\n    /**\n     * @notice Get token address for market\n     */\n    function getTokenForMarket(\n        string memory marketName\n    ) external view returns (address) {\n        return marketNameToToken[marketName];\n    }\n\n    /**\n     * @notice Generate symbol from market name\n     * @dev Removes special characters and converts to uppercase\n     */\n    function _generateSymbol(\n        string memory marketName\n    ) internal pure returns (string memory) {\n        bytes memory nameBytes = bytes(marketName);\n        bytes memory symbolBytes = new bytes(nameBytes.length);\n        uint256 symbolLength = 0;\n\n        for (uint256 i = 0; i < nameBytes.length; i++) {\n            bytes1 char = nameBytes[i];\n            // Keep A-Z, a-z, 0-9\n            if (\n                (char >= 0x30 && char <= 0x39) || // 0-9\n                (char >= 0x41 && char <= 0x5A) || // A-Z\n                (char >= 0x61 && char <= 0x7A) // a-z\n            ) {\n                // Convert to uppercase\n                if (char >= 0x61 && char <= 0x7A) {\n                    symbolBytes[symbolLength] = bytes1(uint8(char) - 32);\n                } else {\n                    symbolBytes[symbolLength] = char;\n                }\n                symbolLength++;\n            }\n        }\n\n        // Create final symbol with correct length\n        bytes memory finalSymbol = new bytes(symbolLength);\n        for (uint256 i = 0; i < symbolLength; i++) {\n            finalSymbol[i] = symbolBytes[i];\n        }\n\n        return string(finalSymbol);\n    }\n}\n"
    },
    "contracts/TrustlessAPIRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title TrustlessAPIRegistry\n * @notice Converts AI-discovered APIs into trustless oracle providers through crypto-economic incentives\n * \n * THE BREAKTHROUGH:\n * - AI discovers APIs (automated, scalable)\n * - APIs must STAKE to be registered (skin in the game)\n * - APIs provide SIGNED data (cryptographically verifiable)\n * - Wrong data = SLASHED (economic penalty)\n * - Right data = REPUTATION (trust builds over time)\n * \n * This makes AI discovery trustless!\n */\ncontract TrustlessAPIRegistry is Ownable, ReentrancyGuard {\n    \n    struct APIProvider {\n        string name;\n        string endpoint;\n        address operator;          // Who operates this API\n        uint256 stakeAmount;       // How much they've staked\n        uint256 reputationScore;   // Builds over time\n        uint256 successfulResponses;\n        uint256 failedResponses;\n        uint256 totalSlashed;\n        bool isActive;\n        uint256 registeredAt;\n        string[] categories;\n    }\n    \n    struct DataAttestation {\n        bytes32 questionHash;      // Hash of the question\n        bool outcome;              // YES/NO answer\n        uint256 confidence;        // 0-100 (percentage)\n        bytes signature;           // Signed by API provider\n        uint256 timestamp;\n        string dataProof;          // IPFS hash or merkle root\n    }\n    \n    struct ConsensusRequest {\n        bytes32 questionHash;\n        string question;\n        address[] selectedProviders;\n        mapping(address => DataAttestation) attestations;\n        uint256 attestationCount;\n        bool resolved;\n        bool finalOutcome;\n        uint256 finalConfidence;\n        uint256 createdAt;\n    }\n    \n    // Storage\n    mapping(string => APIProvider) public providers;  // name => provider\n    mapping(address => string[]) public operatorAPIs; // operator => API names\n    mapping(bytes32 => ConsensusRequest) public requests;\n    mapping(string => bool) public categoryExists;\n    \n    string[] public allProviderNames;\n    string[] public allCategories;\n    \n    // Constants\n    uint256 public constant MIN_STAKE = 1000 * 10**6;  // 1000 USDC minimum\n    uint256 public constant SLASH_PERCENTAGE = 20;     // 20% slash for wrong data\n    uint256 public constant MIN_CONSENSUS = 3;         // Need 3+ sources\n    uint256 public constant CONSENSUS_THRESHOLD = 66;  // 66% agreement\n    \n    // Events\n    event APIRegistered(string indexed name, address indexed operator, uint256 stakeAmount, string[] categories);\n    event APIStakeIncreased(string indexed name, uint256 newStake);\n    event DataAttested(bytes32 indexed questionHash, string apiName, bool outcome, uint256 confidence);\n    event ConsensusReached(bytes32 indexed questionHash, bool outcome, uint256 confidence, uint256 providersUsed);\n    event APISlashed(string indexed name, uint256 slashAmount, bytes32 questionHash);\n    event ReputationIncreased(string indexed name, uint256 newReputation);\n    event CategoryAdded(string category);\n    \n    constructor() Ownable(msg.sender) {}\n    \n    /**\n     * @notice Register a new API provider (discovered by AI or manually)\n     * @dev Provider must stake USDC to be registered\n     */\n    function registerAPI(\n        string memory name,\n        string memory endpoint,\n        string[] memory categories,\n        bytes memory operatorSignature\n    ) external payable nonReentrant {\n        require(bytes(providers[name].name).length == 0, \"API already registered\");\n        require(msg.value >= MIN_STAKE, \"Insufficient stake\");\n        require(bytes(name).length > 0, \"Name required\");\n        require(bytes(endpoint).length > 0, \"Endpoint required\");\n        require(categories.length > 0, \"Categories required\");\n        \n        // Verify operator signature (prevents unauthorized registration)\n        bytes32 messageHash = keccak256(abi.encodePacked(name, endpoint, msg.sender));\n        bytes32 ethSignedHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash));\n        address recovered = recoverSigner(ethSignedHash, operatorSignature);\n        require(recovered == msg.sender, \"Invalid operator signature\");\n        \n        // Register provider\n        providers[name] = APIProvider({\n            name: name,\n            endpoint: endpoint,\n            operator: msg.sender,\n            stakeAmount: msg.value,\n            reputationScore: 0,\n            successfulResponses: 0,\n            failedResponses: 0,\n            totalSlashed: 0,\n            isActive: true,\n            registeredAt: block.timestamp,\n            categories: categories\n        });\n        \n        operatorAPIs[msg.sender].push(name);\n        allProviderNames.push(name);\n        \n        // Track categories\n        for (uint i = 0; i < categories.length; i++) {\n            if (!categoryExists[categories[i]]) {\n                categoryExists[categories[i]] = true;\n                allCategories.push(categories[i]);\n                emit CategoryAdded(categories[i]);\n            }\n        }\n        \n        emit APIRegistered(name, msg.sender, msg.value, categories);\n    }\n    \n    /**\n     * @notice Increase stake for an API provider\n     */\n    function increaseStake(string memory name) external payable {\n        APIProvider storage provider = providers[name];\n        require(provider.operator == msg.sender, \"Not operator\");\n        require(msg.value > 0, \"No stake sent\");\n        \n        provider.stakeAmount += msg.value;\n        emit APIStakeIncreased(name, provider.stakeAmount);\n    }\n    \n    /**\n     * @notice Submit signed data attestation for a question\n     * @dev Signature proves data came from registered API operator\n     */\n    function submitAttestation(\n        string memory apiName,\n        bytes32 questionHash,\n        bool outcome,\n        uint256 confidence,\n        string memory dataProof,  // IPFS hash of raw API response\n        bytes memory signature\n    ) external {\n        APIProvider storage provider = providers[apiName];\n        require(provider.isActive, \"API not active\");\n        require(provider.operator == msg.sender, \"Not operator\");\n        require(confidence <= 100, \"Invalid confidence\");\n        \n        ConsensusRequest storage request = requests[questionHash];\n        require(!request.resolved, \"Already resolved\");\n        \n        // Verify signature (proves operator signed this specific data)\n        bytes32 messageHash = keccak256(abi.encodePacked(\n            questionHash,\n            outcome,\n            confidence,\n            dataProof,\n            block.timestamp\n        ));\n        bytes32 ethSignedHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash));\n        address recovered = recoverSigner(ethSignedHash, signature);\n        require(recovered == msg.sender, \"Invalid data signature\");\n        \n        // Store attestation\n        request.attestations[msg.sender] = DataAttestation({\n            questionHash: questionHash,\n            outcome: outcome,\n            confidence: confidence,\n            signature: signature,\n            timestamp: block.timestamp,\n            dataProof: dataProof\n        });\n        \n        request.attestationCount++;\n        \n        emit DataAttested(questionHash, apiName, outcome, confidence);\n    }\n    \n    /**\n     * @notice Compute consensus from multiple API providers\n     * @dev Requires MIN_CONSENSUS providers with CONSENSUS_THRESHOLD agreement\n     */\n    function computeConsensus(\n        bytes32 questionHash,\n        address[] memory providerAddresses\n    ) external returns (bool outcome, uint256 confidence) {\n        ConsensusRequest storage request = requests[questionHash];\n        require(!request.resolved, \"Already resolved\");\n        require(providerAddresses.length >= MIN_CONSENSUS, \"Need more providers\");\n        \n        uint256 yesCount = 0;\n        uint256 noCount = 0;\n        uint256 totalConfidence = 0;\n        uint256 validAttestations = 0;\n        \n        // Tally votes weighted by confidence\n        for (uint i = 0; i < providerAddresses.length; i++) {\n            DataAttestation memory attestation = request.attestations[providerAddresses[i]];\n            \n            if (attestation.timestamp > 0) {\n                validAttestations++;\n                totalConfidence += attestation.confidence;\n                \n                if (attestation.outcome) {\n                    yesCount += attestation.confidence;\n                } else {\n                    noCount += attestation.confidence;\n                }\n            }\n        }\n        \n        require(validAttestations >= MIN_CONSENSUS, \"Insufficient attestations\");\n        \n        // Determine consensus\n        uint256 total = yesCount + noCount;\n        bool consensusOutcome = yesCount > noCount;\n        uint256 agreementPercentage = (consensusOutcome ? yesCount : noCount) * 100 / total;\n        \n        require(agreementPercentage >= CONSENSUS_THRESHOLD, \"No consensus\");\n        \n        // Update provider reputations\n        _updateReputations(questionHash, providerAddresses, consensusOutcome);\n        \n        // Store result\n        request.resolved = true;\n        request.finalOutcome = consensusOutcome;\n        request.finalConfidence = totalConfidence / validAttestations;\n        \n        emit ConsensusReached(questionHash, consensusOutcome, request.finalConfidence, validAttestations);\n        \n        return (consensusOutcome, request.finalConfidence);\n    }\n    \n    /**\n     * @notice Update provider reputations based on consensus\n     * @dev Providers who agreed with consensus get reputation boost, others get slashed\n     */\n    function _updateReputations(\n        bytes32 questionHash,\n        address[] memory providerAddresses,\n        bool consensusOutcome\n    ) private {\n        ConsensusRequest storage request = requests[questionHash];\n        \n        for (uint i = 0; i < providerAddresses.length; i++) {\n            address providerAddr = providerAddresses[i];\n            DataAttestation memory attestation = request.attestations[providerAddr];\n            \n            if (attestation.timestamp == 0) continue;\n            \n            // Find provider name\n            string[] memory apis = operatorAPIs[providerAddr];\n            for (uint j = 0; j < apis.length; j++) {\n                APIProvider storage provider = providers[apis[j]];\n                \n                if (attestation.outcome == consensusOutcome) {\n                    // CORRECT: Increase reputation\n                    provider.successfulResponses++;\n                    provider.reputationScore += attestation.confidence;\n                    emit ReputationIncreased(apis[j], provider.reputationScore);\n                    \n                } else {\n                    // WRONG: Slash stake\n                    provider.failedResponses++;\n                    uint256 slashAmount = (provider.stakeAmount * SLASH_PERCENTAGE) / 100;\n                    provider.stakeAmount -= slashAmount;\n                    provider.totalSlashed += slashAmount;\n                    \n                    // Deactivate if stake too low\n                    if (provider.stakeAmount < MIN_STAKE) {\n                        provider.isActive = false;\n                    }\n                    \n                    emit APISlashed(apis[j], slashAmount, questionHash);\n                }\n            }\n        }\n    }\n    \n    /**\n     * @notice Get providers for a specific category\n     */\n    function getProvidersForCategory(string memory category) \n        external \n        view \n        returns (string[] memory) \n    {\n        uint256 count = 0;\n        \n        // Count matching providers\n        for (uint i = 0; i < allProviderNames.length; i++) {\n            APIProvider memory provider = providers[allProviderNames[i]];\n            if (!provider.isActive) continue;\n            \n            for (uint j = 0; j < provider.categories.length; j++) {\n                if (keccak256(bytes(provider.categories[j])) == keccak256(bytes(category))) {\n                    count++;\n                    break;\n                }\n            }\n        }\n        \n        // Build result array\n        string[] memory result = new string[](count);\n        uint256 index = 0;\n        \n        for (uint i = 0; i < allProviderNames.length; i++) {\n            APIProvider memory provider = providers[allProviderNames[i]];\n            if (!provider.isActive) continue;\n            \n            for (uint j = 0; j < provider.categories.length; j++) {\n                if (keccak256(bytes(provider.categories[j])) == keccak256(bytes(category))) {\n                    result[index] = allProviderNames[i];\n                    index++;\n                    break;\n                }\n            }\n        }\n        \n        return result;\n    }\n    \n    /**\n     * @notice Recover signer from signature\n     */\n    function recoverSigner(bytes32 ethSignedHash, bytes memory signature) \n        private \n        pure \n        returns (address) \n    {\n        require(signature.length == 65, \"Invalid signature length\");\n        \n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        \n        assembly {\n            r := mload(add(signature, 32))\n            s := mload(add(signature, 64))\n            v := byte(0, mload(add(signature, 96)))\n        }\n        \n        return ecrecover(ethSignedHash, v, r, s);\n    }\n    \n    /**\n     * @notice Get all active providers\n     */\n    function getAllActiveProviders() external view returns (string[] memory) {\n        uint256 count = 0;\n        for (uint i = 0; i < allProviderNames.length; i++) {\n            if (providers[allProviderNames[i]].isActive) {\n                count++;\n            }\n        }\n        \n        string[] memory result = new string[](count);\n        uint256 index = 0;\n        \n        for (uint i = 0; i < allProviderNames.length; i++) {\n            if (providers[allProviderNames[i]].isActive) {\n                result[index] = allProviderNames[i];\n                index++;\n            }\n        }\n        \n        return result;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}